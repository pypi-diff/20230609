# Comparing `tmp/accel-0.2.3-py3-none-any.whl.zip` & `tmp/accel-0.2.4-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,16 +1,16 @@
-Zip file size: 64820 bytes, number of entries: 35
--rw-rw-rw-  2.0 fat      199 b- defN 23-May-10 13:49 accel/__init__.py
+Zip file size: 65874 bytes, number of entries: 35
+-rw-rw-rw-  2.0 fat      199 b- defN 23-Jun-09 14:39 accel/__init__.py
 -rw-rw-rw-  2.0 fat        0 b- defN 21-Jul-01 06:20 accel/__main__.py
 -rw-rw-rw-  2.0 fat        0 b- defN 22-Apr-24 06:17 accel/base/__init__.py
 -rw-rw-rw-  2.0 fat    14485 b- defN 23-May-10 10:31 accel/base/atoms.py
 -rw-rw-rw-  2.0 fat     2514 b- defN 22-Aug-23 04:00 accel/base/box.py
 -rw-rw-rw-  2.0 fat    22882 b- defN 23-May-10 09:09 accel/base/boxcore.py
 -rw-rw-rw-  2.0 fat    10265 b- defN 22-Dec-13 04:06 accel/base/formats.py
--rw-rw-rw-  2.0 fat    78055 b- defN 23-May-10 10:41 accel/base/modeler.py
+-rw-rw-rw-  2.0 fat    84422 b- defN 23-Jun-09 13:31 accel/base/modeler.py
 -rw-rw-rw-  2.0 fat      830 b- defN 22-Aug-23 04:00 accel/base/selector.py
 -rw-rw-rw-  2.0 fat    13436 b- defN 23-Feb-05 06:09 accel/base/systems.py
 -rw-rw-rw-  2.0 fat     1290 b- defN 22-Aug-23 04:00 accel/base/tools.py
 -rw-rw-rw-  2.0 fat    17216 b- defN 22-Aug-23 04:00 accel/base/topology.py
 -rw-rw-rw-  2.0 fat      755 b- defN 22-May-11 09:47 accel/plugin/__init__.py
 -rw-rw-rw-  2.0 fat    31834 b- defN 23-Feb-05 05:59 accel/plugin/gaulib.py
 -rw-rw-rw-  2.0 fat    10488 b- defN 23-Feb-05 06:02 accel/plugin/maelib.py
@@ -25,13 +25,13 @@
 -rw-rw-rw-  2.0 fat     1519 b- defN 23-Feb-05 07:21 accel/util/dialogue.py
 -rw-rw-rw-  2.0 fat     7662 b- defN 22-Apr-24 05:35 accel/util/elements.pkl
 -rw-rw-rw-  2.0 fat      546 b- defN 22-Aug-23 04:00 accel/util/execmd.py
 -rw-rw-rw-  2.0 fat      687 b- defN 22-Aug-23 04:00 accel/util/filetype.py
 -rw-rw-rw-  2.0 fat     4073 b- defN 23-Feb-05 07:59 accel/util/log.py
 -rw-rw-rw-  2.0 fat     7508 b- defN 22-Nov-24 03:42 accel/util/logo32.png
 -rw-rw-rw-  2.0 fat     2978 b- defN 22-Aug-23 04:00 accel/util/matrix.py
--rw-rw-rw-  2.0 fat     1059 b- defN 23-May-10 13:49 accel-0.2.3.dist-info/LICENSE
--rw-rw-rw-  2.0 fat      515 b- defN 23-May-10 13:49 accel-0.2.3.dist-info/METADATA
--rw-rw-rw-  2.0 fat       92 b- defN 23-May-10 13:49 accel-0.2.3.dist-info/WHEEL
--rw-rw-rw-  2.0 fat        6 b- defN 23-May-10 13:49 accel-0.2.3.dist-info/top_level.txt
-?rw-rw-r--  2.0 fat     2706 b- defN 23-May-10 13:49 accel-0.2.3.dist-info/RECORD
-35 files, 253777 bytes uncompressed, 60586 bytes compressed:  76.1%
+-rw-rw-rw-  2.0 fat     1059 b- defN 23-Jun-09 14:39 accel-0.2.4.dist-info/LICENSE
+-rw-rw-rw-  2.0 fat      515 b- defN 23-Jun-09 14:39 accel-0.2.4.dist-info/METADATA
+-rw-rw-rw-  2.0 fat       92 b- defN 23-Jun-09 14:39 accel-0.2.4.dist-info/WHEEL
+-rw-rw-rw-  2.0 fat        6 b- defN 23-Jun-09 14:39 accel-0.2.4.dist-info/top_level.txt
+?rw-rw-r--  2.0 fat     2706 b- defN 23-Jun-09 14:39 accel-0.2.4.dist-info/RECORD
+35 files, 260144 bytes uncompressed, 61640 bytes compressed:  76.3%
```

## zipnote {}

```diff
@@ -84,23 +84,23 @@
 
 Filename: accel/util/logo32.png
 Comment: 
 
 Filename: accel/util/matrix.py
 Comment: 
 
-Filename: accel-0.2.3.dist-info/LICENSE
+Filename: accel-0.2.4.dist-info/LICENSE
 Comment: 
 
-Filename: accel-0.2.3.dist-info/METADATA
+Filename: accel-0.2.4.dist-info/METADATA
 Comment: 
 
-Filename: accel-0.2.3.dist-info/WHEEL
+Filename: accel-0.2.4.dist-info/WHEEL
 Comment: 
 
-Filename: accel-0.2.3.dist-info/top_level.txt
+Filename: accel-0.2.4.dist-info/top_level.txt
 Comment: 
 
-Filename: accel-0.2.3.dist-info/RECORD
+Filename: accel-0.2.4.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## accel/__init__.py

```diff
@@ -1,7 +1,7 @@
-__version__ = "0.2.3"
+__version__ = "0.2.4"
 
 from accel.base.atoms import Atom, Atoms
 from accel.base.box import Box
 from accel.base.systems import System, Systems
 
 __all__ = ["Box", "System", "Atom", "Systems", "Atoms"]
```

## accel/base/modeler.py

```diff
@@ -433,14 +433,15 @@
     def get_mapped(
         self,
         target: "Atoms",
         known_pairs: list[tuple[int]] = [],
         terminal_first: bool = False,
     ) -> list["Atoms"]:
         atoms_map = _get_maps(target, self.atoms, known_pairs=known_pairs, terminal_first=terminal_first)
+        atoms_map = _expand_maps(target, self.atoms, atoms_map)
         atoms_map = _order_maps(target, self.atoms, atoms_map)
         for chain in atoms_map:
             logger.debug(f"maps (target, self): {[(pr[0].number, pr[1].number) for pr in chain]}")
         return_list = []
         for chain in atoms_map:
             chain_target = [pr[0] for pr in chain]
             chain_self = [pr[1] for pr in chain]
@@ -873,25 +874,28 @@
                     a_side_pairs[a_diff_idx[0]] in a_side_pairs[b_diff_idx[0]].bonds
                     and b_side_pairs[b_diff_idx[0]] in b_side_pairs[a_diff_idx[0]].bonds
                 ):
                     return True
             return False
         return True
 
+    logger.debug(f"generating initial_chains from {len(initial_pairs)} initial_pairs")
     initial_chains: list[list[tuple[Atom]]] = [[]]
-    for initial_pair in initial_pairs:
+    for pair_num, initial_pair in enumerate(initial_pairs, 1):
+        if pair_num % 50 == 0:
+            logger.debug(f"processing initial_pairs: {pair_num}")
         stack = [[initial_pair]]
         while stack:
             side_pairs: list[tuple[Atom]] = stack.pop()
             if len(side_pairs) > len(initial_chains[-1]):
                 initial_chains = [side_pairs]
-                logger.debug(f"initial_chains updated: {[(pr[0].number, pr[1].number) for pr in side_pairs]}")
+                # logger.debug(f"initial_chains updated: {[(pr[0].number, pr[1].number) for pr in side_pairs]}")
             elif len(side_pairs) == len(initial_chains[-1]):
                 initial_chains.append(side_pairs)
-                logger.debug(f"initial_chains appended: {[(pr[0].number, pr[1].number) for pr in side_pairs]}")
+                # logger.debug(f"initial_chains appended: {[(pr[0].number, pr[1].number) for pr in side_pairs]}")
             a_list = [pr[0] for pr in side_pairs]
             b_list = [pr[1] for pr in side_pairs]
             for next_a in side_pairs[-1][0].bonds:
                 if next_a.symbol == "H" or next_a in a_list:
                     continue
                 for next_b in side_pairs[-1][1].bonds:
                     if next_b.symbol == "H" or next_b in b_list:
@@ -909,34 +913,34 @@
         return []
 
     canonical_initial_chains: dict[list[set], tuple[tuple[Atom]]] = {}
     for chain in initial_chains:
         key = tuple(sorted([(pr[0].number, pr[1].number) for pr in chain], key=lambda t: t[0]))
         canonical_initial_chains[key] = chain
 
-    for chain in canonical_initial_chains.values():
-        logger.debug(f"canonical_initial_chains: {[(pr[0].number, pr[1].number) for pr in chain]}")
+    # for chain in canonical_initial_chains.values():
+    #     logger.debug(f"canonical_initial_chains: {[(pr[0].number, pr[1].number) for pr in chain]}")
 
     min_invalid = None
-    h_matched_chains: list[list[tuple[Atom]]] = [[]]
+    h_matched_canonical_initial_chains: list[list[tuple[Atom]]] = [[]]
     for chain in canonical_initial_chains.values():
         invalid_atoms = 0
         for pair in chain:
             hs_of_a = [a_ for a_ in pair[0].bonds if a_.symbol == "H"]
             hs_of_b = [b_ for b_ in pair[1].bonds if b_.symbol == "H"]
             if len(hs_of_a) != len(hs_of_b):
                 invalid_atoms += 1
         if min_invalid is None or min_invalid > invalid_atoms:
-            h_matched_chains = [chain]
+            h_matched_canonical_initial_chains = [chain]
             min_invalid = invalid_atoms
         elif min_invalid == invalid_atoms:
-            h_matched_chains.append(chain)
+            h_matched_canonical_initial_chains.append(chain)
 
-    for chain in h_matched_chains:
-        logger.debug(f"h_matched_chains: {[(pr[0].number, pr[1].number) for pr in chain]}")
+    # for chain in h_matched_canonical_initial_chains:
+    #     logger.debug(f"h_matched_canonical_initial_chains: {[(pr[0].number, pr[1].number) for pr in chain]}")
 
     def _det_ez(a: Atom, b: Atom, c: Atom, d: Atom) -> bool:
         vab = np.array(a.xyz) - np.array(b.xyz)
         vcb = np.array(c.xyz) - np.array(b.xyz)
         vdc = np.array(d.xyz) - np.array(c.xyz)
         pvac = np.cross(vab, vcb)
         pvbd = np.cross(vdc, vcb)
@@ -974,16 +978,17 @@
                 angle = -angle
             angle = np.absolute(np.rad2deg(angle))
             if max_dihedral_angle <= angle:
                 max_dihedral_a = a
                 max_dihedral_angle = angle
         return (max_dihedral_a, max_dihedral_angle)
 
+    logger.debug(f"extending {len(h_matched_canonical_initial_chains)} chains")
     extended_chains: list[list[tuple[Atom]]] = []
-    for chain in h_matched_chains:
+    for chain in h_matched_canonical_initial_chains:
         stack = deque([pr for pr in chain])
         assigned_as = given_known_as + [pr[0] for pr in chain]
         assigned_bs = given_known_bs + [pr[1] for pr in chain]
 
         def _new_assign(new_pair: tuple[Atom], root_pair: tuple[Atom]):
             assigned_as.append(new_pair[0])
             assigned_bs.append(new_pair[1])
@@ -1167,19 +1172,119 @@
             chain = chain[len(known_pairs) :]
         key = tuple(sorted([(pr[0].number, pr[1].number) for pr in chain], key=lambda t: t[0]))
         canonical_recursive_extended_chains[key] = chain
 
     for chain in canonical_recursive_extended_chains.values():
         logger.debug(f"canonical_recursive_extended_chains: {[(pr[0].number, pr[1].number) for pr in chain]}")
 
-    return canonical_recursive_extended_chains.values()
+    return list(canonical_recursive_extended_chains.values())
+
 
+def _expand_maps(
+    atoms_a: "Atoms", atoms_b: "Atoms", atom_maps: list[list[tuple[Atom]]], max_loop: int = 3
+) -> list[list[tuple[Atom]]]:
+    def ab_conv(atom: Atom, atom_map: list[tuple[Atom]]) -> Atom:
+        try:
+            idx = [pr[0] for pr in atom_map].index(atom)
+        except ValueError:
+            pass
+        else:
+            return atom_map[idx][1]
+        try:
+            idx = [pr[1] for pr in atom_map].index(atom)
+        except ValueError:
+            pass
+        else:
+            return atom_map[idx][0]
+        return None
 
-def _correct_maps(atoms_a: "Atoms", atoms_b: "Atoms", atom_maps: list[list[tuple[Atom]]]) -> list[list[tuple[Atom]]]:
-    return atom_maps
+    logger.debug(f"expanding {len(atom_maps)} chains")
+    total_atom_maps_dict: dict[tuple[tuple[int]], list[tuple[Atom]]] = {}
+    for atom_map in atom_maps:
+        key = tuple(sorted([(mp[0].number, mp[1].number) for mp in atom_map], key=lambda t: t[0]))
+        total_atom_maps_dict[key] = atom_map
+    for initial_atom_map in atom_maps:
+        que_atom_maps = [initial_atom_map]
+        loop_counter = 0
+        while que_atom_maps:
+            atom_map = que_atom_maps.pop(0)
+            potential_swaps: list[list[Atom]] = []
+            a_diff_bonds: list[tuple[Atom]] = []
+            for ab_map in atom_map:
+                for a_diff_bd in set([a for a in ab_map[0].bonds]) ^ set(
+                    [ab_conv(b, atom_map) for b in ab_map[1].bonds]
+                ):
+                    a_diff_bonds.append((ab_map[0], a_diff_bd))
+            a_diff_bonds = list(set([tuple(sorted(adb, key=lambda a: a.number)) for adb in a_diff_bonds]))
+            # logger.debug(f"a_diff_bonds: {[[a.number for a in adb] for adb in a_diff_bonds]}")
+            loop_rest_que: list[dict] = [
+                {
+                    "loop_atoms": (adb[0],),
+                    "rest_bonds": [b for b in a_diff_bonds if b is not adb],
+                    "end_atom": adb[1],
+                }
+                for adb in a_diff_bonds
+            ]
+            stored_loop_atoms = []
+            while loop_rest_que:
+                q = loop_rest_que.pop(0)
+                loop_atoms: tuple[Atom] = q["loop_atoms"]
+                rest_bonds: list[tuple[Atom]] = q["rest_bonds"]
+                if loop_atoms[-1] is q["end_atom"]:
+                    stored_loop_atoms.append(loop_atoms)
+                    # logger.debug(f"loop_atoms: {[a.number for a in loop_atoms]}")
+                    if len(set([a.symbol for a in loop_atoms[::2]])) == 1:
+                        potential_swaps.append([a for a in loop_atoms[::2]])
+                    if len(set([a.symbol for a in loop_atoms[1::2]])) == 1:
+                        potential_swaps.append([a for a in loop_atoms[1::2]])
+                for checking_bond in rest_bonds:
+                    if loop_atoms[-1] is checking_bond[0]:
+                        new_terminal = checking_bond[1]
+                    elif loop_atoms[-1] is checking_bond[1]:
+                        new_terminal = checking_bond[0]
+                    else:
+                        continue
+                    loop_rest_que.append(
+                        {
+                            "loop_atoms": loop_atoms + (new_terminal,),
+                            "rest_bonds": [b for b in rest_bonds if b is not checking_bond],
+                            "end_atom": q["end_atom"],
+                        }
+                    )
+            for loop_atoms in stored_loop_atoms:
+                # logger.debug(f"loop_atoms: {[a.number for a in loop_atoms]}")
+                if len(set([a.symbol for a in loop_atoms[::2]])) == 1:
+                    potential_swaps.append([a for a in loop_atoms[::2]])
+                if len(set([a.symbol for a in loop_atoms[1::2]])) == 1:
+                    potential_swaps.append([a for a in loop_atoms[1::2]])
+            potential_swaps: list[tuple[Atom]] = list(
+                set([tuple(sorted(adb, key=lambda a: a.number)) for adb in potential_swaps])
+            )
+            # logger.debug(f"potential_swap: {[[a.number for a in pswap] for pswap in potential_swaps]}")
+            atom_map_a = [m[0] for m in atom_map]
+            for pq_swap in potential_swaps:
+                if len(pq_swap) != 2:
+                    continue
+                try:
+                    p_id: int = atom_map_a.index(pq_swap[0])
+                    q_id: int = atom_map_a.index(pq_swap[1])
+                except ValueError:
+                    logger.error("error on swaping potential_swap")
+                    continue
+                new_map = atom_map[:]
+                new_map[p_id], new_map[q_id] = (pq_swap[0], new_map[q_id][1]), (pq_swap[1], new_map[p_id][1])
+                new_map_key = tuple(sorted([(mp[0].number, mp[1].number) for mp in new_map], key=lambda t: t[0]))
+                if new_map_key not in total_atom_maps_dict:
+                    logger.info(f"expanded_chains: {[(pr[0].number, pr[1].number) for pr in new_map]}")
+                    total_atom_maps_dict[new_map_key] = new_map
+                    que_atom_maps.append(new_map)
+            loop_counter += 1
+            if loop_counter >= max_loop:
+                break
+    return list(total_atom_maps_dict.values())
 
 
 def _order_maps(atoms_a: "Atoms", atoms_b: "Atoms", atom_maps: list[list[tuple[Atom]]]) -> list[list[tuple[Atom]]]:
     def aconv(atom: Atom, a_map: list[tuple[Atom]]) -> Atom:
         try:
             idx = [pr[0] for pr in a_map].index(atom)
         except ValueError:
@@ -1231,14 +1336,15 @@
 
     def det_chirality(a: Atom, b: Atom, c: Atom, d: Atom) -> bool:
         neighbors_xyz = np.array([atom_.xyz for atom_ in [b, c, d]]) - np.array(a.xyz)
         if np.linalg.det(neighbors_xyz) > 0:
             return True
         return False
 
+    logger.debug(f"ordering {len(atom_maps)} chains")
     evaluated_dicts = [{"map": mp} for mp in atom_maps]
     for evaluated_dic in evaluated_dicts:
         for a in atoms_a:
             a.cache["map_idx"] = None
         for a in atoms_b:
             a.cache["map_idx"] = None
         atom_map: list[tuple[Atom]] = evaluated_dic["map"]
@@ -1405,25 +1511,36 @@
             if diff_a_atoms[0].symbol == "C" and diff_b_atoms[0].symbol == "C":
                 continue
             a_ord_atoms = [a for a in a_singles if a not in diff_a_atoms]
             b_ord_atoms = [aconv(a, atom_map) for a in a_ord_atoms]
             if det_chirality(*(a_ord_atoms + diff_a_atoms)) == det_chirality(*(b_ord_atoms + diff_b_atoms)):
                 evaluated_dic["invalid_sn2_atoms"] += 1
 
+        evaluated_dic["sp3_carbon_penalty"] = 0
+        for pr in bonding_pairs:
+            if pr[0].symbol != "C" and pr[1].symbol != "C":
+                continue
+            a_singles = pr[0].single
+            b_singles = pr[1].single
+            if len(a_singles) == 4 and len(b_singles) == 4:
+                evaluated_dic["sp3_carbon_penalty"] += 1
+
     evaluated_dicts = sorted(evaluated_dicts, key=lambda d: d["local_rmsd"])
     # evaluated_dicts = sorted(evaluated_dicts, key=lambda d: round(d["bonding_local_rmsd"] * 0.5, 3))
     evaluated_dicts = sorted(evaluated_dicts, key=lambda d: round(d["bonding_tb_local_rmsd"], 1))
     evaluated_dicts = sorted(evaluated_dicts, key=lambda d: d["invalid_sn2_atoms"])
     evaluated_dicts = sorted(evaluated_dicts, key=lambda d: d["sp2_face_transfer_mismatch"])
     evaluated_dicts = sorted(evaluated_dicts, key=lambda d: d["num_of_long_rearranged_atoms"])
+    evaluated_dicts = sorted(evaluated_dicts, key=lambda d: d["sp3_carbon_penalty"])
     return_list = []
     for evaluated_dic in evaluated_dicts:
         mp = [(pr[0].number, pr[1].number) for pr in evaluated_dic["map"]]
         return_list.append(evaluated_dic["map"])
         logger.info(f"mapping: {mp}")
+        logger.info(f"sp3_carbon_penalty: {evaluated_dic['sp3_carbon_penalty']}")
         logger.info(f"num_of_long_rearranged_atoms: {evaluated_dic['num_of_long_rearranged_atoms']}")
         logger.info(f"sp2_face_transfer_mismatch: {evaluated_dic['sp2_face_transfer_mismatch']}")
         logger.info(f"invalid_sn2_atoms: {evaluated_dic['invalid_sn2_atoms']}")
         logger.info(f"bonding_tb_local_rmsd: {evaluated_dic['bonding_tb_local_rmsd']}")
         # logger.info(f"bonding_local_rmsd: {evaluated_dic['bonding_local_rmsd']}")
         logger.info(f"local_rmsd: {evaluated_dic['local_rmsd']}")
 
@@ -1603,15 +1720,15 @@
             terminal_chains = self.elongated(accept_loop=accept_loop)
             if len(terminal_chains) == 0:
                 break
             new_chains.extend(terminal_chains)
         return new_chains
 
     def longest(self) -> "Chains":
-        max_len = self.max_distance() + 1
+        max_len = self.max_distance + 1
         return Chains([chain for chain in self._chains if len(chain) == max_len])
 
     def heavily_terminated(self) -> "Chains":
         symbs = set([chain[-1].symbol for chain in self._chains])
         max_symbol = Elements.canonicalize(max([Elements.symbols.index(s) for s in symbs]))
         return Chains([chain for chain in self._chains if chain[-1].symbol == max_symbol])
 
@@ -1696,14 +1813,20 @@
                 else:
                     next_chains_list.append(chains)
         if len(next_chains_list) == 1:
             sorted_chains_list.extend(next_chains_list)
             return sorted_chains_list
         if len(next_chains_list) == 0 or elongated_flag is False:
             return None
+        max_dst = max([ch.max_distance for ch in next_chains_list])
+        all_term_atoms: set[Atom] = set()
+        for term_atoms in [ch.longest().terminals for ch in next_chains_list if ch.max_distance == max_dst]:
+            all_term_atoms = all_term_atoms | set(term_atoms)
+        if len(all_term_atoms) == 1:
+            return None
         ordered_chains_list = Chains.get_ordered_substituents(next_chains_list)
         if ordered_chains_list is None:
             return None
         for chains in ordered_chains_list:
             for initial_chains in initial_chains_list:
                 if chains[0][1] == initial_chains[0][1]:
                     sorted_chains_list.append(initial_chains)
```

## Comparing `accel-0.2.3.dist-info/LICENSE` & `accel-0.2.4.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `accel-0.2.3.dist-info/METADATA` & `accel-0.2.4.dist-info/METADATA`

 * *Files 24% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: accel
-Version: 0.2.3
+Version: 0.2.4
 Summary: automated computation chemical library specialized for handling large numbers of conformers
 Home-page: https://github.com/kfchem/accel
 Author: Keisuke Fukaya
 Author-email: kfukaya@pu-toyama.ac.jp
 License: MIT License
 Platform: UNKNOWN
 Classifier: Programming Language :: Python :: 3
```

## Comparing `accel-0.2.3.dist-info/RECORD` & `accel-0.2.4.dist-info/RECORD`

 * *Files 4% similar despite different names*

```diff
@@ -1,15 +1,15 @@
-accel/__init__.py,sha256=uz_XgERy2lWGCYMVxsG65BlCCi63ZAM8fHBOd2OwcjA,199
+accel/__init__.py,sha256=85YU53HJQIdWJXNpXgUXBVyMFl1vmSMuGzQhlunS7E8,199
 accel/__main__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 accel/base/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 accel/base/atoms.py,sha256=IuFFP7l7n8_FVDUI4Fx9mdsJHAXoVB9Aa_X-WwEQP0w,14485
 accel/base/box.py,sha256=5pka1-hA7-SeIG9HUI07V-xRFCWESShdcnziElCrv_E,2514
 accel/base/boxcore.py,sha256=b8Y9TNF4UWWFVtMDa3jxnp0J4KBGGK-YhprUTFYTjyE,22882
 accel/base/formats.py,sha256=xCzSv5_jRxCAoZYQLmXZDYKk-MajT4EQW_rkEK_ywE0,10265
-accel/base/modeler.py,sha256=jztsRl4mfGoQ4Xa2bsQhgDSLu7RJvTHUBXrzHVmhy3g,78055
+accel/base/modeler.py,sha256=hH-TDTzO7g0kzHXVi3IGcg9Fpig8qoJedURcZqAgKHk,84422
 accel/base/selector.py,sha256=BZERAbMyb1KoqfBW1c1EC4WTBsKgsfFGQnEh105oQKg,830
 accel/base/systems.py,sha256=08px0f8bFeMwnpf9tOS6P7gYBecjToqmZNNFtMGPfus,13436
 accel/base/tools.py,sha256=O40JDiua5a0RzBBEl13BN_QvfJ_WdhDcuQsz96PLUV8,1290
 accel/base/topology.py,sha256=BNgDRvmcsZorU2l08eqq9tfd7yyMvvaeAyr-M_V9FHA,17216
 accel/plugin/__init__.py,sha256=vIESlj9VGQnUMOVXn6UZHBfGKz54JtsDgJoLUeWMP6M,755
 accel/plugin/gaulib.py,sha256=NRf41yAweIgZd4Rj1qmoOReR_YDrk96OuniqQKy7-qs,31834
 accel/plugin/maelib.py,sha256=wS2AvjW0rMZTquxlB8sdLODjg9-KSMFLf9dS3hOgT4I,10488
@@ -24,12 +24,12 @@
 accel/util/dialogue.py,sha256=-s65zXRnEOohyH7N1ZEhDG9Z9p8e1b_Inog_oPkiK4s,1519
 accel/util/elements.pkl,sha256=JsxWQoKC4IovYUqReMqkHIuU9ykIiWK_Jl7Lgl1lDOg,7662
 accel/util/execmd.py,sha256=kyqgnB2etvU7de3gXlWKmv7H-_GIVRih-Jkl50jK1-o,546
 accel/util/filetype.py,sha256=JKpyowreNB3_lch7fJVBTDwJnHt7XC2LTPpAykZwW-o,687
 accel/util/log.py,sha256=N0eJUOkKU1TiZWAFC9BTEbh7AqPbBTsD08Tufu-l_6M,4073
 accel/util/logo32.png,sha256=fX2pmSs70rTbXTuGlTvy6hqSHjZ4VejSxtZ7F2o6_Wk,7508
 accel/util/matrix.py,sha256=ln-YsbzuTBrGJh4R3YZekFDEV__pcZYyLc9enD0g3dY,2978
-accel-0.2.3.dist-info/LICENSE,sha256=6kVvPMd5fpiLN44G42XCWHb0Q_nDhLOMW1K4py7EY1I,1059
-accel-0.2.3.dist-info/METADATA,sha256=-tkIrXM3z1ciSCVddxGdgSneZZ8juIZ22HXXVXkQV8o,515
-accel-0.2.3.dist-info/WHEEL,sha256=G16H4A3IeoQmnOrYV4ueZGKSjhipXx8zc8nu9FGlvMA,92
-accel-0.2.3.dist-info/top_level.txt,sha256=rvhggDW-aRtU4KyyeMQ0SKa754UarbjRb4izBDCNj6g,6
-accel-0.2.3.dist-info/RECORD,,
+accel-0.2.4.dist-info/LICENSE,sha256=6kVvPMd5fpiLN44G42XCWHb0Q_nDhLOMW1K4py7EY1I,1059
+accel-0.2.4.dist-info/METADATA,sha256=uPTz_EpiKi6xlrcxV5mYib7xbPfBK7-boonJNovm65Q,515
+accel-0.2.4.dist-info/WHEEL,sha256=G16H4A3IeoQmnOrYV4ueZGKSjhipXx8zc8nu9FGlvMA,92
+accel-0.2.4.dist-info/top_level.txt,sha256=rvhggDW-aRtU4KyyeMQ0SKa754UarbjRb4izBDCNj6g,6
+accel-0.2.4.dist-info/RECORD,,
```

