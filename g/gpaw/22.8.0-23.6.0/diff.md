# Comparing `tmp/gpaw-22.8.0.tar.gz` & `tmp/gpaw-23.6.0.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "gpaw-22.8.0.tar", last modified: Fri Aug 19 09:38:54 2022, max compression
+gzip compressed data, was "gpaw-23.6.0.tar", last modified: Fri Jun  9 07:55:42 2023, max compression
```

## Comparing `gpaw-22.8.0.tar` & `gpaw-23.6.0.tar`

### file list

```diff
@@ -1,1144 +1,1213 @@
-drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2022-08-19 09:38:54.854162 gpaw-22.8.0/
--rw-r--r--   0 jensj     (1000) jensj     (1000)      108 2019-08-23 18:18:31.000000 gpaw-22.8.0/CHANGELOG.rst
--rw-r--r--   0 jensj     (1000) jensj     (1000)      220 2019-08-23 18:18:31.000000 gpaw-22.8.0/CONTRIBUTING.rst
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    35147 2020-11-09 18:42:21.000000 gpaw-22.8.0/LICENSE
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      207 2020-11-09 18:42:21.000000 gpaw-22.8.0/MANIFEST.in
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     3469 2022-08-19 09:38:54.854162 gpaw-22.8.0/PKG-INFO
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     2645 2022-05-04 08:34:37.000000 gpaw-22.8.0/README.rst
-drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2022-08-19 09:38:54.770161 gpaw-22.8.0/c/
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    18469 2022-06-29 12:02:59.000000 gpaw-22.8.0/c/_gpaw.c
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     8474 2021-03-25 20:49:04.000000 gpaw-22.8.0/c/bc.c
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1451 2021-03-25 20:49:04.000000 gpaw-22.8.0/c/bc.h
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    57161 2022-05-04 08:34:37.000000 gpaw-22.8.0/c/blacs.c
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     4941 2022-06-29 12:02:59.000000 gpaw-22.8.0/c/blas.c
-drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2022-08-19 09:38:54.770161 gpaw-22.8.0/c/bmgs/
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      563 2021-03-25 20:49:04.000000 gpaw-22.8.0/c/bmgs/bmgs.c
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     4891 2022-05-04 08:34:37.000000 gpaw-22.8.0/c/bmgs/bmgs.h
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1003 2021-03-25 20:49:04.000000 gpaw-22.8.0/c/bmgs/cut.c
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      964 2022-05-04 08:34:37.000000 gpaw-22.8.0/c/bmgs/fd.c
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     2687 2022-05-04 08:34:37.000000 gpaw-22.8.0/c/bmgs/interpolate.c
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      924 2021-03-25 20:49:04.000000 gpaw-22.8.0/c/bmgs/paste.c
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     2095 2022-05-04 08:34:37.000000 gpaw-22.8.0/c/bmgs/relax.c
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     3616 2022-05-04 08:34:37.000000 gpaw-22.8.0/c/bmgs/restrict.c
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     6833 2021-03-25 20:49:04.000000 gpaw-22.8.0/c/bmgs/spherical_harmonics.h
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    24610 2021-08-11 13:41:50.000000 gpaw-22.8.0/c/bmgs/spline.c
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     4973 2021-03-25 20:49:04.000000 gpaw-22.8.0/c/bmgs/stencils.c
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1448 2021-03-25 20:49:04.000000 gpaw-22.8.0/c/bmgs/translate.c
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1399 2022-05-04 08:34:37.000000 gpaw-22.8.0/c/bmgs/wfd.c
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     2909 2021-03-25 20:49:04.000000 gpaw-22.8.0/c/bmgs/wrelax.c
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      446 2021-03-25 20:49:04.000000 gpaw-22.8.0/c/bmgs/zero.c
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    17980 2021-03-25 20:49:04.000000 gpaw-22.8.0/c/constraints.c
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     7532 2021-03-25 20:49:04.000000 gpaw-22.8.0/c/elpa.c
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1441 2022-05-04 08:34:37.000000 gpaw-22.8.0/c/extensions.h
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      290 2021-03-25 20:49:04.000000 gpaw-22.8.0/c/f2c.h
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    13194 2022-05-04 08:34:37.000000 gpaw-22.8.0/c/fd_preconditioner.c
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     2136 2021-03-25 20:49:04.000000 gpaw-22.8.0/c/fftw.c
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     6021 2021-03-25 20:49:04.000000 gpaw-22.8.0/c/lcao.c
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    58230 2022-05-04 08:34:37.000000 gpaw-22.8.0/c/lfc.c
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     4733 2022-05-04 08:34:37.000000 gpaw-22.8.0/c/lfc.h
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    13105 2022-05-04 08:34:37.000000 gpaw-22.8.0/c/lfc2.c
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    41386 2022-05-04 08:34:37.000000 gpaw-22.8.0/c/mpi.c
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      232 2021-03-25 20:49:04.000000 gpaw-22.8.0/c/mympi.h
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    11886 2022-05-04 08:34:37.000000 gpaw-22.8.0/c/operators.c
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      705 2022-05-04 08:34:37.000000 gpaw-22.8.0/c/operators.h
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     5521 2021-03-25 20:49:04.000000 gpaw-22.8.0/c/plane_wave.c
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     3084 2021-03-25 20:49:04.000000 gpaw-22.8.0/c/plt.c
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     5664 2021-03-25 20:49:04.000000 gpaw-22.8.0/c/point_charges.c
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     3913 2021-03-25 20:49:04.000000 gpaw-22.8.0/c/spline.c
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      227 2021-03-25 20:49:04.000000 gpaw-22.8.0/c/spline.h
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     9209 2022-05-04 08:34:37.000000 gpaw-22.8.0/c/symmetry.c
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     3850 2021-03-25 20:49:04.000000 gpaw-22.8.0/c/tetra.c
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1275 2022-05-04 08:34:37.000000 gpaw-22.8.0/c/threading.h
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     6910 2022-05-04 08:34:37.000000 gpaw-22.8.0/c/transformers.c
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      817 2022-05-04 08:34:37.000000 gpaw-22.8.0/c/transformers.h
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    21217 2022-05-04 08:34:37.000000 gpaw-22.8.0/c/utilities.c
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1587 2021-03-25 20:49:04.000000 gpaw-22.8.0/c/wigner_seitz.c
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    14638 2022-05-04 08:34:37.000000 gpaw-22.8.0/c/woperators.c
-drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2022-08-19 09:38:54.774160 gpaw-22.8.0/c/xc/
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1569 2021-03-25 20:49:04.000000 gpaw-22.8.0/c/xc/ensemble_gga.c
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     7001 2021-03-25 20:49:04.000000 gpaw-22.8.0/c/xc/libvdwxc.c
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    23092 2021-03-25 20:49:04.000000 gpaw-22.8.0/c/xc/libxc.c
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    23689 2021-03-25 20:49:04.000000 gpaw-22.8.0/c/xc/m06l.c
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     5026 2021-03-25 20:49:04.000000 gpaw-22.8.0/c/xc/pbe.c
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     5285 2021-03-25 20:49:04.000000 gpaw-22.8.0/c/xc/pw91.c
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    16506 2021-03-25 20:49:04.000000 gpaw-22.8.0/c/xc/revtpss.c
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    14506 2021-03-25 20:49:04.000000 gpaw-22.8.0/c/xc/revtpss_c_pbe.c
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      716 2021-03-25 20:49:04.000000 gpaw-22.8.0/c/xc/rpbe.c
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    16004 2021-03-25 20:49:04.000000 gpaw-22.8.0/c/xc/tpss.c
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     6350 2021-03-25 20:49:04.000000 gpaw-22.8.0/c/xc/vdw.c
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     9034 2021-08-20 11:59:25.000000 gpaw-22.8.0/c/xc/xc.c
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1008 2021-03-25 20:49:04.000000 gpaw-22.8.0/c/xc/xc_gpaw.h
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     3860 2021-03-25 20:49:04.000000 gpaw-22.8.0/c/xc/xc_mgga.c
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1113 2021-03-25 20:49:04.000000 gpaw-22.8.0/c/xc/xc_mgga.h
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     7997 2022-05-04 08:34:37.000000 gpaw-22.8.0/config.py
-drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2022-08-19 09:38:54.778161 gpaw-22.8.0/gpaw/
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     7167 2022-08-19 09:38:29.000000 gpaw-22.8.0/gpaw/__init__.py
--rwxrwxr-x   0 jensj     (1000) jensj     (1000)       73 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/__main__.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     2077 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/ae.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     2260 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/ah.py
-drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2022-08-19 09:38:54.782161 gpaw-22.8.0/gpaw/analyse/
--rw-rw-r--   0 jensj     (1000) jensj     (1000)       33 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/analyse/__init__.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     3054 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/analyse/eed.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     9840 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/analyse/expandyl.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     6755 2022-08-01 11:19:56.000000 gpaw-22.8.0/gpaw/analyse/hirshfeld.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     2607 2022-08-19 09:06:17.000000 gpaw-22.8.0/gpaw/analyse/multipole.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      531 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/analyse/observers.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     3883 2022-08-01 11:19:56.000000 gpaw-22.8.0/gpaw/analyse/overlap.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     8729 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/analyse/simple_stm.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     2510 2022-08-17 07:20:18.000000 gpaw-22.8.0/gpaw/analyse/vdwradii.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     5655 2022-08-01 11:19:56.000000 gpaw-22.8.0/gpaw/analyse/wignerseitz.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     6641 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/arraydict.py
-drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2022-08-19 09:38:54.782161 gpaw-22.8.0/gpaw/atom/
--rw-rw-r--   0 jensj     (1000) jensj     (1000)        0 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/atom/__init__.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    30177 2021-08-20 08:32:04.000000 gpaw-22.8.0/gpaw/atom/aeatom.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    26652 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/atom/all_electron.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     4282 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/atom/analyse_setup.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    11296 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/atom/atompaw.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    24626 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/atom/basis.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     9102 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/atom/check.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    52074 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/atom/configurations.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     6222 2021-08-20 08:32:04.000000 gpaw-22.8.0/gpaw/atom/filter.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    32096 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/atom/generator.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    53998 2022-08-19 09:06:17.000000 gpaw-22.8.0/gpaw/atom/generator2.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     6975 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/atom/gpaw_basis.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     7773 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/atom/gpaw_setup.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    15109 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/atom/optimize.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    18129 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/atom/radialgd.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     2251 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/atom/shapefunc.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    10610 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/band_descriptor.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    11232 2022-08-17 07:20:18.000000 gpaw-22.8.0/gpaw/basis_data.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    15021 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/berryphase.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1722 2022-08-17 07:20:18.000000 gpaw-22.8.0/gpaw/bfield.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    21961 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/blacs.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     3721 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/borncharges.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     5608 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/broadcast_imports.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    13432 2022-05-11 06:13:16.000000 gpaw-22.8.0/gpaw/bztools.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    77779 2022-08-19 09:06:17.000000 gpaw-22.8.0/gpaw/calculator.py
-drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2022-08-19 09:38:54.782161 gpaw-22.8.0/gpaw/cdft/
--rw-rw-r--   0 jensj     (1000) jensj     (1000)        0 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/cdft/__init__.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    43072 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/cdft/cdft.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    41915 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/cdft/cdft_coupling.py
-drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2022-08-19 09:38:54.782161 gpaw-22.8.0/gpaw/cli/
--rw-rw-r--   0 jensj     (1000) jensj     (1000)        0 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/cli/__init__.py
--rwxrwxr-x   0 jensj     (1000) jensj     (1000)     3537 2022-08-17 07:20:18.000000 gpaw-22.8.0/gpaw/cli/complete.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      335 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/cli/completion.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     6810 2022-06-24 21:03:09.000000 gpaw-22.8.0/gpaw/cli/dos.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      859 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/cli/gpw.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     3160 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/cli/info.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     9975 2022-08-19 08:01:32.000000 gpaw-22.8.0/gpaw/cli/install_data.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     2154 2022-08-17 07:20:18.000000 gpaw-22.8.0/gpaw/cli/main.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1368 2022-08-17 07:20:18.000000 gpaw-22.8.0/gpaw/cli/python.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      832 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/cli/quick.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     2282 2022-08-01 10:29:31.000000 gpaw-22.8.0/gpaw/cli/run.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     2073 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/cli/sbatch.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1260 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/cli/test.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     3066 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/cluster.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     3230 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/coding_style.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    13675 2022-08-19 07:19:38.000000 gpaw-22.8.0/gpaw/convergence_criteria.py
-drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2022-08-19 09:38:54.786161 gpaw-22.8.0/gpaw/core/
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      133 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/core/__init__.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     7333 2022-06-03 11:02:25.000000 gpaw-22.8.0/gpaw/core/arrays.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    12559 2022-06-22 07:02:06.000000 gpaw-22.8.0/gpaw/core/atom_arrays.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     5068 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/core/atom_centered_functions.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     4056 2022-05-18 04:39:27.000000 gpaw-22.8.0/gpaw/core/domain.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    26866 2022-07-13 10:13:20.000000 gpaw-22.8.0/gpaw/core/matrix.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    21260 2022-08-19 09:06:17.000000 gpaw-22.8.0/gpaw/core/plane_waves.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    14394 2022-08-01 09:40:12.000000 gpaw-22.8.0/gpaw/core/pwacf.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    24806 2022-08-01 09:40:12.000000 gpaw-22.8.0/gpaw/core/uniform_grid.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    12503 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/coulomb.py
-drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2022-08-19 09:38:54.786161 gpaw-22.8.0/gpaw/data/
--rw-rw-r--   0 jensj     (1000) jensj     (1000)        0 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/data/__init__.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     3270 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/data/g2_1_ref.py
-drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2022-08-19 09:38:54.786161 gpaw-22.8.0/gpaw/defects/
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    14249 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/defects/__init__.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     4516 2022-08-01 09:40:12.000000 gpaw-22.8.0/gpaw/densities.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    29565 2022-07-08 10:24:24.000000 gpaw-22.8.0/gpaw/density.py
-drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2022-08-19 09:38:54.786161 gpaw-22.8.0/gpaw/dfpt/
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     3571 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/dfpt/__init__.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    17526 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/dfpt/dynamicalmatrix.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     7591 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/dfpt/electronphononcoupling.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      412 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/dfpt/kpointcontainer.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1648 2021-08-20 08:32:04.000000 gpaw-22.8.0/gpaw/dfpt/linearsolver.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    16069 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/dfpt/mixer.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      789 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/dfpt/perturbation.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    18713 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/dfpt/phononcalculator.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    11031 2021-08-20 08:32:04.000000 gpaw-22.8.0/gpaw/dfpt/phononperturbation.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     6709 2021-08-20 08:32:04.000000 gpaw-22.8.0/gpaw/dfpt/phonons.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     2198 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/dfpt/poisson.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1697 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/dfpt/preconditioner.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    14402 2021-08-20 08:32:04.000000 gpaw-22.8.0/gpaw/dfpt/responsecalculator.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     2889 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/dfpt/scipylinearsolver.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     6632 2022-06-29 12:02:59.000000 gpaw-22.8.0/gpaw/dfpt/sternheimeroperator.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     6730 2021-08-20 08:32:04.000000 gpaw-22.8.0/gpaw/dfpt/wavefunctions.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     5924 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/dipole_correction.py
-drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2022-08-19 09:38:54.786161 gpaw-22.8.0/gpaw/directmin/
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1609 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/directmin/__init__.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     5978 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/directmin/derivatives.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    31833 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/directmin/etdm.py
-drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2022-08-19 09:38:54.786161 gpaw-22.8.0/gpaw/directmin/functional/
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      543 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/directmin/functional/__init__.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     4170 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/directmin/functional/ks.py
-drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2022-08-19 09:38:54.786161 gpaw-22.8.0/gpaw/directmin/lcao/
--rw-rw-r--   0 jensj     (1000) jensj     (1000)        0 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/directmin/lcao/__init__.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     5371 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/directmin/lcao/directmin_lcao.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    14008 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/directmin/ls_etdm.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    15354 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/directmin/sd_etdm.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     6741 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/directmin/tools.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     7718 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/domain.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     8457 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/dos.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    12661 2022-08-01 11:19:56.000000 gpaw-22.8.0/gpaw/dscf.py
-drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2022-08-19 09:38:54.786161 gpaw-22.8.0/gpaw/eigensolvers/
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1306 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/eigensolvers/__init__.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     9108 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/eigensolvers/cg.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     7354 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/eigensolvers/davidson.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     5626 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/eigensolvers/diagonalizerbackend.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1093 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/eigensolvers/direct.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     9120 2022-04-29 14:33:47.000000 gpaw-22.8.0/gpaw/eigensolvers/eigensolver.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    11500 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/eigensolvers/rmmdiis.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     4115 2022-06-03 11:02:25.000000 gpaw-22.8.0/gpaw/electrostatic_potential.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     5513 2022-05-11 06:13:16.000000 gpaw-22.8.0/gpaw/elf.py
-drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2022-08-19 09:38:54.786161 gpaw-22.8.0/gpaw/elph/
--rw-rw-r--   0 jensj     (1000) jensj     (1000)        0 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/elph/__init__.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    32300 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/elph/electronphonon.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      283 2022-08-19 09:38:29.000000 gpaw-22.8.0/gpaw/entry_points.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    12874 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/external.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    13082 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/fd_operators.py
-drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2022-08-19 09:38:54.786161 gpaw-22.8.0/gpaw/fdtd/
--rw-rw-r--   0 jensj     (1000) jensj     (1000)       45 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/fdtd/__init__.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    42272 2022-08-01 11:19:56.000000 gpaw-22.8.0/gpaw/fdtd/poisson_fdtd.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    23649 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/fdtd/polarizable_material.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     7009 2022-08-19 09:06:17.000000 gpaw-22.8.0/gpaw/fdtd/potential_couplers.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     6424 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/fftw.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1134 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/forces.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1212 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/fulldiag.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     2256 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/gaunt.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     4298 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/gauss.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    25761 2022-08-01 11:19:56.000000 gpaw-22.8.0/gpaw/grid_descriptor.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    30450 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/hamiltonian.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      967 2022-07-08 08:21:04.000000 gpaw-22.8.0/gpaw/heg.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     6391 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/helmholtz.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    20096 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/hgh.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    28877 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/hgh_parameters.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     3794 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/hubbard.py
-drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2022-08-19 09:38:54.790161 gpaw-22.8.0/gpaw/hybrids/
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      484 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/hybrids/__init__.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      910 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/hybrids/coulomb.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    10483 2022-07-08 05:55:11.000000 gpaw-22.8.0/gpaw/hybrids/eigenvalues.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     5688 2022-08-17 07:20:18.000000 gpaw-22.8.0/gpaw/hybrids/energy.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     4250 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/hybrids/forces.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     3696 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/hybrids/kpts.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1953 2022-08-19 09:06:17.000000 gpaw-22.8.0/gpaw/hybrids/paw.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    11796 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/hybrids/scf.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     6843 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/hybrids/symmetry.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     5433 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/hybrids/wrapper.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    12226 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/hyperfine.py
-drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2022-08-19 09:38:54.790161 gpaw-22.8.0/gpaw/inducedfield/
--rw-rw-r--   0 jensj     (1000) jensj     (1000)       62 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/inducedfield/__init__.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    18155 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/inducedfield/inducedfield_base.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    12149 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/inducedfield/inducedfield_fdtd.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     5584 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/inducedfield/inducedfield_lrtddft.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    17818 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/inducedfield/inducedfield_tddft.py
-drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2022-08-19 09:38:54.790161 gpaw-22.8.0/gpaw/io/
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      425 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/io/__init__.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1814 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/io/fmf.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     5248 2022-06-22 07:02:06.000000 gpaw-22.8.0/gpaw/io/logger.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     8774 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/io/old.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     5947 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/io/tar.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     2722 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/jellium.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    21858 2022-06-29 05:51:57.000000 gpaw-22.8.0/gpaw/kohnsham_layouts.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     2507 2021-09-16 08:03:16.000000 gpaw-22.8.0/gpaw/kpoint.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    20028 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/kpt_descriptor.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    15543 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/kpt_refine.py
-drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2022-08-19 09:38:54.790161 gpaw-22.8.0/gpaw/lcao/
--rw-rw-r--   0 jensj     (1000) jensj     (1000)        0 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/lcao/__init__.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1846 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/lcao/analyse_basis.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     4437 2022-06-29 12:02:59.000000 gpaw-22.8.0/gpaw/lcao/atomic_correction.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     3388 2022-08-19 09:06:17.000000 gpaw-22.8.0/gpaw/lcao/bsse.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     5702 2022-06-12 08:53:14.000000 gpaw-22.8.0/gpaw/lcao/eigensolver.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    14529 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/lcao/el_ph.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     4430 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/lcao/generate_extended.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     6879 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/lcao/generate_ngto_augmented.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     5040 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/lcao/newoverlap.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    29701 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/lcao/overlap.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    14517 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/lcao/projected_wannier.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    16108 2022-06-29 12:02:59.000000 gpaw-22.8.0/gpaw/lcao/pwf2.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     2849 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/lcao/scissors.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    12506 2022-05-11 06:13:16.000000 gpaw-22.8.0/gpaw/lcao/tci.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     6707 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/lcao/tightbinding.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    22448 2022-06-29 12:02:59.000000 gpaw-22.8.0/gpaw/lcao/tools.py
-drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2022-08-19 09:38:54.794161 gpaw-22.8.0/gpaw/lcaotddft/
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     7884 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/lcaotddft/__init__.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     2830 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/lcaotddft/densitymatrix.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     5221 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/lcaotddft/dipolemomentwriter.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     3411 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/lcaotddft/energywriter.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     6834 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/lcaotddft/frequencydensitymatrix.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    10288 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/lcaotddft/hamiltonian.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    20869 2022-05-11 06:13:16.000000 gpaw-22.8.0/gpaw/lcaotddft/ksdecomposition.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     5022 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/lcaotddft/laser.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     3976 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/lcaotddft/linedensity.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1360 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/lcaotddft/logger.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    15521 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/lcaotddft/magneticmomentwriter.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      791 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/lcaotddft/observer.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    17475 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/lcaotddft/propagators.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     2953 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/lcaotddft/qed.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     3819 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/lcaotddft/quadrupolemomentwriter.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1082 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/lcaotddft/restartfilewriter.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     7376 2022-05-11 06:13:16.000000 gpaw-22.8.0/gpaw/lcaotddft/tcm.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      789 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/lcaotddft/timedensitymatrix.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     4882 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/lcaotddft/utilities.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     4358 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/lcaotddft/wfwriter.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    38476 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/lfc.py
-drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2022-08-19 09:38:54.794161 gpaw-22.8.0/gpaw/lrtddft/
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    18566 2022-08-19 09:06:17.000000 gpaw-22.8.0/gpaw/lrtddft/__init__.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    14534 2022-06-29 12:02:59.000000 gpaw-22.8.0/gpaw/lrtddft/apmb.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     6012 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/lrtddft/convergence.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     4054 2022-08-01 11:19:56.000000 gpaw-22.8.0/gpaw/lrtddft/dielectric.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     5402 2022-08-01 11:19:56.000000 gpaw-22.8.0/gpaw/lrtddft/excitation.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    17749 2022-08-01 11:19:56.000000 gpaw-22.8.0/gpaw/lrtddft/excited_state.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     5495 2022-05-11 06:13:16.000000 gpaw-22.8.0/gpaw/lrtddft/finite_differences.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    24104 2022-08-01 11:19:56.000000 gpaw-22.8.0/gpaw/lrtddft/kssingle.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    23373 2022-08-01 11:19:56.000000 gpaw-22.8.0/gpaw/lrtddft/omega_matrix.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     7835 2022-08-01 11:19:56.000000 gpaw-22.8.0/gpaw/lrtddft/spectrum.py
-drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2022-08-19 09:38:54.794161 gpaw-22.8.0/gpaw/lrtddft2/
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    17289 2022-06-22 07:02:06.000000 gpaw-22.8.0/gpaw/lrtddft2/__init__.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     2029 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/lrtddft2/eta.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    19705 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/lrtddft2/k_matrix.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    17699 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/lrtddft2/ks_singles.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     5332 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/lrtddft2/lr_communicators.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    14800 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/lrtddft2/lr_layouts.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    25545 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/lrtddft2/lr_response.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    20849 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/lrtddft2/lr_transitions.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     7014 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/lrtddft2/tools.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    20791 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/matrix.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    23229 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/matrix_descriptor.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    25679 2022-05-18 14:14:47.000000 gpaw-22.8.0/gpaw/mixer.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    12379 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/mom.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    40922 2022-08-01 09:40:12.000000 gpaw-22.8.0/gpaw/mpi.py
-drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2022-08-19 09:38:54.798161 gpaw-22.8.0/gpaw/new/
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     2272 2022-05-18 04:39:27.000000 gpaw-22.8.0/gpaw/new/__init__.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    12563 2022-08-19 09:06:17.000000 gpaw-22.8.0/gpaw/new/ase_interface.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     5619 2022-08-19 09:06:17.000000 gpaw-22.8.0/gpaw/new/backwards_compatibility.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      873 2022-06-01 07:45:54.000000 gpaw-22.8.0/gpaw/new/basis.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     3154 2022-05-18 04:39:27.000000 gpaw-22.8.0/gpaw/new/brillouin.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    13882 2022-08-01 09:40:12.000000 gpaw-22.8.0/gpaw/new/builder.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    10455 2022-08-19 07:19:38.000000 gpaw-22.8.0/gpaw/new/calculation.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     8120 2022-08-01 09:40:12.000000 gpaw-22.8.0/gpaw/new/density.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      249 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/new/eigensolver.py
-drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2022-08-19 09:38:54.798161 gpaw-22.8.0/gpaw/new/fd/
--rw-rw-r--   0 jensj     (1000) jensj     (1000)        0 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/new/fd/__init__.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     5419 2022-06-01 11:13:24.000000 gpaw-22.8.0/gpaw/new/fd/builder.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     4577 2022-08-19 07:19:38.000000 gpaw-22.8.0/gpaw/new/fd/pot_calc.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     6693 2022-07-08 07:52:55.000000 gpaw-22.8.0/gpaw/new/gpw.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      184 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/new/hamiltonian.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    15009 2022-08-19 09:06:17.000000 gpaw-22.8.0/gpaw/new/ibzwfs.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     8141 2022-08-01 09:40:12.000000 gpaw-22.8.0/gpaw/new/input_parameters.py
-drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2022-08-19 09:38:54.798161 gpaw-22.8.0/gpaw/new/lcao/
--rw-rw-r--   0 jensj     (1000) jensj     (1000)        0 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/new/lcao/__init__.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     5258 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/new/lcao/builder.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1031 2022-06-12 08:53:14.000000 gpaw-22.8.0/gpaw/new/lcao/eigensolver.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     6435 2022-06-15 06:57:21.000000 gpaw-22.8.0/gpaw/new/lcao/hamiltonian.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      781 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/new/lcao/hybrids.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     5845 2022-06-03 11:02:25.000000 gpaw-22.8.0/gpaw/new/lcao/wave_functions.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1806 2022-05-18 14:14:47.000000 gpaw-22.8.0/gpaw/new/logger.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      535 2022-05-18 14:14:47.000000 gpaw-22.8.0/gpaw/new/poisson.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     4199 2022-06-03 14:36:00.000000 gpaw-22.8.0/gpaw/new/pot_calc.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1917 2022-07-13 10:13:20.000000 gpaw-22.8.0/gpaw/new/potential.py
-drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2022-08-19 09:38:54.798161 gpaw-22.8.0/gpaw/new/pw/
--rw-rw-r--   0 jensj     (1000) jensj     (1000)        0 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/new/pw/__init__.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     7122 2022-06-01 11:13:24.000000 gpaw-22.8.0/gpaw/new/pw/builder.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     4859 2022-08-01 09:40:12.000000 gpaw-22.8.0/gpaw/new/pw/fulldiag.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     3547 2022-05-11 06:13:16.000000 gpaw-22.8.0/gpaw/new/pw/hamiltonian.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     3757 2022-06-22 07:02:06.000000 gpaw-22.8.0/gpaw/new/pw/poisson.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     5956 2022-08-19 07:19:38.000000 gpaw-22.8.0/gpaw/new/pw/pot_calc.py
-drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2022-08-19 09:38:54.798161 gpaw-22.8.0/gpaw/new/pwfd/
--rw-rw-r--   0 jensj     (1000) jensj     (1000)        0 2022-05-11 06:13:16.000000 gpaw-22.8.0/gpaw/new/pwfd/__init__.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     7792 2022-07-13 10:13:20.000000 gpaw-22.8.0/gpaw/new/pwfd/builder.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    10812 2022-08-01 09:40:12.000000 gpaw-22.8.0/gpaw/new/pwfd/davidson.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    14151 2022-06-03 11:02:25.000000 gpaw-22.8.0/gpaw/new/pwfd/wave_functions.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    12954 2022-05-18 04:39:27.000000 gpaw-22.8.0/gpaw/new/rttddft.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     5753 2022-08-19 09:06:17.000000 gpaw-22.8.0/gpaw/new/scf.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     2098 2022-08-01 09:40:12.000000 gpaw-22.8.0/gpaw/new/smearing.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      888 2022-05-11 06:13:16.000000 gpaw-22.8.0/gpaw/new/spinors.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1714 2022-08-01 09:40:12.000000 gpaw-22.8.0/gpaw/new/spinspiral.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     3823 2022-05-18 04:39:27.000000 gpaw-22.8.0/gpaw/new/symmetry.py
-drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2022-08-19 09:38:54.798161 gpaw-22.8.0/gpaw/new/tb/
--rw-rw-r--   0 jensj     (1000) jensj     (1000)        0 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/new/tb/__init__.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    11135 2022-05-18 14:14:47.000000 gpaw-22.8.0/gpaw/new/tb/builder.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     4339 2022-06-03 11:02:25.000000 gpaw-22.8.0/gpaw/new/wave_functions.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      685 2022-05-18 14:14:47.000000 gpaw-22.8.0/gpaw/new/xc.py
-drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2022-08-19 09:38:54.798161 gpaw-22.8.0/gpaw/nlopt/
--rw-rw-r--   0 jensj     (1000) jensj     (1000)        0 2021-08-20 08:32:04.000000 gpaw-22.8.0/gpaw/nlopt/__init__.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     3055 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/nlopt/basic.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     3665 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/nlopt/linear.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     9804 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/nlopt/matrixel.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    11923 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/nlopt/shg.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     5229 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/nlopt/shift.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    27759 2022-05-18 14:14:47.000000 gpaw-22.8.0/gpaw/occupations.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     4794 2022-06-24 06:07:59.000000 gpaw-22.8.0/gpaw/output.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     2532 2022-05-11 06:13:16.000000 gpaw-22.8.0/gpaw/overlap.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     9020 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/pair_density.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    20149 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/pair_overlap.py
-drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2022-08-19 09:38:54.798161 gpaw-22.8.0/gpaw/pes/
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1497 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/pes/__init__.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     2999 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/pes/continuum.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1697 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/pes/dos.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     6905 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/pes/ds_beta.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     3117 2022-08-01 11:19:56.000000 gpaw-22.8.0/gpaw/pes/state.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     8951 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/pes/tddft.py
-drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2022-08-19 09:38:54.798161 gpaw-22.8.0/gpaw/point_groups/
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      428 2021-08-20 08:32:04.000000 gpaw-22.8.0/gpaw/point_groups/__init__.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)       64 2021-08-20 08:32:04.000000 gpaw-22.8.0/gpaw/point_groups/__main__.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     6343 2022-06-03 11:02:25.000000 gpaw-22.8.0/gpaw/point_groups/check.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     3311 2022-06-07 06:37:06.000000 gpaw-22.8.0/gpaw/point_groups/cli.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1561 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/point_groups/group.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    62872 2021-08-20 08:32:04.000000 gpaw-22.8.0/gpaw/point_groups/groups.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    35010 2022-08-19 09:06:17.000000 gpaw-22.8.0/gpaw/poisson.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    11434 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/poisson_extravacuum.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     8340 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/poisson_moment.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     3562 2022-08-19 09:06:17.000000 gpaw-22.8.0/gpaw/preconditioner.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     5653 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/projections.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    10310 2022-08-19 09:06:17.000000 gpaw-22.8.0/gpaw/pseudopotential.py
-drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2022-08-19 09:38:54.802161 gpaw-22.8.0/gpaw/pw/
--rw-rw-r--   0 jensj     (1000) jensj     (1000)        0 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/pw/__init__.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     4317 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/pw/density.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    18069 2022-07-14 11:17:02.000000 gpaw-22.8.0/gpaw/pw/descriptor.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     5769 2022-06-22 07:02:06.000000 gpaw-22.8.0/gpaw/pw/hamiltonian.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    15166 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/pw/lfc.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     4051 2022-06-22 07:02:06.000000 gpaw-22.8.0/gpaw/pw/poisson.py
-drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2022-08-19 09:38:54.802161 gpaw-22.8.0/gpaw/raman/
--rw-rw-r--   0 jensj     (1000) jensj     (1000)        0 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/raman/__init__.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     3181 2022-06-24 06:07:59.000000 gpaw-22.8.0/gpaw/raman/dipoletransition.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     4721 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/raman/elph.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    14801 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/raman/raman.py
-drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2022-08-19 09:38:54.802161 gpaw-22.8.0/gpaw/response/
--rw-rw-r--   0 jensj     (1000) jensj     (1000)        0 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/response/__init__.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    46643 2022-07-08 08:21:04.000000 gpaw-22.8.0/gpaw/response/bse.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    36557 2022-08-01 09:40:12.000000 gpaw-22.8.0/gpaw/response/chi0.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     4375 2022-07-14 11:17:02.000000 gpaw-22.8.0/gpaw/response/chi0_data.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     9600 2022-07-14 11:17:02.000000 gpaw-22.8.0/gpaw/response/chiks.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1217 2022-08-19 09:06:17.000000 gpaw-22.8.0/gpaw/response/context.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    34068 2022-07-08 05:55:11.000000 gpaw-22.8.0/gpaw/response/df.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     4517 2022-06-24 06:07:59.000000 gpaw-22.8.0/gpaw/response/frequencies.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     7093 2022-07-08 05:55:11.000000 gpaw-22.8.0/gpaw/response/fxc.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     2978 2022-07-08 05:55:11.000000 gpaw-22.8.0/gpaw/response/fxckernel_calc.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    50137 2022-08-01 09:40:12.000000 gpaw-22.8.0/gpaw/response/g0w0.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      894 2022-06-22 07:02:06.000000 gpaw-22.8.0/gpaw/response/gamma_int.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     3977 2022-07-08 08:21:04.000000 gpaw-22.8.0/gpaw/response/groundstate.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     8542 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/response/gw_bands.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    21231 2022-07-08 05:55:11.000000 gpaw-22.8.0/gpaw/response/gwqeh.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     5138 2022-08-01 09:40:12.000000 gpaw-22.8.0/gpaw/response/heisenberg.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     3292 2022-06-29 05:51:57.000000 gpaw-22.8.0/gpaw/response/hilbert.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    21900 2022-07-14 11:17:02.000000 gpaw-22.8.0/gpaw/response/integrators.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     7109 2022-06-15 12:42:16.000000 gpaw-22.8.0/gpaw/response/kernels.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    40262 2022-08-01 11:19:56.000000 gpaw-22.8.0/gpaw/response/kslrf.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    38831 2022-08-01 09:40:12.000000 gpaw-22.8.0/gpaw/response/kspair.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    26023 2022-08-01 09:40:12.000000 gpaw-22.8.0/gpaw/response/kxc.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     7444 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/response/math_func.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     9348 2022-08-01 09:40:12.000000 gpaw-22.8.0/gpaw/response/mft.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    25012 2022-08-01 09:40:12.000000 gpaw-22.8.0/gpaw/response/pair.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     2144 2022-06-15 06:57:21.000000 gpaw-22.8.0/gpaw/response/paw.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     4323 2022-07-14 11:17:02.000000 gpaw-22.8.0/gpaw/response/pw_parallelization.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     4563 2022-05-25 11:56:18.000000 gpaw-22.8.0/gpaw/response/q0_correction.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    18441 2022-07-08 05:55:11.000000 gpaw-22.8.0/gpaw/response/qeh.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    17050 2022-08-01 11:19:56.000000 gpaw-22.8.0/gpaw/response/site_kernels.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    19802 2022-08-01 09:40:12.000000 gpaw-22.8.0/gpaw/response/susceptibility.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    18524 2022-06-15 06:57:21.000000 gpaw-22.8.0/gpaw/response/symmetry.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     2568 2022-07-08 05:55:11.000000 gpaw-22.8.0/gpaw/response/symmetry_ops.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1541 2022-05-11 06:13:16.000000 gpaw-22.8.0/gpaw/response/temp.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     8025 2022-07-14 11:17:02.000000 gpaw-22.8.0/gpaw/response/tms.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     8078 2022-07-08 08:21:04.000000 gpaw-22.8.0/gpaw/response/tool.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     7177 2022-05-11 06:13:16.000000 gpaw-22.8.0/gpaw/response/wgg.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     3508 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/response/wstc.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1730 2021-08-20 08:32:04.000000 gpaw-22.8.0/gpaw/rotation.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     8397 2022-08-19 07:19:38.000000 gpaw-22.8.0/gpaw/scf.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    57937 2022-08-19 09:06:17.000000 gpaw-22.8.0/gpaw/setup.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    24050 2022-08-19 09:06:17.000000 gpaw-22.8.0/gpaw/setup_data.py
-drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2022-08-19 09:38:54.806161 gpaw-22.8.0/gpaw/solvation/
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     2231 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/solvation/__init__.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     6429 2022-06-15 13:25:04.000000 gpaw-22.8.0/gpaw/solvation/calculator.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    35118 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/solvation/cavity.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     3443 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/solvation/dielectric.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      306 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/solvation/gridmem.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    10379 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/solvation/hamiltonian.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     5718 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/solvation/interactions.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    11188 2022-05-11 06:13:16.000000 gpaw-22.8.0/gpaw/solvation/poisson.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    51310 2022-08-01 11:19:56.000000 gpaw-22.8.0/gpaw/solvation/sjm.py
-drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2022-08-19 09:38:54.806161 gpaw-22.8.0/gpaw/sphere/
--rw-rw-r--   0 jensj     (1000) jensj     (1000)        0 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/sphere/__init__.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    28076 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/sphere/lebedev.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     9227 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/spherical_harmonics.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    29555 2022-06-01 09:46:51.000000 gpaw-22.8.0/gpaw/spinorbit.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     2687 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/spline.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     3099 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/stress.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    21337 2022-05-18 04:39:27.000000 gpaw-22.8.0/gpaw/symmetry.py
-drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2022-08-19 09:38:54.806161 gpaw-22.8.0/gpaw/tddft/
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    21299 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/tddft/__init__.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    11361 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/tddft/abc.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     6147 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/tddft/ehrenfest.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     2845 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/tddft/folding.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1005 2021-08-20 08:32:04.000000 gpaw-22.8.0/gpaw/tddft/laser.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    45460 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/tddft/propagators.py
-drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2022-08-19 09:38:54.806161 gpaw-22.8.0/gpaw/tddft/solvers/
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      508 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/tddft/solvers/__init__.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     2145 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/tddft/solvers/base.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     6863 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/tddft/solvers/bicgstab.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     5006 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/tddft/solvers/cscg.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    15861 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/tddft/spectrum.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    30508 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/tddft/tdopers.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1691 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/tddft/units.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     5086 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/tddft/utils.py
-drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2022-08-19 09:38:54.810161 gpaw-22.8.0/gpaw/test/
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     2511 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/__init__.py
-drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2022-08-19 09:38:54.814161 gpaw-22.8.0/gpaw/test/ase_features/
--rw-rw-r--   0 jensj     (1000) jensj     (1000)        0 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/test/ase_features/__init__.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     2432 2022-05-11 06:13:16.000000 gpaw-22.8.0/gpaw/test/ase_features/autoneb.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      675 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/test/ase_features/test_ase3k.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      218 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/ase_features/test_ase3k_version.py
-drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2022-08-19 09:38:54.814161 gpaw-22.8.0/gpaw/test/big/
--rw-rw-r--   0 jensj     (1000) jensj     (1000)        0 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/test/big/__init__.py
-drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2022-08-19 09:38:54.814161 gpaw-22.8.0/gpaw/test/big/dcdft/
--rw-rw-r--   0 jensj     (1000) jensj     (1000)        0 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/test/big/dcdft/__init__.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     4167 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/big/dcdft/analyse.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     2903 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/test/big/dcdft/pbe_abinit_fhi.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     3371 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/test/big/dcdft/pbe_abinit_hgh.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     3477 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/test/big/dcdft/pbe_abinit_paw.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     4205 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/big/dcdft/pbe_aims.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     3857 2022-08-19 09:06:17.000000 gpaw-22.8.0/gpaw/test/big/dcdft/pbe_gpaw_pw.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     2644 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/test/big/dcdft/pbe_gpaw_pw_verify.py
-drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2022-08-19 09:38:54.814161 gpaw-22.8.0/gpaw/test/big/g2_1/
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     6393 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/test/big/g2_1/analyse.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      962 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/test/big/g2_1/g21gpaw.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1060 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/test/big/g2_1/g21nwchem.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      171 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/big/g2_1/generate.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     7259 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/big/g2_1/pbe_gpaw_nrel_plot.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      131 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/big/g2_1/submit.agts.py
-drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2022-08-19 09:38:54.814161 gpaw-22.8.0/gpaw/test/big/hsk/
--rw-rw-r--   0 jensj     (1000) jensj     (1000)        0 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/test/big/hsk/__init__.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     3254 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/test/big/hsk/hsk.py
-drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2022-08-19 09:38:54.814161 gpaw-22.8.0/gpaw/test/big/kpb/
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      960 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/big/kpb/check.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     2681 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/big/kpb/molecules.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      130 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/big/kpb/submit.agts.py
-drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2022-08-19 09:38:54.814161 gpaw-22.8.0/gpaw/test/big/scf/
--rw-rw-r--   0 jensj     (1000) jensj     (1000)        0 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/test/big/scf/__init__.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    32199 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/test/big/scf/analyse.py
-drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2022-08-19 09:38:54.814161 gpaw-22.8.0/gpaw/test/big/setups/
--rw-rw-r--   0 jensj     (1000) jensj     (1000)        0 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/test/big/setups/__init__.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    12935 2022-07-08 05:55:11.000000 gpaw-22.8.0/gpaw/test/conftest.py
-drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2022-08-19 09:38:54.814161 gpaw-22.8.0/gpaw/test/corehole/
--rw-rw-r--   0 jensj     (1000) jensj     (1000)        0 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/test/corehole/__init__.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1768 2021-08-20 08:32:04.000000 gpaw-22.8.0/gpaw/test/corehole/si_nonortho.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1755 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/corehole/test_h2o.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1687 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/test/corehole/test_h2o_dks.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1156 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/test/corehole/test_h2o_recursion.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1611 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/corehole/test_si.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1237 2022-08-19 07:57:19.000000 gpaw-22.8.0/gpaw/test/crontab.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1252 2022-05-18 04:39:27.000000 gpaw-22.8.0/gpaw/test/dipole_me_test.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      661 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/dipole_test.py
-drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2022-08-19 09:38:54.814161 gpaw-22.8.0/gpaw/test/dscf/
--rw-rw-r--   0 jensj     (1000) jensj     (1000)        0 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/test/dscf/__init__.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     2933 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/test/dscf/dscf_forces.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1294 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/test/dscf/test_dscf_lcao.py
-drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2022-08-19 09:38:54.814161 gpaw-22.8.0/gpaw/test/eigen/
--rw-rw-r--   0 jensj     (1000) jensj     (1000)        0 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/test/eigen/__init__.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      988 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/eigen/test_blocked_rmm_diis.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      856 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/eigen/test_cg.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1227 2021-08-20 08:32:04.000000 gpaw-22.8.0/gpaw/test/eigen/test_cg2.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1524 2021-08-20 08:32:04.000000 gpaw-22.8.0/gpaw/test/eigen/test_davidson.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      744 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/test/eigen/test_keep_htpsit.py
-drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2022-08-19 09:38:54.814161 gpaw-22.8.0/gpaw/test/elph/
--rw-rw-r--   0 jensj     (1000) jensj     (1000)        0 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/elph/__init__.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1525 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/elph/test_electronphonon.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     3077 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/elph/test_elph_li.py
-drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2022-08-19 09:38:54.818162 gpaw-22.8.0/gpaw/test/ext_potential/
--rw-rw-r--   0 jensj     (1000) jensj     (1000)        0 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/test/ext_potential/__init__.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     7131 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/test/ext_potential/stark_shift.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1231 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/ext_potential/test_b_field.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1023 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/ext_potential/test_collection.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1322 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/ext_potential/test_constant_e_field.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1880 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/ext_potential/test_external.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1948 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/ext_potential/test_external_pw.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     2530 2022-08-19 09:06:17.000000 gpaw-22.8.0/gpaw/test/ext_potential/test_harmonic.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     2991 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/ext_potential/test_point_charge.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1109 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/ext_potential/test_step.py
-drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2022-08-19 09:38:54.818162 gpaw-22.8.0/gpaw/test/exx/
--rw-rw-r--   0 jensj     (1000) jensj     (1000)        0 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/test/exx/__init__.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1771 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/test/exx/test_coarse.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     2552 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/exx/test_derivs.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1308 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/exx/test_double_cell.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1926 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/test/exx/test_exx.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1725 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/exx/test_exx_scf.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     3865 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/exx/test_forces_ut.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1555 2022-07-13 10:13:20.000000 gpaw-22.8.0/gpaw/test/exx/test_kpts.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     2027 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/test/exx/test_unocc.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      240 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/exx/test_xc.py
-drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2022-08-19 09:38:54.818162 gpaw-22.8.0/gpaw/test/fd_ops/
--rw-rw-r--   0 jensj     (1000) jensj     (1000)        0 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/test/fd_ops/__init__.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1372 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/fd_ops/test_gd.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     2838 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/fd_ops/test_gradient.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     3598 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/fd_ops/test_laplace.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1205 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/fd_ops/test_nabla.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      686 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/test/fd_ops/test_non_periodic.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1444 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/test/fd_ops/test_transformations.py
-drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2022-08-19 09:38:54.818162 gpaw-22.8.0/gpaw/test/fdtd/
--rw-rw-r--   0 jensj     (1000) jensj     (1000)        0 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/test/fdtd/__init__.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     3558 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/fdtd/test_ed.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     7219 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/fdtd/test_ed_inducedfield.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     3390 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/fdtd/test_ed_shapes.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     2410 2021-08-20 08:32:04.000000 gpaw-22.8.0/gpaw/test/fdtd/test_ed_wrapper.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      986 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/fermilevel_test.py
-drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2022-08-19 09:38:54.818162 gpaw-22.8.0/gpaw/test/fileio/
--rw-rw-r--   0 jensj     (1000) jensj     (1000)        0 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/test/fileio/__init__.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1288 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/fileio/test_ascii_art.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1142 2022-08-01 11:19:56.000000 gpaw-22.8.0/gpaw/test/fileio/test_file_reference.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      411 2022-07-08 05:55:11.000000 gpaw-22.8.0/gpaw/test/fileio/test_idiotproof_setup.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1274 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/test/fileio/test_parallel.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      330 2021-08-20 08:32:04.000000 gpaw-22.8.0/gpaw/test/fileio/test_read_old_gpw.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      994 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/test/fileio/test_refine.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     2298 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/fileio/test_restart.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1864 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/fileio/test_restart_density.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      467 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/fileio/test_wfs_auto.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      620 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/fileio/test_wfs_io.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      220 2022-05-18 04:39:27.000000 gpaw-22.8.0/gpaw/test/fileio/yaml_test.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    12389 2022-08-19 07:19:38.000000 gpaw-22.8.0/gpaw/test/fuzz.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      306 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/fuzz_test.py
-drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2022-08-19 09:38:54.822162 gpaw-22.8.0/gpaw/test/generic/
--rw-rw-r--   0 jensj     (1000) jensj     (1000)       74 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/test/generic/__init__.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      682 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/test/generic/colinear.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      904 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/generic/test_2Al.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1617 2022-07-08 05:55:11.000000 gpaw-22.8.0/gpaw/test/generic/test_8Si.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      402 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/test/generic/test_Cl_minus.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1080 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/generic/test_Cu.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1024 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/generic/test_H_force.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      696 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/generic/test_IP_oxygen.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      539 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/generic/test_al_chain.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1121 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/generic/test_asym_box.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      680 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/test/generic/test_bulk.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     2200 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/generic/test_guc_force.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1876 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/generic/test_hydrogen.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      444 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/generic/test_mixer.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1554 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/generic/test_move_across_cell.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1600 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/test/generic/test_proton.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     3264 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/generic/test_relax.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1286 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/test/generic/test_si.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      722 2022-07-08 05:55:11.000000 gpaw-22.8.0/gpaw/test/generic/test_si_primitive.py
-drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2022-08-19 09:38:54.822162 gpaw-22.8.0/gpaw/test/gllb/
--rw-rw-r--   0 jensj     (1000) jensj     (1000)        0 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/test/gllb/__init__.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      321 2022-05-18 04:39:27.000000 gpaw-22.8.0/gpaw/test/gllb/gllbghost_test.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1885 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/test/gllb/test_atomic.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     5719 2021-07-05 14:53:36.000000 gpaw-22.8.0/gpaw/test/gllb/test_diamond.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1326 2022-07-14 11:17:02.000000 gpaw-22.8.0/gpaw/test/gllb/test_metallic.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1349 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/gllb/test_ne.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     2169 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/gllb/test_ne_disc.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     3405 2022-07-14 11:17:02.000000 gpaw-22.8.0/gpaw/test/gllb/test_restart_eigenvalues.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1530 2021-07-05 14:53:36.000000 gpaw-22.8.0/gpaw/test/gllb/test_spin.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     2625 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/gllb/test_variants.py
-drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2022-08-19 09:38:54.822162 gpaw-22.8.0/gpaw/test/lcao/
--rw-rw-r--   0 jensj     (1000) jensj     (1000)        0 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/test/lcao/__init__.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      877 2022-07-08 08:21:04.000000 gpaw-22.8.0/gpaw/test/lcao/restart.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      345 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/lcao/test_analyse_basis.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     2145 2022-05-11 06:13:16.000000 gpaw-22.8.0/gpaw/test/lcao/test_atomic_corrections.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1876 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/lcao/test_bsse.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1212 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/lcao/test_bulk.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1863 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/test/lcao/test_density.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1597 2021-08-20 08:32:04.000000 gpaw-22.8.0/gpaw/test/lcao/test_dos.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1565 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/lcao/test_fd2lcao_restart.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      412 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/test/lcao/test_fftmixer.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     2056 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/lcao/test_force.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     3015 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/lcao/test_generate_ngto.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1124 2022-05-18 04:39:27.000000 gpaw-22.8.0/gpaw/test/lcao/test_gllb_si.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      988 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/lcao/test_h2o.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     3518 2022-05-11 06:13:16.000000 gpaw-22.8.0/gpaw/test/lcao/test_kpts_many_combinations.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     2122 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/lcao/test_largecellforce.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     3499 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/lcao/test_lcao_complicated.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      858 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/lcao/test_lcao_elpa.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1231 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/lcao/test_lcao_elpa_kpts.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1194 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/lcao/test_lcao_hamiltonian.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     4873 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/lcao/test_lcao_parallel.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     5125 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/lcao/test_lcao_parallel_kpt.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1094 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/lcao/test_lcao_projections.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     2441 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/lcao/test_pair_and_coulomb.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      583 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/lcao/test_scissors.py
-drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2022-08-19 09:38:54.826162 gpaw-22.8.0/gpaw/test/lcaotddft/
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     3173 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/lcaotddft/__init__.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     3189 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/lcaotddft/demo_tddft.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     7840 2022-05-18 04:39:27.000000 gpaw-22.8.0/gpaw/test/lcaotddft/test_circular_dichroism.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1554 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/lcaotddft/test_fxc_is_xc.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1671 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/lcaotddft/test_fxc_rpa.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     2265 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/lcaotddft/test_fxc_vs_linearize.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     2263 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/lcaotddft/test_laser.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     3674 2022-08-19 07:19:38.000000 gpaw-22.8.0/gpaw/test/lcaotddft/test_lcaotddft_vs_lrtddft.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1799 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/lcaotddft/test_lcaotddft_vs_lrtddft2_rpa.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    10995 2022-05-18 04:39:27.000000 gpaw-22.8.0/gpaw/test/lcaotddft/test_molecule.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     2822 2022-08-17 09:31:15.000000 gpaw-22.8.0/gpaw/test/lcaotddft/test_periodic.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     2165 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/lcaotddft/test_replay.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     3859 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/lcaotddft/test_restart.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     3650 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/lcaotddft/test_rremission.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     2947 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/lcaotddft/test_simple.py
-drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2022-08-19 09:38:54.826162 gpaw-22.8.0/gpaw/test/lfc/
--rw-rw-r--   0 jensj     (1000) jensj     (1000)        0 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/test/lfc/__init__.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1757 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/lfc/test_derivatives.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      749 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/test/lfc/test_lf.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1420 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/test/lfc/test_second_derivative.py
-drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2022-08-19 09:38:54.826162 gpaw-22.8.0/gpaw/test/linalg/
--rw-rw-r--   0 jensj     (1000) jensj     (1000)        0 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/test/linalg/__init__.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     2332 2022-06-29 12:02:59.000000 gpaw-22.8.0/gpaw/test/linalg/test_blas.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      851 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/linalg/test_dot.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      880 2022-06-29 12:02:59.000000 gpaw-22.8.0/gpaw/test/linalg/test_gemm.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      811 2022-06-29 12:02:59.000000 gpaw-22.8.0/gpaw/test/linalg/test_gemm_complex.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      359 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/test/linalg/test_lapack.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      798 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/linalg/test_mmm.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      962 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/test/linalg/test_zher.py
-drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2022-08-19 09:38:54.826162 gpaw-22.8.0/gpaw/test/lrtddft/
--rw-rw-r--   0 jensj     (1000) jensj     (1000)        0 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/test/lrtddft/__init__.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1075 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/test/lrtddft/d2Excdn2.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1829 2022-08-01 11:19:56.000000 gpaw-22.8.0/gpaw/test/lrtddft/rraman.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     2284 2022-08-01 11:19:56.000000 gpaw-22.8.0/gpaw/test/lrtddft/rraman_albrecht.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     4681 2022-08-01 11:19:56.000000 gpaw-22.8.0/gpaw/test/lrtddft/test_1.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1394 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/test/lrtddft/test_2.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     4359 2021-08-20 08:32:04.000000 gpaw-22.8.0/gpaw/test/lrtddft/test_3.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     2450 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/test/lrtddft/test_apmb.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1077 2022-05-18 04:39:27.000000 gpaw-22.8.0/gpaw/test/lrtddft/test_dielectric.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     7209 2022-08-01 11:19:56.000000 gpaw-22.8.0/gpaw/test/lrtddft/test_excited_state.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     2323 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/lrtddft/test_kssingles.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     2792 2022-08-01 11:19:56.000000 gpaw-22.8.0/gpaw/test/lrtddft/test_kssingles_Be.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     2333 2022-05-18 04:39:27.000000 gpaw-22.8.0/gpaw/test/lrtddft/test_lrtddft2.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1521 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/lrtddft/test_lrtddft_basics.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1541 2022-08-01 11:19:56.000000 gpaw-22.8.0/gpaw/test/lrtddft/test_lrtddft_log.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     2337 2021-08-20 08:32:04.000000 gpaw-22.8.0/gpaw/test/lrtddft/test_pes.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     3152 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/lrtddft/test_placzek_profeta_albrecht.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      516 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/lrtddft/test_rraman.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      719 2022-08-01 11:19:56.000000 gpaw-22.8.0/gpaw/test/lrtddft/test_select.py
-drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2022-08-19 09:38:54.826162 gpaw-22.8.0/gpaw/test/lrtddft2/
--rw-rw-r--   0 jensj     (1000) jensj     (1000)        0 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/test/lrtddft2/__init__.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     2414 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/test/lrtddft2/test_Al2.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     2250 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/test/lrtddft2/test_H2O-lcao.py
-drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2022-08-19 09:38:54.826162 gpaw-22.8.0/gpaw/test/maths/
--rw-rw-r--   0 jensj     (1000) jensj     (1000)        0 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/test/maths/__init__.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1365 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/test/maths/test_fftw.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      908 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/maths/test_fsbt.py
-drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2022-08-19 09:38:54.826162 gpaw-22.8.0/gpaw/test/mgga/
--rw-rw-r--   0 jensj     (1000) jensj     (1000)        0 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/test/mgga/__init__.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1378 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/test/mgga/test_mgga_restart.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      620 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/test/mgga/test_mgga_sc.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     2293 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/test/mgga/test_nsc_MGGA.py
-drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2022-08-19 09:38:54.830162 gpaw-22.8.0/gpaw/test/mom/
--rw-rw-r--   0 jensj     (1000) jensj     (1000)        0 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/mom/__init__.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     2350 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/mom/test_mom_fd_energy.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1664 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/mom/test_mom_lcao_forces.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1506 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/mom/test_mom_lcao_smearing.py
-drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2022-08-19 09:38:54.830162 gpaw-22.8.0/gpaw/test/noncollinear/
--rw-rw-r--   0 jensj     (1000) jensj     (1000)        0 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/test/noncollinear/__init__.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      685 2022-06-01 06:14:40.000000 gpaw-22.8.0/gpaw/test/noncollinear/o2_test.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      592 2022-08-01 09:40:12.000000 gpaw-22.8.0/gpaw/test/noncollinear/rad_pot_test.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     2301 2022-06-03 11:02:16.000000 gpaw-22.8.0/gpaw/test/noncollinear/soc_test.py
-drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2022-08-19 09:38:54.830162 gpaw-22.8.0/gpaw/test/ofdft/
--rw-rw-r--   0 jensj     (1000) jensj     (1000)        0 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/test/ofdft/__init__.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1381 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/ofdft/test_ofdft.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      958 2022-06-29 06:55:05.000000 gpaw-22.8.0/gpaw/test/ofdft/test_ofdft_pbc.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1302 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/test/ofdft/test_ofdft_scale.py
-drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2022-08-19 09:38:54.830162 gpaw-22.8.0/gpaw/test/parallel/
--rw-rw-r--   0 jensj     (1000) jensj     (1000)        0 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/test/parallel/__init__.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1280 2022-05-18 04:39:27.000000 gpaw-22.8.0/gpaw/test/parallel/davidson_scalapack_test.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      832 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/test/parallel/scalapack_pdlasrt_hang.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     2315 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/parallel/test_arraydict_redist.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1781 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/parallel/test_augment_grid.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1847 2022-05-11 06:13:16.000000 gpaw-22.8.0/gpaw/test/parallel/test_blacsdist.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      493 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/parallel/test_compare.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     2251 2021-07-05 14:53:36.000000 gpaw-22.8.0/gpaw/test/parallel/test_diamond_gllb.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     5252 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/parallel/test_fd_parallel.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     5237 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/parallel/test_fd_parallel_kpt.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1420 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/test/parallel/test_kptpar.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1158 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/parallel/test_mpi.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     2463 2022-05-11 06:13:16.000000 gpaw-22.8.0/gpaw/test/parallel/test_parallel_eigh.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    11365 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/parallel/test_pblas.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      126 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/test/parallel/test_redistribute_grid.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     7747 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/parallel/test_scalapack.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     2096 2022-05-11 06:13:16.000000 gpaw-22.8.0/gpaw/test/parallel/test_scalapack_diag_simple.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1071 2021-08-20 08:32:04.000000 gpaw-22.8.0/gpaw/test/parallel/test_scalapack_mpirecv_crash.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      818 2022-05-11 06:13:16.000000 gpaw-22.8.0/gpaw/test/parallel/test_submatrix_redist.py
-drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2022-08-19 09:38:54.830162 gpaw-22.8.0/gpaw/test/pathological/
--rw-rw-r--   0 jensj     (1000) jensj     (1000)        0 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/test/pathological/__init__.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      689 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/pathological/test_LDA_unstable.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      680 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/test/pathological/test_lcao_spos_derivative.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     2158 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/test/pathological/test_nonlocalset.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      859 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/test/pathological/test_numpy_zdotc_graphite.py
-drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2022-08-19 09:38:54.830162 gpaw-22.8.0/gpaw/test/poisson/
--rw-rw-r--   0 jensj     (1000) jensj     (1000)        0 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/test/poisson/__init__.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     4711 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/poisson/test_fastpoisson.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1746 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/poisson/test_generalizedlaue.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1363 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/test/poisson/test_metallic_poisson.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1421 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/poisson/test_poisson.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1454 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/poisson/test_poisson_asym.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     5939 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/poisson/test_poisson_extravacuum.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     9519 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/poisson/test_poisson_moment.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     3328 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/poisson/test_poisson_restart.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1379 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/poisson/test_pw_charged.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1718 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/poisson/test_screened_poisson.py
-drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2022-08-19 09:38:54.834162 gpaw-22.8.0/gpaw/test/pseudopotential/
--rw-rw-r--   0 jensj     (1000) jensj     (1000)   114225 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/test/pseudopotential/H_pz_hgh.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    64903 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/test/pseudopotential/H_sg15.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)   187223 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/test/pseudopotential/O_pz_hgh.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)        0 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/test/pseudopotential/__init__.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      344 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/test/pseudopotential/test_ah.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1886 2021-08-20 08:32:04.000000 gpaw-22.8.0/gpaw/test/pseudopotential/test_atompaw.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     3171 2021-08-20 08:32:04.000000 gpaw-22.8.0/gpaw/test/pseudopotential/test_hgh_h2o.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1473 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/pseudopotential/test_sg15_hydrogen.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     2239 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/pseudopotential/test_upf_h2o.py
-drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2022-08-19 09:38:54.834162 gpaw-22.8.0/gpaw/test/pw/
--rw-rw-r--   0 jensj     (1000) jensj     (1000)        0 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/test/pw/__init__.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1399 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/test/pw/test_augment_grids.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      554 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/pw/test_bulk.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1274 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/pw/test_davidson_pw.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      572 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/test/pw/test_direct.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      311 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/pw/test_electrostatic_potential.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     2903 2022-05-11 06:13:16.000000 gpaw-22.8.0/gpaw/test/pw/test_expert_diag.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      461 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/pw/test_fftmixer.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1562 2022-07-13 10:13:20.000000 gpaw-22.8.0/gpaw/test/pw/test_fulldiag.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1945 2022-07-13 10:13:20.000000 gpaw-22.8.0/gpaw/test/pw/test_fulldiagk.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      695 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/test/pw/test_h.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     2203 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/pw/test_interpol.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1923 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/pw/test_lfc.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      443 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/pw/test_moleculecg.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1937 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/pw/test_par_strategies.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1665 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/pw/test_reallfc.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1106 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/pw/test_si_stress.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      558 2022-07-08 05:55:11.000000 gpaw-22.8.0/gpaw/test/pw/test_slab.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      446 2022-06-22 07:02:06.000000 gpaw-22.8.0/gpaw/test/pw/test_smallanglecell.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     2099 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/pw/test_stresstest.py
-drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2022-08-19 09:38:54.834162 gpaw-22.8.0/gpaw/test/radial/
--rw-rw-r--   0 jensj     (1000) jensj     (1000)        0 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/test/radial/__init__.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      464 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/radial/test_integral4.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      292 2021-08-11 13:41:50.000000 gpaw-22.8.0/gpaw/test/radial/test_lebedev.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     2069 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/test/radial/test_two_phi_plw_integrals.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     2207 2022-08-01 11:19:56.000000 gpaw-22.8.0/gpaw/test/radial/test_ylexpand.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     5218 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/test/radial/test_yukawa_radial.py
-drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2022-08-19 09:38:54.834162 gpaw-22.8.0/gpaw/test/ralda/
--rw-rw-r--   0 jensj     (1000) jensj     (1000)        0 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/test/ralda/__init__.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     2238 2022-08-01 09:40:12.000000 gpaw-22.8.0/gpaw/test/ralda/ralda_H2_test.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1615 2022-06-15 12:42:16.000000 gpaw-22.8.0/gpaw/test/ralda/ralda_He_test.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1433 2022-08-01 09:40:12.000000 gpaw-22.8.0/gpaw/test/ralda/ralda_Ni_test.py
-drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2022-08-19 09:38:54.834162 gpaw-22.8.0/gpaw/test/raman/
--rw-rw-r--   0 jensj     (1000) jensj     (1000)        0 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/raman/__init__.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     3652 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/raman/test_dipole_transition.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     3833 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/raman/test_dipole_transition2.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     2994 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/raman/test_elph_matrix.py
-drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2022-08-19 09:38:54.838162 gpaw-22.8.0/gpaw/test/response/
--rw-rw-r--   0 jensj     (1000) jensj     (1000)        0 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/test/response/__init__.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1563 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/response/hyd_chain_response.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     4786 2022-07-08 05:55:11.000000 gpaw-22.8.0/gpaw/test/response/test_afm_hchain_sf_gssALDA.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1991 2022-07-08 05:55:11.000000 gpaw-22.8.0/gpaw/test/response/test_aluminum_EELS_ALDA.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     2023 2022-07-08 05:55:11.000000 gpaw-22.8.0/gpaw/test/response/test_aluminum_EELS_RPA.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     2732 2022-05-11 06:13:16.000000 gpaw-22.8.0/gpaw/test/response/test_au02_absorption.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     2117 2022-05-11 06:13:16.000000 gpaw-22.8.0/gpaw/test/response/test_bse_MoS2_cut.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1993 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/response/test_bse_aluminum.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     2442 2022-05-11 06:13:16.000000 gpaw-22.8.0/gpaw/test/response/test_bse_silicon.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     2855 2022-05-26 05:25:41.000000 gpaw-22.8.0/gpaw/test/response/test_chi0.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     8920 2022-08-19 09:38:29.000000 gpaw-22.8.0/gpaw/test/response/test_chi0_extend_head.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     3861 2022-05-11 06:12:59.000000 gpaw-22.8.0/gpaw/test/response/test_chi0_intraband_test.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     6578 2022-08-17 07:20:18.000000 gpaw-22.8.0/gpaw/test/response/test_chiks.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     3798 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/response/test_diamond_absorption.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     3879 2022-07-08 05:55:11.000000 gpaw-22.8.0/gpaw/test/response/test_graphene.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     3967 2022-07-08 05:55:11.000000 gpaw-22.8.0/gpaw/test/response/test_graphene_EELS.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1713 2022-08-01 09:40:12.000000 gpaw-22.8.0/gpaw/test/response/test_gw_MoS2_cut.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1807 2022-05-25 12:10:30.000000 gpaw-22.8.0/gpaw/test/response/test_gw_hBN_extrapolate.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      577 2022-05-25 06:01:43.000000 gpaw-22.8.0/gpaw/test/response/test_gw_ppa.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1377 2022-06-01 06:14:40.000000 gpaw-22.8.0/gpaw/test/response/test_gw_restart_file.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     2741 2022-08-01 09:40:12.000000 gpaw-22.8.0/gpaw/test/response/test_gw_si.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      955 2022-06-15 06:57:21.000000 gpaw-22.8.0/gpaw/test/response/test_gw_too.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      665 2022-05-25 06:01:43.000000 gpaw-22.8.0/gpaw/test/response/test_gw_vertex.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     6631 2022-06-22 07:02:06.000000 gpaw-22.8.0/gpaw/test/response/test_heisenberg.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     6018 2022-07-14 11:17:02.000000 gpaw-22.8.0/gpaw/test/response/test_iron_sf_ALDA.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     3441 2022-08-01 09:40:12.000000 gpaw-22.8.0/gpaw/test/response/test_iron_sf_gssALDA.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    11654 2022-08-01 09:40:12.000000 gpaw-22.8.0/gpaw/test/response/test_mft.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     4609 2022-07-08 05:55:11.000000 gpaw-22.8.0/gpaw/test/response/test_na_plasmon.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1784 2022-07-08 05:55:11.000000 gpaw-22.8.0/gpaw/test/response/test_na_plasmons.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     2095 2022-07-08 05:55:11.000000 gpaw-22.8.0/gpaw/test/response/test_na_plasmons_tetrahedron.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     3912 2022-07-08 08:21:04.000000 gpaw-22.8.0/gpaw/test/response/test_pair.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     2502 2022-08-01 09:40:12.000000 gpaw-22.8.0/gpaw/test/response/test_paw_ft.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     3956 2022-05-25 06:01:43.000000 gpaw-22.8.0/gpaw/test/response/test_pdens_tool.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     5524 2022-07-08 05:55:11.000000 gpaw-22.8.0/gpaw/test/response/test_qeh.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     2182 2022-07-08 05:55:11.000000 gpaw-22.8.0/gpaw/test/response/test_silicon_chi_RPA.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    24061 2022-08-19 09:06:17.000000 gpaw-22.8.0/gpaw/test/response/test_site_kernels.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1042 2022-06-01 06:14:40.000000 gpaw-22.8.0/gpaw/test/response/test_test_unit_sphere_area.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     3472 2022-07-14 11:17:02.000000 gpaw-22.8.0/gpaw/test/response/test_two-aluminum_chi_RPA.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      339 2022-05-11 06:13:16.000000 gpaw-22.8.0/gpaw/test/response/test_wgg_factorization.py
-drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2022-08-19 09:38:54.838162 gpaw-22.8.0/gpaw/test/rpa/
--rw-rw-r--   0 jensj     (1000) jensj     (1000)        0 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/test/rpa/__init__.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      736 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/rpa/rpa_C6_He.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1550 2022-05-11 06:13:16.000000 gpaw-22.8.0/gpaw/test/rpa/test_rpa_energy_N2.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1038 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/rpa/test_rpa_energy_Na.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      911 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/rpa/test_rpa_energy_Ni.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      857 2022-08-01 09:40:12.000000 gpaw-22.8.0/gpaw/test/rpa/test_rpa_energy_Si.py
-drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2022-08-19 09:38:54.838162 gpaw-22.8.0/gpaw/test/rsf_yukawa/
--rw-rw-r--   0 jensj     (1000) jensj     (1000)        0 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/test/rsf_yukawa/__init__.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1920 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/rsf_yukawa/test_lrtddft_short.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1636 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/rsf_yukawa/test_rsf_general.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1775 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/rsf_yukawa/test_rsf_ivo_sing_mg.py
-drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2022-08-19 09:38:54.838162 gpaw-22.8.0/gpaw/test/setups/
--rw-rw-r--   0 jensj     (1000) jensj     (1000)        0 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/test/setups/__init__.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1580 2022-05-18 04:39:27.000000 gpaw-22.8.0/gpaw/test/setups/setup_basis_spec_test.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    12594 2022-08-03 12:10:29.000000 gpaw-22.8.0/gpaw/test/setups/test_derivative_integrals.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1020 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/setups/test_generator2.py
-drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2022-08-19 09:38:54.838162 gpaw-22.8.0/gpaw/test/sic/
--rw-rw-r--   0 jensj     (1000) jensj     (1000)        0 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/test/sic/__init__.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1030 2021-08-20 08:32:04.000000 gpaw-22.8.0/gpaw/test/sic/test_nscfsic.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      825 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/sic/test_scfsic_h2.py
-drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2022-08-19 09:38:54.842162 gpaw-22.8.0/gpaw/test/solvation/
--rw-rw-r--   0 jensj     (1000) jensj     (1000)        0 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/test/solvation/__init__.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     2144 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/test/solvation/test_adm12.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     9957 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/test/solvation/test_forces.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1823 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/solvation/test_forces_symmetry.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1251 2021-08-20 08:32:04.000000 gpaw-22.8.0/gpaw/test/solvation/test_lrtddft.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      631 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/solvation/test_nan_radius.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      889 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/solvation/test_overlap.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1266 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/solvation/test_pbc.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     2740 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/solvation/test_pbc_pos_repeat.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     4900 2022-05-11 06:13:16.000000 gpaw-22.8.0/gpaw/test/solvation/test_poisson.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1723 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/test/solvation/test_sfgcm06.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1753 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/solvation/test_sjm.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     5836 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/solvation/test_solvation_api.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     2004 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/solvation/test_spinpol.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1801 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/solvation/test_sss09.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     2359 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/solvation/test_swap_atoms.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1963 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/test/solvation/test_vacuum.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     2074 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/solvation/test_water_water.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1913 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/solvation/test_water_water_etdm_lcao.py
-drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2022-08-19 09:38:54.842162 gpaw-22.8.0/gpaw/test/spin/
--rw-rw-r--   0 jensj     (1000) jensj     (1000)        0 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/test/spin/__init__.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      800 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/spin/test_spinFe3plus.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1489 2021-08-20 08:32:04.000000 gpaw-22.8.0/gpaw/test/spin/test_spin_contamination.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      669 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/spin/test_spinpol.py
-drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2022-08-19 09:38:54.842162 gpaw-22.8.0/gpaw/test/symmetry/
--rw-rw-r--   0 jensj     (1000) jensj     (1000)        0 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/test/symmetry/__init__.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      844 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/symmetry/test_check.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1365 2022-08-01 11:19:56.000000 gpaw-22.8.0/gpaw/test/symmetry/test_fractional_translations.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1322 2022-08-01 11:19:56.000000 gpaw-22.8.0/gpaw/test/symmetry/test_fractional_translations_big.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1319 2022-08-01 11:19:56.000000 gpaw-22.8.0/gpaw/test/symmetry/test_fractional_translations_med.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     2033 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/symmetry/test_kpoint_mapping.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     2981 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/symmetry/test_symmetry.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      946 2022-05-26 05:25:41.000000 gpaw-22.8.0/gpaw/test/symmetry/test_symmetry2.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     3597 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/symmetry/test_symmetry_ft.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      658 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/test/symmetry/test_usesymm.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1154 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/symmetry/test_usesymm2.py
-drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2022-08-19 09:38:54.842162 gpaw-22.8.0/gpaw/test/tddft/
--rw-rw-r--   0 jensj     (1000) jensj     (1000)        0 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/test/tddft/__init__.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1046 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/tddft/test_be_nltd_ip.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1008 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/test/tddft/test_ehrenfest_nacl.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     2036 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/tddft/test_fxc_linearize.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     6240 2022-05-18 04:39:27.000000 gpaw-22.8.0/gpaw/test/tddft/test_molecule.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     2477 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/tddft/test_td_na2.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     8180 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/test_AA_enthalpy.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      632 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/test/test_Gauss.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1146 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/test/test_aeatom.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1341 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/test_aedensity.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      235 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/test_atomic_el_pot.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1502 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/test_atoms_mismatch.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      386 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/test_atoms_too_close.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      744 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/test_broadcast_imports.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      510 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/test_broydenmixer.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     2073 2022-08-01 11:19:56.000000 gpaw-22.8.0/gpaw/test/test_cluster.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      471 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/test/test_complete.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1136 2022-05-18 04:39:27.000000 gpaw-22.8.0/gpaw/test/test_complex.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      800 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/test_coreeig.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     2189 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/test_coulomb.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     2509 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/test_diagonalizer_backend.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     2894 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/test/test_dipole.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1930 2022-08-01 11:19:56.000000 gpaw-22.8.0/gpaw/test/test_ds_beta.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1407 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/test/test_fermisplit.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1474 2022-08-19 09:06:17.000000 gpaw-22.8.0/gpaw/test/test_fixdensity.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      801 2022-08-19 07:19:38.000000 gpaw-22.8.0/gpaw/test/test_fixmom.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1561 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/test/test_fixocc.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      474 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/test/test_force_as_stop.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     2818 2021-08-20 08:32:04.000000 gpaw-22.8.0/gpaw/test/test_gauss_func.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     6425 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/test/test_gauss_wave.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      844 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/test_ibzqpt.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     3220 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/test_inducedfield_lrtddft.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     4196 2022-08-19 09:06:17.000000 gpaw-22.8.0/gpaw/test/test_inducedfield_td.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      725 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/test/test_initial_occs.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1846 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/test/test_jellium.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1003 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/test_kpt.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      996 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/test/test_kpt_refine.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1059 2021-08-20 08:32:04.000000 gpaw-22.8.0/gpaw/test/test_libelpa.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1763 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/test/test_mpicomm.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      992 2021-08-20 08:32:04.000000 gpaw-22.8.0/gpaw/test/test_muffintinpot.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1151 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/test/test_multipoleH2O.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1465 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/test/test_multipoletest.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      582 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/test/test_negative_eigerror.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1679 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/test_occupations.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     2573 2022-07-08 08:21:04.000000 gpaw-22.8.0/gpaw/test/test_overlap.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1390 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/test/test_potential.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1343 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/test_rattle.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1192 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/test_reuse_wfs.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     2006 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/test_reuse_wfs_celldisp.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     4225 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/test_scf_criteria.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      946 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/test_spectrum.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      673 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/test/test_spinorbit_Kr.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      832 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/test_stdout.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1839 2022-05-18 04:39:27.000000 gpaw-22.8.0/gpaw/test/test_timelimit.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      663 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/test_timing.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      858 2022-08-01 11:19:56.000000 gpaw-22.8.0/gpaw/test/test_vdwradii.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     2907 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/test_watermodel.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      665 2022-05-18 04:39:27.000000 gpaw-22.8.0/gpaw/test/too_close_test.py
-drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2022-08-19 09:38:54.842162 gpaw-22.8.0/gpaw/test/utilities/
--rw-rw-r--   0 jensj     (1000) jensj     (1000)       80 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/test/utilities/__init__.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      557 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/utilities/test_eed.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1870 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/utilities/test_elf.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     5903 2021-08-20 08:32:04.000000 gpaw-22.8.0/gpaw/test/utilities/test_ewald.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      355 2021-07-05 14:53:36.000000 gpaw-22.8.0/gpaw/test/utilities/test_ibz2bz.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     3587 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/test/utilities/test_ldos.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     2816 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/utilities/test_partitioning.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     2744 2021-08-20 08:32:04.000000 gpaw-22.8.0/gpaw/test/utilities/test_simple_stm.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     2126 2021-08-20 08:32:04.000000 gpaw-22.8.0/gpaw/test/utilities/test_wannier_ethylene.py
-drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2022-08-19 09:38:54.846162 gpaw-22.8.0/gpaw/test/vdw/
--rw-rw-r--   0 jensj     (1000) jensj     (1000)        0 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/test/vdw/__init__.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      845 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/test/vdw/test_H_Hirshfeld.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1300 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/vdw/test_ar2.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     3482 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/test/vdw/test_libvdwxc_functionals.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1796 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/test/vdw/test_libvdwxc_h2.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1058 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/test/vdw/test_libvdwxc_mbeef.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     2026 2021-08-20 08:32:04.000000 gpaw-22.8.0/gpaw/test/vdw/test_libvdwxc_spin.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1475 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/test/vdw/test_potential.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      402 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/test/vdw/test_quick.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      676 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/test/vdw/test_quick_spin.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     2325 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/vdw/test_ts09.py
-drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2022-08-19 09:38:54.846162 gpaw-22.8.0/gpaw/test/xc/
--rw-rw-r--   0 jensj     (1000) jensj     (1000)       71 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/test/xc/__init__.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     2416 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/test/xc/test_XC2.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     3015 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/test/xc/test_atomize.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     2209 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/test/xc/test_beef.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1207 2022-07-08 05:55:11.000000 gpaw-22.8.0/gpaw/test/xc/test_degeneracy.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     2159 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/xc/test_gga_atom.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     3831 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/xc/test_lb94.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     3129 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/test/xc/test_lxc_xcatom.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1108 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/xc/test_nonselfconsistent.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1142 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/xc/test_nonselfconsistentLDA.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1303 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/test/xc/test_pbe_pw91.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1473 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/xc/test_pplda.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1372 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/xc/test_pygga.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      989 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/test/xc/test_qna_band.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1459 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/test/xc/test_qna_force.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      937 2021-08-20 08:32:04.000000 gpaw-22.8.0/gpaw/test/xc/test_qna_spinpol.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1421 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/test/xc/test_qna_stress.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      823 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/xc/test_revPBE.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1085 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/xc/test_revPBE_Li.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      830 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/xc/test_tb09.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     4064 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/xc/test_xc.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1433 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/test/xc/test_xcatom.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     2679 2022-05-18 14:14:47.000000 gpaw-22.8.0/gpaw/test/xc/tpss_test.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    11352 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/tetrahedron.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     4741 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/transformers.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      513 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/typing.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    15808 2022-05-11 06:13:16.000000 gpaw-22.8.0/gpaw/unfold.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    23402 2021-08-20 08:32:04.000000 gpaw-22.8.0/gpaw/upf.py
-drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2022-08-19 09:38:54.850162 gpaw-22.8.0/gpaw/utilities/
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    11235 2022-05-11 06:13:16.000000 gpaw-22.8.0/gpaw/utilities/__init__.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1177 2022-06-24 21:03:09.000000 gpaw-22.8.0/gpaw/utilities/bader.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     8322 2022-08-01 09:40:12.000000 gpaw-22.8.0/gpaw/utilities/blas.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1264 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/utilities/cg.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      575 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/utilities/debug.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     3208 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/utilities/dipole.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    22595 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/utilities/dos.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     2286 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/utilities/ekin.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     4073 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/utilities/elpa.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     4953 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/utilities/ewald.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1907 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/utilities/extend_grid.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     2338 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/utilities/extrapolate.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     6385 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/utilities/folder.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     8181 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/utilities/gauss.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    11292 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/utilities/gl_quadrature.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     2882 2022-06-22 07:02:06.000000 gpaw-22.8.0/gpaw/utilities/gpts.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     7068 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/utilities/grid.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    26834 2021-07-05 14:53:36.000000 gpaw-22.8.0/gpaw/utilities/grid_redistribute.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     5612 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/utilities/hardware.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     3344 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/utilities/hilbert.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     3773 2021-08-20 08:32:04.000000 gpaw-22.8.0/gpaw/utilities/ibz2bz.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      367 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/utilities/jth.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     8206 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/utilities/kspot.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     5764 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/utilities/memory.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     2479 2022-06-10 07:52:26.000000 gpaw-22.8.0/gpaw/utilities/nbrun.py
--rwxrwxr-x   0 jensj     (1000) jensj     (1000)     7489 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/utilities/newrelease.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    11728 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/utilities/partition.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     3155 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/utilities/progressbar.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     8663 2022-06-03 09:31:13.000000 gpaw-22.8.0/gpaw/utilities/ps2ae.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      593 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/utilities/pw.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    20394 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/utilities/scalapack.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     3190 2021-08-20 08:32:04.000000 gpaw-22.8.0/gpaw/utilities/sic.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     6026 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/utilities/timelimit.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     5356 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/utilities/timing.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    14212 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/utilities/tools.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1739 2022-08-19 09:06:17.000000 gpaw-22.8.0/gpaw/utilities/urlcheck.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     4155 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/utilities/watermodel.py
-drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2022-08-19 09:38:54.850162 gpaw-22.8.0/gpaw/wannier/
--rw-rw-r--   0 jensj     (1000) jensj     (1000)       74 2021-08-20 08:32:04.000000 gpaw-22.8.0/gpaw/wannier/__init__.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1974 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/wannier/edmiston_ruedenberg.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      915 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/wannier/functions.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    11579 2022-06-24 06:07:59.000000 gpaw-22.8.0/gpaw/wannier/overlaps.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     6799 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/wannier/w90.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    13987 2021-08-20 08:32:04.000000 gpaw-22.8.0/gpaw/wannier90.py
-drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2022-08-19 09:38:54.850162 gpaw-22.8.0/gpaw/wavefunctions/
--rw-rw-r--   0 jensj     (1000) jensj     (1000)        0 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/wavefunctions/__init__.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    14221 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/wavefunctions/arrays.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    25062 2022-08-17 06:54:56.000000 gpaw-22.8.0/gpaw/wavefunctions/base.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    13500 2022-06-15 12:42:16.000000 gpaw-22.8.0/gpaw/wavefunctions/fd.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    20243 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/wavefunctions/fdpw.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    44119 2022-06-29 12:02:59.000000 gpaw-22.8.0/gpaw/wavefunctions/lcao.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      604 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/wavefunctions/mode.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    27830 2022-07-13 10:13:20.000000 gpaw-22.8.0/gpaw/wavefunctions/pw.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     2945 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/wfd_operators.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    23833 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/xas.py
-drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2022-08-19 09:38:54.854162 gpaw-22.8.0/gpaw/xc/
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     5675 2022-08-17 07:20:18.000000 gpaw-22.8.0/gpaw/xc/__init__.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     8637 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/xc/bee.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    12705 2022-08-19 09:06:17.000000 gpaw-22.8.0/gpaw/xc/exx.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     3192 2021-12-21 11:47:18.000000 gpaw-22.8.0/gpaw/xc/functional.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    61262 2022-07-14 11:17:02.000000 gpaw-22.8.0/gpaw/xc/fxc.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    17110 2021-08-20 11:59:25.000000 gpaw-22.8.0/gpaw/xc/gga.py
-drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2022-08-19 09:38:54.854162 gpaw-22.8.0/gpaw/xc/gllb/
--rw-rw-r--   0 jensj     (1000) jensj     (1000)       90 2021-07-05 14:53:36.000000 gpaw-22.8.0/gpaw/xc/gllb/__init__.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     6445 2021-07-05 14:53:36.000000 gpaw-22.8.0/gpaw/xc/gllb/c_gllbscr.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    27525 2022-07-14 11:17:02.000000 gpaw-22.8.0/gpaw/xc/gllb/c_response.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1936 2021-07-05 14:53:36.000000 gpaw-22.8.0/gpaw/xc/gllb/c_xc.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     4171 2022-08-01 09:40:12.000000 gpaw-22.8.0/gpaw/xc/gllb/coefficients.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1038 2021-07-05 14:53:36.000000 gpaw-22.8.0/gpaw/xc/gllb/contribution.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     5799 2022-07-14 11:17:02.000000 gpaw-22.8.0/gpaw/xc/gllb/nonlocalfunctional.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     3700 2022-07-14 11:17:02.000000 gpaw-22.8.0/gpaw/xc/gllb/nonlocalfunctionalfactory.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    26626 2022-06-29 05:51:57.000000 gpaw-22.8.0/gpaw/xc/hybrid.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     2951 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/xc/kernel.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      995 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/xc/lb94.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     7376 2021-12-21 11:47:23.000000 gpaw-22.8.0/gpaw/xc/lda.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    30032 2022-06-15 13:25:04.000000 gpaw-22.8.0/gpaw/xc/libvdwxc.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     2868 2021-12-21 11:47:26.000000 gpaw-22.8.0/gpaw/xc/libxc.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    13074 2022-08-01 11:19:56.000000 gpaw-22.8.0/gpaw/xc/mgga.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     2420 2022-06-12 08:53:14.000000 gpaw-22.8.0/gpaw/xc/noncollinear.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1420 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/xc/parametrizedxc.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     4590 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/xc/pawcorrection.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     8413 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/xc/qna.py
-drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2022-08-19 09:38:54.854162 gpaw-22.8.0/gpaw/xc/ri/
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     3025 2022-08-19 09:06:17.000000 gpaw-22.8.0/gpaw/xc/ri/__init__.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1551 2022-08-17 07:20:18.000000 gpaw-22.8.0/gpaw/xc/ri/ribasis.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     3962 2022-08-19 09:06:17.000000 gpaw-22.8.0/gpaw/xc/ri/spherical_hse_kernel.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    17912 2022-07-14 11:17:02.000000 gpaw-22.8.0/gpaw/xc/rpa.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    44695 2022-06-29 12:02:59.000000 gpaw-22.8.0/gpaw/xc/sic.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     4784 2021-06-14 18:26:24.000000 gpaw-22.8.0/gpaw/xc/tb09.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     1899 2022-07-08 05:55:11.000000 gpaw-22.8.0/gpaw/xc/tools.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    29774 2022-05-11 06:13:16.000000 gpaw-22.8.0/gpaw/xc/vdw.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     2704 2022-06-22 07:02:06.000000 gpaw-22.8.0/gpaw/yml.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     7531 2022-05-04 08:34:37.000000 gpaw-22.8.0/gpaw/zero_field_splitting.py
-drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2022-08-19 09:38:54.782161 gpaw-22.8.0/gpaw.egg-info/
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     3469 2022-08-19 09:38:54.000000 gpaw-22.8.0/gpaw.egg-info/PKG-INFO
--rw-rw-r--   0 jensj     (1000) jensj     (1000)    29134 2022-08-19 09:38:54.000000 gpaw-22.8.0/gpaw.egg-info/SOURCES.txt
--rw-rw-r--   0 jensj     (1000) jensj     (1000)        1 2022-08-19 09:38:54.000000 gpaw-22.8.0/gpaw.egg-info/dependency_links.txt
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      102 2022-08-19 09:38:54.000000 gpaw-22.8.0/gpaw.egg-info/entry_points.txt
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      112 2022-08-19 09:38:54.000000 gpaw-22.8.0/gpaw.egg-info/requires.txt
--rw-rw-r--   0 jensj     (1000) jensj     (1000)       11 2022-08-19 09:38:54.000000 gpaw-22.8.0/gpaw.egg-info/top_level.txt
--rw-rw-r--   0 jensj     (1000) jensj     (1000)      105 2022-08-19 09:38:54.854162 gpaw-22.8.0/setup.cfg
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     8866 2022-06-22 07:02:06.000000 gpaw-22.8.0/setup.py
--rw-rw-r--   0 jensj     (1000) jensj     (1000)     2441 2022-05-04 08:34:37.000000 gpaw-22.8.0/siteconfig_example.py
-drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2022-08-19 09:38:54.854162 gpaw-22.8.0/tools/
--rwxrwxr-x   0 jensj     (1000) jensj     (1000)       73 2021-03-25 20:50:34.000000 gpaw-22.8.0/tools/gpaw-analyse-basis
--rwxrwxr-x   0 jensj     (1000) jensj     (1000)       70 2021-03-25 20:50:34.000000 gpaw-22.8.0/tools/gpaw-basis
--rwxrwxr-x   0 jensj     (1000) jensj     (1000)     7512 2021-03-25 20:50:34.000000 gpaw-22.8.0/tools/gpaw-plot-parallel-timings
--rwxrwxr-x   0 jensj     (1000) jensj     (1000)     4964 2021-03-25 20:50:34.000000 gpaw-22.8.0/tools/gpaw-runscript
--rwxrwxr-x   0 jensj     (1000) jensj     (1000)       70 2021-03-25 20:50:34.000000 gpaw-22.8.0/tools/gpaw-setup
--rwxrwxr-x   0 jensj     (1000) jensj     (1000)       68 2021-03-25 20:50:34.000000 gpaw-22.8.0/tools/gpaw-upfplot
+drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2023-06-09 07:55:42.123446 gpaw-23.6.0/
+-rw-r--r--   0 jensj     (1000) jensj     (1000)      108 2019-08-23 18:18:31.000000 gpaw-23.6.0/CHANGELOG.rst
+-rw-r--r--   0 jensj     (1000) jensj     (1000)      220 2019-08-23 18:18:31.000000 gpaw-23.6.0/CONTRIBUTING.rst
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    35147 2020-11-09 18:42:21.000000 gpaw-23.6.0/LICENSE
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      207 2020-11-09 18:42:21.000000 gpaw-23.6.0/MANIFEST.in
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     3867 2023-06-09 07:55:42.123446 gpaw-23.6.0/PKG-INFO
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     3045 2023-05-26 06:07:46.000000 gpaw-23.6.0/README.rst
+drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2023-06-09 07:55:41.751442 gpaw-23.6.0/c/
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    15143 2023-05-26 06:07:46.000000 gpaw-23.6.0/c/_gpaw.h
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      234 2023-04-19 09:55:20.000000 gpaw-23.6.0/c/_gpaw_so.c
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     5535 2023-05-26 06:07:46.000000 gpaw-23.6.0/c/array.h
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     8474 2023-05-26 06:07:46.000000 gpaw-23.6.0/c/bc.c
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1451 2023-05-26 06:07:46.000000 gpaw-23.6.0/c/bc.h
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    56659 2023-04-19 09:55:20.000000 gpaw-23.6.0/c/blacs.c
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     4941 2023-05-26 06:07:46.000000 gpaw-23.6.0/c/blas.c
+drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2023-06-09 07:55:41.755442 gpaw-23.6.0/c/bmgs/
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      563 2021-03-25 20:49:04.000000 gpaw-23.6.0/c/bmgs/bmgs.c
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     4288 2023-05-26 06:07:46.000000 gpaw-23.6.0/c/bmgs/bmgs.h
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1003 2021-03-25 20:49:04.000000 gpaw-23.6.0/c/bmgs/cut.c
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      964 2022-05-04 08:34:37.000000 gpaw-23.6.0/c/bmgs/fd.c
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     2687 2022-05-04 08:34:37.000000 gpaw-23.6.0/c/bmgs/interpolate.c
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      924 2021-03-25 20:49:04.000000 gpaw-23.6.0/c/bmgs/paste.c
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     2095 2022-05-04 08:34:37.000000 gpaw-23.6.0/c/bmgs/relax.c
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     3616 2023-05-26 06:07:46.000000 gpaw-23.6.0/c/bmgs/restrict.c
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     6833 2021-03-25 20:49:04.000000 gpaw-23.6.0/c/bmgs/spherical_harmonics.h
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     2098 2023-02-15 19:14:44.000000 gpaw-23.6.0/c/bmgs/spline.c
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     4973 2021-03-25 20:49:04.000000 gpaw-23.6.0/c/bmgs/stencils.c
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1448 2021-03-25 20:49:04.000000 gpaw-23.6.0/c/bmgs/translate.c
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1399 2022-05-04 08:34:37.000000 gpaw-23.6.0/c/bmgs/wfd.c
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     2909 2021-03-25 20:49:04.000000 gpaw-23.6.0/c/bmgs/wrelax.c
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      446 2021-03-25 20:49:04.000000 gpaw-23.6.0/c/bmgs/zero.c
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    17980 2021-03-25 20:49:04.000000 gpaw-23.6.0/c/constraints.c
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     5950 2023-02-15 19:14:44.000000 gpaw-23.6.0/c/elpa.c
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1441 2023-05-26 06:07:46.000000 gpaw-23.6.0/c/extensions.h
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      290 2021-03-25 20:49:04.000000 gpaw-23.6.0/c/f2c.h
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    13194 2022-05-04 08:34:37.000000 gpaw-23.6.0/c/fd_preconditioner.c
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     2136 2021-03-25 20:49:04.000000 gpaw-23.6.0/c/fftw.c
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     6021 2021-03-25 20:49:04.000000 gpaw-23.6.0/c/lcao.c
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    58668 2023-05-26 06:07:46.000000 gpaw-23.6.0/c/lfc.c
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     4733 2023-05-26 06:07:46.000000 gpaw-23.6.0/c/lfc.h
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    13105 2022-05-04 08:34:37.000000 gpaw-23.6.0/c/lfc2.c
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     2420 2023-05-26 06:07:46.000000 gpaw-23.6.0/c/main.c
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    40520 2023-06-05 15:36:49.000000 gpaw-23.6.0/c/mpi.c
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      232 2021-03-25 20:49:04.000000 gpaw-23.6.0/c/mympi.h
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    11886 2023-05-26 06:07:46.000000 gpaw-23.6.0/c/operators.c
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      705 2023-05-26 06:07:46.000000 gpaw-23.6.0/c/operators.h
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     5521 2021-03-25 20:49:04.000000 gpaw-23.6.0/c/plane_wave.c
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     3084 2021-03-25 20:49:04.000000 gpaw-23.6.0/c/plt.c
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     5664 2021-03-25 20:49:04.000000 gpaw-23.6.0/c/point_charges.c
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     3913 2021-03-25 20:49:04.000000 gpaw-23.6.0/c/spline.c
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      227 2021-03-25 20:49:04.000000 gpaw-23.6.0/c/spline.h
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    11753 2023-02-15 19:14:44.000000 gpaw-23.6.0/c/symmetry.c
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     3850 2021-03-25 20:49:04.000000 gpaw-23.6.0/c/tetra.c
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1275 2022-05-04 08:34:37.000000 gpaw-23.6.0/c/threading.h
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     6910 2023-05-26 06:07:46.000000 gpaw-23.6.0/c/transformers.c
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      817 2023-05-26 06:07:46.000000 gpaw-23.6.0/c/transformers.h
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    25373 2023-02-15 19:14:44.000000 gpaw-23.6.0/c/utilities.c
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1587 2021-03-25 20:49:04.000000 gpaw-23.6.0/c/wigner_seitz.c
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    14638 2022-05-04 08:34:37.000000 gpaw-23.6.0/c/woperators.c
+drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2023-06-09 07:55:41.755442 gpaw-23.6.0/c/xc/
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1569 2021-03-25 20:49:04.000000 gpaw-23.6.0/c/xc/ensemble_gga.c
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     7001 2021-03-25 20:49:04.000000 gpaw-23.6.0/c/xc/libvdwxc.c
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    23092 2022-12-08 08:00:00.000000 gpaw-23.6.0/c/xc/libxc.c
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    23689 2021-03-25 20:49:04.000000 gpaw-23.6.0/c/xc/m06l.c
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     5026 2021-03-25 20:49:04.000000 gpaw-23.6.0/c/xc/pbe.c
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     5285 2021-03-25 20:49:04.000000 gpaw-23.6.0/c/xc/pw91.c
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    16506 2021-03-25 20:49:04.000000 gpaw-23.6.0/c/xc/revtpss.c
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    14506 2021-03-25 20:49:04.000000 gpaw-23.6.0/c/xc/revtpss_c_pbe.c
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      716 2021-03-25 20:49:04.000000 gpaw-23.6.0/c/xc/rpbe.c
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    16004 2021-03-25 20:49:04.000000 gpaw-23.6.0/c/xc/tpss.c
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     6350 2021-03-25 20:49:04.000000 gpaw-23.6.0/c/xc/vdw.c
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     9034 2023-05-26 06:07:46.000000 gpaw-23.6.0/c/xc/xc.c
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1008 2022-12-07 09:50:51.000000 gpaw-23.6.0/c/xc/xc_gpaw.h
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     3860 2022-12-08 08:00:00.000000 gpaw-23.6.0/c/xc/xc_mgga.c
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1113 2021-03-25 20:49:04.000000 gpaw-23.6.0/c/xc/xc_mgga.h
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     4501 2023-05-26 06:07:46.000000 gpaw-23.6.0/config.py
+drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2023-06-09 07:55:41.791442 gpaw-23.6.0/gpaw/
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     7268 2023-06-09 07:32:07.000000 gpaw-23.6.0/gpaw/__init__.py
+-rwxrwxr-x   0 jensj     (1000) jensj     (1000)       73 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/__main__.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     2137 2023-05-26 06:07:47.000000 gpaw-23.6.0/gpaw/ae.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     2259 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/ah.py
+drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2023-06-09 07:55:41.795442 gpaw-23.6.0/gpaw/analyse/
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)       33 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/analyse/__init__.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     3054 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/analyse/eed.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     9840 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/analyse/expandyl.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     6766 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/analyse/hirshfeld.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     2607 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/analyse/multipole.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      531 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/analyse/observers.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     3883 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/analyse/overlap.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     8729 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/analyse/simple_stm.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     2510 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/analyse/vdwradii.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     5655 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/analyse/wignerseitz.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     6641 2022-05-04 08:34:37.000000 gpaw-23.6.0/gpaw/arraydict.py
+drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2023-06-09 07:55:41.803442 gpaw-23.6.0/gpaw/atom/
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)        0 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/atom/__init__.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    30177 2022-12-07 12:06:51.000000 gpaw-23.6.0/gpaw/atom/aeatom.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    26652 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/atom/all_electron.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     4286 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/atom/analyse_setup.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    11278 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/atom/atompaw.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    24626 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/atom/basis.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     9102 2022-05-04 08:34:37.000000 gpaw-23.6.0/gpaw/atom/check.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    52074 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/atom/configurations.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     6222 2021-08-20 08:32:04.000000 gpaw-23.6.0/gpaw/atom/filter.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    32096 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/atom/generator.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    54079 2023-04-19 09:55:20.000000 gpaw-23.6.0/gpaw/atom/generator2.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     6975 2022-05-04 08:34:37.000000 gpaw-23.6.0/gpaw/atom/gpaw_basis.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     7773 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/atom/gpaw_setup.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    15109 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/atom/optimize.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    18475 2023-02-15 20:12:55.000000 gpaw-23.6.0/gpaw/atom/radialgd.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     2251 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/atom/shapefunc.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    10610 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/band_descriptor.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    11232 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/basis_data.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    15298 2023-05-26 06:07:47.000000 gpaw-23.6.0/gpaw/berryphase.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1722 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/bfield.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    21951 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/blacs.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     3721 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/borncharges.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     5821 2023-04-19 09:55:20.000000 gpaw-23.6.0/gpaw/broadcast_imports.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    14192 2023-04-19 09:55:20.000000 gpaw-23.6.0/gpaw/bztools.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    80338 2023-05-26 06:07:47.000000 gpaw-23.6.0/gpaw/calculator.py
+drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2023-06-09 07:55:41.803442 gpaw-23.6.0/gpaw/cdft/
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)        0 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/cdft/__init__.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    43072 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/cdft/cdft.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    41906 2023-05-26 06:07:47.000000 gpaw-23.6.0/gpaw/cdft/cdft_coupling.py
+drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2023-06-09 07:55:41.807442 gpaw-23.6.0/gpaw/cli/
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)        0 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/cli/__init__.py
+-rwxrwxr-x   0 jensj     (1000) jensj     (1000)     3479 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/cli/complete.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      335 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/cli/completion.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     6810 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/cli/dos.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      859 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/cli/gpw.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     3238 2023-04-19 09:55:20.000000 gpaw-23.6.0/gpaw/cli/info.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    10386 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/cli/install_data.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     2126 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/cli/main.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1669 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/cli/python.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      832 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/cli/quick.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     2282 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/cli/run.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     2089 2023-04-19 09:55:20.000000 gpaw-23.6.0/gpaw/cli/sbatch.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1279 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/cli/test.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     3066 2022-05-04 08:34:37.000000 gpaw-23.6.0/gpaw/cluster.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     3230 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/coding_style.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    14459 2023-04-19 09:55:20.000000 gpaw-23.6.0/gpaw/convergence_criteria.py
+drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2023-06-09 07:55:41.811442 gpaw-23.6.0/gpaw/core/
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      133 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/core/__init__.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     8198 2023-06-07 08:43:09.000000 gpaw-23.6.0/gpaw/core/arrays.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    13773 2023-04-19 09:55:20.000000 gpaw-23.6.0/gpaw/core/atom_arrays.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     5334 2023-04-19 09:55:20.000000 gpaw-23.6.0/gpaw/core/atom_centered_functions.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     4481 2023-04-19 09:55:20.000000 gpaw-23.6.0/gpaw/core/domain.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    31625 2023-04-19 09:55:20.000000 gpaw-23.6.0/gpaw/core/matrix.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    23927 2023-06-07 15:02:45.000000 gpaw-23.6.0/gpaw/core/plane_waves.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    17064 2023-05-26 06:07:47.000000 gpaw-23.6.0/gpaw/core/pwacf.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    25915 2023-06-07 15:02:45.000000 gpaw-23.6.0/gpaw/core/uniform_grid.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    12503 2022-05-04 08:34:37.000000 gpaw-23.6.0/gpaw/coulomb.py
+drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2023-06-09 07:55:41.811442 gpaw-23.6.0/gpaw/data/
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)        0 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/data/__init__.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     3270 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/data/g2_1_ref.py
+drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2023-06-09 07:55:41.811442 gpaw-23.6.0/gpaw/defects/
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    14325 2023-04-19 09:55:20.000000 gpaw-23.6.0/gpaw/defects/__init__.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     7344 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/densities.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    31107 2023-04-19 09:55:20.000000 gpaw-23.6.0/gpaw/density.py
+drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2023-06-09 07:55:41.819442 gpaw-23.6.0/gpaw/dfpt/
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     3571 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/dfpt/__init__.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    17526 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/dfpt/dynamicalmatrix.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     7591 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/dfpt/electronphononcoupling.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      412 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/dfpt/kpointcontainer.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1648 2021-08-20 08:32:04.000000 gpaw-23.6.0/gpaw/dfpt/linearsolver.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    16069 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/dfpt/mixer.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      789 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/dfpt/perturbation.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    18713 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/dfpt/phononcalculator.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    11031 2021-08-20 08:32:04.000000 gpaw-23.6.0/gpaw/dfpt/phononperturbation.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     6709 2021-08-20 08:32:04.000000 gpaw-23.6.0/gpaw/dfpt/phonons.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     2198 2022-05-04 08:34:37.000000 gpaw-23.6.0/gpaw/dfpt/poisson.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1697 2022-05-04 08:34:37.000000 gpaw-23.6.0/gpaw/dfpt/preconditioner.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    14402 2021-08-20 08:32:04.000000 gpaw-23.6.0/gpaw/dfpt/responsecalculator.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     2889 2022-05-04 08:34:37.000000 gpaw-23.6.0/gpaw/dfpt/scipylinearsolver.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     6632 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/dfpt/sternheimeroperator.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     6730 2021-08-20 08:32:04.000000 gpaw-23.6.0/gpaw/dfpt/wavefunctions.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     5924 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/dipole_correction.py
+drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2023-06-09 07:55:41.823442 gpaw-23.6.0/gpaw/directmin/
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     2529 2023-05-26 12:00:48.000000 gpaw-23.6.0/gpaw/directmin/__init__.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    32802 2023-05-26 06:08:18.000000 gpaw-23.6.0/gpaw/directmin/derivatives.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    40120 2023-05-26 12:00:48.000000 gpaw-23.6.0/gpaw/directmin/etdm.py
+drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2023-06-09 07:55:41.823442 gpaw-23.6.0/gpaw/directmin/functional/
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      543 2023-05-26 12:00:48.000000 gpaw-23.6.0/gpaw/directmin/functional/__init__.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     5144 2023-05-26 12:00:48.000000 gpaw-23.6.0/gpaw/directmin/functional/ks.py
+drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2023-06-09 07:55:41.823442 gpaw-23.6.0/gpaw/directmin/lcao/
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)        0 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/directmin/lcao/__init__.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     5397 2023-05-26 12:00:48.000000 gpaw-23.6.0/gpaw/directmin/lcao/directmin_lcao.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    14008 2023-05-26 12:00:48.000000 gpaw-23.6.0/gpaw/directmin/ls_etdm.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    20442 2023-05-26 12:00:48.000000 gpaw-23.6.0/gpaw/directmin/sd_etdm.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    10920 2023-05-26 12:00:48.000000 gpaw-23.6.0/gpaw/directmin/tools.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     7718 2022-05-04 08:34:37.000000 gpaw-23.6.0/gpaw/domain.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     8537 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/dos.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    12693 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/dscf.py
+drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2023-06-09 07:55:41.827443 gpaw-23.6.0/gpaw/eigensolvers/
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1306 2023-05-26 12:00:48.000000 gpaw-23.6.0/gpaw/eigensolvers/__init__.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     9108 2023-05-10 10:07:50.000000 gpaw-23.6.0/gpaw/eigensolvers/cg.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     7528 2023-05-26 06:07:47.000000 gpaw-23.6.0/gpaw/eigensolvers/davidson.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     5626 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/eigensolvers/diagonalizerbackend.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1093 2023-05-10 10:07:08.000000 gpaw-23.6.0/gpaw/eigensolvers/direct.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     9119 2023-05-26 12:00:48.000000 gpaw-23.6.0/gpaw/eigensolvers/eigensolver.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    11500 2023-05-26 06:07:47.000000 gpaw-23.6.0/gpaw/eigensolvers/rmmdiis.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     4531 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/electrostatic_potential.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     5513 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/elf.py
+drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2023-06-09 07:55:41.827443 gpaw-23.6.0/gpaw/elph/
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     2758 2023-05-26 06:08:18.000000 gpaw-23.6.0/gpaw/elph/__init__.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     5382 2023-05-26 06:07:47.000000 gpaw-23.6.0/gpaw/elph/displacements.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    29954 2023-05-26 06:07:47.000000 gpaw-23.6.0/gpaw/elph/electronphonon.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     3172 2023-05-26 06:07:47.000000 gpaw-23.6.0/gpaw/elph/filter.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    13336 2023-05-26 06:07:47.000000 gpaw-23.6.0/gpaw/elph/gmatrix.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     6382 2023-05-26 06:08:18.000000 gpaw-23.6.0/gpaw/elph/raman_calculator.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     5594 2023-05-26 06:08:18.000000 gpaw-23.6.0/gpaw/elph/raman_data.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    12792 2023-05-26 06:08:18.000000 gpaw-23.6.0/gpaw/elph/supercell.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      283 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/entry_points.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    13125 2023-04-19 09:55:20.000000 gpaw-23.6.0/gpaw/external.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    13082 2023-05-26 06:07:47.000000 gpaw-23.6.0/gpaw/fd_operators.py
+drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2023-06-09 07:55:41.831442 gpaw-23.6.0/gpaw/fdtd/
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)       45 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/fdtd/__init__.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    42272 2023-05-26 06:07:47.000000 gpaw-23.6.0/gpaw/fdtd/poisson_fdtd.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    23650 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/fdtd/polarizable_material.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     7009 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/fdtd/potential_couplers.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    10602 2023-06-07 10:43:27.000000 gpaw-23.6.0/gpaw/fftw.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1134 2023-05-26 12:00:48.000000 gpaw-23.6.0/gpaw/forces.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1212 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/fulldiag.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     2256 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/gaunt.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     4298 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/gauss.py
+drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2023-06-09 07:55:41.831442 gpaw-23.6.0/gpaw/gpu/
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     2019 2023-05-26 06:07:47.000000 gpaw-23.6.0/gpaw/gpu/__init__.py
+drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2023-06-09 07:55:41.835443 gpaw-23.6.0/gpaw/gpu/cpupy/
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     5979 2023-06-09 07:32:02.000000 gpaw-23.6.0/gpaw/gpu/cpupy/__init__.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      393 2023-05-26 06:07:47.000000 gpaw-23.6.0/gpaw/gpu/cpupy/cublas.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      269 2023-04-19 09:55:20.000000 gpaw-23.6.0/gpaw/gpu/cpupy/fft.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      394 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/gpu/cpupy/linalg.py
+drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2023-06-09 07:55:41.835443 gpaw-23.6.0/gpaw/gpu/cpupyx/
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      145 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/gpu/cpupyx/__init__.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1171 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/gpu/cpupyx/fft.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)       52 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/gpu/cpupyx/scipy.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      445 2023-05-26 06:07:47.000000 gpaw-23.6.0/gpaw/gpu/kernels.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     3025 2023-04-19 09:55:20.000000 gpaw-23.6.0/gpaw/gpu/mpi.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    25447 2023-05-26 06:07:47.000000 gpaw-23.6.0/gpaw/grid_descriptor.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    30300 2023-05-26 12:00:48.000000 gpaw-23.6.0/gpaw/hamiltonian.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      502 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/heg.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     6391 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/helmholtz.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    20096 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/hgh.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    28877 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/hgh_parameters.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     5215 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/hubbard.py
+drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2023-06-09 07:55:41.839443 gpaw-23.6.0/gpaw/hybrids/
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      484 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/hybrids/__init__.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      779 2023-04-19 09:55:20.000000 gpaw-23.6.0/gpaw/hybrids/coulomb.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    10679 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/hybrids/eigenvalues.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     5705 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/hybrids/energy.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     4250 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/hybrids/forces.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     3695 2023-05-26 06:07:47.000000 gpaw-23.6.0/gpaw/hybrids/kpts.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1952 2023-05-26 06:07:47.000000 gpaw-23.6.0/gpaw/hybrids/paw.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    11796 2023-02-17 12:14:33.000000 gpaw-23.6.0/gpaw/hybrids/scf.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     6814 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/hybrids/symmetry.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     5439 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/hybrids/wrapper.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     3641 2023-04-19 09:55:20.000000 gpaw-23.6.0/gpaw/hybrids/wstc.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    12237 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/hyperfine.py
+drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2023-06-09 07:55:41.839443 gpaw-23.6.0/gpaw/inducedfield/
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)       62 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/inducedfield/__init__.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    18155 2022-05-04 08:34:37.000000 gpaw-23.6.0/gpaw/inducedfield/inducedfield_base.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    12149 2022-05-04 08:34:37.000000 gpaw-23.6.0/gpaw/inducedfield/inducedfield_fdtd.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     5584 2022-05-04 08:34:37.000000 gpaw-23.6.0/gpaw/inducedfield/inducedfield_lrtddft.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    17818 2022-05-04 08:34:37.000000 gpaw-23.6.0/gpaw/inducedfield/inducedfield_tddft.py
+drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2023-06-09 07:55:41.843443 gpaw-23.6.0/gpaw/io/
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      425 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/io/__init__.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1814 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/io/fmf.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     5248 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/io/logger.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     8774 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/io/old.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     5947 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/io/tar.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     2722 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/jellium.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    21858 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/kohnsham_layouts.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     2507 2023-05-26 06:07:47.000000 gpaw-23.6.0/gpaw/kpoint.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    20028 2023-05-26 06:07:47.000000 gpaw-23.6.0/gpaw/kpt_descriptor.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    15543 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/kpt_refine.py
+drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2023-06-09 07:55:41.847443 gpaw-23.6.0/gpaw/lcao/
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)        0 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/lcao/__init__.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1846 2022-05-04 08:34:37.000000 gpaw-23.6.0/gpaw/lcao/analyse_basis.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     4437 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/lcao/atomic_correction.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     3438 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/lcao/bsse.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     3205 2023-05-26 06:08:18.000000 gpaw-23.6.0/gpaw/lcao/dipoletransition.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     5702 2023-05-26 06:07:47.000000 gpaw-23.6.0/gpaw/lcao/eigensolver.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    14529 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/lcao/el_ph.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     4430 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/lcao/generate_extended.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     6879 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/lcao/generate_ngto_augmented.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    24335 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/lcao/local_orbitals.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    26320 2023-04-19 09:28:43.000000 gpaw-23.6.0/gpaw/lcao/overlap.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    14553 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/lcao/projected_wannier.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    16108 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/lcao/pwf2.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     2849 2022-05-04 08:34:37.000000 gpaw-23.6.0/gpaw/lcao/scissors.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    12517 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/lcao/tci.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     6707 2022-05-04 08:34:37.000000 gpaw-23.6.0/gpaw/lcao/tightbinding.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    22448 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/lcao/tools.py
+drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2023-06-09 07:55:41.855443 gpaw-23.6.0/gpaw/lcaotddft/
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     7884 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/lcaotddft/__init__.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     2830 2022-05-04 08:34:37.000000 gpaw-23.6.0/gpaw/lcaotddft/densitymatrix.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     5221 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/lcaotddft/dipolemomentwriter.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     3411 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/lcaotddft/energywriter.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     6834 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/lcaotddft/frequencydensitymatrix.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    10288 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/lcaotddft/hamiltonian.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    20869 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/lcaotddft/ksdecomposition.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     5022 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/lcaotddft/laser.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     3976 2022-05-04 08:34:37.000000 gpaw-23.6.0/gpaw/lcaotddft/linedensity.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1360 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/lcaotddft/logger.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    15539 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/lcaotddft/magneticmomentwriter.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      791 2022-05-04 08:34:37.000000 gpaw-23.6.0/gpaw/lcaotddft/observer.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    17475 2022-05-04 08:34:37.000000 gpaw-23.6.0/gpaw/lcaotddft/propagators.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     2953 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/lcaotddft/qed.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     3819 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/lcaotddft/quadrupolemomentwriter.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1082 2022-05-04 08:34:37.000000 gpaw-23.6.0/gpaw/lcaotddft/restartfilewriter.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     7454 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/lcaotddft/tcm.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      789 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/lcaotddft/timedensitymatrix.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     4882 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/lcaotddft/utilities.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     4358 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/lcaotddft/wfwriter.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    38476 2023-05-26 06:07:47.000000 gpaw-23.6.0/gpaw/lfc.py
+drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2023-06-09 07:55:41.859443 gpaw-23.6.0/gpaw/lrtddft/
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    18559 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/lrtddft/__init__.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    14534 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/lrtddft/apmb.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     6012 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/lrtddft/convergence.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     4054 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/lrtddft/dielectric.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     5402 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/lrtddft/excitation.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    17749 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/lrtddft/excited_state.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     5495 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/lrtddft/finite_differences.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    24104 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/lrtddft/kssingle.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    23373 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/lrtddft/omega_matrix.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     7835 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/lrtddft/spectrum.py
+drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2023-06-09 07:55:41.863443 gpaw-23.6.0/gpaw/lrtddft2/
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    18471 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/lrtddft2/__init__.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     2029 2022-05-04 08:34:37.000000 gpaw-23.6.0/gpaw/lrtddft2/eta.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    19705 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/lrtddft2/k_matrix.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    17699 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/lrtddft2/ks_singles.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     5332 2022-05-04 08:34:37.000000 gpaw-23.6.0/gpaw/lrtddft2/lr_communicators.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    14800 2022-05-04 08:34:37.000000 gpaw-23.6.0/gpaw/lrtddft2/lr_layouts.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    25545 2022-05-04 08:34:37.000000 gpaw-23.6.0/gpaw/lrtddft2/lr_response.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    20849 2022-05-04 08:34:37.000000 gpaw-23.6.0/gpaw/lrtddft2/lr_transitions.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     7014 2022-05-04 08:34:37.000000 gpaw-23.6.0/gpaw/lrtddft2/tools.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    20791 2023-05-26 06:07:47.000000 gpaw-23.6.0/gpaw/matrix.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    23237 2023-04-19 09:55:20.000000 gpaw-23.6.0/gpaw/matrix_descriptor.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    27291 2023-06-07 15:02:45.000000 gpaw-23.6.0/gpaw/mixer.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    12379 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/mom.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    42428 2023-04-19 09:55:20.000000 gpaw-23.6.0/gpaw/mpi.py
+drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2023-06-09 07:55:41.871443 gpaw-23.6.0/gpaw/new/
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     2272 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/new/__init__.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    18443 2023-06-09 07:52:47.000000 gpaw-23.6.0/gpaw/new/ase_interface.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     6731 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/new/backwards_compatibility.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      884 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/new/basis.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     3154 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/new/brillouin.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    15478 2023-06-07 15:02:45.000000 gpaw-23.6.0/gpaw/new/builder.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    13886 2023-06-07 15:02:45.000000 gpaw-23.6.0/gpaw/new/calculation.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     9421 2023-06-07 15:03:23.000000 gpaw-23.6.0/gpaw/new/density.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      249 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/new/eigensolver.py
+drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2023-06-09 07:55:41.871443 gpaw-23.6.0/gpaw/new/fd/
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)        0 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/new/fd/__init__.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     5445 2023-04-19 09:55:20.000000 gpaw-23.6.0/gpaw/new/fd/builder.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     5075 2023-04-19 09:55:20.000000 gpaw-23.6.0/gpaw/new/fd/pot_calc.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     8180 2023-05-26 06:07:47.000000 gpaw-23.6.0/gpaw/new/gpw.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      184 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/new/hamiltonian.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    16929 2023-06-07 15:02:45.000000 gpaw-23.6.0/gpaw/new/ibzwfs.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     8030 2023-04-19 09:55:20.000000 gpaw-23.6.0/gpaw/new/input_parameters.py
+drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2023-06-09 07:55:41.875443 gpaw-23.6.0/gpaw/new/lcao/
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)        0 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/new/lcao/__init__.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     5707 2023-04-19 09:55:20.000000 gpaw-23.6.0/gpaw/new/lcao/builder.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1030 2023-04-19 09:55:20.000000 gpaw-23.6.0/gpaw/new/lcao/eigensolver.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     7422 2023-04-19 09:55:20.000000 gpaw-23.6.0/gpaw/new/lcao/forces.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     6500 2023-04-19 09:55:20.000000 gpaw-23.6.0/gpaw/new/lcao/hamiltonian.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      781 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/new/lcao/hybrids.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     6729 2023-04-19 09:55:20.000000 gpaw-23.6.0/gpaw/new/lcao/wave_functions.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1842 2023-06-09 07:32:02.000000 gpaw-23.6.0/gpaw/new/logger.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      535 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/new/poisson.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     5558 2023-04-19 09:55:20.000000 gpaw-23.6.0/gpaw/new/pot_calc.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     2431 2023-04-19 09:55:20.000000 gpaw-23.6.0/gpaw/new/potential.py
+drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2023-06-09 07:55:41.875443 gpaw-23.6.0/gpaw/new/pw/
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)        0 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/new/pw/__init__.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     7455 2023-05-26 06:07:47.000000 gpaw-23.6.0/gpaw/new/pw/builder.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     4859 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/new/pw/fulldiag.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     4600 2023-04-19 09:55:20.000000 gpaw-23.6.0/gpaw/new/pw/hamiltonian.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     7335 2023-05-26 06:07:47.000000 gpaw-23.6.0/gpaw/new/pw/poisson.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     7992 2023-05-26 06:07:47.000000 gpaw-23.6.0/gpaw/new/pw/pot_calc.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     4160 2023-06-07 15:02:45.000000 gpaw-23.6.0/gpaw/new/pw/stress.py
+drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2023-06-09 07:55:41.879443 gpaw-23.6.0/gpaw/new/pwfd/
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)        0 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/new/pwfd/__init__.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     4924 2023-04-19 09:55:20.000000 gpaw-23.6.0/gpaw/new/pwfd/builder.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    11194 2023-06-05 15:36:49.000000 gpaw-23.6.0/gpaw/new/pwfd/davidson.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    16426 2023-04-19 09:55:20.000000 gpaw-23.6.0/gpaw/new/pwfd/wave_functions.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    12943 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/new/rttddft.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     7068 2023-04-19 09:55:20.000000 gpaw-23.6.0/gpaw/new/scf.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     2098 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/new/smearing.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1066 2023-04-19 09:28:43.000000 gpaw-23.6.0/gpaw/new/spinors.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1714 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/new/spinspiral.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     4262 2023-04-19 09:55:20.000000 gpaw-23.6.0/gpaw/new/symmetry.py
+drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2023-06-09 07:55:41.879443 gpaw-23.6.0/gpaw/new/tb/
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)        0 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/new/tb/__init__.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    11643 2023-04-19 09:55:20.000000 gpaw-23.6.0/gpaw/new/tb/builder.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     4587 2023-04-19 09:55:20.000000 gpaw-23.6.0/gpaw/new/wave_functions.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1087 2023-04-19 09:55:20.000000 gpaw-23.6.0/gpaw/new/xc.py
+drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2023-06-09 07:55:41.879443 gpaw-23.6.0/gpaw/nlopt/
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)        0 2021-08-20 08:32:04.000000 gpaw-23.6.0/gpaw/nlopt/__init__.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     2936 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/nlopt/basic.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     3665 2022-05-04 08:34:37.000000 gpaw-23.6.0/gpaw/nlopt/linear.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     9804 2022-05-04 08:34:37.000000 gpaw-23.6.0/gpaw/nlopt/matrixel.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    11923 2022-05-04 08:34:37.000000 gpaw-23.6.0/gpaw/nlopt/shg.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     5079 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/nlopt/shift.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    27831 2023-05-26 06:08:18.000000 gpaw-23.6.0/gpaw/occupations.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     4794 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/output.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     2532 2023-05-26 06:07:47.000000 gpaw-23.6.0/gpaw/overlap.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     9020 2022-05-04 08:34:37.000000 gpaw-23.6.0/gpaw/pair_density.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    20149 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/pair_overlap.py
+drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2023-06-09 07:55:41.883443 gpaw-23.6.0/gpaw/pes/
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1497 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/pes/__init__.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     2999 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/pes/continuum.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1697 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/pes/dos.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     6905 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/pes/ds_beta.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     3117 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/pes/state.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     8951 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/pes/tddft.py
+drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2023-06-09 07:55:41.883443 gpaw-23.6.0/gpaw/point_groups/
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      428 2021-08-20 08:32:04.000000 gpaw-23.6.0/gpaw/point_groups/__init__.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)       64 2021-08-20 08:32:04.000000 gpaw-23.6.0/gpaw/point_groups/__main__.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     6343 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/point_groups/check.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     3290 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/point_groups/cli.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1561 2022-05-04 08:34:37.000000 gpaw-23.6.0/gpaw/point_groups/group.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    62872 2021-08-20 08:32:04.000000 gpaw-23.6.0/gpaw/point_groups/groups.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    35010 2023-05-26 12:00:48.000000 gpaw-23.6.0/gpaw/poisson.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    11434 2023-05-26 06:07:47.000000 gpaw-23.6.0/gpaw/poisson_extravacuum.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     8340 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/poisson_moment.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     3562 2023-05-26 06:07:47.000000 gpaw-23.6.0/gpaw/preconditioner.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     5660 2023-06-05 15:36:49.000000 gpaw-23.6.0/gpaw/projections.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    10559 2023-04-19 09:55:20.000000 gpaw-23.6.0/gpaw/pseudopotential.py
+drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2023-06-09 07:55:41.887443 gpaw-23.6.0/gpaw/pw/
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)        0 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/pw/__init__.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     4315 2023-05-26 06:07:47.000000 gpaw-23.6.0/gpaw/pw/density.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    18186 2023-05-26 06:07:47.000000 gpaw-23.6.0/gpaw/pw/descriptor.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     5731 2023-04-28 06:58:41.000000 gpaw-23.6.0/gpaw/pw/hamiltonian.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    15166 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/pw/lfc.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     4090 2023-05-26 06:07:47.000000 gpaw-23.6.0/gpaw/pw/poisson.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)        0 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/py.typed
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     3195 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/quiz.py
+drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2023-06-09 07:55:41.887443 gpaw-23.6.0/gpaw/raman/
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)        0 2022-05-04 08:34:37.000000 gpaw-23.6.0/gpaw/raman/__init__.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    15120 2023-05-26 06:08:18.000000 gpaw-23.6.0/gpaw/raman/raman.py
+drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2023-06-09 07:55:41.907443 gpaw-23.6.0/gpaw/response/
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      222 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/response/__init__.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    39663 2023-05-26 06:07:47.000000 gpaw-23.6.0/gpaw/response/bse.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    29830 2023-05-26 06:08:18.000000 gpaw-23.6.0/gpaw/response/chi0.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     8888 2023-05-26 06:07:47.000000 gpaw-23.6.0/gpaw/response/chi0_data.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    20067 2023-05-26 06:08:18.000000 gpaw-23.6.0/gpaw/response/chiks.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     2581 2023-05-26 06:08:18.000000 gpaw-23.6.0/gpaw/response/context.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     6156 2023-04-19 09:55:20.000000 gpaw-23.6.0/gpaw/response/coulomb_kernels.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     3519 2023-04-19 09:55:20.000000 gpaw-23.6.0/gpaw/response/density_kernels.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    22839 2023-05-26 06:07:47.000000 gpaw-23.6.0/gpaw/response/df.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     7036 2023-05-26 06:08:18.000000 gpaw-23.6.0/gpaw/response/drude.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     4158 2023-05-26 06:07:47.000000 gpaw-23.6.0/gpaw/response/dyson.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     5931 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/response/frequencies.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     8039 2023-05-26 06:07:47.000000 gpaw-23.6.0/gpaw/response/fxc_kernels.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    43688 2023-05-26 06:08:18.000000 gpaw-23.6.0/gpaw/response/g0w0.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     2207 2023-04-19 09:55:20.000000 gpaw-23.6.0/gpaw/response/g0w0_kernels.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1190 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/response/gamma_int.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     5069 2023-05-26 06:07:47.000000 gpaw-23.6.0/gpaw/response/goldstone.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     8267 2023-04-19 09:55:20.000000 gpaw-23.6.0/gpaw/response/groundstate.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     7929 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/response/gw_bands.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     5138 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/response/heisenberg.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     3292 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/response/hilbert.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     7089 2023-06-05 15:36:49.000000 gpaw-23.6.0/gpaw/response/ibz2bz.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    20833 2023-05-26 06:08:18.000000 gpaw-23.6.0/gpaw/response/integrators.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     6020 2023-05-26 06:08:18.000000 gpaw-23.6.0/gpaw/response/jdos.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    26071 2023-05-26 06:08:18.000000 gpaw-23.6.0/gpaw/response/kspair.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    22927 2023-06-05 15:36:49.000000 gpaw-23.6.0/gpaw/response/localft.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     7116 2023-05-26 06:07:47.000000 gpaw-23.6.0/gpaw/response/matrix_elements.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     6422 2023-05-26 06:07:47.000000 gpaw-23.6.0/gpaw/response/mft.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    19962 2023-04-19 09:55:20.000000 gpaw-23.6.0/gpaw/response/pair.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    19157 2023-05-26 06:07:47.000000 gpaw-23.6.0/gpaw/response/pair_functions.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    18454 2023-05-26 06:08:18.000000 gpaw-23.6.0/gpaw/response/pair_integrator.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     8297 2023-05-26 06:08:18.000000 gpaw-23.6.0/gpaw/response/pair_transitions.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     5117 2023-04-19 09:55:20.000000 gpaw-23.6.0/gpaw/response/paw.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     9785 2023-05-26 06:07:47.000000 gpaw-23.6.0/gpaw/response/pw_parallelization.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     4785 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/response/q0_correction.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    18279 2023-04-19 09:55:20.000000 gpaw-23.6.0/gpaw/response/qeh.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    15175 2023-05-26 06:08:18.000000 gpaw-23.6.0/gpaw/response/screened_interaction.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    16996 2023-05-26 06:07:47.000000 gpaw-23.6.0/gpaw/response/site_kernels.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    19853 2023-05-26 06:08:18.000000 gpaw-23.6.0/gpaw/response/susceptibility.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    19235 2023-05-26 06:07:47.000000 gpaw-23.6.0/gpaw/response/symmetry.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     4964 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/response/temp.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     8391 2023-04-19 09:55:20.000000 gpaw-23.6.0/gpaw/response/tool.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     7177 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/response/wgg.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1730 2021-08-20 08:32:04.000000 gpaw-23.6.0/gpaw/rotation.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     8623 2023-05-26 12:00:48.000000 gpaw-23.6.0/gpaw/scf.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    57695 2023-04-19 09:55:20.000000 gpaw-23.6.0/gpaw/setup.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    23983 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/setup_data.py
+drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2023-06-09 07:55:41.911443 gpaw-23.6.0/gpaw/solvation/
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     2231 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/solvation/__init__.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     6429 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/solvation/calculator.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    35118 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/solvation/cavity.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     3443 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/solvation/dielectric.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      306 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/solvation/gridmem.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    10379 2023-05-26 12:00:48.000000 gpaw-23.6.0/gpaw/solvation/hamiltonian.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     5718 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/solvation/interactions.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    11188 2023-05-26 06:07:47.000000 gpaw-23.6.0/gpaw/solvation/poisson.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    51731 2023-05-26 06:08:18.000000 gpaw-23.6.0/gpaw/solvation/sjm.py
+drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2023-06-09 07:55:41.911443 gpaw-23.6.0/gpaw/sphere/
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)        0 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/sphere/__init__.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    28413 2023-06-05 15:36:49.000000 gpaw-23.6.0/gpaw/sphere/lebedev.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     6413 2023-06-05 15:36:49.000000 gpaw-23.6.0/gpaw/sphere/rshe.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    16072 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/spherical_harmonics.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    30925 2023-05-26 06:08:18.000000 gpaw-23.6.0/gpaw/spinorbit.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     2687 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/spline.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     3441 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/stress.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    21337 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/symmetry.py
+drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2023-06-09 07:55:41.915444 gpaw-23.6.0/gpaw/tddft/
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    21299 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/tddft/__init__.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    11361 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/tddft/abc.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     6147 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/tddft/ehrenfest.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     2845 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/tddft/folding.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1005 2021-08-20 08:32:04.000000 gpaw-23.6.0/gpaw/tddft/laser.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    45460 2022-05-04 08:34:37.000000 gpaw-23.6.0/gpaw/tddft/propagators.py
+drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2023-06-09 07:55:41.915444 gpaw-23.6.0/gpaw/tddft/solvers/
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      508 2022-05-04 08:34:37.000000 gpaw-23.6.0/gpaw/tddft/solvers/__init__.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     2145 2022-05-04 08:34:37.000000 gpaw-23.6.0/gpaw/tddft/solvers/base.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     6863 2022-05-04 08:34:37.000000 gpaw-23.6.0/gpaw/tddft/solvers/bicgstab.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     5006 2022-05-04 08:34:37.000000 gpaw-23.6.0/gpaw/tddft/solvers/cscg.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    15861 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/tddft/spectrum.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    30508 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/tddft/tdopers.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1691 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/tddft/units.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     5086 2022-05-04 08:34:37.000000 gpaw-23.6.0/gpaw/tddft/utils.py
+drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2023-06-09 07:55:41.939444 gpaw-23.6.0/gpaw/test/
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     2511 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/__init__.py
+drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2023-06-09 07:55:41.939444 gpaw-23.6.0/gpaw/test/ase_features/
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)        0 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/test/ase_features/__init__.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     2432 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/ase_features/autoneb.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      749 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/ase_features/test_ase3k.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      218 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/ase_features/test_ase3k_version.py
+drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2023-06-09 07:55:41.939444 gpaw-23.6.0/gpaw/test/big/
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)        0 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/test/big/__init__.py
+drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2023-06-09 07:55:41.943444 gpaw-23.6.0/gpaw/test/big/dcdft/
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)        0 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/test/big/dcdft/__init__.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     4167 2022-05-04 08:34:37.000000 gpaw-23.6.0/gpaw/test/big/dcdft/analyse.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     2903 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/test/big/dcdft/pbe_abinit_fhi.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     3371 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/test/big/dcdft/pbe_abinit_hgh.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     3477 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/test/big/dcdft/pbe_abinit_paw.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     4205 2022-05-04 08:34:37.000000 gpaw-23.6.0/gpaw/test/big/dcdft/pbe_aims.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     3870 2023-04-19 09:55:20.000000 gpaw-23.6.0/gpaw/test/big/dcdft/pbe_gpaw_pw.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     2644 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/test/big/dcdft/pbe_gpaw_pw_verify.py
+drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2023-06-09 07:55:41.943444 gpaw-23.6.0/gpaw/test/big/g2_1/
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     6393 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/test/big/g2_1/analyse.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      988 2023-04-19 09:55:20.000000 gpaw-23.6.0/gpaw/test/big/g2_1/g21gpaw.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1060 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/test/big/g2_1/g21nwchem.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      171 2022-05-04 08:34:37.000000 gpaw-23.6.0/gpaw/test/big/g2_1/generate.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     7169 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/big/g2_1/pbe_gpaw_nrel_plot.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      131 2022-05-04 08:34:37.000000 gpaw-23.6.0/gpaw/test/big/g2_1/submit.agts.py
+drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2023-06-09 07:55:41.947444 gpaw-23.6.0/gpaw/test/big/hsk/
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)        0 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/test/big/hsk/__init__.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     3254 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/test/big/hsk/hsk.py
+drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2023-06-09 07:55:41.947444 gpaw-23.6.0/gpaw/test/big/kpb/
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      960 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/big/kpb/check.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     2681 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/big/kpb/molecules.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      130 2022-05-04 08:34:37.000000 gpaw-23.6.0/gpaw/test/big/kpb/submit.agts.py
+drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2023-06-09 07:55:41.947444 gpaw-23.6.0/gpaw/test/big/setups/
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)        0 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/test/big/setups/__init__.py
+drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2023-06-09 07:55:41.947444 gpaw-23.6.0/gpaw/test/big/test_systems/
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)        0 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/big/test_systems/__init__.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1390 2023-06-09 07:32:07.000000 gpaw-23.6.0/gpaw/test/big/test_systems/agts.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    17010 2023-05-26 06:07:47.000000 gpaw-23.6.0/gpaw/test/big/test_systems/create.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    30229 2023-06-09 07:32:07.000000 gpaw-23.6.0/gpaw/test/conftest.py
+drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2023-06-09 07:55:41.951444 gpaw-23.6.0/gpaw/test/corehole/
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)        0 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/test/corehole/__init__.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1768 2021-08-20 08:32:04.000000 gpaw-23.6.0/gpaw/test/corehole/si_nonortho.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1772 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/corehole/test_h2o.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1668 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/corehole/test_h2o_dks.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1191 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/corehole/test_h2o_recursion.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1336 2023-04-19 09:55:20.000000 gpaw-23.6.0/gpaw/test/corehole/test_li2.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1627 2023-04-19 09:55:20.000000 gpaw-23.6.0/gpaw/test/corehole/test_si.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1228 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/crontab.py
+drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2023-06-09 07:55:41.951444 gpaw-23.6.0/gpaw/test/dscf/
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)        0 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/test/dscf/__init__.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     2933 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/test/dscf/dscf_forces.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1294 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/test/dscf/test_dscf_lcao.py
+drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2023-06-09 07:55:41.951444 gpaw-23.6.0/gpaw/test/eigen/
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)        0 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/test/eigen/__init__.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      988 2022-05-04 08:34:37.000000 gpaw-23.6.0/gpaw/test/eigen/test_blocked_rmm_diis.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      856 2022-05-04 08:34:37.000000 gpaw-23.6.0/gpaw/test/eigen/test_cg.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1227 2021-08-20 08:32:04.000000 gpaw-23.6.0/gpaw/test/eigen/test_cg2.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1524 2021-08-20 08:32:04.000000 gpaw-23.6.0/gpaw/test/eigen/test_davidson.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      744 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/test/eigen/test_keep_htpsit.py
+drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2023-06-09 07:55:41.955444 gpaw-23.6.0/gpaw/test/elph/
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)        0 2022-05-04 08:34:37.000000 gpaw-23.6.0/gpaw/test/elph/__init__.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1746 2023-05-26 06:07:47.000000 gpaw-23.6.0/gpaw/test/elph/conftest.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     2362 2023-05-26 06:07:47.000000 gpaw-23.6.0/gpaw/test/elph/test_displacements.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1525 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/elph/test_electronphonon.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     3077 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/elph/test_elph_li.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     2287 2023-05-26 06:08:18.000000 gpaw-23.6.0/gpaw/test/elph/test_gmatrix.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     2570 2023-06-05 15:36:49.000000 gpaw-23.6.0/gpaw/test/elph/test_gradient.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     2713 2023-05-26 06:08:18.000000 gpaw-23.6.0/gpaw/test/elph/test_ramancalculator.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1583 2023-05-26 06:08:18.000000 gpaw-23.6.0/gpaw/test/elph/test_resonant_term.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1010 2023-05-26 06:07:47.000000 gpaw-23.6.0/gpaw/test/elph/test_supercell.py
+drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2023-06-09 07:55:41.959444 gpaw-23.6.0/gpaw/test/ext_potential/
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)        0 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/test/ext_potential/__init__.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     7185 2023-04-19 09:55:20.000000 gpaw-23.6.0/gpaw/test/ext_potential/stark_shift.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1250 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/ext_potential/test_b_field.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1023 2022-05-04 08:34:37.000000 gpaw-23.6.0/gpaw/test/ext_potential/test_collection.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1536 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/ext_potential/test_constant_e_field.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1912 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/ext_potential/test_external.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     2782 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/ext_potential/test_external_pw.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     2568 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/ext_potential/test_harmonic.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     3028 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/ext_potential/test_point_charge.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1128 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/ext_potential/test_step.py
+drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2023-06-09 07:55:41.963444 gpaw-23.6.0/gpaw/test/exx/
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)        0 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/test/exx/__init__.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1819 2023-04-19 09:55:20.000000 gpaw-23.6.0/gpaw/test/exx/test_coarse.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     2551 2023-04-19 09:55:20.000000 gpaw-23.6.0/gpaw/test/exx/test_derivs.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1573 2023-06-05 15:36:49.000000 gpaw-23.6.0/gpaw/test/exx/test_double_cell.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1973 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/exx/test_exx.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1730 2023-04-19 09:55:20.000000 gpaw-23.6.0/gpaw/test/exx/test_exx_scf.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     3865 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/exx/test_forces_ut.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1589 2023-04-26 11:01:30.000000 gpaw-23.6.0/gpaw/test/exx/test_kpts.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     2048 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/exx/test_unocc.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      240 2022-05-04 08:34:37.000000 gpaw-23.6.0/gpaw/test/exx/test_xc.py
+drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2023-06-09 07:55:41.963444 gpaw-23.6.0/gpaw/test/fd_ops/
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)        0 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/test/fd_ops/__init__.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1372 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/fd_ops/test_gd.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     2838 2022-05-04 08:34:37.000000 gpaw-23.6.0/gpaw/test/fd_ops/test_gradient.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     3598 2022-05-04 08:34:37.000000 gpaw-23.6.0/gpaw/test/fd_ops/test_laplace.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1205 2022-05-04 08:34:37.000000 gpaw-23.6.0/gpaw/test/fd_ops/test_nabla.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      686 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/test/fd_ops/test_non_periodic.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1444 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/test/fd_ops/test_transformations.py
+drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2023-06-09 07:55:41.967444 gpaw-23.6.0/gpaw/test/fdtd/
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)        0 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/test/fdtd/__init__.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     3591 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/fdtd/test_ed.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     7252 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/fdtd/test_ed_inducedfield.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     3423 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/fdtd/test_ed_shapes.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     2443 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/fdtd/test_ed_wrapper.py
+drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2023-06-09 07:55:41.971444 gpaw-23.6.0/gpaw/test/fileio/
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)        0 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/test/fileio/__init__.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1288 2022-05-04 08:34:37.000000 gpaw-23.6.0/gpaw/test/fileio/test_ascii_art.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1126 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/fileio/test_file_reference.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      447 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/fileio/test_idiotproof_setup.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1274 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/test/fileio/test_parallel.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      330 2021-08-20 08:32:04.000000 gpaw-23.6.0/gpaw/test/fileio/test_read_old_gpw.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1037 2023-04-19 09:55:20.000000 gpaw-23.6.0/gpaw/test/fileio/test_refine.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     2333 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/fileio/test_restart.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1785 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/fileio/test_restart_density.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      408 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/fileio/test_wfs_auto.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      654 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/fileio/test_wfs_io.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      238 2023-04-19 09:55:20.000000 gpaw-23.6.0/gpaw/test/fileio/test_yaml.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    12556 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/fuzz.py
+drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2023-06-09 07:55:41.975444 gpaw-23.6.0/gpaw/test/generic/
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)       74 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/test/generic/__init__.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      685 2023-04-19 09:55:20.000000 gpaw-23.6.0/gpaw/test/generic/colinear.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      940 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/generic/test_2Al.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1617 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/generic/test_8Si.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      402 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/test/generic/test_Cl_minus.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1080 2022-05-04 08:34:37.000000 gpaw-23.6.0/gpaw/test/generic/test_Cu.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1024 2022-05-04 08:34:37.000000 gpaw-23.6.0/gpaw/test/generic/test_H_force.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      748 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/generic/test_IP_oxygen.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      539 2022-05-04 08:34:37.000000 gpaw-23.6.0/gpaw/test/generic/test_al_chain.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1121 2022-05-04 08:34:37.000000 gpaw-23.6.0/gpaw/test/generic/test_asym_box.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      680 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/test/generic/test_bulk.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     2248 2023-04-19 09:55:20.000000 gpaw-23.6.0/gpaw/test/generic/test_guc_force.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1963 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/generic/test_hydrogen.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      444 2022-05-04 08:34:37.000000 gpaw-23.6.0/gpaw/test/generic/test_mixer.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1588 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/generic/test_move_across_cell.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1634 2023-04-19 09:55:20.000000 gpaw-23.6.0/gpaw/test/generic/test_proton.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     3299 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/generic/test_relax.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1188 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/generic/test_si.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      722 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/generic/test_si_primitive.py
+drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2023-06-09 07:55:41.979444 gpaw-23.6.0/gpaw/test/gllb/
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)        0 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/test/gllb/__init__.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1885 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/test/gllb/test_atomic.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     5719 2021-07-05 14:53:36.000000 gpaw-23.6.0/gpaw/test/gllb/test_diamond.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      339 2023-04-19 09:55:20.000000 gpaw-23.6.0/gpaw/test/gllb/test_gllbghost.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1326 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/gllb/test_metallic.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1349 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/gllb/test_ne.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     2169 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/gllb/test_ne_disc.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     3405 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/gllb/test_restart_eigenvalues.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1530 2021-07-05 14:53:36.000000 gpaw-23.6.0/gpaw/test/gllb/test_spin.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     2597 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/gllb/test_variants.py
+drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2023-06-09 07:55:41.979444 gpaw-23.6.0/gpaw/test/gpu/
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)        0 2023-05-26 06:07:47.000000 gpaw-23.6.0/gpaw/test/gpu/__init__.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      403 2023-04-19 09:55:20.000000 gpaw-23.6.0/gpaw/test/gpu/test_cpupy.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1112 2023-04-19 09:55:20.000000 gpaw-23.6.0/gpaw/test/gpu/test_matrix.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      395 2023-04-19 09:55:20.000000 gpaw-23.6.0/gpaw/test/gpu/test_mpi.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      553 2023-04-19 09:55:20.000000 gpaw-23.6.0/gpaw/test/gpu/test_precondition.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1569 2023-04-19 09:55:20.000000 gpaw-23.6.0/gpaw/test/gpu/test_pw.py
+drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2023-06-09 07:55:41.991444 gpaw-23.6.0/gpaw/test/lcao/
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)        0 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/test/lcao/__init__.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      877 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/lcao/restart.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      345 2022-05-04 08:34:37.000000 gpaw-23.6.0/gpaw/test/lcao/test_analyse_basis.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     2126 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/lcao/test_atomic_corrections.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1930 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/lcao/test_bsse.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1214 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/lcao/test_bulk.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1964 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/lcao/test_density.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     3639 2023-05-26 06:08:18.000000 gpaw-23.6.0/gpaw/test/lcao/test_dipole_transition.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     3851 2023-05-26 06:08:18.000000 gpaw-23.6.0/gpaw/test/lcao/test_dipole_transition2.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1636 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/lcao/test_dos.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1599 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/lcao/test_fd2lcao_restart.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      430 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/lcao/test_fftmixer.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     2462 2023-05-26 06:08:18.000000 gpaw-23.6.0/gpaw/test/lcao/test_force.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     3015 2022-05-04 08:34:37.000000 gpaw-23.6.0/gpaw/test/lcao/test_generate_ngto.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1079 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/lcao/test_gllb_si.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1044 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/lcao/test_h2o.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     3498 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/lcao/test_kpts_many_combinations.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     2122 2022-05-04 08:34:37.000000 gpaw-23.6.0/gpaw/test/lcao/test_largecellforce.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     3516 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/lcao/test_lcao_complicated.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      858 2022-05-04 08:34:37.000000 gpaw-23.6.0/gpaw/test/lcao/test_lcao_elpa.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1193 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/lcao/test_lcao_elpa_kpts.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1228 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/lcao/test_lcao_hamiltonian.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     4873 2022-05-04 08:34:37.000000 gpaw-23.6.0/gpaw/test/lcao/test_lcao_parallel.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     5125 2022-05-04 08:34:37.000000 gpaw-23.6.0/gpaw/test/lcao/test_lcao_parallel_kpt.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1127 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/lcao/test_lcao_projections.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     2209 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/lcao/test_local_orbitals.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     2460 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/lcao/test_pair_and_coulomb.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      602 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/lcao/test_scissors.py
+drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2023-06-09 07:55:41.995444 gpaw-23.6.0/gpaw/test/lcaotddft/
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     3245 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/lcaotddft/__init__.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     3189 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/lcaotddft/demo_tddft.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     7836 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/lcaotddft/test_circular_dichroism.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1579 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/lcaotddft/test_fxc_is_xc.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1695 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/lcaotddft/test_fxc_rpa.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     2286 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/lcaotddft/test_fxc_vs_linearize.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     2296 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/lcaotddft/test_laser.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     3737 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/lcaotddft/test_lcaotddft_vs_lrtddft.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1823 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/lcaotddft/test_lcaotddft_vs_lrtddft2_rpa.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    10895 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/lcaotddft/test_molecule.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     2823 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/lcaotddft/test_periodic.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     2198 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/lcaotddft/test_replay.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     3880 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/lcaotddft/test_restart.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     3685 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/lcaotddft/test_rremission.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     2971 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/lcaotddft/test_simple.py
+drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2023-06-09 07:55:41.995444 gpaw-23.6.0/gpaw/test/lfc/
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)        0 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/test/lfc/__init__.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1757 2022-05-04 08:34:37.000000 gpaw-23.6.0/gpaw/test/lfc/test_derivatives.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      749 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/test/lfc/test_lf.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1420 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/test/lfc/test_second_derivative.py
+drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2023-06-09 07:55:41.999444 gpaw-23.6.0/gpaw/test/linalg/
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)        0 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/test/linalg/__init__.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     2332 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/linalg/test_blas.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      851 2022-05-04 08:34:37.000000 gpaw-23.6.0/gpaw/test/linalg/test_dot.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      880 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/linalg/test_gemm.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      811 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/linalg/test_gemm_complex.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      359 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/test/linalg/test_lapack.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      798 2022-05-04 08:34:37.000000 gpaw-23.6.0/gpaw/test/linalg/test_mmm.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      962 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/test/linalg/test_zher.py
+drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2023-06-09 07:55:42.003445 gpaw-23.6.0/gpaw/test/lrtddft/
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)        0 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/test/lrtddft/__init__.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1075 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/test/lrtddft/d2Excdn2.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1829 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/lrtddft/rraman.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     2284 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/lrtddft/rraman_albrecht.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     4631 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/lrtddft/test_1.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1429 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/lrtddft/test_2.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     4380 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/lrtddft/test_3.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     2471 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/lrtddft/test_apmb.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1057 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/lrtddft/test_dielectric.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     7335 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/lrtddft/test_excited_state.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     2382 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/lrtddft/test_kssingles.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     2827 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/lrtddft/test_kssingles_Be.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     2321 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/lrtddft/test_lrtddft2.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1569 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/lrtddft/test_lrtddft_basics.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1576 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/lrtddft/test_lrtddft_log.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     2384 2023-04-19 09:55:20.000000 gpaw-23.6.0/gpaw/test/lrtddft/test_pes.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     3187 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/lrtddft/test_placzek_profeta_albrecht.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      551 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/lrtddft/test_rraman.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      753 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/lrtddft/test_select.py
+drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2023-06-09 07:55:42.003445 gpaw-23.6.0/gpaw/test/lrtddft2/
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)        0 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/test/lrtddft2/__init__.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     2449 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/lrtddft2/test_Al2.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     2285 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/lrtddft2/test_H2O-lcao.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     2299 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/lrtddft2/test_parameters.py
+drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2023-06-09 07:55:42.003445 gpaw-23.6.0/gpaw/test/maths/
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)        0 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/test/maths/__init__.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1365 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/test/maths/test_fftw.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      913 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/maths/test_fsbt.py
+drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2023-06-09 07:55:42.007444 gpaw-23.6.0/gpaw/test/mgga/
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)        0 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/test/mgga/__init__.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1378 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/test/mgga/test_mgga_restart.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      629 2023-04-28 06:58:34.000000 gpaw-23.6.0/gpaw/test/mgga/test_mgga_sc.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     2293 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/test/mgga/test_nsc_MGGA.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      717 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/mgga/test_symm.py
+drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2023-06-09 07:55:42.007444 gpaw-23.6.0/gpaw/test/mom/
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)        0 2022-05-04 08:34:37.000000 gpaw-23.6.0/gpaw/test/mom/__init__.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     2350 2022-05-04 08:34:37.000000 gpaw-23.6.0/gpaw/test/mom/test_mom_fd_energy.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1664 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/mom/test_mom_lcao_forces.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1506 2022-05-04 08:34:37.000000 gpaw-23.6.0/gpaw/test/mom/test_mom_lcao_smearing.py
+drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2023-06-09 07:55:42.007444 gpaw-23.6.0/gpaw/test/noncollinear/
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)        0 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/test/noncollinear/__init__.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      720 2023-04-19 09:55:20.000000 gpaw-23.6.0/gpaw/test/noncollinear/test_o2.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1141 2023-05-26 06:08:18.000000 gpaw-23.6.0/gpaw/test/noncollinear/test_rad_pot.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     2301 2023-04-19 09:55:20.000000 gpaw-23.6.0/gpaw/test/noncollinear/test_soc.py
+drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2023-06-09 07:55:42.007444 gpaw-23.6.0/gpaw/test/ofdft/
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)        0 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/test/ofdft/__init__.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1400 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/ofdft/test_ofdft.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      946 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/ofdft/test_ofdft_pbc.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1321 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/ofdft/test_ofdft_scale.py
+drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2023-06-09 07:55:42.015445 gpaw-23.6.0/gpaw/test/parallel/
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)        0 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/test/parallel/__init__.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      892 2023-04-19 09:55:20.000000 gpaw-23.6.0/gpaw/test/parallel/scalapack_pdlasrt_hang.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     2315 2022-05-04 08:34:37.000000 gpaw-23.6.0/gpaw/test/parallel/test_arraydict_redist.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1844 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/parallel/test_augment_grid.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1847 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/parallel/test_blacsdist.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      493 2022-05-04 08:34:37.000000 gpaw-23.6.0/gpaw/test/parallel/test_compare.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1229 2023-04-19 09:55:20.000000 gpaw-23.6.0/gpaw/test/parallel/test_davidson_scalapack.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     2251 2021-07-05 14:53:36.000000 gpaw-23.6.0/gpaw/test/parallel/test_diamond_gllb.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     5252 2022-05-04 08:34:37.000000 gpaw-23.6.0/gpaw/test/parallel/test_fd_parallel.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     5237 2022-05-04 08:34:37.000000 gpaw-23.6.0/gpaw/test/parallel/test_fd_parallel_kpt.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1420 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/test/parallel/test_kptpar.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1660 2023-04-19 09:55:20.000000 gpaw-23.6.0/gpaw/test/parallel/test_mpi.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     2463 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/parallel/test_parallel_eigh.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    11365 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/parallel/test_pblas.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      126 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/test/parallel/test_redistribute_grid.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     7747 2022-05-04 08:34:37.000000 gpaw-23.6.0/gpaw/test/parallel/test_scalapack.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     2096 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/parallel/test_scalapack_diag_simple.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1071 2021-08-20 08:32:04.000000 gpaw-23.6.0/gpaw/test/parallel/test_scalapack_mpirecv_crash.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      818 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/parallel/test_submatrix_redist.py
+drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2023-06-09 07:55:42.015445 gpaw-23.6.0/gpaw/test/pathological/
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)        0 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/test/pathological/__init__.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      652 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/pathological/test_LDA_unstable.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      714 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/pathological/test_lcao_spos_derivative.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     2219 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/pathological/test_nonlocalset.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      879 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/pathological/test_numpy_zdotc_graphite.py
+drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2023-06-09 07:55:42.019445 gpaw-23.6.0/gpaw/test/poisson/
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)        0 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/test/poisson/__init__.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     4711 2022-05-04 08:34:37.000000 gpaw-23.6.0/gpaw/test/poisson/test_fastpoisson.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1746 2022-05-04 08:34:37.000000 gpaw-23.6.0/gpaw/test/poisson/test_generalizedlaue.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1289 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/poisson/test_metallic_poisson.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1421 2022-05-04 08:34:37.000000 gpaw-23.6.0/gpaw/test/poisson/test_poisson.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1454 2022-05-04 08:34:37.000000 gpaw-23.6.0/gpaw/test/poisson/test_poisson_asym.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     5939 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/poisson/test_poisson_extravacuum.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     9519 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/poisson/test_poisson_moment.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     3347 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/poisson/test_poisson_restart.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1379 2023-05-26 06:07:47.000000 gpaw-23.6.0/gpaw/test/poisson/test_pw_charged.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1718 2022-05-04 08:34:37.000000 gpaw-23.6.0/gpaw/test/poisson/test_screened_poisson.py
+drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2023-06-09 07:55:42.027445 gpaw-23.6.0/gpaw/test/pseudopotential/
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)   114225 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/test/pseudopotential/H_pz_hgh.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    64903 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/test/pseudopotential/H_sg15.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)   187223 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/test/pseudopotential/O_pz_hgh.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)        0 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/test/pseudopotential/__init__.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      512 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/pseudopotential/test_ah.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1886 2021-08-20 08:32:04.000000 gpaw-23.6.0/gpaw/test/pseudopotential/test_atompaw.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     3380 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/pseudopotential/test_hgh_h2o.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      985 2023-04-19 09:55:20.000000 gpaw-23.6.0/gpaw/test/pseudopotential/test_sg15_hydrogen.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     2014 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/pseudopotential/test_upf_h2o.py
+drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2023-06-09 07:55:42.035445 gpaw-23.6.0/gpaw/test/pw/
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)        0 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/test/pw/__init__.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1781 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/pw/test_augment_grids.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      554 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/pw/test_bulk.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1274 2022-05-04 08:34:37.000000 gpaw-23.6.0/gpaw/test/pw/test_davidson_pw.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      572 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/test/pw/test_direct.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      311 2022-05-04 08:34:37.000000 gpaw-23.6.0/gpaw/test/pw/test_electrostatic_potential.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     2922 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/pw/test_expert_diag.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1608 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/pw/test_fe_stress_mgga.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      461 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/pw/test_fftmixer.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1562 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/pw/test_fulldiag.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      646 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/pw/test_fulldiag_mgga.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1883 2023-04-19 09:55:20.000000 gpaw-23.6.0/gpaw/test/pw/test_fulldiagk.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      695 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/test/pw/test_h.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     2203 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/pw/test_interpol.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1923 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/pw/test_lfc.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      443 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/pw/test_moleculecg.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     2036 2023-04-19 09:55:20.000000 gpaw-23.6.0/gpaw/test/pw/test_par_strategies.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1665 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/pw/test_reallfc.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1105 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/pw/test_si_stress.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1467 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/pw/test_si_stress_mgga.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1010 2023-04-19 09:55:20.000000 gpaw-23.6.0/gpaw/test/pw/test_slab.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      446 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/pw/test_smallanglecell.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     2099 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/pw/test_stresstest.py
+drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2023-06-09 07:55:42.035445 gpaw-23.6.0/gpaw/test/radial/
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)        0 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/test/radial/__init__.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      464 2022-05-04 08:34:37.000000 gpaw-23.6.0/gpaw/test/radial/test_integral4.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      300 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/radial/test_lebedev.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     2057 2023-04-19 09:55:20.000000 gpaw-23.6.0/gpaw/test/radial/test_two_phi_plw_integrals.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     2207 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/radial/test_ylexpand.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     5218 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/test/radial/test_yukawa_radial.py
+drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2023-06-09 07:55:42.039445 gpaw-23.6.0/gpaw/test/ralda/
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)        0 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/test/ralda/__init__.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1273 2023-05-26 06:08:18.000000 gpaw-23.6.0/gpaw/test/ralda/test_pbe_deriv.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      810 2023-05-26 06:08:18.000000 gpaw-23.6.0/gpaw/test/ralda/test_ralda_H2.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1686 2023-05-26 06:08:18.000000 gpaw-23.6.0/gpaw/test/ralda/test_ralda_He.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      627 2023-05-26 06:08:18.000000 gpaw-23.6.0/gpaw/test/ralda/test_ralda_Ni.py
+drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2023-06-09 07:55:42.055445 gpaw-23.6.0/gpaw/test/response/
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)        0 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/test/response/__init__.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1563 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/response/hyd_chain_response.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     4031 2023-04-19 09:55:20.000000 gpaw-23.6.0/gpaw/test/response/test_Na_EELS_RPA_tetra_point_comparison.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     2920 2023-04-19 09:55:20.000000 gpaw-23.6.0/gpaw/test/response/test_WGG_GaAs.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     5442 2023-05-26 06:08:18.000000 gpaw-23.6.0/gpaw/test/response/test_afm_hchain_sf_gssALDA.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     2035 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/response/test_aluminum_EELS_ALDA.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     3935 2023-04-19 09:55:20.000000 gpaw-23.6.0/gpaw/test/response/test_aluminum_EELS_RPA.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1889 2023-04-19 09:55:20.000000 gpaw-23.6.0/gpaw/test/response/test_au02_absorption.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     2345 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/response/test_bse_MoS2_cut.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     2083 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/response/test_bse_aluminum.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     2777 2023-04-19 09:55:20.000000 gpaw-23.6.0/gpaw/test/response/test_bse_silicon.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     2319 2023-04-19 09:55:20.000000 gpaw-23.6.0/gpaw/test/response/test_chi0.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1829 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/response/test_chi0_update.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    16400 2023-06-05 15:36:49.000000 gpaw-23.6.0/gpaw/test/response/test_chiks.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    10702 2023-05-26 06:08:18.000000 gpaw-23.6.0/gpaw/test/response/test_cobalt_sf_gssALDA.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     3116 2023-04-19 09:55:20.000000 gpaw-23.6.0/gpaw/test/response/test_diamond_absorption.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     3879 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/response/test_graphene.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     3967 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/response/test_graphene_EELS.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1715 2023-06-09 07:32:07.000000 gpaw-23.6.0/gpaw/test/response/test_gw_MoS2_cut.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      862 2023-06-09 07:32:07.000000 gpaw-23.6.0/gpaw/test/response/test_gw_hBN_extrapolate.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      595 2023-06-09 07:32:07.000000 gpaw-23.6.0/gpaw/test/response/test_gw_ppa.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1274 2023-06-09 07:32:07.000000 gpaw-23.6.0/gpaw/test/response/test_gw_restart_file.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     3716 2023-06-09 07:32:07.000000 gpaw-23.6.0/gpaw/test/response/test_gw_si.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1012 2023-06-09 07:32:07.000000 gpaw-23.6.0/gpaw/test/response/test_gw_spinpol.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      880 2023-06-09 07:32:07.000000 gpaw-23.6.0/gpaw/test/response/test_gw_too.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      700 2023-06-09 07:32:07.000000 gpaw-23.6.0/gpaw/test/response/test_gw_vertex.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     6631 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/response/test_heisenberg.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1072 2023-06-09 07:32:07.000000 gpaw-23.6.0/gpaw/test/response/test_hubbard.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     9663 2023-05-26 12:00:52.000000 gpaw-23.6.0/gpaw/test/response/test_ibz2bz.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     5347 2023-05-26 06:08:18.000000 gpaw-23.6.0/gpaw/test/response/test_iron_sf_ALDA.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     7883 2023-06-05 15:36:49.000000 gpaw-23.6.0/gpaw/test/response/test_iron_sf_gssALDA.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     6000 2023-06-05 15:36:49.000000 gpaw-23.6.0/gpaw/test/response/test_jdos.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     9720 2023-05-26 06:07:47.000000 gpaw-23.6.0/gpaw/test/response/test_localft.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     9881 2023-05-26 06:08:18.000000 gpaw-23.6.0/gpaw/test/response/test_mft.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     4309 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/response/test_na_plasmon.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1775 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/response/test_na_plasmons.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     2997 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/response/test_na_plasmons_tetrahedron.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     5127 2023-05-26 06:07:47.000000 gpaw-23.6.0/gpaw/test/response/test_nicl2_sf_gssALDA.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     4420 2023-06-05 15:36:49.000000 gpaw-23.6.0/gpaw/test/response/test_parallel_kptpair_extraction.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      844 2023-05-26 06:07:47.000000 gpaw-23.6.0/gpaw/test/response/test_parallelization.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     4031 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/response/test_pdens_tool.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     5524 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/response/test_qeh.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1606 2023-06-05 15:36:49.000000 gpaw-23.6.0/gpaw/test/response/test_response_band_cutoff.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     3252 2023-05-26 06:07:47.000000 gpaw-23.6.0/gpaw/test/response/test_silicon_chi.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    24221 2023-05-26 06:07:47.000000 gpaw-23.6.0/gpaw/test/response/test_site_kernels.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     6156 2023-04-19 09:55:20.000000 gpaw-23.6.0/gpaw/test/response/test_test_chi0_intraband.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1175 2023-05-26 06:08:18.000000 gpaw-23.6.0/gpaw/test/response/test_test_unit_sphere_area.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     3512 2023-05-26 06:08:18.000000 gpaw-23.6.0/gpaw/test/response/test_tetra_point_smoothing.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     3743 2023-05-26 06:07:47.000000 gpaw-23.6.0/gpaw/test/response/test_two-aluminum_chi_RPA.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      453 2023-04-19 09:55:20.000000 gpaw-23.6.0/gpaw/test/response/test_two_phi_integrals.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      339 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/response/test_wgg_factorization.py
+drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2023-06-09 07:55:42.055445 gpaw-23.6.0/gpaw/test/rpa/
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)        0 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/test/rpa/__init__.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      736 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/rpa/rpa_C6_He.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1683 2023-03-31 18:59:03.000000 gpaw-23.6.0/gpaw/test/rpa/test_rpa_energy_N2.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1057 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/rpa/test_rpa_energy_Na.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      957 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/rpa/test_rpa_energy_Ni.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      649 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/rpa/test_rpa_energy_Si.py
+drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2023-06-09 07:55:42.059445 gpaw-23.6.0/gpaw/test/rsf_yukawa/
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)        0 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/test/rsf_yukawa/__init__.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     2006 2023-04-19 09:55:20.000000 gpaw-23.6.0/gpaw/test/rsf_yukawa/test_lrtddft_short.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1593 2023-04-19 09:55:20.000000 gpaw-23.6.0/gpaw/test/rsf_yukawa/test_rsf_general.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1811 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/rsf_yukawa/test_rsf_ivo_sing_mg.py
+drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2023-06-09 07:55:42.059445 gpaw-23.6.0/gpaw/test/setups/
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)        0 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/test/setups/__init__.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    12594 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/setups/test_derivative_integrals.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1020 2022-05-04 08:34:37.000000 gpaw-23.6.0/gpaw/test/setups/test_generator2.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1580 2023-04-19 09:55:20.000000 gpaw-23.6.0/gpaw/test/setups/test_setup_basis_spec.py
+drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2023-06-09 07:55:42.059445 gpaw-23.6.0/gpaw/test/sic/
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)        0 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/test/sic/__init__.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1062 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/sic/test_nscfsic.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      858 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/sic/test_scfsic_h2.py
+drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2023-06-09 07:55:42.063445 gpaw-23.6.0/gpaw/test/solvation/
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)        0 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/test/solvation/__init__.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     2144 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/test/solvation/test_adm12.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     9957 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/test/solvation/test_forces.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1823 2022-05-04 08:34:37.000000 gpaw-23.6.0/gpaw/test/solvation/test_forces_symmetry.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1251 2021-08-20 08:32:04.000000 gpaw-23.6.0/gpaw/test/solvation/test_lrtddft.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      631 2022-05-04 08:34:37.000000 gpaw-23.6.0/gpaw/test/solvation/test_nan_radius.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      889 2022-05-04 08:34:37.000000 gpaw-23.6.0/gpaw/test/solvation/test_overlap.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1266 2022-05-04 08:34:37.000000 gpaw-23.6.0/gpaw/test/solvation/test_pbc.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     2740 2022-05-04 08:34:37.000000 gpaw-23.6.0/gpaw/test/solvation/test_pbc_pos_repeat.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     4900 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/solvation/test_poisson.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1723 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/test/solvation/test_sfgcm06.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1753 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/solvation/test_sjm.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     5836 2022-05-04 08:34:37.000000 gpaw-23.6.0/gpaw/test/solvation/test_solvation_api.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     2004 2022-05-04 08:34:37.000000 gpaw-23.6.0/gpaw/test/solvation/test_spinpol.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1801 2022-05-04 08:34:37.000000 gpaw-23.6.0/gpaw/test/solvation/test_sss09.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     2359 2022-05-04 08:34:37.000000 gpaw-23.6.0/gpaw/test/solvation/test_swap_atoms.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1963 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/test/solvation/test_vacuum.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     2074 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/solvation/test_water_water.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1913 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/solvation/test_water_water_etdm_lcao.py
+drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2023-06-09 07:55:42.067445 gpaw-23.6.0/gpaw/test/spin/
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)        0 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/test/spin/__init__.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      800 2022-05-04 08:34:37.000000 gpaw-23.6.0/gpaw/test/spin/test_spinFe3plus.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1527 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/spin/test_spin_contamination.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      721 2023-04-19 09:55:20.000000 gpaw-23.6.0/gpaw/test/spin/test_spinpol.py
+drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2023-06-09 07:55:42.071445 gpaw-23.6.0/gpaw/test/symmetry/
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)        0 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/test/symmetry/__init__.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      844 2022-05-04 08:34:37.000000 gpaw-23.6.0/gpaw/test/symmetry/test_check.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1365 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/symmetry/test_fractional_translations.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1322 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/symmetry/test_fractional_translations_big.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1319 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/symmetry/test_fractional_translations_med.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     2033 2022-05-04 08:34:37.000000 gpaw-23.6.0/gpaw/test/symmetry/test_kpoint_mapping.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      775 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/symmetry/test_symmetrize_wGG.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     2981 2022-05-04 08:34:37.000000 gpaw-23.6.0/gpaw/test/symmetry/test_symmetry.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      946 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/symmetry/test_symmetry2.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     3597 2022-05-04 08:34:37.000000 gpaw-23.6.0/gpaw/test/symmetry/test_symmetry_ft.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      658 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/test/symmetry/test_usesymm.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1154 2022-05-04 08:34:37.000000 gpaw-23.6.0/gpaw/test/symmetry/test_usesymm2.py
+drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2023-06-09 07:55:42.071445 gpaw-23.6.0/gpaw/test/tddft/
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)        0 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/test/tddft/__init__.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1079 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/tddft/test_be_nltd_ip.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1041 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/tddft/test_ehrenfest_nacl.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     2036 2022-05-04 08:34:37.000000 gpaw-23.6.0/gpaw/test/tddft/test_fxc_linearize.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     6204 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/tddft/test_molecule.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     2510 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/tddft/test_td_na2.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     8220 2023-04-19 09:55:20.000000 gpaw-23.6.0/gpaw/test/test_AA_enthalpy.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      632 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/test/test_Gauss.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      287 2023-06-05 15:36:49.000000 gpaw-23.6.0/gpaw/test/test_ae.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1146 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/test/test_aeatom.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1215 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/test_aedensity.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      235 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/test_atomic_el_pot.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1502 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/test_atoms_mismatch.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      386 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/test_atoms_too_close.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      744 2022-05-04 08:34:37.000000 gpaw-23.6.0/gpaw/test/test_broadcast_imports.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      510 2022-05-04 08:34:37.000000 gpaw-23.6.0/gpaw/test/test_broydenmixer.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     2073 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/test_cluster.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      471 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/test/test_complete.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1181 2023-04-19 09:55:20.000000 gpaw-23.6.0/gpaw/test/test_complex.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      819 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/test_coreeig.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     2189 2022-05-04 08:34:37.000000 gpaw-23.6.0/gpaw/test/test_coulomb.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     2509 2022-05-04 08:34:37.000000 gpaw-23.6.0/gpaw/test/test_diagonalizer_backend.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     3058 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/test_dipole.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1252 2023-04-19 09:55:20.000000 gpaw-23.6.0/gpaw/test/test_dipole_me.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      661 2023-04-19 09:55:20.000000 gpaw-23.6.0/gpaw/test/test_dipole_new.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1930 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/test_ds_beta.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      987 2023-04-19 09:55:20.000000 gpaw-23.6.0/gpaw/test/test_fermilevel.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1407 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/test/test_fermisplit.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1474 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/test_fixdensity.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1906 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/test_fixdensity_mgga.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      801 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/test_fixmom.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1561 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/test/test_fixocc.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      474 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/test/test_force_as_stop.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      306 2023-04-19 09:55:20.000000 gpaw-23.6.0/gpaw/test/test_fuzz.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     2818 2021-08-20 08:32:04.000000 gpaw-23.6.0/gpaw/test/test_gauss_func.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     6425 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/test/test_gauss_wave.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      844 2022-05-04 08:34:37.000000 gpaw-23.6.0/gpaw/test/test_ibzqpt.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     3239 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/test_inducedfield_lrtddft.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     4184 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/test_inducedfield_td.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      725 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/test/test_initial_occs.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1865 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/test_jellium.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1003 2022-05-04 08:34:37.000000 gpaw-23.6.0/gpaw/test/test_kpt.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      999 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/test_kpt_refine.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1059 2021-08-20 08:32:04.000000 gpaw-23.6.0/gpaw/test/test_libelpa.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1763 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/test/test_mpicomm.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1011 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/test_muffintinpot.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      848 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/test_multipoleH2O.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1465 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/test/test_multipoletest.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      582 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/test/test_negative_eigerror.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1863 2023-04-19 09:55:20.000000 gpaw-23.6.0/gpaw/test/test_new_calculator.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1679 2022-05-04 08:34:37.000000 gpaw-23.6.0/gpaw/test/test_occupations.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     2606 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/test_overlap.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1410 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/test_potential.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1343 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/test_rattle.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     2737 2023-04-19 09:55:20.000000 gpaw-23.6.0/gpaw/test/test_reuse_wfs.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     2040 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/test_reuse_wfs_celldisp.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     4365 2023-04-19 09:55:20.000000 gpaw-23.6.0/gpaw/test/test_scf_criteria.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      946 2022-05-04 08:34:37.000000 gpaw-23.6.0/gpaw/test/test_spectrum.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1692 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/test_spherical_harmonics.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      673 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/test/test_spinorbit_Kr.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      832 2022-05-04 08:34:37.000000 gpaw-23.6.0/gpaw/test/test_stdout.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1827 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/test_timelimit.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      663 2022-05-04 08:34:37.000000 gpaw-23.6.0/gpaw/test/test_timing.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      665 2023-04-19 09:55:20.000000 gpaw-23.6.0/gpaw/test/test_too_close.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      858 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/test_vdwradii.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     2907 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/test_watermodel.py
+drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2023-06-09 07:55:42.075445 gpaw-23.6.0/gpaw/test/utilities/
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)       80 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/test/utilities/__init__.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      557 2022-05-04 08:34:37.000000 gpaw-23.6.0/gpaw/test/utilities/test_eed.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1899 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/utilities/test_elf.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     5903 2021-08-20 08:32:04.000000 gpaw-23.6.0/gpaw/test/utilities/test_ewald.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      375 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/utilities/test_ibz2bz.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     3654 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/utilities/test_ldos.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     2849 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/utilities/test_partitioning.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     2777 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/utilities/test_simple_stm.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     2126 2021-08-20 08:32:04.000000 gpaw-23.6.0/gpaw/test/utilities/test_wannier_ethylene.py
+drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2023-06-09 07:55:42.079445 gpaw-23.6.0/gpaw/test/vdw/
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)        0 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/test/vdw/__init__.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      863 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/vdw/test_H_Hirshfeld.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1300 2022-05-04 08:34:37.000000 gpaw-23.6.0/gpaw/test/vdw/test_ar2.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     3482 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/test/vdw/test_libvdwxc_functionals.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1815 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/vdw/test_libvdwxc_h2.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1075 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/vdw/test_libvdwxc_mbeef.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     2026 2021-08-20 08:32:04.000000 gpaw-23.6.0/gpaw/test/vdw/test_libvdwxc_spin.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1475 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/test/vdw/test_potential.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      402 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/test/vdw/test_quick.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      732 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/vdw/test_quick_spin.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     2362 2023-04-19 09:55:20.000000 gpaw-23.6.0/gpaw/test/vdw/test_ts09.py
+drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2023-06-09 07:55:42.087446 gpaw-23.6.0/gpaw/test/xc/
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)       71 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/test/xc/__init__.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     2416 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/test/xc/test_XC2.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     3060 2023-04-19 09:55:20.000000 gpaw-23.6.0/gpaw/test/xc/test_atomize.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     2227 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/xc/test_beef.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1272 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/xc/test_degeneracy.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     2170 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/xc/test_gga_atom.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     3768 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/xc/test_lb94.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     3129 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/test/xc/test_lxc_xcatom.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1162 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/xc/test_nonselfconsistent.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1193 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/xc/test_nonselfconsistentLDA.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1303 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/test/xc/test_pbe_pw91.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1473 2022-05-04 08:34:37.000000 gpaw-23.6.0/gpaw/test/xc/test_pplda.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1372 2022-05-04 08:34:37.000000 gpaw-23.6.0/gpaw/test/xc/test_pygga.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1023 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/xc/test_qna_band.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      971 2023-06-05 15:36:49.000000 gpaw-23.6.0/gpaw/test/xc/test_qna_force.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      971 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/xc/test_qna_spinpol.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     2303 2023-06-05 15:36:49.000000 gpaw-23.6.0/gpaw/test/xc/test_qna_stress.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      883 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/xc/test_revPBE.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1120 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/xc/test_revPBE_Li.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      867 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/test/xc/test_tb09.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     2686 2023-04-19 09:55:20.000000 gpaw-23.6.0/gpaw/test/xc/test_tpss.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     4064 2022-05-04 08:34:37.000000 gpaw-23.6.0/gpaw/test/xc/test_xc.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1433 2022-05-04 08:34:37.000000 gpaw-23.6.0/gpaw/test/xc/test_xcatom.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    11352 2022-05-04 08:34:37.000000 gpaw-23.6.0/gpaw/tetrahedron.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     4741 2023-05-26 06:07:47.000000 gpaw-23.6.0/gpaw/transformers.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      497 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/typing.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    15727 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/unfold.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    23370 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/upf.py
+drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2023-06-09 07:55:42.099446 gpaw-23.6.0/gpaw/utilities/
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    11235 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/utilities/__init__.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1203 2023-04-19 09:55:20.000000 gpaw-23.6.0/gpaw/utilities/bader.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     8382 2023-05-26 06:07:47.000000 gpaw-23.6.0/gpaw/utilities/blas.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1264 2022-05-04 08:34:37.000000 gpaw-23.6.0/gpaw/utilities/cg.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      575 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/utilities/debug.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     3208 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/utilities/dipole.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    22457 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/utilities/dos.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     2286 2022-05-04 08:34:37.000000 gpaw-23.6.0/gpaw/utilities/ekin.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     3413 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/utilities/elpa.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     4953 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/utilities/ewald.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1907 2022-05-04 08:34:37.000000 gpaw-23.6.0/gpaw/utilities/extend_grid.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     2338 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/utilities/extrapolate.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     6390 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/utilities/folder.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     8181 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/utilities/gauss.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    11292 2022-05-04 08:34:37.000000 gpaw-23.6.0/gpaw/utilities/gl_quadrature.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     2882 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/utilities/gpts.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     7068 2022-05-04 08:34:37.000000 gpaw-23.6.0/gpaw/utilities/grid.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    26834 2021-07-05 14:53:36.000000 gpaw-23.6.0/gpaw/utilities/grid_redistribute.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     5612 2022-05-04 08:34:37.000000 gpaw-23.6.0/gpaw/utilities/hardware.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     3344 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/utilities/hilbert.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     3773 2021-08-20 08:32:04.000000 gpaw-23.6.0/gpaw/utilities/ibz2bz.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      367 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/utilities/jth.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     8206 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/utilities/kspot.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     5777 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/utilities/memory.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     2479 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/utilities/nbrun.py
+-rwxrwxr-x   0 jensj     (1000) jensj     (1000)     7489 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/utilities/newrelease.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    11728 2022-05-04 08:34:37.000000 gpaw-23.6.0/gpaw/utilities/partition.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     3155 2022-05-04 08:34:37.000000 gpaw-23.6.0/gpaw/utilities/progressbar.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     8653 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/utilities/ps2ae.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      593 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/utilities/pw.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    20394 2022-05-04 08:34:37.000000 gpaw-23.6.0/gpaw/utilities/scalapack.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     3190 2021-08-20 08:32:04.000000 gpaw-23.6.0/gpaw/utilities/sic.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     6026 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/utilities/timelimit.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     5356 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/utilities/timing.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    14212 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/utilities/tools.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     2029 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/utilities/urlcheck.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     4155 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/utilities/watermodel.py
+drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2023-06-09 07:55:42.103446 gpaw-23.6.0/gpaw/wannier/
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)       74 2021-08-20 08:32:04.000000 gpaw-23.6.0/gpaw/wannier/__init__.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1974 2022-05-04 08:34:37.000000 gpaw-23.6.0/gpaw/wannier/edmiston_ruedenberg.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      915 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/wannier/functions.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    11579 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/wannier/overlaps.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     6799 2022-05-04 08:34:37.000000 gpaw-23.6.0/gpaw/wannier/w90.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    14076 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/wannier90.py
+drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2023-06-09 07:55:42.107446 gpaw-23.6.0/gpaw/wavefunctions/
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)        0 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/wavefunctions/__init__.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    14221 2023-05-26 06:07:47.000000 gpaw-23.6.0/gpaw/wavefunctions/arrays.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    24917 2023-05-26 12:00:48.000000 gpaw-23.6.0/gpaw/wavefunctions/base.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    13588 2023-05-26 12:00:48.000000 gpaw-23.6.0/gpaw/wavefunctions/fd.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    20254 2023-05-26 12:00:48.000000 gpaw-23.6.0/gpaw/wavefunctions/fdpw.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    44338 2023-05-26 06:08:18.000000 gpaw-23.6.0/gpaw/wavefunctions/lcao.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      604 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/wavefunctions/mode.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    32781 2023-05-26 12:00:48.000000 gpaw-23.6.0/gpaw/wavefunctions/pw.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     2945 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/wfd_operators.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    23833 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/xas.py
+drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2023-06-09 07:55:42.115446 gpaw-23.6.0/gpaw/xc/
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     5769 2023-04-19 09:55:20.000000 gpaw-23.6.0/gpaw/xc/__init__.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     8637 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/xc/bee.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     3386 2023-03-20 20:28:10.000000 gpaw-23.6.0/gpaw/xc/functional.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    36897 2023-05-26 06:08:18.000000 gpaw-23.6.0/gpaw/xc/fxc.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     6825 2023-05-26 06:08:18.000000 gpaw-23.6.0/gpaw/xc/fxc_kernels.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    17110 2023-03-20 20:28:10.000000 gpaw-23.6.0/gpaw/xc/gga.py
+drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2023-06-09 07:55:42.119446 gpaw-23.6.0/gpaw/xc/gllb/
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)       90 2021-07-05 14:53:36.000000 gpaw-23.6.0/gpaw/xc/gllb/__init__.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     6445 2021-07-05 14:53:36.000000 gpaw-23.6.0/gpaw/xc/gllb/c_gllbscr.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    27525 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/xc/gllb/c_response.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1936 2021-07-05 14:53:36.000000 gpaw-23.6.0/gpaw/xc/gllb/c_xc.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     4171 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/xc/gllb/coefficients.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1038 2021-07-05 14:53:36.000000 gpaw-23.6.0/gpaw/xc/gllb/contribution.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     5799 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/xc/gllb/nonlocalfunctional.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     3700 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/xc/gllb/nonlocalfunctionalfactory.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    26624 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/xc/hybrid.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     2951 2023-03-20 20:28:10.000000 gpaw-23.6.0/gpaw/xc/kernel.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      995 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/xc/lb94.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     7376 2023-03-20 20:28:10.000000 gpaw-23.6.0/gpaw/xc/lda.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    30032 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/xc/libvdwxc.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     2868 2021-12-21 11:47:26.000000 gpaw-23.6.0/gpaw/xc/libxc.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    17190 2023-05-26 06:07:47.000000 gpaw-23.6.0/gpaw/xc/mgga.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     2571 2023-04-19 09:55:20.000000 gpaw-23.6.0/gpaw/xc/noncollinear.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1420 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/xc/parametrizedxc.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     4590 2022-05-04 08:34:37.000000 gpaw-23.6.0/gpaw/xc/pawcorrection.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     8492 2023-06-05 15:36:49.000000 gpaw-23.6.0/gpaw/xc/qna.py
+drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2023-06-09 07:55:42.119446 gpaw-23.6.0/gpaw/xc/ri/
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     3025 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/xc/ri/__init__.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     1551 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/xc/ri/ribasis.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     3962 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/xc/ri/spherical_hse_kernel.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    18172 2023-05-26 06:07:47.000000 gpaw-23.6.0/gpaw/xc/rpa.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    44695 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/xc/sic.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     4784 2021-06-14 18:26:24.000000 gpaw-23.6.0/gpaw/xc/tb09.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     2348 2023-04-19 09:55:20.000000 gpaw-23.6.0/gpaw/xc/tools.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    29766 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/xc/vdw.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     2704 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/yml.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     7457 2023-02-15 19:14:44.000000 gpaw-23.6.0/gpaw/zero_field_splitting.py
+drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2023-06-09 07:55:41.791442 gpaw-23.6.0/gpaw.egg-info/
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     3867 2023-06-09 07:55:41.000000 gpaw-23.6.0/gpaw.egg-info/PKG-INFO
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    31208 2023-06-09 07:55:41.000000 gpaw-23.6.0/gpaw.egg-info/SOURCES.txt
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)        1 2023-06-09 07:55:41.000000 gpaw-23.6.0/gpaw.egg-info/dependency_links.txt
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)       44 2023-06-09 07:55:41.000000 gpaw-23.6.0/gpaw.egg-info/entry_points.txt
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      112 2023-06-09 07:55:41.000000 gpaw-23.6.0/gpaw.egg-info/requires.txt
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)       11 2023-06-09 07:55:41.000000 gpaw-23.6.0/gpaw.egg-info/top_level.txt
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)      105 2023-06-09 07:55:42.123446 gpaw-23.6.0/setup.cfg
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)    13580 2023-06-05 15:36:49.000000 gpaw-23.6.0/setup.py
+-rw-rw-r--   0 jensj     (1000) jensj     (1000)     2317 2023-06-05 15:36:49.000000 gpaw-23.6.0/siteconfig_example.py
+drwxrwxr-x   0 jensj     (1000) jensj     (1000)        0 2023-06-09 07:55:42.119446 gpaw-23.6.0/tools/
+-rwxrwxr-x   0 jensj     (1000) jensj     (1000)       73 2021-03-25 20:50:34.000000 gpaw-23.6.0/tools/gpaw-analyse-basis
+-rwxrwxr-x   0 jensj     (1000) jensj     (1000)       70 2021-03-25 20:50:34.000000 gpaw-23.6.0/tools/gpaw-basis
+-rwxrwxr-x   0 jensj     (1000) jensj     (1000)     7512 2021-03-25 20:50:34.000000 gpaw-23.6.0/tools/gpaw-plot-parallel-timings
+-rwxrwxr-x   0 jensj     (1000) jensj     (1000)     4964 2021-03-25 20:50:34.000000 gpaw-23.6.0/tools/gpaw-runscript
+-rwxrwxr-x   0 jensj     (1000) jensj     (1000)       70 2021-03-25 20:50:34.000000 gpaw-23.6.0/tools/gpaw-setup
+-rwxrwxr-x   0 jensj     (1000) jensj     (1000)       68 2021-03-25 20:50:34.000000 gpaw-23.6.0/tools/gpaw-upfplot
```

### Comparing `gpaw-22.8.0/LICENSE` & `gpaw-23.6.0/LICENSE`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/PKG-INFO` & `gpaw-23.6.0/PKG-INFO`

 * *Files 20% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: gpaw
-Version: 22.8.0
+Version: 23.6.0
 Summary: GPAW: DFT and beyond within the projector-augmented wave method
 Home-page: https://wiki.fysik.dtu.dk/gpaw
 Maintainer: GPAW-community
 Maintainer-email: gpaw-users@listserv.fysik.dtu.dk
 License: GPLv3+
 Platform: unix
 Classifier: Development Status :: 6 - Mature
@@ -12,16 +12,16 @@
 Classifier: Operating System :: OS Independent
 Classifier: Programming Language :: Python :: 3
 Classifier: Programming Language :: Python :: 3.7
 Classifier: Programming Language :: Python :: 3.8
 Classifier: Programming Language :: Python :: 3.9
 Classifier: Programming Language :: Python :: 3.10
 Classifier: Topic :: Scientific/Engineering :: Physics
-Provides-Extra: devel
 Provides-Extra: docs
+Provides-Extra: devel
 License-File: LICENSE
 
 .. image:: https://badge.fury.io/py/gpaw.svg
     :target: https://pypi.org/project/gpaw/
 
 Coverage_
 
@@ -36,24 +36,28 @@
 Webpage: http://wiki.fysik.dtu.dk/gpaw
 
 
 Requirements
 ------------
 
 * Python_ 3.7 or later
-* ASE_ (atomic simulation environment)
-* NumPy_ (base N-dimensional array package)
-* SciPy_ (library for scientific computing)
-* LibXC
-* BLAS
-
-Optional (highly recommended):
+* ASE_
+* NumPy_
+* SciPy_
+* LibXC_
+* A C compiler
+* A BLAS_ library
+
+Optional (highly recommended for increased performance):
+
+* A MPI_ library (required for parallel calculations)
+* BLACS_ and ScaLAPACK_ libraries
+* FFTW_
 
-* MPI
-* ScaLAPACK
+See `Release notes <releasenotes_>`_ for version requirements.
 
 
 Installation
 ------------
 
 Do this::
 
@@ -118,15 +122,20 @@
 look at the GPAW exercises_ and tutorials_.
 
 
 .. _Python: http://www.python.org/
 .. _ASE: http://wiki.fysik.dtu.dk/ase
 .. _NumPy: http://docs.scipy.org/doc/numpy/reference/
 .. _SciPy: http://docs.scipy.org/doc/scipy/reference/
+.. _LibXC: http://www.tddft.org/programs/libxc/
+.. _MPI: http://www.mpi-forum.org/
+.. _BLAS: http://www.netlib.org/blas/
+.. _FFTW: http://www.fftw.org/
+.. _BLACS: http://www.netlib.org/blacs/
+.. _ScaLAPACK: http://www.netlib.org/scalapack/
 .. _gpaw-users: https://listserv.fysik.dtu.dk/mailman/listinfo/gpaw-users
 .. _Matrix: https://matrix.io/#/#gpaw:matrix.org
 .. _gitlab-issues: https://gitlab.com/gpaw/gpaw/issues
 .. _exercises: https://wiki.fysik.dtu.dk/gpaw/exercises/exercises.html
 .. _tutorials: https://wiki.fysik.dtu.dk/gpaw/tutorials/tutorials.html
 .. _Coverage: https://wiki.fysik.dtu.dk/gpaw/htmlcov/index.html
-
-
+.. _releasenotes: https://wiki.fysik.dtu.dk/gpaw/releasenotes.html
```

### Comparing `gpaw-22.8.0/README.rst` & `gpaw-23.6.0/README.rst`

 * *Files 17% similar despite different names*

```diff
@@ -14,24 +14,28 @@
 Webpage: http://wiki.fysik.dtu.dk/gpaw
 
 
 Requirements
 ------------
 
 * Python_ 3.7 or later
-* ASE_ (atomic simulation environment)
-* NumPy_ (base N-dimensional array package)
-* SciPy_ (library for scientific computing)
-* LibXC
-* BLAS
+* ASE_
+* NumPy_
+* SciPy_
+* LibXC_
+* A C compiler
+* A BLAS_ library
+
+Optional (highly recommended for increased performance):
+
+* A MPI_ library (required for parallel calculations)
+* BLACS_ and ScaLAPACK_ libraries
+* FFTW_
 
-Optional (highly recommended):
-
-* MPI
-* ScaLAPACK
+See `Release notes <releasenotes_>`_ for version requirements.
 
 
 Installation
 ------------
 
 Do this::
 
@@ -96,13 +100,20 @@
 look at the GPAW exercises_ and tutorials_.
 
 
 .. _Python: http://www.python.org/
 .. _ASE: http://wiki.fysik.dtu.dk/ase
 .. _NumPy: http://docs.scipy.org/doc/numpy/reference/
 .. _SciPy: http://docs.scipy.org/doc/scipy/reference/
+.. _LibXC: http://www.tddft.org/programs/libxc/
+.. _MPI: http://www.mpi-forum.org/
+.. _BLAS: http://www.netlib.org/blas/
+.. _FFTW: http://www.fftw.org/
+.. _BLACS: http://www.netlib.org/blacs/
+.. _ScaLAPACK: http://www.netlib.org/scalapack/
 .. _gpaw-users: https://listserv.fysik.dtu.dk/mailman/listinfo/gpaw-users
 .. _Matrix: https://matrix.io/#/#gpaw:matrix.org
 .. _gitlab-issues: https://gitlab.com/gpaw/gpaw/issues
 .. _exercises: https://wiki.fysik.dtu.dk/gpaw/exercises/exercises.html
 .. _tutorials: https://wiki.fysik.dtu.dk/gpaw/tutorials/tutorials.html
 .. _Coverage: https://wiki.fysik.dtu.dk/gpaw/htmlcov/index.html
+.. _releasenotes: https://wiki.fysik.dtu.dk/gpaw/releasenotes.html
```

### Comparing `gpaw-22.8.0/c/bc.c` & `gpaw-23.6.0/c/bc.c`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/c/bc.h` & `gpaw-23.6.0/c/bc.h`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/c/blacs.c` & `gpaw-23.6.0/c/blacs.c`

 * *Files 2% similar despite different names*

```diff
@@ -757,23 +757,19 @@
   char* uplo;
 
   if (!PyArg_ParseTuple(args, "OOsOO", &a, &desca, &uplo, &z, &w))
     return NULL;
 
   // adesc
   // int a_ConTxt = INTP(desca)[1];
-  int a_m      = INTP(desca)[2];
-  int a_n      = INTP(desca)[3];
+  int n = INTP(desca)[2];
+  assert(n == INTP(desca)[3]); // Only square matrices
 
   // zdesc = adesc; this can be relaxed a bit according to pdsyevd.f
 
-  // Only square matrices
-  assert (a_m == a_n);
-  int n = a_n;
-
   // If process not on BLACS grid, then return.
   // if (a_ConTxt == -1) Py_RETURN_NONE;
 
   // Query part, need to find the optimal size of a number of work arrays
   int info;
   int querywork = -1;
   int* iwork;
@@ -872,20 +868,16 @@
 
   if (!PyArg_ParseTuple(args, "OOsiOO", &a, &desca, &uplo, &iu,
                         &z, &w))
     return NULL;
 
   // a desc
   int a_ConTxt = INTP(desca)[1];
-  int a_m      = INTP(desca)[2];
-  int a_n      = INTP(desca)[3];
-
-  // Only square matrices
-  assert (a_m == a_n);
-  int n = a_n;
+  int n = INTP(desca)[2];
+  assert(n == INTP(desca)[3]); // Only square matrices
 
   // zdesc = adesc = bdesc; required by pdsyevx.f
 
   // If process not on BLACS grid, then return.
   // if (a_ConTxt == -1) Py_RETURN_NONE;
 
   Cblacs_gridinfo_(a_ConTxt, &a_nprow, &a_npcol, &a_myrow, &a_mycol);
@@ -1015,20 +1007,16 @@
 
   if (!PyArg_ParseTuple(args, "OOsiOO", &a, &desca, &uplo, &iu,
                         &z, &w))
     return NULL;
 
   // a desc
   // int a_ConTxt = INTP(desca)[1];
-  int a_m      = INTP(desca)[2];
-  int a_n      = INTP(desca)[3];
-
-  // Only square matrices
-  assert (a_m == a_n);
-  int n = a_n;
+  int n = INTP(desca)[2];
+  assert(n == INTP(desca)[3]); // Only square matrices
 
   // zdesc = adesc = bdesc; required by pdsyevx.f
 
   // If process not on BLACS grid, then return.
   // if (a_ConTxt == -1) Py_RETURN_NONE;
 
   // Query part, need to find the optimal size of a number of work arrays
@@ -1134,20 +1122,16 @@
 
   if (!PyArg_ParseTuple(args, "OOsOOO", &a, &desca, &uplo,
                         &b, &z, &w))
     return NULL;
 
   // a desc
   // int a_ConTxt = INTP(desca)[1];
-  int a_m      = INTP(desca)[2];
-  int a_n      = INTP(desca)[3];
-
-  // Only square matrices
-  assert (a_m == a_n);
-  int n = a_n;
+  int n = INTP(desca)[2];
+  assert(n == INTP(desca)[3]); // Only square matrices
 
   // zdesc = adesc = bdesc can be relaxed a bit according to pdsyevd.f
 
   // If process not on BLACS grid, then return.
   // if (a_ConTxt == -1) Py_RETURN_NONE;
 
   // Cholesky Decomposition
@@ -1333,20 +1317,16 @@
 
   if (!PyArg_ParseTuple(args, "OOsiOOO", &a, &desca, &uplo, &iu,
                         &b, &z, &w))
     return NULL;
 
   // a desc
   int a_ConTxt = INTP(desca)[1];
-  int a_m      = INTP(desca)[2];
-  int a_n      = INTP(desca)[3];
-
-  // Only square matrices
-  assert (a_m == a_n);
-  int n = a_n;
+  int n = INTP(desca)[2];
+  assert(n == INTP(desca)[3]); // Only square matrices
 
   // zdesc = adesc = bdesc; required by pdsygvx.f
 
   // If process not on BLACS grid, then return.
   // if (a_ConTxt == -1) Py_RETURN_NONE;
 
   Cblacs_gridinfo_(a_ConTxt, &a_nprow, &a_npcol, &a_myrow, &a_mycol);
@@ -1481,20 +1461,16 @@
 
   if (!PyArg_ParseTuple(args, "OOsiOOO", &a, &desca, &uplo, &iu,
                         &b, &z, &w))
     return NULL;
 
   // a desc
   // int a_ConTxt = INTP(desca)[1];
-  int a_m      = INTP(desca)[2];
-  int a_n      = INTP(desca)[3];
-
-  // Only square matrices
-  assert (a_m == a_n);
-  int n = a_n;
+  int n = INTP(desca)[2];
+  assert(n == INTP(desca)[3]); // Only square matrices
 
   // zdesc = adesc = bdesc can be relaxed a bit according to pdsyevd.f
 
   // If process not on BLACS grid, then return.
   // if (a_ConTxt == -1) Py_RETURN_NONE;
 
   // Cholesky Decomposition
@@ -1681,21 +1657,17 @@
   char* uplo;
 
   if (!PyArg_ParseTuple(args, "OOs", &a, &desca, &uplo))
     return NULL;
 
   // adesc
   // int a_ConTxt = INTP(desca)[1];
-  int a_m      = INTP(desca)[2];
-  int a_n      = INTP(desca)[3];
-
-  // Only square matrices
-  assert (a_m == a_n);
-  int n = a_n;
-  int p = a_n - 1;
+  int n = INTP(desca)[2];
+  assert(n == INTP(desca)[3]); // Only square matrices
+  int p = n - 1;
 
   // If process not on BLACS grid, then return.
   // if (a_ConTxt == -1) Py_RETURN_NONE;
 
   if (PyArray_DESCR(a)->type_num == NPY_DOUBLE)
     {
       pdpotrf_(uplo, &n, DOUBLEP(a), &one, &one,
@@ -1740,20 +1712,16 @@
   PyArrayObject* desca; // Matrix description vector
   char* uplo;
   int info;
   int one = 1;
   if (!PyArg_ParseTuple(args, "OOs", &a, &desca, &uplo))
     return NULL;
 
-  int a_m      = INTP(desca)[2];
-  int a_n      = INTP(desca)[3];
-  // Only square matrices
-  assert (a_m == a_n);
-
-  int n = a_n;
+  int n = INTP(desca)[2];
+  assert(n == INTP(desca)[3]); // Only square matrices
 
   if (PyArray_DESCR(a)->type_num == NPY_DOUBLE)
      {
       assert(1==-1);       // No double version implemented
      }
   else
     {
@@ -1819,33 +1787,26 @@
   PyArrayObject* descb; // Matrix description vector
   int info;
   int one = 1;
   if (!PyArg_ParseTuple(args, "OOOO", &a, &desca, &b, &descb))
     return NULL;
 
   int a_ConTxt = INTP(desca)[1];
-  int a_m      = INTP(desca)[2];
-  int a_n      = INTP(desca)[3];
+  int n = INTP(desca)[2];
+  assert(n == INTP(desca)[3]); // Only square matrices
   int a_mb     = INTP(desca)[4];
-  // Only square matrices
-  assert (a_m == a_n);
 
-  int b_m      = INTP(descb)[2];
-  int b_n      = INTP(descb)[3];
-  // Equation valid
-  assert (a_n == b_m);
-
-  int n = a_n;
-  int nrhs = b_n;
+  assert(n == INTP(descb)[2]);  // Equation valid
+  int nrhs = INTP(descb)[3];
 
   int nprow, npcol, myrow, mycol, locM;
 
   Cblacs_gridinfo_(a_ConTxt, &nprow, &npcol, &myrow, &mycol);
   // LOCr( M ) <= ceil( ceil(M/MB_A)/NPROW )*MB_A
-  locM = (((a_m/a_mb) + 1)/nprow + 1) * a_mb;
+  locM = (((n/a_mb) + 1)/nprow + 1) * a_mb;
 
   /*
    *  IPIV    (local output) INTEGER array, dimension ( LOCr(M_A)+MB_A )
    *          This array contains the pivoting information.
    *          IPIV(i) -> The global row local row i was swapped with.
    *          This array is tied to the distributed matrix A.
```

### Comparing `gpaw-22.8.0/c/blas.c` & `gpaw-23.6.0/c/blas.c`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/c/bmgs/bmgs.c` & `gpaw-23.6.0/c/bmgs/bmgs.c`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/c/bmgs/bmgs.h` & `gpaw-23.6.0/c/bmgs/bmgs.h`

 * *Files 4% similar despite different names*

```diff
@@ -54,31 +54,14 @@
         const long n[3]);
 void bmgs_deletestencil(bmgsstencil* spline);
 bmgsspline bmgs_spline(int l, double dr, int nbins, double* f);
 double bmgs_splinevalue(const bmgsspline* spline, double r);
 void bmgs_get_value_and_derivative(const bmgsspline* spline, double r,
            double *f, double *dfdr);
 void bmgs_deletespline(bmgsspline* spline);
-void bmgs_radial1(const bmgsspline* spline,
-      const int n[3], const double C[3],
-      const double h[3],
-      int* b, double* d);
-void bmgs_radial2(const bmgsspline* spline, const int n[3],
-      const int* b, const double* d,
-      double* f, double* g);
-void bmgs_radial3(const bmgsspline* spline, int m,
-      const int n[3],
-      const double C[3],
-      const double h[3],
-      const double* f, double* a);
-void bmgs_radiald3(const bmgsspline* spline, int m, int c,
-      const int n[3],
-      const double C[3],
-      const double h[3],
-      const double* f, const double* g, double* a);
 void bmgs_fd(const bmgsstencil* s, const double* a, double* b);
 void bmgs_wfd(int nweights, const bmgsstencil* stencils, const double** weights, const double* a, double* b);
 void bmgs_relax(const int relax_method, const bmgsstencil* s, double* a, double* b,
     const double* src, const double w);
 void bmgs_wrelax(const int relax_method, const int nweights, const bmgsstencil* stencils, const double** weights, double* a, double* b,
     const double* src, const double w);
 void bmgs_cut(const double* a, const int n[3], const int c[3],
```

### Comparing `gpaw-22.8.0/c/bmgs/cut.c` & `gpaw-23.6.0/c/bmgs/cut.c`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/c/bmgs/fd.c` & `gpaw-23.6.0/c/bmgs/fd.c`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/c/bmgs/interpolate.c` & `gpaw-23.6.0/c/bmgs/interpolate.c`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/c/bmgs/paste.c` & `gpaw-23.6.0/c/bmgs/paste.c`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/c/bmgs/relax.c` & `gpaw-23.6.0/c/bmgs/relax.c`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/c/bmgs/restrict.c` & `gpaw-23.6.0/c/bmgs/restrict.c`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/c/bmgs/spherical_harmonics.h` & `gpaw-23.6.0/c/bmgs/spherical_harmonics.h`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/c/bmgs/stencils.c` & `gpaw-23.6.0/c/bmgs/stencils.c`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/c/bmgs/translate.c` & `gpaw-23.6.0/c/bmgs/translate.c`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/c/bmgs/wfd.c` & `gpaw-23.6.0/c/bmgs/wfd.c`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/c/bmgs/wrelax.c` & `gpaw-23.6.0/c/bmgs/wrelax.c`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/c/constraints.c` & `gpaw-23.6.0/c/constraints.c`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/c/elpa.c` & `gpaw-23.6.0/c/elpa.c`

 * *Files 15% similar despite different names*

```diff
@@ -203,58 +203,14 @@
                                       ev,
                                       (double complex *)q,
                                       is_already_decomposed, &err);
     }
     return checkerr(err);
 }
 
-PyObject *pyelpa_hermitian_multiply(PyObject *self, PyObject *args)
-{
-    PyObject *handle_obj;
-    int ncb;
-
-    char *uplo_a, *uplo_c;
-    int nrows_b, ncols_b, nrows_c, ncols_c;
-
-    PyArrayObject *A_obj, *B_obj, *C_obj;
-
-    if(!PyArg_ParseTuple(args, "OssiOOiiOii",
-                         &handle_obj, &uplo_a, &uplo_c,
-                         &ncb, &A_obj, &B_obj, &nrows_b, &ncols_b,
-                         &C_obj, &nrows_c, &ncols_c)) {
-        return NULL;
-    }
-
-    elpa_t handle = unpack_handle(handle_obj);
-    int err;
-
-    double *A = (double *)PyArray_DATA(A_obj);
-    double *B = (double *)PyArray_DATA(B_obj);
-    double *C = (double *)PyArray_DATA(C_obj);
-
-    // The elpa_hermitian_multiply() has a typo, which means it will
-    // resolve as a compilation error in the precompiler.
-    // We shall have to call the _d function explicitly then.
-    if(PyArray_DESCR(A_obj)->type_num == NPY_DOUBLE) {
-        elpa_hermitian_multiply_d(handle, uplo_a[0], uplo_c[0], ncb,
-                                  A, B, nrows_b, ncols_b,
-                                  C, nrows_c, ncols_c,
-                                  &err);
-    } else {
-        elpa_hermitian_multiply_dc(handle, uplo_a[0], uplo_c[0], ncb,
-                                   (double complex *)A,
-                                   (double complex *)B,
-                                   nrows_b, ncols_b,
-                                   (double complex *)C,
-                                   nrows_c, ncols_c,
-                                   &err);
-    }
-    return checkerr(err);
-}
-
 PyObject *pyelpa_deallocate(PyObject *self, PyObject *args)
 {
     PyObject *handle_obj;
     if(!PyArg_ParseTuple(args, "O", &handle_obj)) {
         return NULL;
     }
```

### Comparing `gpaw-22.8.0/c/extensions.h` & `gpaw-23.6.0/c/extensions.h`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/c/fd_preconditioner.c` & `gpaw-23.6.0/c/fd_preconditioner.c`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/c/fftw.c` & `gpaw-23.6.0/c/fftw.c`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/c/lcao.c` & `gpaw-23.6.0/c/lcao.c`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/c/lfc.c` & `gpaw-23.6.0/c/lfc.c`

 * *Files 0% similar despite different names*

```diff
@@ -490,14 +490,21 @@
   double* nt_G = (double*)PyArray_DATA(nt_G_obj);
 
   int nM = PyArray_DIMS(rho_MM_obj)[1];
 
   double* work_gm = lfc->work_gm;
 
   if (!lfc->bloch_boundary_conditions) {
+
+    if (!(PyArray_DESCR(rho_MM_obj)->kind == 'f' && PyArray_DESCR(rho_MM_obj)->elsize == 8))
+    {
+        PyErr_SetString(PyExc_ValueError ,"Expected float64 dtype for rho_MM array.");
+        return NULL;
+    }
+
     const double* rho_MM = (const double*)PyArray_DATA(rho_MM_obj);
     GRID_LOOP_START(lfc, -1, 0) {
       for (int i1 = 0; i1 < ni; i1++) {
         LFVolume* v1 = volume_i[i1];
         int M1 = v1->M;
         int nm1 = v1->nm;
 
@@ -538,14 +545,21 @@
           nt_G[G] += nt;
         }
       }
     }
     GRID_LOOP_STOP(lfc, -1, 0);
   }
   else {
+
+    if (!(PyArray_DESCR(rho_MM_obj)->kind == 'c' && PyArray_DESCR(rho_MM_obj)->elsize == 16))
+    {
+        PyErr_SetString(PyExc_ValueError, "Expected complex128 dtype for rho_MM array.");
+        return NULL;    
+    }
+
     const double complex* rho_MM = (const double complex*)PyArray_DATA(rho_MM_obj);
     GRID_LOOP_START(lfc, k, 0) {
       for (int i1 = 0; i1 < ni; i1++) {
         LFVolume* v1 = volume_i[i1];
         int M1 = v1->M;
         int nm1 = v1->nm;
```

### Comparing `gpaw-22.8.0/c/lfc.h` & `gpaw-23.6.0/c/lfc.h`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/c/lfc2.c` & `gpaw-23.6.0/c/lfc2.c`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/c/mpi.c` & `gpaw-23.6.0/c/mpi.c`

 * *Files 12% similar despite different names*

```diff
@@ -15,38 +15,25 @@
 #include "extensions.h"
 #include <structmember.h>
 #include "mympi.h"
 #ifdef __bgp__
 #include <mpix.h>
 #endif
 
-// Check that array is well-behaved and contains data that can be sent.
-#define CHK_ARRAY(a) if ((a) == NULL || !PyArray_Check(a)                   \
-                         || !PyArray_ISCARRAY(a) || !PyArray_ISNUMBER(a)) { \
-    PyErr_SetString(PyExc_TypeError,                                        \
-                    "Not a proper NumPy array for MPI communication.");     \
-    return NULL; } else
-
-// Check that array is well-behaved, read-only  and contains data that
-// can be sent.
-#define CHK_ARRAY_RO(a) if ((a) == NULL || !PyArray_Check(a)                \
-                         || !PyArray_ISCARRAY_RO(a)                         \
-                         || !PyArray_ISNUMBER(a)) {                         \
-    PyErr_SetString(PyExc_TypeError,                                        \
-                    "Not a proper NumPy array for MPI communication.");     \
-    return NULL; } else
+// Wrappers to support GPU_AWARE_MPI
+#ifdef GPAW_GPU_AWARE_MPI
+#define GPAW_ARRAY_ALLOW_CUPY
+#endif
+#include "array.h"
 
-// Check that two arrays have the same type, and the size of the
-// second is a given multiple of the size of the first
-#define CHK_ARRAYS(a,b,n)                                               \
-  if ((PyArray_TYPE(a) != PyArray_TYPE(b))                              \
-      || (PyArray_SIZE(b) != PyArray_SIZE(a) * n)) {                    \
-    PyErr_SetString(PyExc_ValueError,                                   \
-                    "Incompatible array types or sizes.");              \
-      return NULL; } else
+#ifdef GPAW_MPI2
+#ifndef GPAW_MPI_INPLACE
+#error "Deprecated: Define or undefine GPAW_MPI_INPLACE, instead of using GPAW_MPI2."
+#endif
+#endif
 
 // Check that a processor number is valid
 #define CHK_PROC(n) if (n < 0 || n >= self->size) {\
     PyErr_SetString(PyExc_ValueError, "Invalid processor number.");     \
     return NULL; } else
 
 // Check that a processor number is valid or is -1
@@ -72,48 +59,40 @@
 {
 
   if (self->status == 0)
     {
       // Calling wait multiple times is allowed but meaningless (as in the MPI standard)
       Py_RETURN_NONE;
     }
-#ifndef GPAW_MPI_DEBUG
-  MPI_Wait(&(self->rq), MPI_STATUS_IGNORE);
-#else
   int ret = MPI_Wait(&(self->rq), MPI_STATUS_IGNORE);
   if (ret != MPI_SUCCESS)
     {
       PyErr_SetString(PyExc_RuntimeError, "MPI_Wait error occurred.");
       return NULL;
     }
-#endif
   Py_DECREF(self->buffer);
   self->status = 0;
 
   Py_RETURN_NONE;
 }
 
 static PyObject *mpi_request_test(GPAW_MPI_Request *self, PyObject *noargs)
 {
 
   if (self->status == 0)
     {
       Py_RETURN_TRUE;  // Already completed
     }
   int flag;
-#ifndef GPAW_MPI_DEBUG
-  MPI_Test(&(self->rq), &flag, MPI_STATUS_IGNORE); // Can this change the Python string?
-#else
   int ret = MPI_Test(&(self->rq), &flag, MPI_STATUS_IGNORE); // Can this change the Python string?
   if (ret != MPI_SUCCESS)
     {
       PyErr_SetString(PyExc_RuntimeError, "MPI_Test error occurred.");
       return NULL;
     }
-#endif
   if (flag)
     {
       Py_DECREF(self->buffer);
       self->status = 0;
       Py_RETURN_TRUE;
     }
   else
@@ -130,24 +109,24 @@
       Py_DECREF(none);
     }
   PyObject_Del(self);
 }
 
 static PyMemberDef mpi_request_members[] = {
     {"status", T_INT, offsetof(GPAW_MPI_Request, status), READONLY,
-        "status of the request, non-zero if communication is pending."},
+	"status of the request, non-zero if communication is pending."},
     {NULL}
 };
 
 static PyMethodDef mpi_request_methods[] = {
     {"wait", (PyCFunction) mpi_request_wait, METH_NOARGS,
-        "Wait for the communication to complete."
+	"Wait for the communication to complete."
     },
     {"test", (PyCFunction) mpi_request_test, METH_NOARGS,
-        "Test if the communication has completed."
+	"Test if the communication has completed."
     },
     {NULL}
 };
 
 PyTypeObject GPAW_MPI_Request_type = {
     PyVarObject_HEAD_INIT(NULL, 0)
     "MPI_Request",             /*tp_name*/
@@ -207,243 +186,219 @@
 {
     int already_finalized = 1;
     int ierr = MPI_SUCCESS;
 
     MPI_Finalized(&already_finalized);
     if (!already_finalized)
     {
-        ierr = MPI_Finalize();
+	ierr = MPI_Finalize();
     }
     if (ierr != MPI_SUCCESS)
-        PyErr_SetString(PyExc_RuntimeError, "MPI_Finalize error occurred");
+	PyErr_SetString(PyExc_RuntimeError, "MPI_Finalize error occurred");
 }
 
 
 // MPI initialization
 static void mpi_ensure_initialized(void)
 {
     int already_initialized = 1;
     int ierr = MPI_SUCCESS;
 
     // Check whether MPI is already initialized
     MPI_Initialized(&already_initialized);
     if (!already_initialized)
     {
-        // if not, let's initialize it
+	// if not, let's initialize it
 #ifndef _OPENMP
-        ierr = MPI_Init(NULL, NULL);
-        if (ierr == MPI_SUCCESS)
-        {
-            // No problem: register finalization when at Python exit
-            Py_AtExit(*mpi_ensure_finalized);
-        }
-        else
-        {
-            // We have a problem: raise an exception
-            char err[MPI_MAX_ERROR_STRING];
-            int resultlen;
-            MPI_Error_string(ierr, err, &resultlen);
-            PyErr_SetString(PyExc_RuntimeError, err);
-        }
+	ierr = MPI_Init(NULL, NULL);
+	if (ierr == MPI_SUCCESS)
+	{
+	    // No problem: register finalization when at Python exit
+	    Py_AtExit(*mpi_ensure_finalized);
+	}
+	else
+	{
+	    // We have a problem: raise an exception
+	    char err[MPI_MAX_ERROR_STRING];
+	    int resultlen;
+	    MPI_Error_string(ierr, err, &resultlen);
+	    PyErr_SetString(PyExc_RuntimeError, err);
+	}
 #else
-        int granted;
-        ierr = MPI_Init_thread(NULL, NULL, MPI_THREAD_MULTIPLE, &granted);
-        if (ierr == MPI_SUCCESS && granted == MPI_THREAD_MULTIPLE)
-        {
-            // No problem: register finalization when at Python exit
-            Py_AtExit(*mpi_ensure_finalized);
-        }
-        else if (granted != MPI_THREAD_MULTIPLE)
-        {
-            // We have a problem: raise an exception
-            char err[MPI_MAX_ERROR_STRING] = "MPI_THREAD_MULTIPLE is not supported";
-            PyErr_SetString(PyExc_RuntimeError, err);
-        }
-        else
-        {
-            // We have a problem: raise an exception
-            char err[MPI_MAX_ERROR_STRING];
-            int resultlen;
-            MPI_Error_string(ierr, err, &resultlen);
-            PyErr_SetString(PyExc_RuntimeError, err);
-        }
+	int granted;
+	ierr = MPI_Init_thread(NULL, NULL, MPI_THREAD_MULTIPLE, &granted);
+	if (ierr == MPI_SUCCESS && granted == MPI_THREAD_MULTIPLE)
+	{
+	    // No problem: register finalization when at Python exit
+	    Py_AtExit(*mpi_ensure_finalized);
+	}
+	else if (granted != MPI_THREAD_MULTIPLE)
+	{
+	    // We have a problem: raise an exception
+	    char err[MPI_MAX_ERROR_STRING] = "MPI_THREAD_MULTIPLE is not supported";
+	    PyErr_SetString(PyExc_RuntimeError, err);
+	}
+	else
+	{
+	    // We have a problem: raise an exception
+	    char err[MPI_MAX_ERROR_STRING];
+	    int resultlen;
+	    MPI_Error_string(ierr, err, &resultlen);
+	    PyErr_SetString(PyExc_RuntimeError, err);
+	}
 #endif
     }
 }
 
 
 static void mpi_dealloc(MPIObject *obj)
 {
     if (obj->comm != MPI_COMM_WORLD)
-        MPI_Comm_free(&(obj->comm));
+	MPI_Comm_free(&(obj->comm));
     Py_XDECREF(obj->parent);
     free(obj->members);
     PyObject_DEL(obj);
 }
 
 static PyObject * mpi_sendreceive(MPIObject *self, PyObject *args,
-                                  PyObject *kwargs)
+				  PyObject *kwargs)
 {
-    PyArrayObject* a;
-    PyArrayObject* b;
+    PyObject* a;
+    PyObject* b;
     int dest, src;
     int sendtag = 123;
     int recvtag = 123;
     static char *kwlist[] = {"a", "dest", "b", "src", "sendtag", "recvtag",
-                             NULL};
+			     NULL};
     if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OiOi|ii:sendreceive",
-                                     kwlist,
-                                     &a, &dest, &b, &src, &sendtag, &recvtag))
-        return NULL;
+				     kwlist,
+				     &a, &dest, &b, &src, &sendtag, &recvtag))
+	return NULL;
     CHK_ARRAY(a);
     CHK_OTHER_PROC(dest);
     CHK_ARRAY(b);
     CHK_OTHER_PROC(src);
-    int nsend = PyArray_DESCR(a)->elsize;
-    for (int d = 0; d < PyArray_NDIM(a); d++)
-        nsend *= PyArray_DIM(a,d);
-    int nrecv = PyArray_DESCR(b)->elsize;
-    for (int d = 0; d < PyArray_NDIM(b); d++)
-        nrecv *= PyArray_DIM(b,d);
-#ifndef GPAW_MPI_DEBUG
-    MPI_Sendrecv(PyArray_BYTES(a), nsend, MPI_BYTE, dest, sendtag,
-                 PyArray_BYTES(b), nrecv, MPI_BYTE, src, recvtag,
-                 self->comm, MPI_STATUS_IGNORE);
-#else
-    int ret = MPI_Sendrecv(PyArray_BYTES(a), nsend, MPI_BYTE, dest, sendtag,
-                           PyArray_BYTES(b), nrecv, MPI_BYTE, src, recvtag,
-                           self->comm, MPI_STATUS_IGNORE);
+    int nsend = Array_ITEMSIZE(a);
+    for (int d = 0; d < Array_NDIM(a); d++)
+	nsend *= Array_DIM(a,d);
+    int nrecv = Array_ITEMSIZE(b);
+    for (int d = 0; d < Array_NDIM(b); d++)
+	nrecv *= Array_DIM(b,d);
+    int ret = MPI_Sendrecv(Array_BYTES(a), nsend, MPI_BYTE, dest, sendtag,
+			   Array_BYTES(b), nrecv, MPI_BYTE, src, recvtag,
+			   self->comm, MPI_STATUS_IGNORE);
     if (ret != MPI_SUCCESS) {
-        PyErr_SetString(PyExc_RuntimeError, "MPI_Sendrecv error occurred.");
-        return NULL;
+	PyErr_SetString(PyExc_RuntimeError, "MPI_Sendrecv error occurred.");
+	return NULL;
     }
-#endif
     Py_RETURN_NONE;
 }
 
 
 static PyObject * mpi_receive(MPIObject *self, PyObject *args, PyObject *kwargs)
 {
-  PyArrayObject* a;
+  PyObject* a;
   int src;
   int tag = 123;
   int block = 1;
   static char *kwlist[] = {"a", "src", "tag", "block", NULL};
 
   if (!PyArg_ParseTupleAndKeywords(args, kwargs, "Oi|ii:receive", kwlist,
-                                   &a, &src, &tag, &block))
+				   &a, &src, &tag, &block))
     return NULL;
   CHK_ARRAY(a);
   CHK_OTHER_PROC(src);
-  int n = PyArray_DESCR(a)->elsize;
-  for (int d = 0; d < PyArray_NDIM(a); d++)
-    n *= PyArray_DIM(a, d);
+  int n = Array_ITEMSIZE(a);
+  for (int d = 0; d < Array_NDIM(a); d++)
+    n *= Array_DIM(a, d);
   if (block)
     {
-#ifndef GPAW_MPI_DEBUG
-      MPI_Recv(PyArray_BYTES(a), n, MPI_BYTE, src, tag, self->comm,
-               MPI_STATUS_IGNORE);
-#else
-      int ret = MPI_Recv(PyArray_BYTES(a), n, MPI_BYTE, src, tag, self->comm,
-                         MPI_STATUS_IGNORE);
+      int ret = MPI_Recv(Array_BYTES(a), n, MPI_BYTE, src, tag, self->comm,
+			 MPI_STATUS_IGNORE);
       if (ret != MPI_SUCCESS)
-        {
-          PyErr_SetString(PyExc_RuntimeError, "MPI_Recv error occurred.");
-          return NULL;
-        }
-#endif
+	{
+	  PyErr_SetString(PyExc_RuntimeError, "MPI_Recv error occurred.");
+	  return NULL;
+	}
       Py_RETURN_NONE;
     }
   else
     {
       GPAW_MPI_Request *req = NewMPIRequest();
       if (req == NULL) return NULL;
       req->buffer = (PyObject*)a;
       Py_INCREF(req->buffer);
-#ifndef GPAW_MPI_DEBUG
-      MPI_Irecv(PyArray_BYTES(a), n, MPI_BYTE, src, tag, self->comm, &(req->rq));
-#else
-      int ret = MPI_Irecv(PyArray_BYTES(a), n, MPI_BYTE, src, tag, self->comm,
-                          &(req->rq));
+      int ret = MPI_Irecv(Array_BYTES(a), n, MPI_BYTE, src, tag, self->comm,
+			  &(req->rq));
       if (ret != MPI_SUCCESS)
-        {
-          PyErr_SetString(PyExc_RuntimeError, "MPI_Irecv error occurred.");
-          return NULL;
-        }
-#endif
+	{
+	  PyErr_SetString(PyExc_RuntimeError, "MPI_Irecv error occurred.");
+	  return NULL;
+	}
       return (PyObject *) req;
     }
 }
 
 static PyObject * mpi_send(MPIObject *self, PyObject *args, PyObject *kwargs)
 {
-  PyArrayObject* a;
+  PyObject* a;
   int dest;
   int tag = 123;
   int block = 1;
   static char *kwlist[] = {"a", "dest", "tag", "block", NULL};
   if (!PyArg_ParseTupleAndKeywords(args, kwargs, "Oi|ii:send", kwlist,
-                                   &a, &dest, &tag, &block))
+				   &a, &dest, &tag, &block))
     return NULL;
   CHK_ARRAY(a);
   CHK_OTHER_PROC(dest);
-  int n = PyArray_DESCR(a)->elsize;
-  for (int d = 0; d < PyArray_NDIM(a); d++)
-    n *= PyArray_DIM(a,d);
+  int n = Array_ITEMSIZE(a);
+  for (int d = 0; d < Array_NDIM(a); d++)
+    n *= Array_DIM(a,d);
   if (block)
     {
-#ifndef GPAW_MPI_DEBUG
-      MPI_Send(PyArray_BYTES(a), n, MPI_BYTE, dest, tag, self->comm);
-#else
-      int ret = MPI_Send(PyArray_BYTES(a), n, MPI_BYTE, dest, tag, self->comm);
+      int ret = MPI_Send(Array_BYTES(a), n, MPI_BYTE, dest, tag, self->comm);
       if (ret != MPI_SUCCESS)
-        {
-          PyErr_SetString(PyExc_RuntimeError, "MPI_Send error occurred.");
-          return NULL;
-        }
-#endif
+	{
+	  PyErr_SetString(PyExc_RuntimeError, "MPI_Send error occurred.");
+	  return NULL;
+	}
       Py_RETURN_NONE;
     }
   else
     {
       GPAW_MPI_Request *req = NewMPIRequest();
       req->buffer = (PyObject*)a;
       Py_INCREF(a);
-#ifndef GPAW_MPI_DEBUG
-      MPI_Isend(PyArray_BYTES(a), n, MPI_BYTE, dest, tag, self->comm,
-                &(req->rq));
-#else
-      int ret = MPI_Isend(PyArray_BYTES(a), n, MPI_BYTE, dest, tag, self->comm,
-                          &(req->rq));
+      int ret = MPI_Isend(Array_BYTES(a), n, MPI_BYTE, dest, tag, self->comm,
+			  &(req->rq));
       if (ret != MPI_SUCCESS)
-        {
-          PyErr_SetString(PyExc_RuntimeError, "MPI_Isend error occurred.");
-          return NULL;
-        }
-#endif
+	{
+	  PyErr_SetString(PyExc_RuntimeError, "MPI_Isend error occurred.");
+	  return NULL;
+	}
       return (PyObject *)req;
     }
 }
 
 
 static PyObject * mpi_ssend(MPIObject *self, PyObject *args, PyObject *kwargs)
 {
-  PyArrayObject* a;
+  PyObject* a;
   int dest;
   int tag = 123;
   static char *kwlist[] = {"a", "dest", "tag", NULL};
   if (!PyArg_ParseTupleAndKeywords(args, kwargs, "Oi|i:send", kwlist,
-                                   &a, &dest, &tag))
+				   &a, &dest, &tag))
     return NULL;
   CHK_ARRAY_RO(a);
   CHK_OTHER_PROC(dest);
-  int n = PyArray_DESCR(a)->elsize;
-  for (int d = 0; d < PyArray_NDIM(a); d++)
-    n *= PyArray_DIM(a,d);
-  MPI_Ssend(PyArray_BYTES(a), n, MPI_BYTE, dest, tag, self->comm);
+  int n = Array_ITEMSIZE(a);
+  for (int d = 0; d < Array_NDIM(a); d++)
+    n *= Array_DIM(a,d);
+  MPI_Ssend(Array_BYTES(a), n, MPI_BYTE, dest, tag, self->comm);
   Py_RETURN_NONE;
 }
 
 
 static PyObject * mpi_name(MPIObject *self, PyObject *noargs)
 {
   char name[MPI_MAX_PROCESSOR_NAME];
@@ -468,15 +423,15 @@
   Py_RETURN_NONE;
 }
 
 static PyObject * mpi_test(MPIObject *self, PyObject *args)
 {
   GPAW_MPI_Request* s;
   if (!PyArg_ParseTuple(args, "O!:wait", &GPAW_MPI_Request_type, &s))
-        return NULL;
+	return NULL;
   return mpi_request_test(s, NULL);
 }
 
 static PyObject * mpi_testall(MPIObject *self, PyObject *requests)
 {
   int n;   // Number of requests
   MPI_Request *rqs = NULL;
@@ -491,54 +446,50 @@
   assert(n >= 0);  // This cannot fail.
   rqs = GPAW_MALLOC(MPI_Request, n);
   assert(rqs != NULL);
   for (int i = 0; i < n; i++)
     {
       PyObject *o = PySequence_GetItem(requests, i);
       if (o == NULL)
-        return NULL;
+	return NULL;
       if (Py_TYPE(o) != &GPAW_MPI_Request_type)
-        {
-          Py_DECREF(o);
-          free(rqs);
-          PyErr_SetString(PyExc_TypeError, "mpi.testall: argument must be a sequence of MPI requests");
-          return NULL;
-        }
+	{
+	  Py_DECREF(o);
+	  free(rqs);
+	  PyErr_SetString(PyExc_TypeError, "mpi.testall: argument must be a sequence of MPI requests");
+	  return NULL;
+	}
       GPAW_MPI_Request *s = (GPAW_MPI_Request *)o;
       rqs[i] = s->rq;
       Py_DECREF(o);
     }
   // Do the actual test.
-#ifndef GPAW_MPI_DEBUG
-  MPI_Testall(n, rqs, &flag, MPI_STATUSES_IGNORE);
-#else
   int ret = MPI_Testall(n, rqs, &flag, MPI_STATUSES_IGNORE);
   if (ret != MPI_SUCCESS)
     {
       // We do not dare to release the buffers now!
       PyErr_SetString(PyExc_RuntimeError, "MPI_Testall error occurred.");
       return NULL;
     }
-#endif
   // Unlike MPI_Test, if flag outcome is non-zero, MPI_Testall will deallocate
   // all requests which were allocated by nonblocking communication calls, so
   // we must free these buffers. Otherwise, none of the requests are modified.
   if (flag != 0)
     {
       // Release the buffers used by the MPI communication
       for (int i = 0; i < n; i++)
       {
-        GPAW_MPI_Request *o = (GPAW_MPI_Request *) PySequence_GetItem(requests, i);
-        if (o->status)
-        {
-          assert(o->buffer != NULL);
-          Py_DECREF(o->buffer);
-        }
-        o->status = 0;
-        Py_DECREF(o);
+	GPAW_MPI_Request *o = (GPAW_MPI_Request *) PySequence_GetItem(requests, i);
+	if (o->status)
+	{
+	  assert(o->buffer != NULL);
+	  Py_DECREF(o->buffer);
+	}
+	o->status = 0;
+	Py_DECREF(o);
       }
     }
   // Release internal data and return.
   free(rqs);
   return Py_BuildValue("i", flag);
 }
 
@@ -563,38 +514,33 @@
   n = PySequence_Size(requests);
   assert(n >= 0);  // This cannot fail.
   rqs = GPAW_MALLOC(MPI_Request, n);
   for (int i = 0; i < n; i++)
     {
       PyObject *o = PySequence_GetItem(requests, i);
       if (o == NULL)
-        return NULL;
+	return NULL;
       if (Py_TYPE(o) != &GPAW_MPI_Request_type)
-        {
-          Py_DECREF(o);
-          free(rqs);
-          PyErr_SetString(PyExc_TypeError, "mpi.waitall: argument must be a sequence of MPI requests");
-          return NULL;
-        }
+	{
+	  Py_DECREF(o);
+	  free(rqs);
+	  PyErr_SetString(PyExc_TypeError, "mpi.waitall: argument must be a sequence of MPI requests");
+	  return NULL;
+	}
       GPAW_MPI_Request *s = (GPAW_MPI_Request *)o;
       rqs[i] = s->rq;
       Py_DECREF(o);
     }
-  // Do the actual wait.
-#ifndef GPAW_MPI_DEBUG
-  MPI_Waitall(n, rqs, MPI_STATUSES_IGNORE);
-#else
   int ret = MPI_Waitall(n, rqs, MPI_STATUSES_IGNORE);
   if (ret != MPI_SUCCESS)
     {
       // We do not dare to release the buffers now!
       PyErr_SetString(PyExc_RuntimeError, "MPI_Waitall error occurred.");
       return NULL;
     }
-#endif
   // Release the buffers used by the MPI communication
   for (int i = 0; i < n; i++)
    {
      GPAW_MPI_Request *o = (GPAW_MPI_Request *) PySequence_GetItem(requests, i);
      if (o->status)
      {
        assert(o->buffer != NULL);
@@ -605,21 +551,21 @@
    }
   // Release internal data and return.
   free(rqs);
   Py_RETURN_NONE;
 }
 
 
-static MPI_Datatype get_mpi_datatype(PyArrayObject *a)
+static MPI_Datatype get_mpi_datatype(PyObject *a)
 {
-  int n = PyArray_DESCR(a)->elsize;
-  if (PyArray_ISCOMPLEX(a))
+  int n = Array_ITEMSIZE(a);
+  if (Array_ISCOMPLEX(a))
     n = n / 2;
-
-  switch(PyArray_TYPE(a))
+  int array_type = Array_TYPE(a);
+  switch(array_type)
     {
       // Floating point numbers including complex numbers
     case NPY_DOUBLE:
     case NPY_CDOUBLE:
       assert(sizeof(double) == n);
       return MPI_DOUBLE;
     case NPY_FLOAT:
@@ -654,255 +600,331 @@
     case NPY_UINT:
       assert(sizeof(unsigned) == n);
       return MPI_UNSIGNED;
     case NPY_ULONG:
       assert(sizeof(unsigned long) == n);
       return MPI_UNSIGNED_LONG;
     }
+
   // If we reach this point none of the cases worked out.
   PyErr_SetString(PyExc_ValueError, "Cannot communicate data of this type.");
   return 0;
 }
 
 static PyObject * mpi_reduce(MPIObject *self, PyObject *args, PyObject *kwargs,
-                             MPI_Op operation, int allowcomplex)
+			     MPI_Op operation, int allowcomplex)
 {
 #ifdef GPAW_MPI_DEBUG
   MPI_Barrier(self->comm);
 #endif
   PyObject* obj;
   int root = -1;
   static char *kwlist[] = {"a", "root", NULL};
 
   if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O|i:reduce", kwlist,
-                                   &obj, &root))
+				   &obj, &root))
     return NULL;
   CHK_PROC_DEF(root);
   if (PyFloat_Check(obj))
     {
       double din = PyFloat_AS_DOUBLE(obj);
       double dout;
       if (root == -1)
-        MPI_Allreduce(&din, &dout, 1, MPI_DOUBLE, operation, self->comm);
+	MPI_Allreduce(&din, &dout, 1, MPI_DOUBLE, operation, self->comm);
       else
-        MPI_Reduce(&din, &dout, 1, MPI_DOUBLE, operation, root, self->comm);
+	MPI_Reduce(&din, &dout, 1, MPI_DOUBLE, operation, root, self->comm);
       return PyFloat_FromDouble(dout);
     }
   if (PyLong_Check(obj))
     {
       long din = PyLong_AS_LONG(obj);
       long dout;
       if (root == -1)
-        MPI_Allreduce(&din, &dout, 1, MPI_LONG, operation, self->comm);
+	MPI_Allreduce(&din, &dout, 1, MPI_LONG, operation, self->comm);
       else
-        MPI_Reduce(&din, &dout, 1, MPI_LONG, operation, root, self->comm);
+	MPI_Reduce(&din, &dout, 1, MPI_LONG, operation, root, self->comm);
       return PyLong_FromLong(dout);
     }
   else if (PyComplex_Check(obj) && allowcomplex)
     {
       double din[2];
       double dout[2];
       din[0] = PyComplex_RealAsDouble(obj);
       din[1] = PyComplex_ImagAsDouble(obj);
       if (root == -1)
-        MPI_Allreduce(&din, &dout, 2, MPI_DOUBLE, MPI_SUM, self->comm);
+	MPI_Allreduce(&din, &dout, 2, MPI_DOUBLE, MPI_SUM, self->comm);
       else
-        MPI_Reduce(&din, &dout, 2, MPI_DOUBLE, MPI_SUM, root, self->comm);
+	MPI_Reduce(&din, &dout, 2, MPI_DOUBLE, MPI_SUM, root, self->comm);
       return PyComplex_FromDoubles(dout[0], dout[1]);
     }
   else if (PyComplex_Check(obj))
     {
       PyErr_SetString(PyExc_ValueError,
-                      "Operation not allowed on complex numbers");
+		      "Operation not allowed on complex numbers");
       return NULL;
     }
   else   // It should be an array
     {
       int n;
       int elemsize;
       MPI_Datatype datatype;
-      PyArrayObject* aobj = (PyArrayObject*)obj;
+      PyObject* aobj = obj;
       CHK_ARRAY(aobj);
       datatype = get_mpi_datatype(aobj);
       if (datatype == 0)
-        return NULL;
-      n = PyArray_SIZE(aobj);
-      elemsize = PyArray_DESCR(aobj)->elsize;
-      if (PyArray_ISCOMPLEX(aobj))
-        {
-          if (allowcomplex)
-            {
-              n *= 2;
-              elemsize /= 2;
-            }
-          else
-            {
-              PyErr_SetString(PyExc_ValueError,
-                              "Operation not allowed on complex numbers");
-              return NULL;
-            }
-        }
+	return NULL;
+      n = Array_SIZE(aobj);
+      elemsize = Array_ITEMSIZE(aobj);
+      if (Array_ISCOMPLEX(aobj))
+	{
+	  if (allowcomplex)
+	    {
+	      n *= 2;
+	      elemsize /= 2;
+	    }
+	  else
+	    {
+	      PyErr_SetString(PyExc_ValueError,
+			      "Operation not allowed on complex numbers");
+	      return NULL;
+	    }
+	}
       if (root == -1)
-        {
-#ifdef GPAW_MPI2
-          MPI_Allreduce(MPI_IN_PLACE, PyArray_BYTES(aobj), n, datatype,
-                        operation, self->comm);
+	{
+#ifdef GPAW_MPI_INPLACE
+	  MPI_Allreduce(MPI_IN_PLACE, Array_BYTES(aobj), n, datatype,
+			operation, self->comm);
 #else
-          char* b = GPAW_MALLOC(char, n * elemsize);
-          MPI_Allreduce(PyArray_BYTES(aobj), b, n, datatype, operation,
-                        self->comm);
-          assert(PyArray_NBYTES(aobj) == n * elemsize);
-          memcpy(PyArray_BYTES(aobj), b, n * elemsize);
-          free(b);
+	  char* b = GPAW_MALLOC(char, n * elemsize);
+      MPI_Allreduce(Array_BYTES(aobj), b, n, datatype, operation,
+                    self->comm);
+      assert(Array_NBYTES(aobj) == n * elemsize);
+      memcpy(Array_BYTES(aobj), b, n * elemsize);
+      free(b);
 #endif
-        }
+	}
       else
-        {
-          int rank;
-          MPI_Comm_rank(self->comm, &rank);
-          char* b = 0;
-          if (rank == root)
-            {
-#ifdef GPAW_MPI2
-              MPI_Reduce(MPI_IN_PLACE, PyArray_BYTES(aobj), n,
-                         datatype, operation, root, self->comm);
+	{
+	  int rank;
+	  MPI_Comm_rank(self->comm, &rank);
+	  char* b = 0;
+	  if (rank == root)
+	    {
+#ifdef GPAW_MPI_INPLACE
+	      MPI_Reduce(MPI_IN_PLACE, Array_BYTES(aobj), n,
+			 datatype, operation, root, self->comm);
 #else
-              b = GPAW_MALLOC(char, n * elemsize);
-              MPI_Reduce(PyArray_BYTES(aobj), b, n, datatype,
-                         operation, root, self->comm);
-              assert(PyArray_NBYTES(aobj) == n * elemsize);
-              memcpy(PyArray_BYTES(aobj), b, n * elemsize);
-              free(b);
+	      b = GPAW_MALLOC(char, n * elemsize);
+	      MPI_Reduce(Array_BYTES(aobj), b, n, datatype,
+			 operation, root, self->comm);
+	      assert(Array_NBYTES(aobj) == n * elemsize);
+	      memcpy(Array_BYTES(aobj), b, n * elemsize);
+	      free(b);
 #endif
-            }
-          else
-            {
-              MPI_Reduce(PyArray_BYTES(aobj), b, n, datatype,
-                         operation, root, self->comm);
-            }
-        }
+	    }
+	  else
+	    {
+	      MPI_Reduce(Array_BYTES(aobj), b, n, datatype,
+			 operation, root, self->comm);
+	    }
+	}
       Py_RETURN_NONE;
     }
 }
 
+static PyObject * mpi_reduce_scalar(MPIObject *self, PyObject *args, PyObject *kwargs,
+                                    MPI_Op operation, int allowcomplex)
+{
+#ifdef GPAW_MPI_DEBUG
+  MPI_Barrier(self->comm);
+#endif
+  PyObject* obj;
+  int root = -1;
+  static char *kwlist[] = {"a", "root", NULL};
+
+  if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O|i:reduce", kwlist,
+				   &obj, &root))
+    return NULL;
+  CHK_PROC_DEF(root);
+  if (PyFloat_Check(obj))
+    {
+      double din = PyFloat_AS_DOUBLE(obj);
+      double dout;
+      if (root == -1)
+	MPI_Allreduce(&din, &dout, 1, MPI_DOUBLE, operation, self->comm);
+      else
+	MPI_Reduce(&din, &dout, 1, MPI_DOUBLE, operation, root, self->comm);
+      return PyFloat_FromDouble(dout);
+    }
+  if (PyLong_Check(obj))
+    {
+      long din = PyLong_AS_LONG(obj);
+      long dout;
+      if (root == -1)
+	MPI_Allreduce(&din, &dout, 1, MPI_LONG, operation, self->comm);
+      else
+	MPI_Reduce(&din, &dout, 1, MPI_LONG, operation, root, self->comm);
+      return PyLong_FromLong(dout);
+    }
+  else if (PyComplex_Check(obj) && allowcomplex)
+    {
+      double din[2];
+      double dout[2];
+      din[0] = PyComplex_RealAsDouble(obj);
+      din[1] = PyComplex_ImagAsDouble(obj);
+      if (root == -1)
+	MPI_Allreduce(&din, &dout, 2, MPI_DOUBLE, MPI_SUM, self->comm);
+      else
+	MPI_Reduce(&din, &dout, 2, MPI_DOUBLE, MPI_SUM, root, self->comm);
+      return PyComplex_FromDoubles(dout[0], dout[1]);
+    }
+  else if (PyComplex_Check(obj))
+    {
+      PyErr_SetString(PyExc_ValueError,
+		      "Operation not allowed on complex numbers");
+      return NULL;
+    }
+  else   // It should be an array
+    {
+       PyErr_SetString(PyExc_ValueError,
+           "Operation not allowed for this datatype for mpi_sum_scalar.");
+	      return NULL;
+    }
+}
+
 static PyObject * mpi_sum(MPIObject *self, PyObject *args, PyObject *kwargs)
 {
   return mpi_reduce(self, args, kwargs, MPI_SUM, 1);
 }
 
+static PyObject * mpi_sum_scalar(MPIObject *self, PyObject *args, PyObject *kwargs)
+{
+  return mpi_reduce_scalar(self, args, kwargs, MPI_SUM, 1);
+}
+
 static PyObject * mpi_product(MPIObject *self, PyObject *args, PyObject *kwargs)
 {
   // No complex numbers as that would give separate products of
   // real and imaginary parts.
   return mpi_reduce(self, args, kwargs,  MPI_PROD, 0);
 }
 
 static PyObject * mpi_max(MPIObject *self, PyObject *args, PyObject *kwargs)
 {
   return mpi_reduce(self, args,  kwargs, MPI_MAX, 0);
 }
 
+static PyObject * mpi_max_scalar(MPIObject *self, PyObject *args, PyObject *kwargs)
+{
+  return mpi_reduce_scalar(self, args,  kwargs, MPI_MAX, 0);
+}
+
 static PyObject * mpi_min(MPIObject *self, PyObject *args, PyObject *kwargs)
 {
   return mpi_reduce(self, args,  kwargs, MPI_MIN, 0);
 }
 
+static PyObject * mpi_min_scalar(MPIObject *self, PyObject *args, PyObject *kwargs)
+{
+  return mpi_reduce_scalar(self, args,  kwargs, MPI_MIN, 0);
+}
+
 static PyObject * mpi_scatter(MPIObject *self, PyObject *args)
 {
-  PyArrayObject* sendobj;
-  PyArrayObject* recvobj;
+  PyObject* sendobj;
+  PyObject* recvobj;
   int root;
   if (!PyArg_ParseTuple(args, "OOi:scatter", &sendobj, &recvobj, &root))
     return NULL;
   CHK_ARRAY(recvobj);
   CHK_PROC(root);
   char* source = 0;
   if (self->rank == root) {
     CHK_ARRAY(sendobj);
     CHK_ARRAYS(recvobj, sendobj, self->size); // size(send) = size(recv)*Ncpu
-    source = PyArray_BYTES(sendobj);
+    source = Array_BYTES(sendobj);
   }
-  int n = PyArray_DESCR(recvobj)->elsize;
-  for (int d = 0; d < PyArray_NDIM(recvobj); d++)
-    n *= PyArray_DIM(recvobj,d);
-  MPI_Scatter(source, n, MPI_BYTE, PyArray_BYTES(recvobj),
-              n, MPI_BYTE, root, self->comm);
+  int n = Array_ITEMSIZE(recvobj);
+  for (int d = 0; d < Array_NDIM(recvobj); d++)
+    n *= Array_DIM(recvobj,d);
+  MPI_Scatter(source, n, MPI_BYTE, Array_BYTES(recvobj),
+	      n, MPI_BYTE, root, self->comm);
   Py_RETURN_NONE;
 }
 
 
 
 static PyObject * mpi_allgather(MPIObject *self, PyObject *args)
 {
-  PyArrayObject* a;
-  PyArrayObject* b;
+  PyObject* a;
+  PyObject* b;
   if (!PyArg_ParseTuple(args, "OO:allgather", &a, &b))
     return NULL;
   CHK_ARRAY(a);
   CHK_ARRAY(b);
   CHK_ARRAYS(a, b, self->size);
-  int n = PyArray_DESCR(a)->elsize;
-  for (int d = 0; d < PyArray_NDIM(a); d++)
-    n *= PyArray_DIM(a,d);
+  int n = Array_ITEMSIZE(a);
+  for (int d = 0; d < Array_NDIM(a); d++)
+    n *= Array_DIM(a,d);
   // What about endianness????
-  MPI_Allgather(PyArray_BYTES(a), n, MPI_BYTE, PyArray_BYTES(b), n,
-                MPI_BYTE, self->comm);
+  MPI_Allgather(Array_BYTES(a), n, MPI_BYTE, Array_BYTES(b), n,
+		MPI_BYTE, self->comm);
   Py_RETURN_NONE;
 }
 
 static PyObject * mpi_gather(MPIObject *self, PyObject *args)
 {
-  PyArrayObject* a;
+  PyObject* a;
   int root;
-  PyArrayObject* b = 0;
+  PyObject* b = 0;
   if (!PyArg_ParseTuple(args, "Oi|O", &a, &root, &b))
     return NULL;
   CHK_ARRAY(a);
   CHK_PROC(root);
   if (root == self->rank)
     {
       CHK_ARRAY(b);
       CHK_ARRAYS(a, b, self->size);
     }
   else if ((PyObject*)b != Py_None && b != NULL)
     {
       fprintf(stderr, "******** Root=%d\n", root);
       PyErr_SetString(PyExc_ValueError,
-                      "mpi_gather: b array should not be given on non-root processors.");
+		      "mpi_gather: b array should not be given on non-root processors.");
       return NULL;
     }
-  int n = PyArray_DESCR(a)->elsize;
-  for (int d = 0; d < PyArray_NDIM(a); d++)
-    n *= PyArray_DIM(a,d);
+  int n = Array_ITEMSIZE(a);
+  for (int d = 0; d < Array_NDIM(a); d++)
+    n *= Array_DIM(a,d);
   if (root != self->rank)
-    MPI_Gather(PyArray_BYTES(a), n, MPI_BYTE, 0, n, MPI_BYTE, root, self->comm);
+    MPI_Gather(Array_BYTES(a), n, MPI_BYTE, 0, n, MPI_BYTE, root, self->comm);
   else
-    MPI_Gather(PyArray_BYTES(a), n, MPI_BYTE, PyArray_BYTES(b), n, MPI_BYTE, root, self->comm);
+    MPI_Gather(Array_BYTES(a), n, MPI_BYTE, Array_BYTES(b), n, MPI_BYTE, root, self->comm);
   Py_RETURN_NONE;
 }
 
 static PyObject * mpi_broadcast(MPIObject *self, PyObject *args)
 {
 #ifdef GPAW_MPI_DEBUG
   MPI_Barrier(self->comm);
 #endif
-  PyArrayObject* buf;
+  PyObject* buf;
   int root;
   if (!PyArg_ParseTuple(args, "Oi:broadcast", &buf, &root))
     return NULL;
   if (root == self->rank)
       CHK_ARRAY_RO(buf);
   else
       CHK_ARRAY(buf);
 
   CHK_PROC(root);
-  int n = PyArray_DESCR(buf)->elsize;
-  for (int d = 0; d < PyArray_NDIM(buf); d++)
-    n *= PyArray_DIM(buf,d);
-  MPI_Bcast(PyArray_BYTES(buf), n, MPI_BYTE, root, self->comm);
+  int n = Array_ITEMSIZE(buf);
+  for (int d = 0; d < Array_NDIM(buf); d++)
+    n *= Array_DIM(buf,d);
+  MPI_Bcast(Array_BYTES(buf), n, MPI_BYTE, root, self->comm);
   Py_RETURN_NONE;
 }
 
 static PyObject *mpi_compare(MPIObject *self, PyObject *args)
 {
   MPIObject* other;
   int result;
@@ -932,95 +954,95 @@
   // int64.  This should very probably be changed so it always
   // corresponds to the default int of numpy.
 
   // This handling of arrays of ranks is taken from the MPICommunicator
   // creation method.  See that method for explanation of casting, datatypes
   // etc.
   PyArrayObject *myranks_long = (PyArrayObject*)PyArray_ContiguousFromAny(
-                                            myranks_anytype, NPY_LONG, 1, 1);
+					    myranks_anytype, NPY_LONG, 1, 1);
   if(myranks_long == NULL)
     return NULL;
 
   int nranks = PyArray_DIM(myranks_long, 0);
 
   PyArrayObject *myranks;
   myranks = (PyArrayObject*)PyArray_Cast(myranks_long, NPY_INT);
 
   npy_intp rankshape[1];
   rankshape[0] = PyArray_SIZE(myranks);
   PyArrayObject* other_ranks = (PyArrayObject*)PyArray_SimpleNew(1, rankshape,
-                                                                 NPY_INT);
+								 NPY_INT);
 
   MPI_Group mygroup, othergroup;
   MPI_Comm_group(self->comm, &mygroup);
   MPI_Comm_group(other->comm, &othergroup);
 
   int* rankdata = (int*)PyArray_BYTES(myranks);
   int* otherrankdata = (int*)PyArray_BYTES(other_ranks);
   MPI_Group_translate_ranks(mygroup, nranks, rankdata, othergroup,
-                            otherrankdata);
+			    otherrankdata);
 
   // Return something with a definite value to Python.
   for(int i=0; i < nranks; i++) {
       if(otherrankdata[i] == MPI_UNDEFINED) {
-          otherrankdata[i] = -1;
+	  otherrankdata[i] = -1;
       }
   }
   PyObject* other_ranks_anytype = PyArray_Cast(other_ranks,
       PyArray_TYPE((PyArrayObject*)myranks_anytype));
 
   Py_DECREF(myranks_long);
   Py_DECREF(myranks);
   Py_DECREF(other_ranks);
   return (PyObject*)other_ranks_anytype;
 }
 
 static PyObject * mpi_alltoallv(MPIObject *self, PyObject *args)
 {
-  PyArrayObject* send_obj;
-  PyArrayObject* send_cnts;
-  PyArrayObject* send_displs;
-  PyArrayObject* recv_obj;
-  PyArrayObject* recv_cnts;
-  PyArrayObject* recv_displs;
+  PyObject* send_obj;
+  PyObject* send_cnts;
+  PyObject* send_displs;
+  PyObject* recv_obj;
+  PyObject* recv_cnts;
+  PyObject* recv_displs;
 
   if (!PyArg_ParseTuple(args, "OOOOOO:alltoallv", &send_obj, &send_cnts,
-                                                  &send_displs, &recv_obj,
-                                                  &recv_cnts, &recv_displs))
+						  &send_displs, &recv_obj,
+						  &recv_cnts, &recv_displs))
     return NULL;
   CHK_ARRAY(send_obj);
   CHK_ARRAY(send_cnts);
   CHK_ARRAY(send_displs);
   CHK_ARRAY(recv_obj);
   CHK_ARRAY(recv_cnts);
   CHK_ARRAY(recv_displs);
 
   int *s_cnts = GPAW_MALLOC(int, self->size);
   int *s_displs = GPAW_MALLOC(int, self->size);
   int *r_cnts = GPAW_MALLOC(int, self->size);
   int *r_displs = GPAW_MALLOC(int, self->size);
 
   /* Create count and displacement arrays in units of bytes */
-  int elem_size = PyArray_ITEMSIZE(send_obj);
+  int elem_size = Array_ITEMSIZE(send_obj);
 
-  long* tmp1 = PyArray_DATA(send_cnts);
-  long* tmp2 = PyArray_DATA(send_displs);
-  long* tmp3 = PyArray_DATA(recv_cnts);
-  long* tmp4 = PyArray_DATA(recv_displs);
+  long* tmp1 = Array_DATA(send_cnts);
+  long* tmp2 = Array_DATA(send_displs);
+  long* tmp3 = Array_DATA(recv_cnts);
+  long* tmp4 = Array_DATA(recv_displs);
   for (int i=0; i < self->size; i++) {
       s_cnts[i] = tmp1[i] * elem_size;
       s_displs[i] = tmp2[i] * elem_size;
       r_cnts[i] = tmp3[i] * elem_size;
       r_displs[i] = tmp4[i] * elem_size;
   }
 
-  MPI_Alltoallv(PyArray_BYTES(send_obj),
-                s_cnts, s_displs,
-                MPI_BYTE, PyArray_BYTES(recv_obj), r_cnts,
-                r_displs, MPI_BYTE, self->comm);
+  MPI_Alltoallv(Array_BYTES(send_obj),
+		s_cnts, s_displs,
+		MPI_BYTE, Array_BYTES(recv_obj), r_cnts,
+		r_displs, MPI_BYTE, self->comm);
 
   free(s_cnts);
   free(s_displs);
   free(r_cnts);
   free(r_displs);
 
   Py_RETURN_NONE;
@@ -1077,23 +1099,32 @@
     {"wait",             (PyCFunction)mpi_wait,         METH_VARARGS,
      "wait(request) waits for a nonblocking communication to complete."},
     {"waitall",          (PyCFunction)mpi_waitall,      METH_O,
      "waitall(list_of_rqs) waits for multiple nonblocking communications to complete."},
     {"sum",              (PyCFunction)mpi_sum,
      METH_VARARGS|METH_KEYWORDS,
      "sum(a, root=-1) sums arrays, result on all tasks unless root is given."},
+    {"sum_scalar",       (PyCFunction)mpi_sum_scalar,
+     METH_VARARGS|METH_KEYWORDS,
+     "sum_scalar(a, root=-1) sums numbers, result on all tasks unless root is given. Returns the sum."},
     {"product",          (PyCFunction)mpi_product,
      METH_VARARGS|METH_KEYWORDS,
      "product(a, root=-1) multiplies arrays, result on all tasks unless root is given."},
     {"max",              (PyCFunction)mpi_max,
      METH_VARARGS|METH_KEYWORDS,
      "max(a, root=-1) maximum of arrays, result on all tasks unless root is given."},
+    {"max_scalar",       (PyCFunction)mpi_max_scalar,
+     METH_VARARGS|METH_KEYWORDS,
+     "max_sclar(a, root=-1) maximum of scalars, result on all tasks unless root is given. Returns the value."},
     {"min",              (PyCFunction)mpi_min,
      METH_VARARGS|METH_KEYWORDS,
      "min(a, root=-1) minimum of arrays, result on all tasks unless root is given."},
+    {"min_scalar",       (PyCFunction)mpi_min_scalar,
+     METH_VARARGS|METH_KEYWORDS,
+     "min_scalar(a, root=-1) minimum of scalars, result on all tasks unless root is given. Returns the value."},
     {"scatter",          (PyCFunction)mpi_scatter,      METH_VARARGS,
      "scatter(src, target, root) distributes array from root task."},
     {"gather",           (PyCFunction)mpi_gather,       METH_VARARGS,
      "gather(src, root, target=None) gathers data from all tasks on root task."},
     {"all_gather",       (PyCFunction)mpi_allgather,    METH_VARARGS,
      "all_gather(src, target) gathers data from all tasks on all tasks."},
     {"alltoallv",       (PyCFunction)mpi_alltoallv,    METH_VARARGS,
@@ -1116,38 +1147,38 @@
   {"rank", T_INT, offsetof(MPIObject, rank), 0, "Number of this processor"},
   {"parent", T_OBJECT_EX, offsetof(MPIObject, parent), 0, "Parent communicator"},
   {0, 0, 0, 0, 0}  /* Sentinel */
 };
 
 // __new__
 static PyObject *NewMPIObject(PyTypeObject* type, PyObject *args,
-                              PyObject *kwds)
+			      PyObject *kwds)
 {
     static char *kwlist[] = {NULL};
     MPIObject* self;
 
     if (! PyArg_ParseTupleAndKeywords(args, kwds, "", kwlist))
-        return NULL;
+	return NULL;
 
     self = (MPIObject *) type->tp_alloc(type, 0);
     if (self == NULL)
-        return NULL;
+	return NULL;
 
     mpi_ensure_initialized();
 
     MPI_Comm_size(MPI_COMM_WORLD, &(self->size));
     MPI_Comm_rank(MPI_COMM_WORLD, &(self->rank));
     self->comm = MPI_COMM_WORLD;
     Py_INCREF(Py_None);
     self->parent = Py_None;
     self->members = (int*) malloc(self->size*sizeof(int));
     if (self->members == NULL)
-        return NULL;
+	return NULL;
     for (int i=0; i<self->size; i++)
-        self->members[i] = i;
+	self->members[i] = i;
 
     return (PyObject *) self;
 }
 
 // __init__ does nothing.
 static int InitMPIObject(MPIObject* self, PyObject *args, PyObject *kwds)
 {
@@ -1207,43 +1238,43 @@
   PyObject* orig_ranks;
   if (!PyArg_ParseTuple(args, "O", &orig_ranks))
     return NULL;
   // NB: int32 is NPY_LONG on 32-bit Linux and NPY_INT on 64-bit Linux!
   // First convert to NumPy array of NPY_LONG, then cast to NPY_INT, to
   // allow both 32 and 64 bit integers in the argument (except 64 on 32).
   PyArrayObject *ranks = (PyArrayObject*)PyArray_ContiguousFromAny(
-                                            orig_ranks, NPY_LONG, 1, 1);
+					    orig_ranks, NPY_LONG, 1, 1);
   if (ranks == NULL)
     return NULL;
   PyArrayObject *iranks;
   int n = PyArray_DIM(ranks, 0);
   iranks = (PyArrayObject*)PyArray_Cast((PyArrayObject*) ranks, NPY_INT);
   Py_DECREF(ranks);
   if (iranks == NULL)
     return NULL;
   // Check that all ranks make sense
   for (int i = 0; i < n; i++)
     {
       int *x = PyArray_GETPTR1(iranks, i);
       if (*x < 0 || *x >= self->size)
-        {
-          Py_DECREF(iranks);
-          PyErr_SetString(PyExc_ValueError, "invalid rank");
-          return NULL;
-        }
+	{
+	  Py_DECREF(iranks);
+	  PyErr_SetString(PyExc_ValueError, "invalid rank");
+	  return NULL;
+	}
       for (int j = 0; j < i; j++)
-        {
-          int *y = PyArray_GETPTR1(iranks, j);
-          if (*y == *x)
-            {
-              Py_DECREF(iranks);
-              PyErr_SetString(PyExc_ValueError, "duplicate rank");
-              return NULL;
-            }
-        }
+	{
+	  int *y = PyArray_GETPTR1(iranks, j);
+	  if (*y == *x)
+	    {
+	      Py_DECREF(iranks);
+	      PyErr_SetString(PyExc_ValueError, "duplicate rank");
+	      return NULL;
+	    }
+	}
     }
   MPI_Group group;
   MPI_Comm_group(self->comm, &group);
   MPI_Group newgroup;
   MPI_Group_incl(group, n, (int *) PyArray_BYTES(iranks), &newgroup);
   MPI_Comm comm;
   MPI_Comm_create(self->comm, newgroup, &comm); // has a memory leak!
@@ -1254,15 +1285,15 @@
       MPI_Errhandler_set(comm, MPI_ERRORS_RETURN);
 #ifdef __bgp__
       int result;
       int rank;
       MPI_Comm_rank(comm, &rank);
       MPIX_Get_property(comm, MPIDO_RECT_COMM, &result);
       if (rank == 0) {
-        if(result) fprintf(stderr, "Get_property: comm is rectangular. \n");
+	if(result) fprintf(stderr, "Get_property: comm is rectangular. \n");
       }
 #endif
     }
 #endif // GPAW_MPI_DEBUG
   MPI_Group_free(&newgroup);
   MPI_Group_free(&group);
   if (comm == MPI_COMM_NULL)
@@ -1270,27 +1301,58 @@
       Py_DECREF(iranks);
       Py_RETURN_NONE;
     }
   else
     {
       MPIObject *obj = PyObject_NEW(MPIObject, &MPIType);
       if (obj == NULL)
-        return NULL;
+	return NULL;
       MPI_Comm_size(comm, &(obj->size));
       MPI_Comm_rank(comm, &(obj->rank));
       obj->comm = comm;
       if (obj->parent == Py_None)
-        Py_DECREF(obj->parent);
+	Py_DECREF(obj->parent);
       obj->members = (int*) malloc(obj->size*sizeof(int));
       if (obj->members == NULL)
-        return NULL;
+	return NULL;
       memcpy(obj->members, (int *) PyArray_BYTES(iranks), obj->size*sizeof(int));
       Py_DECREF(iranks);
 
       // Make sure that MPI_COMM_WORLD is kept alive till the end (we
       // don't want MPI_Finalize to be called before MPI_Comm_free):
       Py_INCREF(self);
       obj->parent = (PyObject*)self;
       return (PyObject*)obj;
     }
 }
+
+
+PyObject* globally_broadcast_bytes(PyObject *self, PyObject *args)
+{
+    PyObject *pybytes;
+    if(!PyArg_ParseTuple(args, "O", &pybytes)){
+        return NULL;
+    }
+
+    MPI_Comm comm = MPI_COMM_WORLD;
+    int rank;
+    MPI_Comm_rank(comm, &rank);
+
+    long size;
+    if(rank == 0) {
+        size = PyBytes_Size(pybytes);  // Py_ssize_t --> long
+    }
+    MPI_Bcast(&size, 1, MPI_LONG, 0, comm);
+
+    char *dst = (char *)malloc(size);
+    if(rank == 0) {
+        char *src = PyBytes_AsString(pybytes);  // Read-only
+        memcpy(dst, src, size);
+    }
+    MPI_Bcast(dst, size, MPI_BYTE, 0, comm);
+
+    PyObject *value = PyBytes_FromStringAndSize(dst, size);
+    free(dst);
+    return value;
+}
+
 #endif // PARALLEL
```

### Comparing `gpaw-22.8.0/c/operators.c` & `gpaw-23.6.0/c/operators.c`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/c/operators.h` & `gpaw-23.6.0/c/operators.h`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/c/plane_wave.c` & `gpaw-23.6.0/c/plane_wave.c`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/c/plt.c` & `gpaw-23.6.0/c/plt.c`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/c/point_charges.c` & `gpaw-23.6.0/c/point_charges.c`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/c/spline.c` & `gpaw-23.6.0/c/spline.c`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/c/symmetry.c` & `gpaw-23.6.0/c/symmetry.c`

 * *Files 20% similar despite different names*

```diff
@@ -1,11 +1,105 @@
 /*  Copyright (C) 2010-2011 CAMd
  *  Please see the accompanying LICENSE file for further information. */
 #include "extensions.h"
 
+
+
+PyObject* GG_shuffle(PyObject *self, PyObject *args)
+{
+    PyArrayObject* G_G_obj;
+    int sign;
+    PyArrayObject* A_GG_obj;
+    PyArrayObject* B_GG_obj;
+
+    // def GG_shuffle(G_G:int32 array, sign:int, A_GG:complex128 array, B_GG:complex128 array)
+    if (!PyArg_ParseTuple(args, "OiOO",
+                          &G_G_obj, &sign, &A_GG_obj, &B_GG_obj))
+        return NULL;
+
+
+    int nG = PyArray_DIMS(G_G_obj)[0];
+    // Check dimensions
+    if ((nG != PyArray_DIMS(B_GG_obj)[0]) ||
+        (nG != PyArray_DIMS(B_GG_obj)[1]) ||
+        (nG != PyArray_DIMS(A_GG_obj)[0]) ||
+        (nG != PyArray_DIMS(A_GG_obj)[1]))
+     {
+         PyErr_SetString(PyExc_TypeError, "Unmatched dimensions at GG_shuffle.");
+         return NULL;
+     }
+
+    // Check input types
+    if ((PyArray_TYPE(B_GG_obj) != NPY_COMPLEX128) ||
+        (PyArray_TYPE(A_GG_obj) != NPY_COMPLEX128))
+    {
+         PyErr_SetString(PyExc_TypeError, "Expected complex arrays.");
+         return NULL;
+    }
+
+    if (PyArray_TYPE(G_G_obj) != NPY_INT)
+    {
+         PyErr_SetString(PyExc_TypeError, "G_G expected to be an integer array.");
+         return NULL;
+    }
+
+    if (!PyArray_IS_C_CONTIGUOUS(B_GG_obj))
+    {
+        PyErr_SetString(PyExc_TypeError, "B_GG need to be c-contiguous.");
+        return NULL;
+    }
+
+    if (!((sign == 1) || (sign == -1)))
+    {
+        PyErr_SetString(PyExc_TypeError, "Sign must be 1 or -1.");
+        return NULL;
+    }
+
+    int* G0_G = (int*)malloc(nG * sizeof(int));
+    int* G1_G = (int*)malloc(nG * sizeof(int));
+
+    npy_int32* G_G = (npy_int32*)PyArray_DATA(G_G_obj);
+
+    int stride0 = PyArray_STRIDES(A_GG_obj)[0];
+    int stride1 = PyArray_STRIDES(A_GG_obj)[1];
+    for (int G=0; G < nG; G++)
+    {
+        if (sign==1)
+        {
+            G0_G[G] = G_G[G] * stride0;
+            G1_G[G] = G_G[G] * stride1;
+        }
+        else  // Transpose
+        {
+            G0_G[G] = G_G[G] * stride1;
+            G1_G[G] = G_G[G] * stride0;
+        }
+    }
+
+    double complex* A_GG = (double complex*)PyArray_DATA(A_GG_obj);
+    double complex* B_GG = (double complex*)PyArray_DATA(B_GG_obj);
+
+    for (int G0=0; G0<nG; G0++)
+    {
+        int take0 = G0_G[G0];
+        for (int G1=0; G1<nG; G1++)
+        {
+            int take1 = G1_G[G1];
+            // Instead of numpy magic, we do some C magic.
+            char* ptr = (char*)A_GG + take0 + take1;
+            double complex* value_ptr = (double_complex*) ptr;
+            *(B_GG++) += *value_ptr;
+        }
+    }
+
+    free(G0_G);
+    free(G1_G);
+    Py_RETURN_NONE;
+}
+
 //
 // Apply symmetry operation op_cc to a and add result to b:
 //
 //     =T_       _
 //   b(U g) += a(g),
 //
 // where:
```

### Comparing `gpaw-22.8.0/c/tetra.c` & `gpaw-23.6.0/c/tetra.c`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/c/threading.h` & `gpaw-23.6.0/c/threading.h`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/c/transformers.c` & `gpaw-23.6.0/c/transformers.c`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/c/transformers.h` & `gpaw-23.6.0/c/transformers.h`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/c/utilities.c` & `gpaw-23.6.0/c/utilities.c`

 * *Files 17% similar despite different names*

```diff
@@ -705,11 +705,34 @@
               Y_m[7] = 0.58262136251873142 * (-30*x*z*z*z*r2+33*x*z*z*z*z*z+5*x*z*r2*r2);
               Y_m[8] = 0.46060262975746175 * (33*x*x*z*z*z*z+x*x*r2*r2-y*y*r2*r2-18*x*x*z*z*r2+18*y*y*z*z*r2-33*y*y*z*z*z*z);
               Y_m[9] = 0.92120525951492349 * (-3*x*x*x*z*r2-33*x*y*y*z*z*z+9*x*y*y*z*r2+11*x*x*x*z*z*z);
               Y_m[10] = 0.50456490072872417 * (11*y*y*y*y*z*z-66*x*x*y*y*z*z-x*x*x*x*r2+6*x*x*y*y*r2+11*x*x*x*x*z*z-y*y*y*y*r2);
               Y_m[11] = 2.3666191622317521 * (5*x*y*y*y*y*z+x*x*x*x*x*z-10*x*x*x*y*y*z);
               Y_m[12] = 0.6831841051919143 * (x*x*x*x*x*x+15*x*x*y*y*y*y-15*x*x*x*x*y*y-y*y*y*y*y*y);
             }
+          else if (l == 7)
+            {
+              Y_m[0] = -0.707162732524596 * y*y*y*y*y*y*y + 14.8504173830165 * x*x*y*y*y*y*y + -24.7506956383609 * x*x*x*x*y*y*y + 4.95013912767217 * x*x*x*x*x*x*y;
+              Y_m[1] = 15.8757639708114 * x*y*y*y*y*y*z + -52.919213236038 * x*x*x*y*y*y*z + 15.8757639708114 * x*x*x*x*x*y*z;
+              Y_m[2] = 4.67024020848234 * x*x*y*y*y*y*y + -0.51891557872026 * y*y*y*y*y*y*y + 6.22698694464312 * y*y*y*y*y*z*z + 2.5945778936013 * x*x*x*x*y*y*y + -62.2698694464312 * x*x*y*y*y*z*z + -2.5945778936013 * x*x*x*x*x*x*y + 31.1349347232156 * x*x*x*x*y*z*z;
+              Y_m[3] = 12.4539738892862 * x*y*y*y*y*y*z + -41.5132462976208 * x*y*y*y*z*z*z + -12.4539738892862 * x*x*x*x*x*y*z + 41.5132462976208 * x*x*x*y*z*z*z;
+              Y_m[4] = 2.34688400793441 * x*x*x*x*y*y*y + 0.469376801586882 * x*x*y*y*y*y*y + -18.7750720634753 * x*x*y*y*y*z*z + -0.469376801586882 * y*y*y*y*y*y*y + 9.38753603173764 * y*y*y*y*y*z*z + -12.5167147089835 * y*y*y*z*z*z*z + 1.40813040476065 * x*x*x*x*x*x*y + -28.1626080952129 * x*x*x*x*y*z*z + 37.5501441269506 * x*x*y*z*z*z*z;
+              Y_m[5] = 6.63799038667474 * x*x*x*x*x*y*z + 13.2759807733495 * x*x*x*y*y*y*z + -35.4026153955986 * x*x*x*y*z*z*z + 6.63799038667474 * x*y*y*y*y*y*z + -35.4026153955986 * x*y*y*y*z*z*z + 21.2415692373592 * x*y*z*z*z*z*z;
+              Y_m[6] = -0.451658037912587 * x*x*x*x*x*x*y + -1.35497411373776 * x*x*x*x*y*y*y + 10.8397929099021 * x*x*x*x*y*z*z + -1.35497411373776 * x*x*y*y*y*y*y + 21.6795858198042 * x*x*y*y*y*z*z + -21.6795858198042 * x*x*y*z*z*z*z + -0.451658037912587 * y*y*y*y*y*y*y + 10.8397929099021 * y*y*y*y*y*z*z + -21.6795858198042 * y*y*y*z*z*z*z + 5.78122288528111 * y*z*z*z*z*z*z;
+              Y_m[7] = -2.38994969192017 * x*x*x*x*x*x*z + -7.16984907576052 * x*x*x*x*y*y*z + 14.339698151521 * x*x*x*x*z*z*z + -7.16984907576052 * x*x*y*y*y*y*z + 28.6793963030421 * x*x*y*y*z*z*z + -11.4717585212168 * x*x*z*z*z*z*z + -2.38994969192017 * y*y*y*y*y*y*z + 14.339698151521 * y*y*y*y*z*z*z + -11.4717585212168 * y*y*z*z*z*z*z + 1.09254843059208 * z*z*z*z*z*z*z;
+              Y_m[8] = -0.451658037912587 * x*x*x*x*x*x*x + -1.35497411373776 * x*x*x*x*x*y*y + 10.8397929099021 * x*x*x*x*x*z*z + -1.35497411373776 * x*x*x*y*y*y*y + 21.6795858198042 * x*x*x*y*y*z*z + -21.6795858198042 * x*x*x*z*z*z*z + -0.451658037912587 * x*y*y*y*y*y*y + 10.8397929099021 * x*y*y*y*y*z*z + -21.6795858198042 * x*y*y*z*z*z*z + 5.78122288528111 * x*z*z*z*z*z*z;
+              Y_m[9] = -3.31899519333737 * x*x*y*y*y*y*z + -3.31899519333737 * y*y*y*y*y*y*z + 17.7013076977993 * y*y*y*y*z*z*z + -10.6207846186796 * y*y*z*z*z*z*z + 3.31899519333737 * x*x*x*x*x*x*z + 3.31899519333737 * x*x*x*x*y*y*z + -17.7013076977993 * x*x*x*x*z*z*z + 10.6207846186796 * x*x*z*z*z*z*z;
+              Y_m[10] = -0.469376801586882 * x*x*x*x*x*y*y + -2.34688400793441 * x*x*x*y*y*y*y + 18.7750720634753 * x*x*x*y*y*z*z + -1.40813040476065 * x*y*y*y*y*y*y + 28.1626080952129 * x*y*y*y*y*z*z + -37.5501441269506 * x*y*y*z*z*z*z + 0.469376801586882 * x*x*x*x*x*x*x + -9.38753603173764 * x*x*x*x*x*z*z + 12.5167147089835 * x*x*x*z*z*z*z;
+              Y_m[11] = 15.5674673616078 * x*x*y*y*y*y*z + -3.11349347232156 * y*y*y*y*y*y*z + 10.3783115744052 * y*y*y*y*z*z*z + 15.5674673616078 * x*x*x*x*y*y*z + -62.2698694464312 * x*x*y*y*z*z*z + -3.11349347232156 * x*x*x*x*x*x*z + 10.3783115744052 * x*x*x*x*z*z*z;
+              Y_m[12] = 2.5945778936013 * x*x*x*y*y*y*y + -2.5945778936013 * x*y*y*y*y*y*y + 31.1349347232156 * x*y*y*y*y*z*z + 4.67024020848234 * x*x*x*x*x*y*y + -62.2698694464312 * x*x*x*y*y*z*z + -0.51891557872026 * x*x*x*x*x*x*x + 6.22698694464312 * x*x*x*x*x*z*z;
+              Y_m[13] = -2.6459606618019 * y*y*y*y*y*y*z + 39.6894099270285 * x*x*y*y*y*y*z + -39.6894099270285 * x*x*x*x*y*y*z + 2.6459606618019 * x*x*x*x*x*x*z;
+              Y_m[14] = -4.95013912767217 * x*y*y*y*y*y*y + 24.7506956383609 * x*x*x*y*y*y*y + -14.8504173830165 * x*x*x*x*x*y*y + 0.707162732524596 * x*x*x*x*x*x*x;
+            }
+          else
+            {
+              PyErr_SetString(PyExc_RuntimeError, "l>7 not implemented");
+              return NULL;
+            }
         }
     }
   Py_RETURN_NONE;
 }
```

### Comparing `gpaw-22.8.0/c/wigner_seitz.c` & `gpaw-23.6.0/c/wigner_seitz.c`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/c/woperators.c` & `gpaw-23.6.0/c/woperators.c`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/c/xc/ensemble_gga.c` & `gpaw-23.6.0/c/xc/ensemble_gga.c`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/c/xc/libvdwxc.c` & `gpaw-23.6.0/c/xc/libvdwxc.c`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/c/xc/libxc.c` & `gpaw-23.6.0/c/xc/libxc.c`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/c/xc/m06l.c` & `gpaw-23.6.0/c/xc/m06l.c`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/c/xc/pbe.c` & `gpaw-23.6.0/c/xc/pbe.c`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/c/xc/pw91.c` & `gpaw-23.6.0/c/xc/pw91.c`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/c/xc/revtpss.c` & `gpaw-23.6.0/c/xc/revtpss.c`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/c/xc/revtpss_c_pbe.c` & `gpaw-23.6.0/c/xc/revtpss_c_pbe.c`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/c/xc/rpbe.c` & `gpaw-23.6.0/c/xc/rpbe.c`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/c/xc/tpss.c` & `gpaw-23.6.0/c/xc/tpss.c`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/c/xc/vdw.c` & `gpaw-23.6.0/c/xc/vdw.c`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/c/xc/xc.c` & `gpaw-23.6.0/c/xc/xc.c`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/c/xc/xc_gpaw.h` & `gpaw-23.6.0/c/xc/xc_gpaw.h`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/c/xc/xc_mgga.c` & `gpaw-23.6.0/c/xc/xc_mgga.c`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/c/xc/xc_mgga.h` & `gpaw-23.6.0/c/xc/xc_mgga.h`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/__init__.py` & `gpaw-23.6.0/gpaw/__init__.py`

 * *Files 2% similar despite different names*

```diff
@@ -3,25 +3,25 @@
 """Main gpaw module."""
 import os
 import sys
 import contextlib
 from pathlib import Path
 from typing import List, Dict, Union, Any, TYPE_CHECKING
 
-__version__ = '22.8.0'
+__version__ = '23.6.0'
 __ase_version_required__ = '3.22.1'
 __all__ = ['GPAW',
            'Mixer', 'MixerSum', 'MixerDif', 'MixerSum2',
+           'MixerFull',
            'CG', 'Davidson', 'RMMDIIS', 'DirectLCAO',
            'PoissonSolver',
            'FermiDirac', 'MethfesselPaxton', 'MarzariVanderbilt',
            'PW', 'LCAO', 'FD',
            'restart']
 
-
 setup_paths: List[Union[str, Path]] = []
 is_gpaw_python = '_gpaw' in sys.builtin_module_names
 dry_run = 0
 
 # When type-checking or running pytest, we want the debug-wrappers enabled:
 debug: bool = (TYPE_CHECKING or
                'pytest' in sys.modules or
@@ -60,16 +60,17 @@
         sys.setdlopenflags(old_dlopen_flags | os.RTLD_DEEPBIND)
     import numpy as np
     import scipy.linalg  # noqa: F401
     if is_gpaw_python:
         sys.setdlopenflags(old_dlopen_flags)
     import _gpaw
 
+SCIPY_VERSION = [int(x) for x in scipy.__version__.split('.')[:2]]
 
-if getattr(_gpaw, 'version', 0) < 1:
+if getattr(_gpaw, 'version', 0) != 3:
     raise ImportError('Please recompile GPAW''s C-extensions!')
 
 
 class ConvergenceError(Exception):
     pass
 
 
@@ -167,32 +168,33 @@
     oldempty_like = np.empty_like
 
     def empty(*args, **kwargs):
         a = oldempty(*args, **kwargs)
         try:
             a.fill(np.nan)
         except ValueError:
-            a.fill(-1000000)
+            a.fill(42)
         return a
 
     def empty_like(*args, **kwargs):
         a = oldempty_like(*args, **kwargs)
         try:
             a.fill(np.nan)
         except ValueError:
-            a.fill(-2000000)
+            a.fill(-42)
         return a
 
     np.empty = empty
     np.empty_like = empty_like
 
 
 with broadcast_imports:
     from gpaw.calculator import GPAW as OldGPAW
-    from gpaw.mixer import Mixer, MixerSum, MixerDif, MixerSum2
+    from gpaw.mixer import Mixer, MixerSum, MixerDif, MixerSum2, \
+        MixerFull
     from gpaw.eigensolvers import Davidson, RMMDIIS, CG, DirectLCAO
     from gpaw.poisson import PoissonSolver
     from gpaw.occupations import (FermiDirac, MethfesselPaxton,
                                   MarzariVanderbilt)
     from gpaw.wavefunctions.lcao import LCAO
     from gpaw.wavefunctions.pw import PW
     from gpaw.wavefunctions.fd import FD
```

### Comparing `gpaw-22.8.0/gpaw/ae.py` & `gpaw-23.6.0/gpaw/ae.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 """Bare Coulomb potential for hydrogen."""
 
 import numpy as np
 from scipy.special import erf
 
-from gpaw.spline import Spline
-from gpaw.setup import BaseSetup
 from gpaw.basis_data import Basis
+from gpaw.setup import BaseSetup
+from gpaw.spline import Spline
 
 
 class HydrogenAllElectronSetup(BaseSetup):
 
     def __init__(self, alpha1=10.0, alpha2=300.0):
         self.alpha1 = alpha1
         self.alpha2 = alpha2
@@ -19,19 +19,19 @@
         self.Z = 1
         self.Nc = 0
         self.Nv = 1
         self.nao = None
         self.pt_j = []
         self.ni = 0
         self.l_j = [0]
-        self.l_orb_j = [0]
+        self.l_orb_J = [0]
         self.n_j = [1]
-        self.nct = Spline(0, 0.5, [0.0, 0.0, 0.0])
+        self.tauct = self.nct = Spline(0, 0.5, [0.0, 0.0, 0.0])
         self.Nct = 0.0
-        self.N0_p = []
+        self.N0_p = np.zeros(0)
         rc = 2.0
         r_g = np.linspace(0, rc, 100)
         r2_g = r_g**2
         self.ghat_l = [Spline(0, rc, 4 * alpha1**1.5 / np.pi**0.5 *
                               np.exp(-alpha1 * r2_g))]
         v_g = erf(alpha1**0.5 * r_g) - erf(alpha2**0.5 * r_g)
         v_g[1:] *= (4 * np.pi)**0.5 / r_g[1:]
@@ -43,29 +43,31 @@
         self.lmax = 0
         self.K_p = self.M_p = self.MB_p = self.X_p = np.zeros(0)
         self.M_pp = np.zeros((0, 0))
         self.Kc = 0.0
         self.MB = 0.0
         self.M = -(alpha1 / 2 / np.pi)**0.5
         self.xc_correction = None
-        self.HubU = None
         self.dO_ii = np.zeros((0, 0))
         self.type = 'all-electron'
         self.fingerprint = None
         self.symbol = 'H'
         self.ExxC = 0.0
 
     def get_default_nbands(self):
         return 1
 
     def build(self, basis):
         if basis is None:
             basis = Basis('H', 'sz(dzp)')
         elif isinstance(basis, str):
             basis = Basis('H', basis)
+
         self.basis = basis
-        self.phit_j = self.basis.tosplines()
+        self.basis_functions_J = self.basis.tosplines()
+        self.pseudo_partial_waves_j = None  # XXX
+
         self.f_j = [1.0]
         self.nao = self.basis.nao
 
     def print_info(self, text):
         text('Hydrogen all-electron potential')
```

### Comparing `gpaw-22.8.0/gpaw/ah.py` & `gpaw-23.6.0/gpaw/ah.py`

 * *Files 2% similar despite different names*

```diff
@@ -42,32 +42,32 @@
         self.ghat_l = [Spline(0, rc, 4 * alpha**1.5 / np.pi**0.5 * x_g)]
         self.vbar = Spline(0, rc, 2 * np.pi**0.5 * (v1 + v2 * r2_g) * x_g)
         self.Delta_pL = np.zeros((1, 1))
         self.Delta_iiL = np.zeros((1, 1, 1))
         self.Delta0 = -4 / (4 * np.pi)**0.5
         self.ExxC = 0.0
         self.lmax = 0
-        self.K_p = self.M_p = self.MB_p = self.X_p = np.zeros(1)
+        self.K_p = self.M_p = self.MB_p = self.X_p = self.N0_p = np.zeros(1)
         self.M_pp = np.zeros((1, 1))
         self.Kc = 0.0
         self.MB = 0.0
         self.M = 0.0
         self.xc_correction = None
-        self.HubU = None
         self.dO_ii = np.zeros((1, 1))
         self.type = 'ah'
         self.fingerprint = None
 
     def build(self, basis):
         if basis is None:
             basis = Basis('Si', 'sz(dzp)')
         elif isinstance(basis, str):
             basis = Basis('Si', basis)
+
         self.basis = basis
-        self.phit_j = self.basis.tosplines()
+        self.basis_functions_J = self.basis.tosplines()
         self.nao = self.basis.nao
 
     def print_info(self, text):
         text('Appelbaum-Hamann pseudo potential')
 
     def calculate_initial_occupation_numbers(self, magmom, hund, charge,
                                              nspins):
```

### Comparing `gpaw-22.8.0/gpaw/analyse/eed.py` & `gpaw-23.6.0/gpaw/analyse/eed.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/analyse/expandyl.py` & `gpaw-23.6.0/gpaw/analyse/expandyl.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/analyse/hirshfeld.py` & `gpaw-23.6.0/gpaw/analyse/hirshfeld.py`

 * *Files 1% similar despite different names*

```diff
@@ -82,15 +82,15 @@
         self.initialize(setups,
                         self.calculator.timer,
                         np.zeros((len(atoms), 3)), False)
         self.set_mixer(None)
         rank_a = self.gd.get_ranks_from_positions(spos_ac)
         self.set_positions(spos_ac, AtomPartition(self.gd.comm, rank_a))
         basis_functions = BasisFunctions(self.gd,
-                                         [setup.phit_j
+                                         [setup.basis_functions_J
                                           for setup in self.setups],
                                          cut=True)
         basis_functions.set_positions(spos_ac)
         self.initialize_from_atomic_densities(basis_functions)
 
         aed_sg, gd = self.get_all_electron_density(atoms,
                                                    gridrefinement)
```

### Comparing `gpaw-22.8.0/gpaw/analyse/multipole.py` & `gpaw-23.6.0/gpaw/analyse/multipole.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/analyse/observers.py` & `gpaw-23.6.0/gpaw/analyse/observers.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/analyse/overlap.py` & `gpaw-23.6.0/gpaw/analyse/overlap.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/analyse/simple_stm.py` & `gpaw-23.6.0/gpaw/analyse/simple_stm.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/analyse/vdwradii.py` & `gpaw-23.6.0/gpaw/analyse/vdwradii.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/analyse/wignerseitz.py` & `gpaw-23.6.0/gpaw/analyse/wignerseitz.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/arraydict.py` & `gpaw-23.6.0/gpaw/arraydict.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/atom/aeatom.py` & `gpaw-23.6.0/gpaw/atom/aeatom.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/atom/all_electron.py` & `gpaw-23.6.0/gpaw/atom/all_electron.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/atom/analyse_setup.py` & `gpaw-23.6.0/gpaw/atom/analyse_setup.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,12 +1,12 @@
-import matplotlib.pyplot as plt
 import numpy as np
 
 
 def analyse(generator, show=False):
+    import matplotlib.pyplot as plt
     gen = generator
     symbol = gen.symbol
 
     colors = []
     id_j = []
     for j, n in enumerate(gen.vn_j):
         if n == -1:
```

### Comparing `gpaw-22.8.0/gpaw/atom/atompaw.py` & `gpaw-23.6.0/gpaw/atom/atompaw.py`

 * *Files 3% similar despite different names*

```diff
@@ -30,15 +30,15 @@
 
 
 class AtomWaveFunctions(WaveFunctions):
     mode = 'atompaw'
 
     def initialize(self, density, hamiltonian, spos_ac):
         setup = self.setups[0]
-        bf = AtomBasisFunctions(self.gd, setup.phit_j)
+        bf = AtomBasisFunctions(self.gd, setup.basis_functions_J)
         density.initialize_from_atomic_densities(bf)
         hamiltonian.update(density)
         return 0, 0
 
     def add_to_density_from_k_point(self, nt_sG, kpt):
         nt_sG[kpt.s] += np.dot(kpt.f_n / 4 / pi, kpt.psit_nG**2)
 
@@ -184,31 +184,32 @@
         c_ai[0][1:] = 0.0
 
     def dict(self):
         return {0: np.empty(self.nfunctions)}
 
 
 class AtomBasisFunctions:
-    def __init__(self, gd, phit_j):
+    def __init__(self, gd, bfs_J):
         self.gd = gd
-        self.bl_j = []
+        self.bl_J = []
         self.Mmax = 0
-        for phit in phit_j:
-            l = phit.get_angular_momentum_number()
-            self.bl_j.append((np.array([phit(x) * x**l for x in gd.r_g]), l))
+
+        for bf in bfs_J:
+            l = bf.get_angular_momentum_number()
+            self.bl_J.append((np.array([bf(x) * x**l for x in gd.r_g]), l))
             self.Mmax += 2 * l + 1
         self.atom_indices = [0]
         self.my_atom_indices = [0]
 
     def set_positions(self, spos_ac):
         pass
 
     def add_to_density(self, nt_sG, f_asi):
         i = 0
-        for b_g, l in self.bl_j:
+        for b_g, l in self.bl_J:
             nt_sG += f_asi[0][:, i:i + 1] * (2 * l + 1) / 4 / pi * b_g**2
             i += 2 * l + 1
 
 
 class AtomGridDescriptor(EquidistantRadialGridDescriptor):
     def __init__(self, h, rcut):
         ng = int(float(rcut) / h + 0.5) - 1
@@ -335,20 +336,20 @@
         rgd = EquidistantRadialGridDescriptor(d, ng)
         basis = Basis(self.symbol, basis_name, readxml=False, rgd=rgd)
         basis.generatorattrs = {}  # attrs of the setup maybe
         basis.generatordata = 'AtomPAW'  # version info too?
 
         bf_j = basis.bf_j
         for l, n, f, eps, psit_G in self.state_iter():
-            phit_g = rgd.empty()
-            phit_g[0] = 0.0
-            phit_g[1:] = psit_G
-            phit_g *= np.sign(psit_G[-1])
+            bf_g = rgd.empty()
+            bf_g[0] = 0.0
+            bf_g[1:] = psit_G
+            bf_g *= np.sign(psit_G[-1])
 
-            # If there's no node at zero, we shouldn't set phit_g to zero
+            # If there's no node at zero, we shouldn't set bf_g to zero
             # We'll make an ugly hack
-            if abs(phit_g[1]) > 3.0 * abs(phit_g[2] - phit_g[1]):
-                phit_g[0] = phit_g[1]
-            bf = BasisFunction(n, l, self.wfs.gd.r_g[-1], phit_g,
+            if abs(bf_g[1]) > 3.0 * abs(bf_g[2] - bf_g[1]):
+                bf_g[0] = bf_g[1]
+            bf = BasisFunction(n, l, self.wfs.gd.r_g[-1], bf_g,
                                '%s%d e=%.3f f=%.3f' % ('spdfgh'[l], n, eps, f))
             bf_j.append(bf)
         return basis
```

### Comparing `gpaw-22.8.0/gpaw/atom/basis.py` & `gpaw-23.6.0/gpaw/atom/basis.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/atom/check.py` & `gpaw-23.6.0/gpaw/atom/check.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/atom/configurations.py` & `gpaw-23.6.0/gpaw/atom/configurations.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/atom/filter.py` & `gpaw-23.6.0/gpaw/atom/filter.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/atom/generator.py` & `gpaw-23.6.0/gpaw/atom/generator.py`

 * *Files 0% similar despite different names*

```diff
@@ -724,15 +724,15 @@
                         (p[1] - p[2]) * (r[0] - r[2]) / (r[1] - r[2]))
             return p
 
         def divide_all_by_r(x_jg):
             return [divide_by_r(x_g, l) for x_g, l in zip(x_jg, vl_j)]
 
         setup.l_j = vl_j
-        setup.l_orb_j = vl_j
+        setup.l_orb_J = vl_j
         setup.n_j = vn_j
         setup.f_j = vf_j
         setup.eps_j = ve_j
         setup.rcut_j = [rcut_l[l] for l in vl_j]
 
         setup.nc_g = nc * sqrt4pi
         setup.nct_g = nct * sqrt4pi
```

### Comparing `gpaw-22.8.0/gpaw/atom/generator2.py` & `gpaw-23.6.0/gpaw/atom/generator2.py`

 * *Files 0% similar despite different names*

```diff
@@ -325,14 +325,15 @@
             occ = float(occ)
             aea.add(n, l, -occ)
             self.core_hole = (n, l, occ)
         else:
             self.core_hole = None
 
         if projectors[-1].isupper():
+            assert projectors[-2] == ',', projectors
             self.l0 = 'SPDFG'.find(projectors[-1])
             projectors = projectors[:-2]
         else:
             self.l0 = None
 
         self.lmax = -1
         self.states = {}
@@ -870,27 +871,29 @@
             bf = BasisFunction(n, l, rc, phit_g - phit2_g, 'split valence')
             self.basis.append(bf)
 
             txt += '%d%s split valence:\n' % (n0, 'spdf'[l])
             txt += '  cutoff: %.3f Bohr (tail-norm=%f)\n' % (rc, splitnorm)
 
         # Polarization:
-        gcpol = rgd.round(rcpol)
-        alpha = 1 / (0.25 * rcpol)**2
+        if lpol < 4:
+            gcpol = rgd.round(rcpol)
+            alpha = 1 / (0.25 * rcpol)**2
+
+            # Gaussian that is continuous and has a continuous
+            # derivative at rcpol:
+            phit_g = np.exp(-alpha * rgd.r_g**2) * rgd.r_g**lpol
+            phit_g -= rgd.pseudize(phit_g, gcpol, lpol, 2)[0]
+            phit_g[gcpol:] = 0.0
 
-        # Gaussian that is continuous and has a continuous derivative at rcpol:
-        phit_g = np.exp(-alpha * rgd.r_g**2) * rgd.r_g**lpol
-        phit_g -= rgd.pseudize(phit_g, gcpol, lpol, 2)[0]
-        phit_g[gcpol:] = 0.0
-
-        bf = BasisFunction(None, lpol, rcpol, phit_g, 'polarization')
-        self.basis.append(bf)
-        txt += 'l=%d polarization functions:\n' % lpol
-        txt += '  cutoff: %.3f Bohr (r^%d exp(-%.3f*r^2))\n' % (rcpol, lpol,
-                                                                alpha)
+            bf = BasisFunction(None, lpol, rcpol, phit_g, 'polarization')
+            self.basis.append(bf)
+            txt += f'l={lpol} polarization functions:\n'
+            txt += f'  cutoff: {rcpol:.3f} Bohr '
+            txt += f'(r^{lpol} exp(-{alpha:.3f}*r^2))\n'
 
         self.log(txt)
 
         # Write basis-set file:
         self.basis.generatordata = txt
         self.basis.generatorattrs.update(dict(tailnorm=tailnorm,
                                               scale=scale,
```

### Comparing `gpaw-22.8.0/gpaw/atom/gpaw_basis.py` & `gpaw-23.6.0/gpaw/atom/gpaw_basis.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/atom/gpaw_setup.py` & `gpaw-23.6.0/gpaw/atom/gpaw_setup.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/atom/optimize.py` & `gpaw-23.6.0/gpaw/atom/optimize.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/atom/radialgd.py` & `gpaw-23.6.0/gpaw/atom/radialgd.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,10 +1,11 @@
 import numbers
 from math import pi, factorial as fac
 
+from abc import ABC, abstractmethod
 import numpy as np
 from scipy.interpolate import make_interp_spline, splder
 
 from gpaw.spline import Spline
 from gpaw.utilities import hartree, divrl
 
 
@@ -54,15 +55,15 @@
 
     f_k[1:] /= G_k[1:]**(l + 1)
     if l == 0:
         f_k[0] = np.dot(r_g, f_g * r_g) * r_g[1]
     return f_k
 
 
-class RadialGridDescriptor:
+class RadialGridDescriptor(ABC):
     ndim = 1  # dimension of ndarrays
 
     def __init__(self, r_g: np.ndarray, dr_g, default_spline_points=25):
         """Grid descriptor for radial grid."""
         self.r_g = r_g
         self.dr_g = dr_g
         self.N = len(r_g)
@@ -470,14 +471,23 @@
 
     def get_cutoff(self, f_g):
         g = self.N - 1
         while f_g[g] == 0.0:
             g -= 1
         gcut = g + 1
         return gcut
+   
+    @abstractmethod
+    def r2g(self, r):
+        """Inverse continuous map from a real space distance (r)
+           to a floating point grid index (g).
+        
+           Used by methods floor, round, and ceil, which manipulate this
+           floating point to an integer accordingly.
+        """
 
 
 class EquidistantRadialGridDescriptor(RadialGridDescriptor):
     def __init__(self, h, N=1000, h0=0.0):
         """Equidistant radial grid descriptor.
 
         The radial grid is r(g) = h0 + g*h,  g = 0, 1, ..., N - 1."""
```

### Comparing `gpaw-22.8.0/gpaw/atom/shapefunc.py` & `gpaw-23.6.0/gpaw/atom/shapefunc.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/band_descriptor.py` & `gpaw-23.6.0/gpaw/band_descriptor.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/basis_data.py` & `gpaw-23.6.0/gpaw/basis_data.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/berryphase.py` & `gpaw-23.6.0/gpaw/berryphase.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,17 +1,19 @@
 import json
+import warnings
 from os.path import exists, splitext
 
-from ase.dft.kpoints import get_monkhorst_pack_size_and_offset
 import numpy as np
+from ase.dft.bandgap import bandgap
+from ase.dft.kpoints import get_monkhorst_pack_size_and_offset
 
 from gpaw import GPAW
-from gpaw.mpi import serial_comm, world, rank
-from gpaw.utilities.blas import gemmdot
+from gpaw.mpi import rank, serial_comm, world
 from gpaw.spinorbit import soc_eigenstates
+from gpaw.utilities.blas import gemmdot
 
 
 def get_overlap(calc, bands, u1_nR, u2_nR, P1_ani, P2_ani, dO_aii, bG_v):
     M_nn = np.dot(u1_nR.conj(), u2_nR.T) * calc.wfs.gd.dv
     cell_cv = calc.wfs.gd.cell_cv
     r_av = np.dot(calc.spos_ac, cell_cv)
 
@@ -25,14 +27,17 @@
     return M_nn
 
 
 def get_berry_phases(calc, spin=0, dir=0, check2d=False):
     if isinstance(calc, str):
         calc = GPAW(calc, communicator=serial_comm, txt=None)
 
+    gap = bandgap(calc)[0]
+    assert gap != 0.0
+
     M = np.round(calc.get_magnetic_moment())
     assert np.allclose(M, calc.get_magnetic_moment(), atol=0.05), \
         print(M, calc.get_magnetic_moment())
     nvalence = calc.wfs.setups.nvalence
     nocc_s = [int((nvalence + M) / 2), int((nvalence - M) / 2)]
     assert np.allclose(np.sum(nocc_s), nvalence)
     nocc = nocc_s[spin]
@@ -202,14 +207,15 @@
     name = splitext(calc)[0]
     berryname = '{}-berryphases.json'.format(name)
 
     phase_c = np.zeros((3,), float)
     if not exists(berryname) and world.rank == 0:
         # Calculate and save berry phases
         calc = GPAW(calc, communicator=serial_comm, txt=None)
+        assert len(calc.symmetry.op_scc) == 1
         nspins = calc.wfs.nspins
         data = {}
         for c in [0, 1, 2]:
             data[c] = {}
             for spin in range(nspins):
                 indices_kk, phases = get_berry_phases(calc, dir=c, spin=spin)
                 data[c][spin] = phases
@@ -238,14 +244,15 @@
     for c in [0, 1, 2]:
         nspins = len(data[str(c)])
         for spin in range(nspins):
             phases = data[str(c)][str(spin)]
             phase_c[c] += np.sum(phases) / len(phases)
     phase_c = phase_c * 2 / nspins
 
+    print(phase_c)
     Z_a = data['Z_a']
     spos_ac = data['spos_ac']
     phase_c += 2 * np.pi * np.dot(Z_a, spos_ac)
 
     return phase_c
 
 
@@ -336,15 +343,14 @@
             calc, periodic=True)[bands]
 
     phi_km = np.zeros((Npar, len(bands)), float)
     S_km = np.zeros((Npar, len(bands)), float)
     # Loop over the direction parallel components
     for k in myKrange:
         U_qmm = [np.eye(len(bands))]
-        print(k)
         qpts_q = kpts_kq[k]
         # Loop over kpoints in the phase direction
         for q in range(Nloc - 1):
             iq1 = qpts_q[q]
             iq2 = qpts_q[q + 1]
             # print(kpts_kc[iq1], kpts_kc[iq2])
             if q == 0:
@@ -422,27 +428,30 @@
                            np.reshape(u2_nsG, (len(u2_nsG), Ng)),
                            P1_ani,
                            P2_ani,
                            dO_aii,
                            np.array([0.0, 0.0, 0.0]))
         l_m, l_mm = np.linalg.eig(M_mm)
         phi_km[k] = np.angle(l_m)
-        print(phi_km[k] / 2 / np.pi)
 
         A_mm = np.zeros_like(l_mm, complex)
         for q in range(Nloc):
             iq = qpts_q[q]
             U_mm = U_qmm[q]
-            v_msn = soc_kpts[iq].v_msn
-            v_snm = np.einsum('xm, msn -> snx', U_mm, v_msn[bands])
-            A_mm += np.dot(v_snm[0].T.conj(), v_snm[0])
-            A_mm -= np.dot(v_snm[1].T.conj(), v_snm[1])
+            v_mn = soc_kpts[iq].v_mn
+            v_nm = np.einsum('xm, mn -> nx', U_mm, v_mn[bands])
+            A_mm += np.dot(v_nm[::2].T.conj(), v_nm[::2])
+            A_mm -= np.dot(v_nm[1::2].T.conj(), v_nm[1::2])
         A_mm /= Nloc
         S_km[k] = np.diag(l_mm.T.conj().dot(A_mm).dot(l_mm)).real
 
     world.sum(phi_km)
     world.sum(S_km)
 
+    if not calc.density.collinear:
+        warnings.warn('WARNING: Spin projections are not meaningful ' +
+                      'for non-collinear calculations')
+
     if name is not None:
         np.savez(f'phases_{name}.npz', phi_km=phi_km, S_km=S_km)
 
     return phi_km, S_km
```

### Comparing `gpaw-22.8.0/gpaw/bfield.py` & `gpaw-23.6.0/gpaw/bfield.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/blacs.py` & `gpaw-23.6.0/gpaw/blacs.py`

 * *Files 1% similar despite different names*

```diff
@@ -279,15 +279,15 @@
         ...................
         ...................
         +--+--+--+--+..+--+
         | 2| 3| 2| 3|..| 3|
         +--+--+--+--+..+--+
 
     Also refer to:
-    http://acts.nersc.gov/scalapack/hands-on/datadist.html
+    https://netlib.org/scalapack/slug/index.html
 
     Parameters:
      * blacsgrid: the BLACS grid of processors to distribute matrices.
      * M: global row count
      * N: global column count
      * mb: number of rows per block
      * nb: number of columns per block
```

### Comparing `gpaw-22.8.0/gpaw/borncharges.py` & `gpaw-23.6.0/gpaw/borncharges.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/broadcast_imports.py` & `gpaw-23.6.0/gpaw/broadcast_imports.py`

 * *Files 4% similar despite different names*

```diff
@@ -18,16 +18,14 @@
 data and will crash or deadlock if master sends anything else.
 """
 
 
 import os
 import sys
 import marshal
-import importlib
-import importlib.util
 from importlib.machinery import PathFinder, ModuleSpec
 
 import _gpaw
 
 
 if hasattr(_gpaw, 'Communicator'):
     if '_gpaw' not in sys.builtin_module_names:
@@ -60,34 +58,40 @@
 
 
 class BroadcastLoader:
     def __init__(self, spec, module_cache):
         self.module_cache = module_cache
         self.spec = spec
 
-    def load_module(self, fullname):
+    def create_module(self, spec):
+        # Returning None means to create the (uninitialized) module
+        # in the same way as normal.
+        #
+        # (But we could return e.g. a subclass of Module if we wanted.)
+        return None
+
+    def exec_module(self, module):
         if world.rank == 0:
             # Load from file and store in cache:
-            code = self.spec.loader.get_code(fullname)
+            code = self.spec.loader.get_code(module.__name__)
             metadata = (self.spec.submodule_search_locations, self.spec.origin)
-            self.module_cache[fullname] = (metadata, code)
+            self.module_cache[module.__name__] = (metadata, code)
             # We could execute the default mechanism to load the module here.
             # Instead we load from cache using our own loader, like on the
             # other cores.
 
-        return self.load_from_cache(fullname)
+        return self.load_from_cache(module)
 
-    def load_from_cache(self, fullname):
-        metadata, code = self.module_cache[fullname]
-        module = importlib.util.module_from_spec(self.spec)
+    def load_from_cache(self, module):
+        metadata, code = self.module_cache[module.__name__]
         origin = metadata[1]
         module.__file__ = origin
         # __package__, __path__, __cached__?
         module.__loader__ = self
-        sys.modules[fullname] = module
+        sys.modules[module.__name__] = module
         exec(code, module.__dict__)
         return module
 
     def __str__(self):
         return ('<{} for {}:{} [{} modules cached]>'
                 .format(self.__class__.__name__,
                         self.spec.name, self.spec.origin,
@@ -132,14 +136,16 @@
                               is_package=searchloc is not None)
             if searchloc is not None:
                 spec.submodule_search_locations += searchloc
             loader.spec = spec  # XXX loader.loader is still None
             return spec
 
     def broadcast(self):
+        if world.size == 1:
+            return
         if world.rank == 0:
             # print('bcast {} modules'.format(len(self.module_cache)))
             marshal_broadcast(self.module_cache)
         else:
             self.module_cache = marshal_broadcast(None)
             # print('recv {} modules'.format(len(self.module_cache)))
```

### Comparing `gpaw-22.8.0/gpaw/bztools.py` & `gpaw-23.6.0/gpaw/bztools.py`

 * *Files 3% similar despite different names*

```diff
@@ -25,14 +25,18 @@
         Unit cell.
 
     Returns
     -------
     gpaw.symmetry object
 
     """
+    # NB: Symmetry.find_lattice_symmetry() uses self.pbc_c, which defaults
+    # to pbc along all three dimensions. Hence, it seems that the lattice
+    # symmetry transformations produced by this method could be faulty if
+    # there are non-periodic dimensions in a system. XXX
     latsym = Symmetry([0], cell_cv, tolerance=tolerance)
     latsym.find_lattice_symmetry()
     return latsym
 
 
 def find_high_symmetry_monkhorst_pack(calc, density):
     """Make high symmetry Monkhorst Pack k-point grid.
@@ -57,14 +61,17 @@
     """
 
     atoms, calc = restart(calc, txt=None)
     pbc = atoms.pbc
     minsize, offset = kpts2sizeandoffsets(density=density, even=True,
                                           gamma=True, atoms=atoms)
 
+    # NB: get_bz() wants a pbc_c, but never gets it. This means that the
+    # pbc always will fall back to True along all dimensions. XXX
+    # NB: Why return latibzk_kc, if we never use it? XXX
     bzk_kc, ibzk_kc, latibzk_kc = get_bz(calc, returnlatticeibz=True)
 
     maxsize = minsize + 10
     minsize[~pbc] = 1
     maxsize[~pbc] = 2
 
     if mpi.rank == 0:
@@ -82,14 +89,15 @@
 
                 if (np.abs(ints - np.round(ints)) < 1e-5).all():
                     kpts_kc = monkhorst_pack(size) + offset
                     kpts_kc = to1bz(kpts_kc, calc.wfs.gd.cell_cv)
 
                     for ibzk_c in ibzk_kc:
                         diff_kc = np.abs(kpts_kc - ibzk_c)[:, pbc].round(6)
+                        # NB: The second np.mod() statement seems redundant XXX
                         if not (np.mod(np.mod(diff_kc, 1), 1) <
                                 1e-5).all(axis=1).any():
                             raise AssertionError('Did not find ' + str(ibzk_c))
                     if mpi.rank == 0:
                         print('Done. Monkhorst-Pack grid:', size, offset)
                     return kpts_kc
 
@@ -328,14 +336,17 @@
     time_reversal : bool
         Switch for time reversal.
     pbc: bool or [bool, bool, bool]
         Periodic bcs
     """
 
     if time_reversal:
+        # NB: The method never seems to be called with time_reversal=True,
+        # and hopefully get_bz() will generate the right symmetry operations
+        # always. So, can we remove this input? XXX
         cU_scc = get_symmetry_operations(cU_scc, time_reversal)
 
     # Lattice symmetries
     latsym = get_lattice_symmetry(cell_cv, tolerance=tolerance)
     lU_scc = get_symmetry_operations(latsym.op_scc,
                                      latsym.time_reversal)
```

### Comparing `gpaw-22.8.0/gpaw/calculator.py` & `gpaw-23.6.0/gpaw/calculator.py`

 * *Files 1% similar despite different names*

```diff
@@ -163,14 +163,53 @@
         self.log = GPAWLogger(world=self.world)
         self.log.fd = txt
 
         self.reader = None
 
         Calculator.__init__(self, restart, label=label, **kwargs)
 
+    def new(self,
+            timer=None,
+            communicator=None,
+            txt='-',
+            parallel=None,
+            **kwargs):
+        """Create a new calculator, inheriting input parameters.
+
+        The ``txt`` file and timer are the only input parameters to
+        be created anew. Internal variables, such as the density
+        or the wave functions, are not reused either.
+
+        For example, to perform an identical calculation with a
+        parameter changed (e.g. changing XC functional to PBE)::
+
+            new_calc = calc.new(xc='PBE')
+            atoms.calc = new_calc
+        """
+        assert 'atoms' not in kwargs
+        assert 'restart' not in kwargs
+        assert 'ignore_bad_restart_file' not in kwargs
+        assert 'label' not in kwargs
+
+        # Let the communicator fall back to world
+        if communicator is None:
+            communicator = self.world
+
+        if parallel is not None:
+            new_parallel = dict(self.parallel)
+            new_parallel.update(parallel)
+        else:
+            new_parallel = None
+
+        new_kwargs = dict(self.parameters)
+        new_kwargs.update(kwargs)
+
+        return GPAW(timer=timer, communicator=communicator,
+                    txt=txt, parallel=new_parallel, **new_kwargs)
+
     def fixed_density(self, *,
                       update_fermi_level: bool = False,
                       communicator=None,
                       txt='-',
                       parallel: Dict[str, Any] = None,
                       **kwargs) -> 'GPAW':
         """Create new calculator and do SCF calculation with fixed density.
@@ -210,14 +249,32 @@
         calc.density.fixed = True
         calc.wfs.fermi_levels = self.wfs.fermi_levels
         if calc.hamiltonian.xc.type == 'GLLB':
             new_response = calc.hamiltonian.xc.response
             old_response = self.hamiltonian.xc.response
             new_response.initialize_from_other_response(old_response)
             new_response.fix_potential = True
+        elif calc.hamiltonian.xc.type == 'MGGA':
+            for kpt in self.wfs.kpt_u:
+                if kpt.psit is None:
+                    raise ValueError("Needs wave functions for "
+                                     "MGGA fixed density.\n"
+                                     "To run from a restart file, it must "
+                                     "be written with mode='all'")
+            self.wfs.initialize_wave_functions_from_restart_file()
+            taut_sG = self.wfs.calculate_kinetic_energy_density()
+            wgd = self.wfs.gd.new_descriptor(comm=self.world,
+                                             allow_empty_domains=True)
+            redist = GridRedistributor(self.world, self.wfs.kptband_comm,
+                                       self.wfs.gd, wgd)
+            taut_sG = redist.distribute(taut_sG)
+            redist = GridRedistributor(self.world, calc.wfs.kptband_comm,
+                                       calc.wfs.gd, wgd)
+            taut_sG = redist.collect(taut_sG)
+            calc.hamiltonian.xc.fix_kinetic_energy_density(taut_sG)
         calc.calculate(system_changes=[])
         return calc
 
     def __enter__(self):
         return self
 
     def __exit__(self, *args):
@@ -280,15 +337,15 @@
         self.spos_ac = atoms.get_scaled_positions() % 1.0
 
     def read(self, filename):
         from ase.io.trajectory import read_atoms
         self.log('Reading from {}'.format(filename))
 
         self.reader = reader = Reader(filename)
-        assert reader.version <= 3, 'Can''t read new GPW-files'
+        assert reader.version <= 3, 'Can\'t read new GPW-files'
 
         atoms = read_atoms(reader.atoms)
         self._set_atoms(atoms)
 
         res = reader.results
         self.results = dict((key, res.get(key)) for key in res.keys())
         if self.results:
@@ -358,15 +415,15 @@
         """Calculate things."""
 
         Calculator.calculate(self, atoms)
         atoms = self.atoms
 
         if system_changes:
             self.log('System changes:', ', '.join(system_changes), '\n')
-            if system_changes == ['positions']:
+            if self.density is not None and system_changes == ['positions']:
                 # Only positions have changed:
                 self.density.reset()
             else:
                 # Drastic changes:
                 self.wfs = None
                 self.density = None
                 self.hamiltonian = None
@@ -642,14 +699,17 @@
             xc = self.hamiltonian.xc
 
         if par.fixdensity:
             warnings.warn(
                 'The fixdensity keyword has been deprecated. '
                 'Please use the GPAW.fixed_density() method instead.',
                 DeprecationWarning)
+            if self.hamiltonian.xc.type == 'MGGA':
+                raise ValueError('MGGA does not support deprecated '
+                                 'fixdensity option.')
 
         mode = par.mode
         if isinstance(mode, str):
             mode = {'name': mode}
         if isinstance(mode, dict):
             mode = create_wave_function_mode(**mode)
 
@@ -660,15 +720,15 @@
             del par['dtype']
             par.mode = mode
 
         if xc.orbital_dependent and mode.name == 'lcao':
             raise ValueError('LCAO mode does not support '
                              'orbital-dependent XC functionals.')
 
-        realspace = (mode.name != 'pw' and mode.interpolation != 'fft')
+        realspace = mode.interpolation != 'fft'
 
         self.create_setups(mode, xc)
 
         if not realspace:
             pbc_c = np.ones(3, bool)
 
         magnetic = magmom_av.any()
@@ -927,15 +987,15 @@
                 f_r[:] = ftmp[:len(f_r)]
         else:
             filter = self.parameters.filter
 
         Z_a = self.atoms.get_atomic_numbers()
         self.setups = Setups(Z_a,
                              self.parameters.setups, self.parameters.basis,
-                             xc, filter, self.world)
+                             xc, filter=filter, world=self.world)
         self.log(self.setups)
 
     def create_grid_descriptor(self, N_c, cell_cv, pbc_c,
                                domain_comm, parsize_domain):
         return GridDescriptor(N_c, cell_cv, pbc_c, domain_comm,
                               parsize_domain)
```

### Comparing `gpaw-22.8.0/gpaw/cdft/cdft.py` & `gpaw-23.6.0/gpaw/cdft/cdft.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/cdft/cdft_coupling.py` & `gpaw-23.6.0/gpaw/cdft/cdft_coupling.py`

 * *Files 0% similar despite different names*

```diff
@@ -1089,16 +1089,16 @@
         # crossing of the parabolas
         barrier = 1 / (4 * self.reorg) * (self.reorg + dE)**2
         if self.use_adiabatic_correction:
             # adiabatic correction
             correction = (
                 np.abs(self.ct) +
                 (self.reorg + dE) / 2. -
-                0.25 * np.sqrt(((self.reorg + self.dE))**2 +
-                               (np.abs(self.ct))**2))
+                np.sqrt(((self.reorg + self.dE)**2) / 4. +
+                        (np.abs(self.ct))**2))
 
             return barrier - correction
         else:
             return barrier
 
     def get_n_occupied_bands(self, calc):
         ''' how many occupied bands?'''
```

### Comparing `gpaw-22.8.0/gpaw/cli/complete.py` & `gpaw-23.6.0/gpaw/cli/complete.py`

 * *Files 5% similar despite different names*

```diff
@@ -53,16 +53,14 @@
         [],
     'install-data':
         ['--version', '--tarball', '--list-all', '--gpaw', '--sg15',
          '--basis', '--test', '--register', '--no-register'],
     'python':
         ['--dry-run', '-z', '-d', '--debug', '--command', '-c',
          '--module', '-m'],
-    'rpa':
-        ['-e', '--cut-off', '-b', '--blocks'],
     'run':
         ['-p', '--parameters', '-t', '--tag', '--properties', '-f',
          '--maximum-force', '--constrain-tags', '-s',
          '--maximum-stress', '-E', '--equation-of-state',
          '--eos-type', '-o', '--output', '--modify', '--after',
          '--dry-run', '-w', '--write', '-W', '--write-all'],
     'sbatch':
```

### Comparing `gpaw-22.8.0/gpaw/cli/dos.py` & `gpaw-23.6.0/gpaw/cli/dos.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/cli/gpw.py` & `gpaw-23.6.0/gpaw/cli/gpw.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/cli/info.py` & `gpaw-23.6.0/gpaw/cli/info.py`

 * *Files 3% similar despite different names*

```diff
@@ -47,14 +47,15 @@
                                              'built-in'))))
     if '_gpaw' in sys.builtin_module_names or not have_mpi:
         p = subprocess.Popen(['which', 'gpaw-python'], stdout=subprocess.PIPE)
         results.append(('parallel',
                         p.communicate()[0].strip().decode() or False))
     results.append(('MPI enabled', have_mpi))
     results.append(('OpenMP enabled', _gpaw.have_openmp))
+    results.append(('GPU-aware MPI', getattr(_gpaw, 'gpu_aware_mpi', False)))
     if have_mpi:
         have_sl = compiled_with_sl()
         have_elpa = LibElpa.have_elpa()
         if have_elpa:
             version = LibElpa.api_version()
             if version is None:
                 version = 'unknown, at most 2018.xx'
```

### Comparing `gpaw-22.8.0/gpaw/cli/install_data.py` & `gpaw-23.6.0/gpaw/cli/install_data.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,13 +1,14 @@
 import os
 import fnmatch
 from io import BytesIO
 import tarfile
 import re
 from urllib.request import urlopen
+import ssl
 
 
 sources = [('gpaw', 'official GPAW setups releases [default]'),
            ('sg15', 'SG15 pseudopotentials'),
            ('basis', 'basis sets for LCAO mode'),
            ('test', 'small file for testing this script')]
 
@@ -31,14 +32,27 @@
 Or maybe there it is just a temporary problem or timeout.  Please try
 again, or rummage around the GPAW web page until a solution is found.
 Writing e-mails to gpaw-users@listserv.fysik.dtu.dk or reporting
 an issue on https://gitlab.com/gpaw/gpaw/issues is also
 likely to help."""
 
 
+def urlopen_nocertcheck(src):
+    """Open a URL on a server without checking the certificate.
+
+    Some data is read from a DTU server with a self-signed
+    certificate.  That causes trouble on some machines.
+    """
+
+    ctx = ssl.create_default_context()
+    ctx.check_hostname = False
+    ctx.verify_mode = ssl.CERT_NONE
+    return urlopen(src, context=ctx)
+
+
 class CLICommand:
     """Install PAW datasets, pseudopotential or basis sets.
 
     Without a directory, show available setups and GPAW
     setup paths.
 
     With a directory, download and install gpaw-setups into
@@ -143,15 +157,15 @@
     if args.tarball:
         print('Reading local tarball %s' % args.tarball)
         targzfile = tarfile.open(args.tarball)
         tarfname = args.tarball
     else:
         tarfname = url.rsplit('/', 1)[1]
         print('Selected %s.  Downloading...' % tarfname)
-        response = urlopen(url)
+        response = urlopen_nocertcheck(url)
         targzfile = tarfile.open(fileobj=BytesIO(response.read()))
 
     if not os.path.exists(targetpath):
         os.makedirs(targetpath)
 
     assert tarfname.endswith('.tar.gz')
     setup_dirname = tarfname.rsplit('.', 2)[0]  # remove .tar.gz ending
@@ -226,21 +240,21 @@
         print()
     print('Installation complete.')
 
 
 def get_urls(source):
     page = baseurls[source]
     if source == 'gpaw':
-        response = urlopen(page)
+        response = urlopen_nocertcheck(page)
         pattern = 'https://wiki.fysik.dtu.dk/gpaw-files/gpaw-setups-*.tar.gz'
         lines = (line.strip().decode() for line in response)
         urls = [line for line in lines if fnmatch.fnmatch(line, pattern)]
 
     elif source == 'sg15':
-        response = urlopen(page)
+        response = urlopen_nocertcheck(page)
 
         # We want sg15_oncv_2015-10-07.tar.gz, but they may upload
         # newer files, too.
         pattern = (r'<a\s*href=[^>]+>\s*'
                    r'(sg15_oncv_upf_\d\d\d\d-\d\d-\d\d.tar.gz)'
                    r'\s*</a>')
```

### Comparing `gpaw-22.8.0/gpaw/cli/main.py` & `gpaw-23.6.0/gpaw/cli/main.py`

 * *Files 8% similar despite different names*

```diff
@@ -19,15 +19,14 @@
     ('atom', 'gpaw.atom.aeatom'),
     ('diag', 'gpaw.fulldiag'),
     # ('quick', 'gpaw.cli.quick'),
     ('python', 'gpaw.cli.python'),
     ('sbatch', 'gpaw.cli.sbatch'),
     ('dataset', 'gpaw.atom.generator2'),
     ('symmetry', 'gpaw.symmetry'),
-    ('rpa', 'gpaw.xc.rpa'),
     ('install-data', 'gpaw.cli.install_data')]
 
 
 def hook(parser, args):
     parser.add_argument('-P', '--parallel', type=int, metavar='N',
                         help='Run on N CPUs.')
     args = parser.parse_args(args)
```

### Comparing `gpaw-22.8.0/gpaw/cli/quick.py` & `gpaw-23.6.0/gpaw/cli/quick.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/cli/run.py` & `gpaw-23.6.0/gpaw/cli/run.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/cli/sbatch.py` & `gpaw-23.6.0/gpaw/cli/sbatch.py`

 * *Files 1% similar despite different names*

```diff
@@ -54,9 +54,9 @@
         cmd = ['sbatch'] + args.arguments[:i]
         if args.test:
             print('sbatch command:')
             print(' '.join(cmd))
             print('\nscript:')
             print(script, end='')
         else:
-            p = subprocess.Popen(cmd, stdin=subprocess.PIPE)
+            p = subprocess.Popen(cmd, stdin=subprocess.PIPE, env=os.environ)
             p.communicate(script.encode())
```

### Comparing `gpaw-22.8.0/gpaw/cli/test.py` & `gpaw-23.6.0/gpaw/cli/test.py`

 * *Files 10% similar despite different names*

```diff
@@ -36,14 +36,15 @@
         return
 
     parprint(f'Doing a test calculation (cores: {size}): ... ',
              end='', flush=True)
     a = 2.5
     d = 0.9
     chain = Atoms('H', cell=[a, a, d], pbc=(False, False, True))
+    chain.center()
     chain.calc = GPAW(mode=PW(200),
                       kpts=(1, 1, 8),
                       txt='test.txt')
     chain.get_forces()
     chain.get_stress()
     parprint('Done')
     if size == 1:
```

### Comparing `gpaw-22.8.0/gpaw/cluster.py` & `gpaw-23.6.0/gpaw/cluster.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/coding_style.py` & `gpaw-23.6.0/gpaw/coding_style.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/convergence_criteria.py` & `gpaw-23.6.0/gpaw/convergence_criteria.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,15 +1,14 @@
 from collections import deque
 from inspect import signature
 
 import numpy as np
 from ase.calculators.calculator import InputError
 from ase.units import Bohr, Ha
 
-from gpaw.forces import calculate_forces
 from gpaw.mpi import broadcast_float
 
 
 def get_criterion(name):
     """Returns one of the pre-specified criteria by it's .name attribute,
     and raises sensible error if missing."""
     # All built-in criteria should be in this list.
@@ -93,15 +92,15 @@
     self.description, self.__init__, and self.__call___. See the online
     documentation for details.
     """
     # If calc_last is True, will only be checked after all other (non-last)
     # criteria have been met.
     calc_last = False
     override_others = False
-    description = None
+    description: str
 
     def __repr__(self):
         parameters = signature(self.__class__).parameters
         s = ', '.join([str(getattr(self, p)) for p in parameters])
         return self.__class__.__name__ + '(' + s + ')'
 
     def todict(self):
@@ -121,47 +120,52 @@
 
 
 class Energy(Criterion):
     """A convergence criterion for the total energy.
 
     Parameters:
 
-    tol : float
+    tol: float
         Tolerance for conversion; that is the maximum variation among the
-        last n_old values of the (extrapolated) total energy, normalized per
-        valence electron. [eV/(valence electron)]
-    n_old : int
+        last n_old values of the (extrapolated) total energy.
+    n_old: int
         Number of energy values to compare. I.e., if n_old is 3, then this
         compares the peak-to-peak difference among the current total energy
         and the two previous.
+    relative: bool
+        Use total energy [eV] or total energy relative to number of
+        valence electrons [eV/(valence electron)].
     """
     name = 'energy'
     tablename = 'energy'
 
-    def __init__(self, tol, n_old=3):
+    def __init__(self, tol: float, *, n_old: int = 3, relative: bool = True):
         self.tol = tol
         self.n_old = n_old
-        self.description = ('Maximum [total energy] change in last {:d} cyles:'
-                            ' {:g} eV / electron'
-                            .format(self.n_old, self.tol))
+        self.relative = relative
+        self.description = (
+            f'Maximum [total energy] change in last {self.n_old} cyles: '
+            f'{self.tol:g} eV')
+        if relative:
+            self.description += ' / valence electron'
 
     def reset(self):
         self._old = deque(maxlen=self.n_old)
 
     def __call__(self, context):
         """Should return (bool, entry), where bool is True if converged and
         False if not, and entry is a <=5 character string to be printed in
         the user log file."""
         # Note the previous code was calculating the peak-to-
         # peak energy difference on e_total_free, while reporting
         # e_total_extrapolated in the SCF table (logfile). I changed it to
         # use e_total_extrapolated for both. (Should be a miniscule
         # difference, but more consistent.)
         total_energy = context.ham.e_total_extrapolated * Ha
-        if context.wfs.nvalence == 0:
+        if context.wfs.nvalence == 0 or not self.relative:
             energy = total_energy
         else:
             energy = total_energy / context.wfs.nvalence
         self._old.append(energy)  # Pops off >3!
         error = np.inf
         if len(self._old) == self._old.maxlen:
             error = np.ptp(self._old)
@@ -250,49 +254,66 @@
 
 
 class Forces(Criterion):
     """A convergence criterion for the forces.
 
     Parameters:
 
-    tol : float
-        Tolerance for conversion; that is, the force on each atom is compared
-        with its force from the previous iteration, and the change in each
-        atom's force is calculated as an l2-norm (Euclidean distance). The
-        atom with the largest norm must be less than tol. [eV/Angstrom]
+    atol : float
+        Absolute tolerance for convergence; that is, the force on each atom
+        is compared with its force from the previous iteration, and the change
+        in each atom's force is calculated as an l2-norm
+        (Euclidean distance). The atom with the largest norm must be less
+        than tol. [eV/Angstrom]
+    rtol : float
+        Relative tolerance for convergence. The difference in the l2-norm of
+        force on each atom is calculated, and convergence is achieved when
+        the largest difference between two iterations is rtol * max force.
     calc_last : bool
         If True, calculates forces last; that is, it waits until all other
         convergence criteria are satisfied before checking to see if the
         forces have converged. (This is more computationally efficient.)
         If False, checks forces at each SCF step.
     """
     name = 'forces'
     tablename = 'force'
 
-    def __init__(self, tol, calc_last=True):
-        self.tol = tol
+    def __init__(self, atol, rtol=np.inf, calc_last=True):
+        self.atol = atol
+        self.rtol = rtol
         self.description = ('Maximum change in the atomic [forces] across '
-                            'last 2 cycles: {:g} eV/Ang'.format(self.tol))
+                            f'last 2 cycles: {self.atol} eV/Ang OR\n'
+                            'Maximum error relative to the maximum '
+                            f'force is below {self.rtol}')
         self.calc_last = calc_last
         self.reset()
 
     def __call__(self, context):
         """Should return (bool, entry), where bool is True if converged and
         False if not, and entry is a <=5 character string to be printed in
         the user log file."""
-        if np.isinf(self.tol):  # criterion is off; backwards compatibility
+
+        # criterion is off; backwards compatibility
+        if np.isinf(self.atol) and np.isinf(self.rtol):
             return True, ''
-        with context.wfs.timer('Forces'):
-            F_av = calculate_forces(context.wfs, context.dens, context.ham)
-            F_av *= Ha / Bohr
+        F_av = context.calculate_forces()
+        F_av *= Ha / Bohr
         error = np.inf
+        max_force = np.max(np.linalg.norm(F_av, axis=1))
         if self.old_F_av is not None:
             error = ((F_av - self.old_F_av)**2).sum(1).max()**0.5
         self.old_F_av = F_av
-        converged = (error < self.tol)
+
+        if np.isfinite(self.rtol):
+            error_threshold = min(self.atol, self.rtol * max_force)
+        else:
+            # Avoid possible inf * 0.0:
+            error_threshold = self.atol
+        converged = error < error_threshold
+
         entry = ''
         if np.isfinite(error):
             if error:
                 entry = '{:+5.2f}'.format(np.log10(error))
             else:
                 entry = '-inf'
         return converged, entry
```

### Comparing `gpaw-22.8.0/gpaw/core/arrays.py` & `gpaw-23.6.0/gpaw/core/arrays.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,14 +1,15 @@
 from __future__ import annotations
 
+from types import ModuleType
 from typing import TYPE_CHECKING, Generic, TypeVar
 
-import numpy as np
-
 import gpaw.fftw as fftw
+import numpy as np
+from ase.io.ulm import NDArrayReader
 from gpaw.core.domain import Domain
 from gpaw.core.matrix import Matrix
 from gpaw.mpi import MPIComm
 from gpaw.typing import Array1D
 
 if TYPE_CHECKING:
     from gpaw.core.uniform_grid import UniformGridFunctions, UniformGrid
@@ -24,15 +25,16 @@
     def __init__(self,
                  dims: int | tuple[int, ...],
                  myshape: tuple[int, ...],
                  comm: MPIComm,
                  domain_comm: MPIComm,
                  data: np.ndarray | None,
                  dv: float,
-                 dtype):
+                 dtype,
+                 xp=None):
         self.myshape = myshape
         self.comm = comm
         self.domain_comm = domain_comm
         self.dv = dv
 
         # convert int to tuple:
         self.dims = dims if isinstance(dims, tuple) else (dims,)
@@ -51,37 +53,59 @@
         if data is not None:
             if data.shape != fullshape:
                 raise ValueError(
                     f'Bad shape for data: {data.shape} != {fullshape}')
             if data.dtype != dtype:
                 raise ValueError(
                     f'Bad dtype for data: {data.dtype} != {dtype}')
+            if xp is not None:
+                assert (xp is np) == isinstance(
+                    data, (np.ndarray, NDArrayReader)), xp
         else:
-            data = np.empty(fullshape, dtype)
+            data = (xp or np).empty(fullshape, dtype)
 
         self.data = data
+        self.xp: ModuleType
+        if isinstance(data, (np.ndarray, NDArrayReader)):
+            self.xp = np
+        else:
+            from gpaw.gpu import cupy as cp
+            self.xp = cp
         self._matrix: Matrix | None = None
 
     def new(self, data=None) -> DistributedArrays:
         raise NotImplementedError
 
+    def copy(self):
+        return self.new(data=self.data.copy())
+
     def __getitem__(self, index):
         raise NotImplementedError
 
     def __iter__(self):
         for index in range(self.dims[0]):
             yield self[index]
 
     def flat(self):
         if self.dims == ():
             yield self
         else:
             for index in np.indices(self.dims).reshape((len(self.dims), -1)).T:
                 yield self[tuple(index)]
 
+    def to_xp(self, xp):
+        if xp is self.xp:
+            # Disable assert for now as it would fail with our HIP-rfftn hack!
+            # assert xp is np, 'cp -> cp should not be needed!'
+            return self
+        if xp is np:
+            return self.new(data=self.xp.asnumpy(self.data))
+        else:
+            return self.new(data=xp.asarray(self.data))
+
     @property
     def matrix(self) -> Matrix:
         if self._matrix is not None:
             return self._matrix
 
         nx = prod(self.myshape)
         shape = (self.dims[0], prod(self.dims[1:]) * nx)
@@ -101,14 +125,15 @@
                         function=None,
                         domain_sum=True,
                         cc: bool = False) -> Matrix:
         if symmetric is None:
             symmetric = self is other
         if function:
             other = function(other)
+
         M1 = self.matrix
         M2 = other.matrix
         out = M1.multiply(M2, opb='C', alpha=self.dv,
                           symmetric=symmetric, out=out)
         if not cc:
             out.complex_conjugate()
         # operate_and_multiply(self, self.layout.dv, out, function, ...)
@@ -126,15 +151,15 @@
                                     out: Matrix,
                                     symmetric: bool) -> None:
         """Hook for PlaneWaveExpansion."""
         pass
 
     def abs_square(self,
                    weights: Array1D,
-                   out: UniformGridFunctions = None) -> None:
+                   out: UniformGridFunctions) -> None:
         """Add weighted absolute square of data to output array.
 
         See also :xkcd:`849`.
         """
         raise NotImplementedError
 
     def gather(self, out=None, broadcast=False):
```

### Comparing `gpaw-22.8.0/gpaw/core/atom_arrays.py` & `gpaw-23.6.0/gpaw/core/atom_arrays.py`

 * *Files 4% similar despite different names*

```diff
@@ -4,21 +4,23 @@
 from typing import Sequence
 
 import numpy as np
 from gpaw.mpi import MPIComm, serial_comm
 from gpaw.typing import Array1D, ArrayLike1D
 from gpaw.core.matrix import Matrix
 from gpaw.new import prod
+from gpaw.gpu import cupy as cp
 
 
 class AtomArraysLayout:
     def __init__(self,
                  shapes: list[int | tuple[int, ...]],
                  atomdist: AtomDistribution | MPIComm = serial_comm,
-                 dtype=float):
+                 dtype=float,
+                 xp=None):
         """Description of layout of atom arrays.
 
         Parameters
         ----------
         shapes:
             Shapse of arrays - one for each atom.
         atomdist:
@@ -28,34 +30,37 @@
         """
         self.shape_a = [shape if isinstance(shape, tuple) else (shape,)
                         for shape in shapes]
         if not isinstance(atomdist, AtomDistribution):
             atomdist = AtomDistribution(np.zeros(len(shapes), int), atomdist)
         self.atomdist = atomdist
         self.dtype = np.dtype(dtype)
+        self.xp = xp or np
 
         self.size = sum(prod(shape) for shape in self.shape_a)
 
         self.myindices = []
         self.mysize = 0
         I1 = 0
         for a in atomdist.indices:
             I2 = I1 + prod(self.shape_a[a])
             self.myindices.append((a, I1, I2))
             self.mysize += I2 - I1
             I1 = I2
 
     def __repr__(self):
         return (f'AtomArraysLayout({self.shape_a}, {self.atomdist}, '
-                f'{self.dtype})')
+                f'{self.dtype}, xp={self.xp.__name__})')
 
-    def new(self, atomdist=None, dtype=None):
+    def new(self, atomdist=None, dtype=None, xp=None):
         """Create new AtomsArrayLayout object with new atomdist."""
-        return AtomArraysLayout(self.shape_a, atomdist or self.atomdist,
-                                dtype or self.dtype)
+        return AtomArraysLayout(self.shape_a,
+                                atomdist or self.atomdist,
+                                dtype or self.dtype,
+                                xp or self.xp)
 
     def empty(self,
               dims: int | tuple[int, ...] = (),
               comm: MPIComm = serial_comm) -> AtomArrays:
         """Create new AtomArrays object.
 
         parameters
@@ -63,14 +68,21 @@
         dims:
             Extra dimensions.
         comm:
             Distribute dimensions along this communicator.
         """
         return AtomArrays(self, dims, comm)
 
+    def zeros(self,
+              dims: int | tuple[int, ...] = (),
+              comm: MPIComm = serial_comm) -> AtomArrays:
+        aa = self.empty(dims, comm)
+        aa.data[:] = 0.0
+        return aa
+
     def sizes(self) -> tuple[list[dict[int, int]], Array1D]:
         """Compute array sizes for all ranks.
 
         >>> AtomArraysLayout([3, 4]).sizes()
         ([{0: 3, 1: 4}], array([7]))
         """
         comm = self.atomdist.comm
@@ -190,15 +202,15 @@
             if data.shape != fullshape:
                 raise ValueError(
                     f'Bad shape for data: {data.shape} != {fullshape}')
             if data.dtype != dtype:
                 raise ValueError(
                     f'Bad dtype for data: {data.dtype} != {dtype}')
         else:
-            data = np.empty(fullshape, dtype)
+            data = layout.xp.empty(fullshape, dtype)
 
         self.data = data
         self._matrix: Matrix | None = None
 
         self.layout = layout
         self._arrays = {}
         for a, I1, I2 in layout.myindices:
@@ -222,29 +234,49 @@
         dist = (self.comm, -1, 1)
 
         data = self.data.reshape(myshape)
         self._matrix = Matrix(*shape, data=data, dist=dist)
 
         return self._matrix
 
-    def new(self, layout=None, data=None):
+    def new(self, *, layout=None, data=None, xp=None):
         """Create new AtomArrays object of same kind.
 
         Parameters
         ----------
         layout:
             Layout-description.
         data:
             Array to use for storage.
         """
+        if xp is np:
+            assert layout is None
+            assert data is None
+            assert self.layout.xp is cp
+            layout = self.layout.new(xp=np)
         return AtomArrays(layout or self.layout,
                           self.dims,
                           self.comm,
                           data=data)
 
+    def to_cpu(self):
+        if self.layout.xp is np:
+            return self
+        return self.new(layout=self.layout.new(xp=np),
+                        data=cp.asnumpy(self.data))
+
+    def to_xp(self, xp):
+        if self.layout.xp is xp:
+            return self
+        if xp is np:
+            return self.new(layout=self.layout.new(xp=np),
+                            data=cp.asnumpy(self.data))
+        return self.new(layout=self.layout.new(xp=cp),
+                        data=cp.asarray(self.data))
+
     def __getitem__(self, a):
         if isinstance(a, numbers.Integral):
             return self._arrays[a]
         if len(self.dims) == 1:
             a_ai = AtomArrays(self.layout, data=self.data[a[1]].copy())
             return a_ai
         1 / 0
@@ -281,23 +313,24 @@
             aa = self.new(layout=self.layout.new(atomdist=serial_comm))
         else:
             aa = None
 
         if comm.rank == 0:
             size_ra, size_r = self.layout.sizes()
             shape = self.mydims + (size_r.max(),)
-            buffer = np.empty(shape, self.layout.dtype)
+            buffer = self.layout.xp.empty(shape, self.layout.dtype)
             for rank in range(1, comm.size):
                 buf = buffer[..., :size_r[rank]]
                 comm.receive(buf, rank)
                 b1 = 0
                 for a, size in size_ra[rank].items():
                     b2 = b1 + size
                     A = aa[a]
                     A[:] = buf[..., b1:b2].reshape(A.shape)
+                    b1 = b2
             for a, array in self._arrays.items():
                 aa[a] = array
         else:
             comm.send(self.data, 0)
 
         if broadcast:
             comm.broadcast(aa.data, 0)
@@ -348,21 +381,23 @@
         >>> a.to_lower_triangle()[0]
         array([11., 12., 22., 13., 23., 33.])
         """
         shape_a = []
         for i1, i2 in self.layout.shape_a:
             assert i1 == i2
             shape_a.append((i1 * (i1 + 1) // 2,))
+        xp = self.layout.xp
         layout = AtomArraysLayout(shape_a,
                                   self.layout.atomdist.comm,
-                                  dtype=self.layout.dtype)
+                                  dtype=self.layout.dtype,
+                                  xp=xp)
         a_axp = layout.empty(self.dims)
         for a_xii, a_xp in zip(self.values(), a_axp.values()):
             i = a_xii.shape[-1]
-            L = np.tril_indices(i)
+            L = xp.tril_indices(i)
             for a_p, a_ii in zip(a_xp.reshape((-1, i * (i + 1) // 2)),
                                  a_xii.reshape((-1, i, i))):
                 a_p[:] = a_ii[L]
 
         return a_axp
 
     def to_full(self):
```

### Comparing `gpaw-22.8.0/gpaw/core/atom_centered_functions.py` & `gpaw-23.6.0/gpaw/core/atom_centered_functions.py`

 * *Files 3% similar despite different names*

```diff
@@ -20,15 +20,17 @@
     return Spline(l, rcut, f(r))
 
 
 class AtomCenteredFunctions:
     def __init__(self,
                  functions,
                  fracpos_ac: ArrayLike2D,
-                 atomdist: AtomDistribution = None):
+                 atomdist: AtomDistribution = None,
+                 xp=None):
+        self.xp = xp or np
         self.functions = [[to_spline(*f) if isinstance(f, tuple) else f
                            for f in funcs]
                           for funcs in functions]
         self.fracpos_ac = np.array(fracpos_ac)
         self._atomdist = atomdist
 
         self._layout = None
@@ -47,14 +49,17 @@
         return self._layout
 
     @property
     def atomdist(self):
         self._lazy_init()
         return self._atomdist
 
+    def _lazy_init(self):
+        raise NotImplementedError
+
     def empty(self,
               dims: int | tuple[int, ...] = (),
               comm: MPIComm = serial_comm) -> AtomArrays:
         """Create AtomsArray for coefficients."""
         return self.layout.empty(dims, comm)
 
     def move(self, fracpos_ac, atomdist):
@@ -83,33 +88,37 @@
     def derivative(self, functions, out=None):
         """Calculate derivatives of integrals with respect to atom
         positions.
         """
         self._lazy_init()
         if out is None:
             out = self.layout.empty((3,) + functions.dims, functions.comm)
-        coef_axiv = {a: np.moveaxis(array_vxi, 0, -1)
+        coef_axiv = {a: self.xp.moveaxis(array_vxi, 0, -1)
                      for a, array_vxi in out._arrays.items()}
         self._lfc.derivative(functions.data, coef_axiv, q=0)
         return out
 
+    def stress_tensor_contribution(self, a, c=1.0):
+        return self._lfc.stress_tensor_contribution(a.data, c)
+
 
 class UniformGridAtomCenteredFunctions(AtomCenteredFunctions):
     def __init__(self,
                  functions,
                  fracpos_ac,
                  grid,
                  *,
                  atomdist=None,
                  integral=None,
-                 cut=False):
+                 cut=False,
+                 xp=np):
         AtomCenteredFunctions.__init__(self,
                                        functions,
                                        fracpos_ac,
-                                       atomdist)
+                                       atomdist, xp=xp)
         self.grid = grid
         self.integral = integral
         self.cut = cut
 
     def _lazy_init(self):
         if self._lfc is not None:
             return
```

### Comparing `gpaw-22.8.0/gpaw/core/domain.py` & `gpaw-23.6.0/gpaw/core/domain.py`

 * *Files 10% similar despite different names*

```diff
@@ -28,27 +28,31 @@
         return cell
     if len(cell) == 3:
         return np.diag(cell)
     return cellpar_to_cell(cell)
 
 
 class Domain:
+    itemsize: int
+
     def __init__(self,
                  cell: ArrayLike1D | ArrayLike2D,
                  pbc=(True, True, True),
                  kpt: Vector = None,
                  comm: MPIComm = serial_comm,
                  dtype: DTypeLike = None):
         """"""
         if isinstance(pbc, int):
             pbc = (pbc,) * 3
         self.cell_cv = normalize_cell(cell)
         self.pbc_c = np.array(pbc, bool)
         self.comm = comm
 
+        self.volume = abs(np.linalg.det(self.cell_cv))
+
         assert dtype in [None, float, complex]
 
         if kpt is not None:
             if dtype is None:
                 dtype = complex
         else:
             if dtype is None:
@@ -96,26 +100,38 @@
 
     @property
     def kpt(self):
         return self.kpt_c.copy()
 
     def empty(self,
               shape: int | tuple[int, ...] = (),
-              comm: MPIComm = serial_comm) -> DistributedArrays:
+              comm: MPIComm = serial_comm, xp=None) -> DistributedArrays:
         raise NotImplementedError
 
     def zeros(self,
               shape: int | tuple[int, ...] = (),
-              comm: MPIComm = serial_comm) -> DistributedArrays:
-        array = self.empty(shape, comm)
+              comm: MPIComm = serial_comm, xp=None) -> DistributedArrays:
+        array = self.empty(shape, comm, xp=xp)
         array.data[:] = 0.0
         return array
 
     @property
     def icell(self):
+        """Inverse of unit cell.
+
+        >>> d = Domain([1, 2, 4])
+        >>> d.icell
+        array([[1.  , 0.  , 0.  ],
+               [0.  , 0.5 , 0.  ],
+               [0.  , 0.  , 0.25]])
+        >>> d.cell @ d.icell.T
+        array([[1., 0., 0.],
+               [0., 1., 0.],
+               [0., 0., 1.]])
+        """
         return np.linalg.inv(self.cell).T
 
     def uniform_grid_with_grid_spacing(self,
                                        grid_spacing: float,
                                        n: int = 1,
                                        factors: Sequence[int] = (2, 3, 5, 7)
                                        ) -> UniformGrid:
```

### Comparing `gpaw-22.8.0/gpaw/core/matrix.py` & `gpaw-23.6.0/gpaw/core/matrix.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,17 +1,20 @@
 """BLACS distributed matrix object."""
 from __future__ import annotations
 
+from types import ModuleType
 from typing import Dict, Tuple, Union
 
 import _gpaw
-import gpaw.utilities.blas as blas
 import numpy as np
-import scipy.linalg as linalg
-from gpaw import debug
+import scipy.linalg as sla
+
+import gpaw.utilities.blas as blas
+from gpaw import debug, SCIPY_VERSION
+from gpaw.gpu import cupy as cp, cupy_eigh
 from gpaw.mpi import MPIComm, _Communicator, serial_comm
 from gpaw.typing import Array1D, ArrayLike1D, ArrayLike2D
 
 _global_blacs_context_store: Dict[Tuple[_Communicator, int, int], int] = {}
 
 
 def suggest_blocking(N: int, ncpus: int) -> tuple[int, int, int]:
@@ -52,15 +55,16 @@
 
 class Matrix:
     def __init__(self,
                  M: int,
                  N: int,
                  dtype=None,
                  data: ArrayLike2D = None,
-                 dist: Union[MatrixDistribution, tuple[int, ...]] = None):
+                 dist: Union[MatrixDistribution, tuple] = None,
+                 xp=None):
         """Matrix object.
 
         Parameters
         ----------
         M:
             Rows.
         N:
@@ -73,38 +77,57 @@
             tuple.  Default is None meaning no distribution.
         data:
             Numpy ndarray to use for storage.  By default, a new ndarray
             will be allocated.
             """
         self.shape = (M, N)
 
-        if data is not None:
+        if data is None or isinstance(data, (np.ndarray, cp.ndarray)):
+            pass
+        else:
             data = np.asarray(data)
 
         if dtype is None:
             if data is None:
                 dtype = float
             else:
                 dtype = data.dtype
         self.dtype = np.dtype(dtype)
         assert dtype == float or dtype == complex, dtype
 
+        self.xp: ModuleType
+        if xp is None:
+            if isinstance(dist, CuPyDistribution):
+                self.xp = cp
+            elif data is not None and not isinstance(data, np.ndarray):
+                self.xp = cp
+            else:
+                self.xp = np
+        else:
+            self.xp = xp
+
         dist = dist or ()
         if isinstance(dist, tuple):
-            dist = create_distribution(M, N, *dist)
+            kwargs = {key: val for key, val in zip(['comm', 'r', 'c', 'b'],
+                                                   dist)}
+            dist = create_distribution(M, N, xp=self.xp, **kwargs)
+        else:
+            assert self.shape == dist.full_shape
         self.dist = dist
 
         if data is None:
-            self.data = np.empty(dist.shape, self.dtype)
+            self.data = self.xp.empty(dist.shape, self.dtype)
         else:
             self.data = data.reshape(dist.shape)
 
     def __repr__(self):
         dist = str(self.dist).split('(')[1]
-        return 'Matrix({}: {}'.format(self.dtype.name, dist)
+        if self.xp is cp:
+            dist = 'xp=cp, ' + dist
+        return f'Matrix({self.dtype.name}: {dist}'
 
     def new(self, dist='inherit', data=None) -> Matrix:
         """Create new matrix of same shape and dtype.
 
         Default is to use same BLACS distribution.  Use dist to use another
         distribution.
         """
@@ -144,31 +167,30 @@
         A = self
         B = other
         dist = self.dist
         if out is None:
             assert beta == 0.0
             M = A.shape[0] if opa == 'N' else A.shape[1]
             N = B.shape[1] if opb == 'N' else B.shape[0]
-            out = Matrix(M, N, A.dtype,
-                         dist=(dist.comm, dist.rows, dist.columns))
+            out = Matrix(M, N, A.dtype, dist=dist.new(M, N))
         elif not isinstance(out, Matrix):
             out = out.matrix
 
         if 0:  # dist.comm.size > 1:
             # Special cases that don't need scalapack - most likely also
             # faster:
             if alpha == 1.0 and opa == 'N' and opb == 'N':
                 return fastmmm(A, B, out, beta)
             if alpha == 1.0 and beta == 1.0 and opa == 'N' and opb == 'C':
                 if symmetric:
                     return fastmmm2(A, B, out)
                 else:
                     return fastmmm2notsym(A, B, out)
 
-        dist.multiply(alpha, A, opa, B, opb, beta, out, symmetric)
+        dist.multiply(alpha, A, opa, B, opb, beta, out, symmetric=symmetric)
         return out
 
     def redist(self, other: Matrix) -> None:
         """Redistribute to other BLACS layout."""
         if self is other:
             return
         d1 = self.dist
@@ -245,52 +267,58 @@
         """Inplace inversion."""
         assert uplo == 'L'
         M, N = self.shape
         assert M == N
         dist = self.dist
         if dist.comm.size == 1:
             self.tril2full()
-            self.data[:] = linalg.inv(self.data,
-                                      overwrite_a=True,
-                                      check_finite=debug)
+            self.data[:] = sla.inv(self.data,
+                                   overwrite_a=True,
+                                   check_finite=debug)
             return
         bc, br = dist.desc[4:6]
         assert bc == br
         info = _gpaw.scalapack_inverse(self.data, dist.desc, 'U')
         if info != 0:
             raise ValueError(f'scalapack_inverse error: {info}')
 
     def invcholesky(self) -> None:
-        """Inverse of Cholesky decomposition.
+        """In-place inverse of Cholesky decomposition.
 
-        Returns a lower triangle matrix `L` where:::
+        Calculate a lower triangle matrix `L` where:::
 
              †
-          LSL = 1
+          LSL = 1,
 
-        Only the lower part of `S` is used.
+        and `S` is self.  Only the lower part of `S` is used.
 
         >>> S = Matrix(2, 2, data=[[1.0, np.nan],
         ...                        [0.1, 1.0]])
         >>> S.invcholesky()
         >>> S.data
         array([[ 1.        , -0.        ],
                [-0.10050378,  1.00503782]])
         """
         S = self.gather()
         if self.dist.comm.rank == 0:
-            if debug:
-                S.data[np.triu_indices(S.shape[0], 1)] = 42.0
-            L_nn = linalg.cholesky(S.data,
-                                   lower=True,
-                                   overwrite_a=True,
-                                   check_finite=debug)
-            S.data[:] = linalg.inv(L_nn,
-                                   overwrite_a=True,
-                                   check_finite=debug)
+            if isinstance(S.data, np.ndarray):
+                if debug:
+                    S.data[np.triu_indices(S.shape[0], 1)] = 42.0
+                L_nn = sla.cholesky(S.data,
+                                    lower=True,
+                                    overwrite_a=True,
+                                    check_finite=debug)
+                S.data[:] = sla.inv(L_nn,
+                                    overwrite_a=True,
+                                    check_finite=debug)
+            else:
+                self.tril2full()
+                L_nn = cp.linalg.cholesky(S.data)
+                S.data[:] = cp.linalg.inv(L_nn)
+
         if S is not self:
             S.redist(self)
 
     def eigh(self,
              S=None,
              *,
              cc=False,
@@ -336,30 +364,42 @@
         if rows * columns == 1:
             if self.dist.comm.rank == 0:
                 if cc and H.dtype == complex:
                     np.negative(H.data.imag, H.data.imag)
                 if debug:
                     H.data[np.triu_indices(H.shape[0], 1)] = 42.0
                 if S is None:
-                    eps[:], H.data.T[:] = linalg.eigh(
+                    if self.xp is not np:
+                        eps, H.data.T[:] = (
+                            cupy_eigh(  # type: ignore[assignment]
+                                H.data, UPLO='L'))
+                        return eps
+                    eps[:], H.data.T[:] = sla.eigh(
                         H.data,
                         lower=True,
                         overwrite_a=True,
                         check_finite=debug,
                         driver='evx' if H.data.size == 1 else 'evd')
                 else:
-                    eps, evecs = linalg.eigh(
+                    if self.xp is cp:
+                        S.invcholesky()
+                        self.tril2full()
+                        eigs = self.eighg(S)
+                        self.data[:] = self.data.T.copy()
+                        return eigs
+                    if debug:
+                        S.data[self.xp.triu_indices(H.shape[0], 1)] = 42.0
+                    eps, evecs = sla.eigh(
                         H.data,
                         S.data,
                         lower=True,
                         overwrite_a=True,
                         overwrite_b=True,
                         check_finite=debug,
-                        subset_by_index=(0, limit - 1) if limit else None,
-                        driver='evx' if H.data.size == 1 else 'evd')
+                        subset_by_index=(0, limit - 1) if limit else None)
                     limit = limit or len(eps)
                     H.data.T[:, :limit] = evecs
             self.dist.comm.broadcast(eps, 0)
         else:
             if slcomm.rank < rows * columns:
                 assert cc
                 assert S is None
@@ -378,49 +418,58 @@
             H.redist(self)
 
         return eps
 
     def eighg(self, L: Matrix, comm2: MPIComm = serial_comm) -> Array1D:
         """Solve generalized eigenvalue problem.
 
-        :::
+        With `H` being self, we solve:::
 
           HC = SCΛ,
 
         where `L` is a lower triangle matrix such that:::
 
              †
           LSL = 1.
 
         The solution has these three steps:::
 
            ~      †   ~~   ~         †~
            H = LHL ,  HC = CΛ,  C = L C.
+
+        Note that `H` must be the full matrix not just half of it!
+
         """
         M, N = self.shape
         assert M == N
         comm = self.dist.comm
 
         if comm2.rank == 0:
             if comm.size == 1:
                 H = self
             else:
                 H = self.new(dist=(comm,))
                 self.redist(H)
             if comm.rank == 0:
+                if self.xp is not np:
+                    return self.dist.eighg(self, L)
                 tmp_MM = np.empty_like(H.data)
                 L_MM = L.data
                 blas.mmm(1.0, L_MM, 'N', H.data, 'N', 0.0, tmp_MM)
                 blas.r2k(0.5, tmp_MM, L_MM, 0.0, H.data)
                 # Ht_MM = L_MM @ self.data @ L_MM.conj().T
-                eig_n, Ct_Mn = linalg.eigh(
+                if SCIPY_VERSION >= [1, 9]:
+                    driver = 'evx' if M == 1 else 'evd'
+                else:
+                    driver = None
+                eig_n, Ct_Mn = sla.eigh(
                     H.data,
                     overwrite_a=True,
                     check_finite=debug,
-                    driver='evx' if M == 1 else 'evd')
+                    driver=driver)
                 assert Ct_Mn.flags.f_contiguous
                 blas.mmm(1.0, L_MM, 'C', Ct_Mn.T, 'T', 0.0, H.data)
                 # self.data[:] = L_MM.T.conj() @ Ct_Mn
             else:
                 eig_n = np.empty(M)
 
             if comm.size > 1:
@@ -433,20 +482,21 @@
         comm2.broadcast(self.data, 0)
 
         return eig_n
 
     def complex_conjugate(self) -> None:
         """Inplace complex conjugation."""
         if self.dtype == complex:
-            np.negative(self.data.imag, self.data.imag)
+            self.xp.negative(self.data.imag, self.data.imag)
 
     def add_hermitian_conjugate(self, scale: float = 1.0) -> None:
         """Add hermitian conjugate to myself."""
         if self.dist.comm.size == 1:
-            self.data *= 0.5
+            if scale != 1.0:
+                self.data *= scale
             self.data += self.data.conj().T
             return
         tmp = self.copy()
         _gpaw.pblas_tran(*self.shape, scale, tmp.data, scale, self.data,
                          self.dist.desc, self.dist.desc, True)
 
     def tril2full(self) -> None:
@@ -464,15 +514,15 @@
         M, N = self.shape
         assert M == N
 
         dist = self.dist
 
         if dist.comm.size == 1 or dist.rows == 1 and dist.columns == 1:
             if dist.comm.rank == 0:
-                u = np.triu_indices(M, 1)
+                u = self.xp.triu_indices(M, 1)
                 self.data[u] = self.data.T[u].conj()
             return
 
         desc = dist.desc
         _gpaw.scalapack_set(self.data, desc, 0.0, 0.0, 'L', M - 1, M - 1, 2, 1)
         buf = self.data.copy()
         # Set diagonal to zero in the copy:
@@ -483,36 +533,48 @@
     def add_to_diagonal(self, d: ArrayLike1D | float) -> None:
         """Add list of numbers or single number to diagonal of matrix."""
         n1, n2 = self.dist.my_row_range()
         M, N = self.shape
         assert M == N
         self.data.ravel()[n1::N + 1] += d
 
+    def to_cpu(self):
+        if isinstance(self.data, np.ndarray):
+            return self
+        return Matrix(*self.shape, data=cp.asnumpy(self.data))
+
 
 def _matrix(M):
     """Dig out Matrix object from wrapper(s)."""
     if isinstance(M, Matrix):
         return M
     return _matrix(M.matrix)
 
 
 class MatrixDistribution:
     comm: MPIComm
     rows: int
     columns: int
     blocksize: int | None  # None means everything on rank=0
     shape: tuple[int, int]
+    full_shape: tuple[int, int]
     desc: Array1D
 
     def matrix(self, dtype=None, data=None):
         return Matrix(*self.full_shape, dtype=dtype, data=data, dist=self)
 
     def multiply(self, alpha, a, opa, b, opb, beta, c, symmetric):
         raise NotImplementedError
 
+    def eighg(self, H, L):
+        raise NotImplementedError
+
+    def new(self, M, N):
+        raise NotImplementedError
+
     def my_row_range(self) -> tuple[int, int]:
         """Return indices for range of my rows.
 
         >>> Matrix(2, 2).dist.my_row_range()
         (0, 2)
         """
         ok = (self.rows == self.comm.size and
@@ -539,14 +601,17 @@
 
     def __str__(self):
         return 'NoDistribution({}x{})'.format(*self.shape)
 
     def global_index(self, n):
         return n
 
+    def new(self, M, N):
+        return NoDistribution(M, N)
+
     def multiply(self, alpha, a, opa, b, opb, beta, c, symmetric):
         if symmetric:
             if opa == 'N':
                 assert opb == 'C' or opb == 'T' and a.dtype == float
                 if a is b:
                     blas.rk(alpha, a.data, beta, c.data)
                 else:
@@ -616,14 +681,20 @@
                           for shape in [self.desc[3:1:-1],
                                         self.shape,
                                         self.desc[5:3:-1]])))
 
     def global_index(self, myi):
         return self.comm.rank * int(self.desc[5]) + myi
 
+    def new(self, M, N):
+        return BLACSDistribution(M, N,
+                                 self.comm,
+                                 self.rows, self.columns,
+                                 self.blocksize)
+
     def multiply(self, alpha, a, opa, b, opb, beta, c, symmetric):
         if symmetric:
             assert opa == 'N'
             assert opb == 'C' or opb == 'T' and a.dtype == float
             N, K = a.shape
             if a is b:
                 _gpaw.pblas_rk(N, K, alpha, a.data,
@@ -657,25 +728,96 @@
 
 
 def create_distribution(M: int,
                         N: int,
                         comm: MPIComm = None,
                         r: int = 1,
                         c: int = 1,
-                        b: int = None) -> MatrixDistribution:
+                        b: int = None,
+                        xp=None) -> MatrixDistribution:
+    if xp is cp:
+        return CuPyDistribution(M, N)
+
     if comm is None or comm.size == 1:
         assert r == 1 and abs(c) == 1 or c == 1 and abs(r) == 1
         return NoDistribution(M, N)
 
     return BLACSDistribution(M, N, comm,
                              r if r != -1 else comm.size,
                              c if c != -1 else comm.size,
                              b)
 
 
+class CuPyDistribution(MatrixDistribution):
+    comm = serial_comm
+    rows = 1
+    columns = 1
+    blocksize = None
+
+    def __init__(self, M, N):
+        self.shape = (M, N)
+        self.full_shape = (M, N)
+
+    def __str__(self):
+        return 'CuPyDistribution({}x{})'.format(*self.shape)
+
+    def global_index(self, n):
+        return n
+
+    def new(self, M, N):
+        return CuPyDistribution(M, N)
+
+    def multiply(self, alpha, a, opa, b, opb, beta, c, *, symmetric=False):
+        if symmetric:
+            if opa == 'N':
+                assert opb == 'C' or opb == 'T' and a.dtype == float
+                if a is b:
+                    cp.cublas.gemm('N', 'H',
+                                   a.data, a.data, c.data,
+                                   alpha, beta)
+                    # cp.cublas.syrk('N', a.data, c.data, alpha, beta, True)
+                else:
+                    if beta == 1.0 and a.shape[1] == 0:
+                        return
+                    cp.cublas.gemm('N', 'H',
+                                   a.data, b.data, c.data,
+                                   0.5 * alpha, beta)
+                    cp.cublas.gemm('N', 'H',
+                                   b.data, a.data, c.data,
+                                   0.5 * alpha, 1.0)
+            else:
+                assert opa == 'C' and opb == 'N'
+                assert a is not b
+                raise NotImplementedError
+                blas.r2k(0.5 * alpha, a.data, b.data, beta, c.data, 'n')
+
+        else:
+            cp.cublas.gemm(opa.replace('C', 'H'),
+                           opb.replace('C', 'H'),
+                           a.data, b.data, c.data,
+                           alpha, beta)
+
+    def eighg(self, H, L):
+        """
+        :::
+
+           ~      †   ~~   ~         †~
+           H = LHL ,  HC = CΛ,  C = L C.
+        """
+        tmp = H.new()
+        self.multiply(1.0, L, 'N', H, 'N', 0.0, tmp)
+        self.multiply(1.0, tmp, 'N', L, 'C', 0.0, H, symmetric=True)
+        eig_M, Ct_MM = cupy_eigh(H.data, UPLO='L')
+        assert Ct_MM.flags.f_contiguous
+        Ct = H.new(data=Ct_MM.T)
+        self.multiply(1.0, L, 'C', Ct, 'T', 0.0, H)
+        # H.complex_conjugate()
+        return eig_M
+
+
 def fastmmm(m1, m2, m3, beta):
     comm = m1.dist.comm
 
     buf1 = m2.data
 
     N = m1.shape[0]
     n = (N + comm.size - 1) // comm.size
```

### Comparing `gpaw-22.8.0/gpaw/core/plane_waves.py` & `gpaw-23.6.0/gpaw/core/plane_waves.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,28 +1,30 @@
 from __future__ import annotations
 
 from math import pi
 
 import _gpaw
-import numpy as np
-
 import gpaw.fftw as fftw
+import numpy as np
+from ase.units import Ha
 from gpaw.core.arrays import DistributedArrays
 from gpaw.core.domain import Domain
 from gpaw.core.matrix import Matrix
 from gpaw.core.pwacf import PlaneWaveAtomCenteredFunctions
 from gpaw.core.uniform_grid import UniformGrid, UniformGridFunctions
 from gpaw.mpi import MPIComm, serial_comm
 from gpaw.new import prod, zip
 from gpaw.pw.descriptor import pad
 from gpaw.typing import (Array1D, Array2D, Array3D, ArrayLike1D, ArrayLike2D,
                          Vector)
 
 
 class PlaneWaves(Domain):
+    itemsize = 16
+
     def __init__(self,
                  *,
                  ecut: float,
                  cell: ArrayLike1D | ArrayLike2D,
                  kpt: Vector = None,
                  comm: MPIComm = serial_comm,
                  dtype=None):
@@ -63,15 +65,17 @@
         self.ekin_G.flags.writeable = False
         # self.myindices_cG = self.indices_cG[:, ng1:ng2]
         self.G_plus_k_Gv = G_plus_k_Gv[ng1:ng2].copy()
 
         self.shape = (ng,)
         self.myshape = (len(self.ekin_G),)
 
-        self.dv = abs(np.linalg.det(self.cell_cv))
+        # Convert from np.float64 to float to avoid fake cupy problem ...
+        # XXX Fix cpupy!!!
+        self.dv = float(abs(np.linalg.det(self.cell_cv)))
 
         self._indices_cache: dict[tuple[int, ...], Array1D] = {}
 
         self.qspiral_v = None
 
     def __repr__(self) -> str:
         m = self.myshape[0]
@@ -80,14 +84,18 @@
             'Domain(',
             f'PlaneWaves(ecut={self.ecut} <coefs={m}/{n}>, ')
         if self.qspiral_v is None:
             return r
         q = self.cell_cv @ self.qspiral_v / (2 * pi)
         return f'{r[:-1]}, qsiral={q}'
 
+    def _short_string(self, global_shape):
+        return (f'plane wave coefficients: {global_shape[-1]}\n'
+                f'cutoff: {self.ecut * Ha} eV\n')
+
     def global_shape(self) -> tuple[int, ...]:
         """Tuple with one element: number of plane waves."""
         return self.shape
 
     def reciprocal_vectors(self) -> Array2D:
         """Returns reciprocal lattice vectors, G + k, in xyz coordinates."""
         return self.G_plus_k_Gv
@@ -101,25 +109,26 @@
             |G+k| / 2
 
         """
         return self.ekin_G
 
     def empty(self,
               dims: int | tuple[int, ...] = (),
-              comm: MPIComm = serial_comm) -> PlaneWaveExpansions:
+              comm: MPIComm = serial_comm,
+              xp=None) -> PlaneWaveExpansions:
         """Create new PlaneWaveExpanions object.
 
         parameters
         ----------
         dims:
             Extra dimensions.
         comm:
             Distribute dimensions along this communicator.
         """
-        return PlaneWaveExpansions(self, dims, comm)
+        return PlaneWaveExpansions(self, dims, comm, xp=xp)
 
     def new(self,
             *,
             ecut: float = None,
             kpt=None,
             comm: MPIComm | str = 'inherit') -> PlaneWaves:
         """Create new plane-wave expansion description."""
@@ -192,32 +201,35 @@
 
     def atom_centered_functions(self,
                                 functions,
                                 positions,
                                 *,
                                 atomdist=None,
                                 integral=None,
-                                cut=False):
+                                cut=False,
+                                xp=None):
         """Create PlaneWaveAtomCenteredFunctions object."""
         if self.qspiral_v is None:
             return PlaneWaveAtomCenteredFunctions(functions, positions, self,
-                                                  atomdist=atomdist)
+                                                  atomdist=atomdist,
+                                                  xp=xp)
 
         from gpaw.new.spinspiral import SpiralPWACF
         return SpiralPWACF(functions, positions, self,
                            atomdist=atomdist,
                            qspiral_v=self.qspiral_v)
 
 
 class PlaneWaveExpansions(DistributedArrays[PlaneWaves]):
     def __init__(self,
                  pw: PlaneWaves,
                  dims: int | tuple[int, ...] = (),
                  comm: MPIComm = serial_comm,
-                 data: np.ndarray = None):
+                 data: np.ndarray = None,
+                 xp=None):
         """Object for storing function(s) as a plane-wave expansions.
 
         parameters
         ----------
         pw:
             Description of plane-waves.
         dims:
@@ -225,25 +237,27 @@
         comm:
             Distribute plane-waves along this communicator.
         data:
             Data array for storage.
         """
         DistributedArrays. __init__(self, dims, pw.myshape,
                                     comm, pw.comm,
-                                    data, pw.dv, complex)
+                                    data, pw.dv, complex, xp)
         self.desc = pw
         self._matrix: Matrix | None
 
     def __repr__(self):
         txt = f'PlaneWaveExpansions(pw={self.desc}, dims={self.dims}'
         if self.comm.size > 1:
             txt += f', comm={self.comm.rank}/{self.comm.size}'
+        if self.xp is not np:
+            txt += ', xp=cp'
         return txt + ')'
 
-    def __getitem__(self, index: int) -> PlaneWaveExpansions:
+    def __getitem__(self, index: int | slice) -> PlaneWaveExpansions:
         data = self.data[index]
         return PlaneWaveExpansions(self.desc, data.shape[:-1], data=data)
 
     def __iter__(self):
         for data in self.data:
             yield PlaneWaveExpansions(self.desc, data.shape[:-1], data=data)
 
@@ -252,15 +266,15 @@
 
         Parameters
         ----------
         data:
             Array to use for storage.
         """
         if data is None:
-            data = np.empty_like(self.data)
+            data = self.xp.empty_like(self.data)
         else:
             # Number of plane-waves depends on the k-point.  We therfore
             # allow for data to be bigger than needed:
             data = data.ravel()[:self.data.size].reshape(self.data.shape)
         return PlaneWaveExpansions(self.desc, self.dims, self.comm, data)
 
     def copy(self):
@@ -288,49 +302,41 @@
             data = data.view(float)
             shape = (shape[0], shape[1] * 2)
 
         self._matrix = Matrix(*shape, data=data, dist=dist)
         return self._matrix
 
     def ifft(self, *, plan=None, grid=None, out=None, periodic=False):
-        """Do inverse FFT to uniform grid.
+        """Do inverse FFT(s) to uniform grid(s).
 
         Parameters
         ----------
         plan:
             Plan for inverse FFT.
         grid:
             Target grid.
         out:
             Target UniformGridFunctions object.
         """
         comm = self.desc.comm
+        xp = self.xp
         if out is None:
-            out = grid.empty(self.dims)
-        assert self.desc.dtype == out.desc.dtype
+            out = grid.empty(self.dims, xp=xp)
+        assert self.desc.dtype == out.desc.dtype, (self.desc, out.desc)
         assert out.desc.pbc_c.all()
         assert comm.size == out.desc.comm.size
 
+        plan = plan or out.desc.fft_plans(xp=xp)
         this = self.gather()
         if this is not None:
-            plan = plan or out.desc.fft_plans()
             for coef_G, out1 in zip(this._arrays(), out.flat()):
-                self.desc.paste(coef_G, plan.tmp_Q)
-                if self.desc.dtype == float:
-                    t = plan.tmp_Q[:, :, 0]
-                    n, m = (s // 2 - 1 for s in out.desc.size_c[:2])
-                    t[0, -m:] = t[0, m:0:-1].conj()
-                    t[n:0:-1, -m:] = t[-n:, m:0:-1].conj()
-                    t[-n:, -m:] = t[n:0:-1, m:0:-1].conj()
-                    t[-n:, 0] = t[n:0:-1, 0].conj()
-                plan.ifft()
-                out1.scatter_from(plan.tmp_R)
+                plan.ifft_sphere(coef_G, self.desc, out1)
         else:
             for out1 in out.flat():
-                out1.scatter_from(None)
+                plan.ifft_sphere(None, self.desc, out1)
 
         if not periodic:
             out.multiply_by_eikr()
 
         return out
 
     def interpolate(self,
@@ -350,95 +356,145 @@
                 return self
             out.data[:] = self.data
             return out
 
         if out is None:
             if comm.rank == 0 or broadcast:
                 pw = self.desc.new(comm=serial_comm)
-                out = pw.empty(self.dims)
+                out = pw.empty(self.dims, xp=self.xp)
             else:
                 out = Empty(self.dims)
 
         if comm.rank == 0:
-            data = np.empty(self.desc.maxmysize * comm.size, complex)
+            data = self.xp.empty(self.desc.maxmysize * comm.size, complex)
         else:
             data = None
 
         for input, output in zip(self._arrays(), out._arrays()):
             mydata = pad(input, self.desc.maxmysize)
             comm.gather(mydata, 0, data)
             if comm.rank == 0:
                 output[:] = data[:len(output)]
 
         if broadcast:
             comm.broadcast(out.data, 0)
 
         return out if not isinstance(out, Empty) else None
 
+    def gather_all(self, out: PlaneWaveExpansions) -> None:
+        """Gather coefficients from self[r] on rank r.
+
+        On rank r, an array of all G-vector coefficients will be returned.
+        These will be gathered from self[r] on all the cores.
+        """
+        assert len(self.dims) == 1
+        pw = self.desc
+        comm = pw.comm
+        if comm.size == 1:
+            out.data[:] = self.data[0]
+            return
+
+        N = self.dims[0]
+        assert N <= comm.size
+
+        ng = pw.shape[0]
+        myng = pw.myshape[0]
+        maxmyng = pw.maxmysize
+
+        ssize_r, soffset_r, rsize_r, roffset_r = a2a_stuff(
+            comm, N, ng, myng, maxmyng)
+
+        comm.alltoallv(self.data, ssize_r, soffset_r,
+                       out.data, rsize_r, roffset_r)
+
     def scatter_from(self, data: Array1D = None) -> None:
         """Scatter data from rank-0 to all ranks."""
         comm = self.desc.comm
         if comm.size == 1:
-            self.data[:] = data
+            assert data is not None
+            self.data[:] = self.xp.asarray(data)
             return
 
         assert self.dims == ()
 
         if comm.rank == 0:
             data = pad(data, comm.size * self.desc.maxmysize)
             comm.scatter(data, self.data, 0)
         else:
-            buf = np.empty(self.desc.maxmysize, complex)
+            buf = self.xp.empty(self.desc.maxmysize, complex)
             comm.scatter(None, buf, 0)
             self.data[:] = buf[:len(self.data)]
 
+    def scatter_from_all(self, a_G: PlaneWaveExpansions) -> None:
+        """Scatter all coefficients from rank r to self on other cores."""
+        assert len(self.dims) == 1
+        pw = self.desc
+        comm = pw.comm
+        if comm.size == 1:
+            self.data[:] = a_G.data
+            return
+
+        N = self.dims[0]
+        assert N <= comm.size
+
+        ng = pw.shape[0]
+        myng = pw.myshape[0]
+        maxmyng = pw.maxmysize
+
+        rsize_r, roffset_r, ssize_r, soffset_r = a2a_stuff(
+            comm, N, ng, myng, maxmyng)
+
+        comm.alltoallv(a_G.data, ssize_r, soffset_r,
+                       self.data, rsize_r, roffset_r)
+
     def integrate(self, other: PlaneWaveExpansions = None) -> np.ndarray:
         """Integral of self or self time cc(other)."""
+        dv = self.dv
         if other is not None:
             assert self.comm.size == 1
             assert self.desc.dtype == other.desc.dtype
             a = self._arrays()
             b = other._arrays()
-            dv = self.dv
             if self.desc.dtype == float:
                 a = a.view(float)
                 b = b.view(float)
                 dv *= 2
             result = a @ b.T.conj()
             if self.desc.dtype == float and self.desc.comm.rank == 0:
-                result -= 0.5 * np.outer(a[:, 0], b[:, 0])
+                result -= 0.5 * a[:, :1] @ b[:, :1].T
             self.desc.comm.sum(result)
-            result.shape = self.dims + other.dims
+            result = result.reshape(self.dims + other.dims)
         else:
-            dv = self.dv
             if self.desc.comm.rank == 0:
                 result = self.data[..., 0]
             else:
-                result = np.empty(self.mydims, complex)
+                result = self.xp.empty(self.mydims, complex)
             self.desc.comm.broadcast(result, 0)
 
         if self.desc.dtype == float:
             result = result.real
+        if result.ndim == 0:
+            result = result.item()  # convert to scalar
         return result * dv
 
     def _matrix_elements_correction(self,
                                     M1: Matrix,
                                     M2: Matrix,
                                     out: Matrix,
                                     symmetric: bool) -> None:
         if self.desc.dtype == float:
             out.data *= 2.0
             if self.desc.comm.rank == 0:
-                correction = np.outer(M1.data[:, 0],
-                                      M2.data[:, 0]) * self.dv
+                correction = M1.data[:, :1] @ M2.data[:, :1].T
                 if symmetric:
-                    correction *= 0.5
+                    correction *= 0.5 * self.dv
                     out.data -= correction
                     out.data -= correction.T
                 else:
+                    correction *= self.dv
                     out.data -= correction
 
     def norm2(self, kind: str = 'normal') -> np.ndarray:
         r"""Calculate integral over cell.
 
         For kind='normal' we calculate:::
 
@@ -455,52 +511,150 @@
           --- > |c |  G V,
            2  --  G
                G
 
         """
         a_xG = self._arrays().view(float)
         if kind == 'normal':
-            result_x = np.einsum('xG, xG -> x', a_xG, a_xG)
+            result_x = self.xp.einsum('xG, xG -> x', a_xG, a_xG)
         elif kind == 'kinetic':
-            a_xG.shape = (len(a_xG), -1, 2)
-            result_x = np.einsum('xGi, xGi, G -> x',
-                                 a_xG, a_xG, self.desc.ekin_G)
+
+            a_xG = a_xG.reshape((len(a_xG), -1, 2))
+            result_x = self.xp.einsum('xGi, xGi, G -> x',
+                                      a_xG,
+                                      a_xG,
+                                      self.xp.asarray(self.desc.ekin_G))
         else:
             1 / 0
         if self.desc.dtype == float:
             result_x *= 2
             if self.desc.comm.rank == 0 and kind == 'normal':
                 result_x -= a_xG[:, 0]**2
         self.desc.comm.sum(result_x)
-        result_x.shape = self.mydims
-        return result_x * self.dv
+        return result_x.reshape(self.mydims) * self.dv
 
     def abs_square(self,
                    weights: Array1D,
-                   out: UniformGridFunctions = None) -> None:
-        """Add weighted absolute square of data to output array."""
-        assert out is not None
-        tmp_R = out.desc.new(dtype=self.desc.dtype).empty()
-        for f, psit_G in zip(weights, self):
-            # Same as (but much faster):
-            # out.data += f * abs(psit.ifft().data)**2
-            psit_G.ifft(out=tmp_R)
-            _gpaw.add_to_density(f, tmp_R.data, out.data)
+                   out: UniformGridFunctions) -> None:
+        """Add weighted absolute square of self to output array.
+
+        With `a_n(G)` being self and `w_n` the weights:::
+
+              _         _    --     -1    _   2
+          out(r) <- out(r) + >  |FFT  [a (G)]| w
+                             --         n       n
+                             n
+
+        """
+        pw = self.desc
+        domain_comm = pw.comm
+        xp = self.xp
+        a_nG = self
+
+        if domain_comm.size == 1:
+            a_R = out.desc.new(dtype=pw.dtype).empty(xp=xp)
+            for weight, a_G in zip(weights, a_nG):
+                if weight == 0.0:
+                    continue
+                a_G.ifft(out=a_R)
+                if xp is np:
+                    _gpaw.add_to_density(weight, a_R.data, out.data)
+                else:
+                    out.data += float(weight) * xp.abs(a_R.data)**2
+            return
+
+        # Undistributed work arrays:
+        a1_R = out.desc.new(comm=None, dtype=pw.dtype).empty(xp=xp)
+        a1_G = pw.new(comm=None).empty(xp=xp)
+        b1_R = out.desc.new(comm=None).zeros(xp=xp)
+
+        (N,) = self.mydims
+        for n1 in range(0, N, domain_comm.size):
+            n2 = min(n1 + domain_comm.size, N)
+            a_nG[n1:n2].gather_all(a1_G)
+            n = n1 + domain_comm.rank
+            if n >= N:
+                continue
+            weight = weights[n]
+            if weight == 0.0:
+                continue
+            a1_G.ifft(out=a1_R)
+            if xp is np:
+                _gpaw.add_to_density(weight, a1_R.data, b1_R.data)
+            else:
+                b1_R.data += float(weight) * xp.abs(a1_R.data)**2
+
+        domain_comm.sum(b1_R.data)
+        b_R = out.new()
+        b_R.scatter_from(b1_R)
+        out.data += b_R.data
 
     def to_pbc_grid(self):
         return self
 
     def randomize(self) -> None:
         """Insert random numbers between -0.5 and 0.5 into data."""
         seed = [self.comm.rank, self.desc.comm.rank]
-        rng = np.random.default_rng(seed)
+        rng = self.xp.random.default_rng(seed)
         a = self.data.view(float)
         rng.random(a.shape, out=a)
         a -= 0.5
 
+    def moment(self):
+        pw = self.desc
+        # Masks:
+        m0_G, m1_G, m2_G = [i_G == 0 for i_G in pw.indices_cG]
+        a_G = self.gather()
+        if a_G is not None:
+            b_G = a_G.data.imag
+            b_cs = [b_G[m1_G & m2_G],
+                    b_G[m0_G & m2_G],
+                    b_G[m0_G & m1_G]]
+            d_c = [b_s[1:] @ (1.0 / np.arange(1, len(b_s)))
+                   for b_s in b_cs]
+            m_v = np.dot(d_c, pw.cell_cv) / pi * pw.dv
+        else:
+            m_v = np.empty(3)
+        pw.comm.broadcast(m_v, 0)
+        return m_v
+
+    def morph(self, pw):
+        pw0 = self.desc
+        out_xG = pw.zeros(self.dims,
+                          comm=self.comm,
+                          xp=self.xp)
+
+        d = {}
+        for G, i_c in enumerate(pw.indices_cG.T):
+            d[tuple(i_c)] = G
+        G_G0 = []
+        G0_G = []
+        for G0, i_c in enumerate(pw0.indices_cG.T):
+            G = d.get(tuple(i_c))
+            if G is not None:
+                G_G0.append(G)
+                G0_G.append(G0)
+
+        out_xG.data[:, G_G0] = self.data[:, G0_G]
+        return out_xG
+
+
+def a2a_stuff(comm, N, ng, myng, maxmyng):
+    """Create arrays for MPI alltoallv call."""
+    ssize_r = np.zeros(comm.size, int)
+    ssize_r[:N] = myng
+    soffset_r = np.arange(comm.size) * myng
+    soffset_r[N:] = 0
+    roffset_r = (np.arange(comm.size) * maxmyng).clip(max=ng)
+    rsize_r = np.zeros(comm.size, int)
+    if comm.rank < N:
+        rsize_r[:-1] = roffset_r[1:] - roffset_r[:-1]
+        rsize_r[-1] = ng - roffset_r[-1]
+    return ssize_r, soffset_r, rsize_r, roffset_r
+
 
 class Empty:
     def __init__(self, dims):
         self.dims = dims
 
     def _arrays(self):
         for _ in range(prod(self.dims)):
@@ -572,75 +726,7 @@
                  ((i_Qc[..., 0] >= 0) & (i_Qc[..., 1] == 0)))
 
     indices = i_Qc[mask]
     ekin = ekin[mask]
     G_plus_k = G_plus_k_Qv[mask]
 
     return G_plus_k, ekin, indices.T
-
-
-x = '''
-class PWMapping:
-    def __init__(self, pw1: PlaneWaves, pw2: PlaneWaves):
-        """Mapping from pd1 to pd2."""
-        N_c = pw1.grid.size
-        N2_c = pw2.grid.size
-        assert pw1.grid.dtype == pw2.grid.dtype
-        if pw1.grid.dtype == float:
-            N_c = N_c.copy()
-            N_c[2] = N_c[2] // 2 + 1
-            N2_c = N2_c.copy()
-            N2_c[2] = N2_c[2] // 2 + 1
-
-        Q1_G = pw1.myindices
-        Q1_Gc = np.empty((len(Q1_G), 3), int)
-        Q1_Gc[:, 0], r_G = divmod(Q1_G, N_c[1] * N_c[2])
-        Q1_Gc.T[1:] = divmod(r_G, N_c[2])
-        if pw1.grid.dtype == float:
-            C = 2
-        else:
-            C = 3
-        Q1_Gc[:, :C] += N_c[:C] // 2
-        Q1_Gc[:, :C] %= N_c[:C]
-        Q1_Gc[:, :C] -= N_c[:C] // 2
-        Q1_Gc[:, :C] %= N2_c[:C]
-        Q2_G = Q1_Gc[:, 2] + N2_c[2] * (Q1_Gc[:, 1] + N2_c[1] * Q1_Gc[:, 0])
-        G2_Q = np.empty(N2_c, int).ravel()
-        G2_Q[:] = -1
-        G2_Q[pw2.myindices] = np.arange(len(pw2.myindices))
-        G2_G1 = G2_Q[Q2_G]
-
-        if pw1.grid.comm.size == 1:
-            self.G2_G1 = G2_G1
-            self.G1 = None
-        else:
-            mask_G1 = (G2_G1 != -1)
-            self.G2_G1 = G2_G1[mask_G1]
-            self.G1 = np.arange(pw1.maxmysize)[mask_G1]
-
-        self.pw1 = pw1
-        self.pw2 = pw2
-
-    def add_to1(self, a_G1, b_G2):
-        """Do a += b * scale, where a is on pd1 and b on pd2."""
-        scale = self.pd1.tmp_R.size / self.pd2.tmp_R.size
-
-        if self.pd1.gd.comm.size == 1:
-            a_G1 += b_G2[self.G2_G1] * scale
-            return
-
-        b_G1 = self.pd1.tmp_G
-        b_G1[:] = 0.0
-        b_G1[self.G1] = b_G2[self.G2_G1]
-        self.pd1.gd.comm.sum(b_G1)
-        ng1 = self.pd1.gd.comm.rank * self.pd1.maxmyng
-        ng2 = ng1 + self.pd1.myng_q[0]
-        a_G1 += b_G1[ng1:ng2] * scale
-
-    def add_to2(self, a2, b1):
-        """Do a += b * scale, where a is on pd2 and b on pd1."""
-        myb = b1.data * (self.pw2.grid.shape[0] / self.pw1.grid.shape[0])
-        if self.desc1.grid.comm.size == 1:
-            a2.data[self.G2_G1] += myb
-        else:
-            1 / 0
-'''
```

### Comparing `gpaw-22.8.0/gpaw/core/pwacf.py` & `gpaw-23.6.0/gpaw/pw/lfc.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,99 +1,87 @@
+from math import factorial as fac
 from math import pi
 
 import _gpaw
 import numpy as np
-from gpaw.core.atom_arrays import AtomArraysLayout, AtomDistribution
-from gpaw.core.atom_centered_functions import AtomCenteredFunctions
+from gpaw.lcao.overlap import fbt
 from gpaw.lfc import BaseLFC
-from gpaw.pw.lfc import ft
 from gpaw.spherical_harmonics import Y, nablarlYL
+from gpaw.spline import Spline
 from gpaw.utilities.blas import mmm
-from gpaw.core.uniform_grid import UniformGridFunctions
-from gpaw.new import prod
 
 
-class PlaneWaveAtomCenteredFunctions(AtomCenteredFunctions):
-    def __init__(self,
-                 functions,
-                 fracpos,
-                 pw,
-                 atomdist=None):
-        AtomCenteredFunctions.__init__(self, functions, fracpos, atomdist)
-        self.pw = pw
+def ft(spline, N=2**10):
+    l = spline.get_angular_momentum_number()
+    rc = 50.0
+    assert spline.get_cutoff() <= rc
+
+    dr = rc / N
+    r_r = np.arange(N) * dr
+    dk = pi / 2 / rc
+    k_q = np.arange(2 * N) * dk
+    f_r = spline.map(r_r) * (4 * pi)
+
+    f_q = fbt(l, f_r, r_r, k_q)
+    f_q[1:] /= k_q[1:]**(2 * l + 1)
+    f_q[0] = (np.dot(f_r, r_r**(2 + 2 * l)) *
+              dr * 2**l * fac(l) / fac(2 * l + 1))
 
-    def _lazy_init(self):
-        if self._lfc is not None:
-            return
-
-        self._lfc = PWLFC(self.functions, self.pw)
-
-        if self._atomdist is None:
-            self._atomdist = AtomDistribution.from_number_of_atoms(
-                len(self.fracpos_ac), self.pw.comm)
-        else:
-            assert self.pw.comm is self._atomdist.comm
-
-        self._lfc.set_positions(self.fracpos_ac, self._atomdist)
-        self._layout = AtomArraysLayout([sum(2 * f.l + 1 for f in funcs)
-                                         for funcs in self.functions],
-                                        self._atomdist,
-                                        self.pw.dtype)
-
-    def to_uniform_grid(self,
-                        out: UniformGridFunctions,
-                        scale: float = 1.0) -> UniformGridFunctions:
-        out_G = self.pw.zeros()
-        self.add_to(out_G, scale)
-        return out_G.ifft(out=out)
+    return Spline(l, k_q[-1], f_q)
 
 
 class PWLFC(BaseLFC):
-    def __init__(self, functions, pw, blocksize=5000):
+    def __init__(self, spline_aj, pd, blocksize=5000, comm=None):
         """Reciprocal-space plane-wave localized function collection.
 
         spline_aj: list of list of spline objects
             Splines.
         pd: PWDescriptor
             Plane-wave descriptor object.
         blocksize: int
             Block-size to use when looping over G-vectors.  Use None for
             doing all G-vectors in one big block.
-        """
+        comm: communicator
+            Communicator for operations that support parallelization
+            over planewaves (only integrate so far)."""
 
-        self.pw = pw
-        self.spline_aj = functions
+        self.pd = pd
+        self.spline_aj = spline_aj
 
-        self.dtype = pw.dtype
+        self.dtype = pd.dtype
 
         self.initialized = False
 
         # These will be filled in later:
-        self.Y_GL = None
-        self.emiGR_Ga = None
-        self.f_Gs = None
+        self.Y_qGL = []
+        self.emiGR_qGa = []
+        self.f_qGs = []
         self.l_s = None
         self.a_J = None
         self.s_J = None
         self.lmax = None
 
         if blocksize is not None:
-            if pw.maxmysize <= blocksize:
+            if pd.ngmax <= blocksize:
                 # No need to block G-vectors
                 blocksize = None
         self.blocksize = blocksize
 
         # These are set later in set_potitions():
-        self.eikR_a = None
+        self.eikR_qa = None
         self.my_atom_indices = None
         self.my_indices = None
         self.pos_av = None
         self.nI = None
 
-        self.comm = pw.comm
+        if comm is None:
+            comm = pd.gd.comm
+        else:
+            assert False
+        self.comm = comm
 
     def initialize(self):
         """Initialize position-independent stuff."""
         if self.initialized:
             return
 
         splines = {}  # Dict[Spline, int]
@@ -101,96 +89,117 @@
             for spline in spline_j:
                 if spline not in splines:
                     splines[spline] = len(splines)
         nsplines = len(splines)
 
         nJ = sum(len(spline_j) for spline_j in self.spline_aj)
 
-        self.f_Gs = np.empty(self.pw.myshape + (nsplines,))
+        self.f_qGs = [np.empty((mynG, nsplines)) for mynG in self.pd.myng_q]
         self.l_s = np.empty(nsplines, np.int32)
         self.a_J = np.empty(nJ, np.int32)
         self.s_J = np.empty(nJ, np.int32)
 
         # Fourier transform radial functions:
         J = 0
         done = set()  # Set[Spline]
         for a, spline_j in enumerate(self.spline_aj):
             for spline in spline_j:
                 s = splines[spline]  # get spline index
                 if spline not in done:
                     f = ft(spline)
-                    G_G = (2 * self.pw.ekin_G)**0.5
-                    self.f_Gs[:, s] = f.map(G_G)
+                    for f_Gs, G2_G in zip(self.f_qGs, self.pd.G2_qG):
+                        G_G = G2_G**0.5
+                        f_Gs[:, s] = f.map(G_G)
                     self.l_s[s] = spline.get_angular_momentum_number()
                     done.add(spline)
                 self.a_J[J] = a
                 self.s_J[J] = s
                 J += 1
 
         self.lmax = max(self.l_s, default=-1)
 
         # Spherical harmonics:
-        G_Gv = self.pw.G_plus_k_Gv
-        self.Y_GL = np.empty((len(G_Gv), (self.lmax + 1)**2))
-        for L in range((self.lmax + 1)**2):
-            self.Y_GL[:, L] = Y(L, *G_Gv.T)
+        for q, K_v in enumerate(self.pd.K_qv):
+            G_Gv = self.pd.get_reciprocal_vectors(q=q)
+            Y_GL = np.empty((len(G_Gv), (self.lmax + 1)**2))
+            for L in range((self.lmax + 1)**2):
+                Y_GL[:, L] = Y(L, *G_Gv.T)
+            self.Y_qGL.append(Y_GL)
 
         self.initialized = True
 
+    def estimate_memory(self, mem):
+        splines = set()
+        lmax = -1
+        for spline_j in self.spline_aj:
+            for spline in spline_j:
+                splines.add(spline)
+                l = spline.get_angular_momentum_number()
+                lmax = max(lmax, l)
+        nbytes = ((len(splines) + (lmax + 1)**2) *
+                  sum(G2_G.nbytes for G2_G in self.pd.G2_qG))
+        mem.subnode('Arrays', nbytes)
+
     def get_function_count(self, a):
         return sum(2 * spline.get_angular_momentum_number() + 1
                    for spline in self.spline_aj[a])
 
-    def set_positions(self, spos_ac, atomdist):
+    def set_positions(self, spos_ac, atom_partition=None):
         self.initialize()
-
-        if self.pw.dtype == float:
-            self.eikR_a = np.ones(len(spos_ac))
+        kd = self.pd.kd
+        if kd is None or kd.gamma:
+            self.eikR_qa = np.ones((1, len(spos_ac)))
         else:
-            self.eikR_a = np.exp(2j * pi * (spos_ac @ self.pw.kpt_c))
+            self.eikR_qa = np.exp(2j * pi * np.dot(kd.ibzk_qc, spos_ac.T))
 
-        self.pos_av = np.dot(spos_ac, self.pw.cell)
+        self.pos_av = np.dot(spos_ac, self.pd.gd.cell_cv)
 
-        Gk_Gv = self.pw.G_plus_k_Gv
-        GkR_Ga = Gk_Gv @ self.pos_av.T
-        self.emiGR_Ga = np.exp(-1j * GkR_Ga) * self.eikR_a
-
-        rank_a = atomdist.rank_a
+        del self.emiGR_qGa[:]
+        G_Qv = self.pd.G_Qv
+        for Q_G in self.pd.myQ_qG:
+            GR_Ga = np.dot(G_Qv[Q_G], self.pos_av.T)
+            self.emiGR_qGa.append(np.exp(-1j * GR_Ga))
+
+        if atom_partition is None:
+            assert self.comm.size == 1
+            rank_a = np.zeros(len(spos_ac), int)
+        else:
+            rank_a = atom_partition.rank_a
 
         self.my_atom_indices = []
         self.my_indices = []
         I1 = 0
         for a, rank in enumerate(rank_a):
             I2 = I1 + self.get_function_count(a)
             if rank == self.comm.rank:
                 self.my_atom_indices.append(a)
                 self.my_indices.append((a, I1, I2))
             I1 = I2
         self.nI = I1
 
-    def expand(self, G1=0, G2=None, cc=False):
+    def expand(self, q=-1, G1=0, G2=None, cc=False):
         """Expand functions in plane-waves.
 
         q: int
             k-point index.
         G1: int
             Start G-vector index.
         G2: int
             End G-vector index.
         cc: bool
             Complex conjugate.
         """
         if G2 is None:
-            G2 = self.Y_GL.shape[0]
+            G2 = self.Y_qGL[q].shape[0]
 
-        emiGR_Ga = self.emiGR_Ga[G1:G2]
-        f_Gs = self.f_Gs[G1:G2]
-        Y_GL = self.Y_GL[G1:G2]
+        emiGR_Ga = self.emiGR_qGa[q][G1:G2]
+        f_Gs = self.f_qGs[q][G1:G2]
+        Y_GL = self.Y_qGL[q][G1:G2]
 
-        if self.dtype == complex:
+        if self.pd.dtype == complex:
             f_GI = np.empty((G2 - G1, self.nI), complex)
         else:
             # Special layout because BLAS does not have real-complex
             # multiplications.  f_GI(G,I) layout:
             #
             #    real(G1, 0),   real(G1, 1),   ...
             #    imag(G1, 0),   imag(G1, 1),   ...
@@ -221,16 +230,16 @@
         if cc:
             f_GI = f_GI.conj()
         if self.pd.dtype == float:
             f_GI = f_GI.T.copy().view(float).T.copy()
 
         return f_GI
 
-    def block(self, ensure_same_number_of_blocks=False):
-        nG = self.Y_GL.shape[0]
+    def block(self, q=-1, ensure_same_number_of_blocks=False):
+        nG = self.Y_qGL[q].shape[0]
         B = self.blocksize
         if B:
             G1 = 0
             while G1 < nG:
                 G2 = min(G1 + B, nG)
                 yield G1, G2
                 G1 = G2
@@ -239,116 +248,127 @@
                 nb = (self.pd.maxmyng + B - 1) // B
                 mynb = (nG + B - 1) // B
                 if mynb < nb:
                     yield nG, nG  # empty block
         else:
             yield 0, nG
 
-    def add(self, a_xG, c_axi=1.0, q=None):
-        c_xI = np.empty(a_xG.shape[:-1] + (self.nI,), self.dtype)
+    def add(self, a_xG, c_axi=1.0, q=-1, f0_IG=None):
+        c_xI = np.empty(a_xG.shape[:-1] + (self.nI,), self.pd.dtype)
 
         if isinstance(c_axi, float):
-            assert a_xG.ndim == 1
+            assert q == -1 and a_xG.ndim == 1
             c_xI[:] = c_axi
         else:
+            assert q != -1 or self.pd.only_one_k_point
             if self.comm.size != 1:
                 c_xI[:] = 0.0
             for a, I1, I2 in self.my_indices:
-                c_xI[..., I1:I2] = c_axi[a] * self.eikR_a[a].conj()
+                c_xI[..., I1:I2] = c_axi[a] * self.eikR_qa[q][a].conj()
             if self.comm.size != 1:
                 self.comm.sum(c_xI)
 
-        nx = prod(c_xI.shape[:-1])
+        nx = np.prod(c_xI.shape[:-1], dtype=int)
         c_xI = c_xI.reshape((nx, self.nI))
-        a_xG = a_xG.reshape((nx, a_xG.shape[-1])).view(self.dtype)
+        a_xG = a_xG.reshape((nx, a_xG.shape[-1])).view(self.pd.dtype)
 
-        for G1, G2 in self.block():
-            f_GI = self.expand(G1, G2, cc=False)
+        for G1, G2 in self.block(q):
+            if f0_IG is None:
+                f_GI = self.expand(q, G1, G2, cc=False)
+            else:
+                1 / 0
+                # f_IG = f0_IG
 
-            if self.dtype == float:
+            if self.pd.dtype == float:
                 # f_IG = f_IG.view(float)
                 G1 *= 2
                 G2 *= 2
 
-            mmm(1.0 / self.pw.dv, c_xI, 'N', f_GI, 'T',
+            mmm(1.0 / self.pd.gd.dv, c_xI, 'N', f_GI, 'T',
                 1.0, a_xG[:, G1:G2])
 
     def integrate(self, a_xG, c_axi=None, q=-1):
-        c_xI = np.zeros(a_xG.shape[:-1] + (self.nI,), self.dtype)
+        c_xI = np.zeros(a_xG.shape[:-1] + (self.nI,), self.pd.dtype)
 
-        nx = prod(c_xI.shape[:-1])
+        nx = np.prod(c_xI.shape[:-1], dtype=int)
         b_xI = c_xI.reshape((nx, self.nI))
         a_xG = a_xG.reshape((nx, a_xG.shape[-1]))
 
-        alpha = 1.0  # / self.pd.gd.N_c.prod()
-        if self.dtype == float:
+        alpha = 1.0 / self.pd.gd.N_c.prod()
+        if self.pd.dtype == float:
             alpha *= 2
             a_xG = a_xG.view(float)
 
         if c_axi is None:
             c_axi = self.dict(a_xG.shape[:-1])
 
         x = 0.0
-        for G1, G2 in self.block():
-            f_GI = self.expand(G1, G2, cc=self.dtype == complex)
-            if self.dtype == float:
+        for G1, G2 in self.block(q):
+            f_GI = self.expand(q, G1, G2, cc=self.pd.dtype == complex)
+            if self.pd.dtype == float:
                 if G1 == 0 and self.comm.rank == 0:
                     f_GI[0] *= 0.5
                 G1 *= 2
                 G2 *= 2
             mmm(alpha, a_xG[:, G1:G2], 'N', f_GI, 'N', x, b_xI)
             x = 1.0
 
         self.comm.sum(b_xI)
         for a, I1, I2 in self.my_indices:
-            c_axi[a][:] = self.eikR_a[a] * c_xI[..., I1:I2]
+            c_axi[a][:] = self.eikR_qa[q][a] * c_xI[..., I1:I2]
 
         return c_axi
 
+    def matrix_elements(self, psit, out):
+        P_ani = {a: P_in.T for a, P_in in out.items()}
+        self.integrate(psit.array, P_ani, psit.kpt)
+
     def derivative(self, a_xG, c_axiv=None, q=-1):
-        c_vxI = np.zeros((3,) + a_xG.shape[:-1] + (self.nI,), self.dtype)
-        nx = prod(c_vxI.shape[1:-1])
+        c_vxI = np.zeros((3,) + a_xG.shape[:-1] + (self.nI,), self.pd.dtype)
+        nx = np.prod(c_vxI.shape[1:-1], dtype=int)
         b_vxI = c_vxI.reshape((3, nx, self.nI))
-        a_xG = a_xG.reshape((nx, a_xG.shape[-1])).view(self.dtype)
+        a_xG = a_xG.reshape((nx, a_xG.shape[-1])).view(self.pd.dtype)
 
-        alpha = 1.0
+        alpha = 1.0 / self.pd.gd.N_c.prod()
 
         if c_axiv is None:
             c_axiv = self.dict(a_xG.shape[:-1], derivative=True)
 
+        K_v = self.pd.K_qv[q]
+
         x = 0.0
-        for G1, G2 in self.block():
-            f_GI = self.expand(G1, G2, cc=True)
-            G_Gv = self.pw.G_plus_k_Gv[G1:G2]
-            if self.dtype == float:
+        for G1, G2 in self.block(q):
+            f_GI = self.expand(q, G1, G2, cc=True)
+            G_Gv = self.pd.G_Qv[self.pd.myQ_qG[q][G1:G2]]
+            if self.pd.dtype == float:
                 d_GI = np.empty_like(f_GI)
                 for v in range(3):
                     d_GI[::2] = f_GI[1::2] * G_Gv[:, v, np.newaxis]
                     d_GI[1::2] = f_GI[::2] * G_Gv[:, v, np.newaxis]
                     mmm(2 * alpha,
                         a_xG[:, 2 * G1:2 * G2], 'N',
                         d_GI, 'N',
                         x, b_vxI[v])
             else:
                 for v in range(3):
                     mmm(-alpha,
                         a_xG[:, G1:G2], 'N',
-                        f_GI * G_Gv[:, v, np.newaxis], 'N',
+                        f_GI * (G_Gv[:, v] + K_v[v])[:, np.newaxis], 'N',
                         x, b_vxI[v])
             x = 1.0
 
         self.comm.sum(c_vxI)
 
         for v in range(3):
-            if self.dtype == float:
+            if self.pd.dtype == float:
                 for a, I1, I2 in self.my_indices:
                     c_axiv[a][..., v] = c_vxI[v, ..., I1:I2]
             else:
                 for a, I1, I2 in self.my_indices:
-                    c_axiv[a][..., v] = (1.0j * self.eikR_a[a] *
+                    c_axiv[a][..., v] = (1.0j * self.eikR_qa[q][a] *
                                          c_vxI[v, ..., I1:I2])
 
         return c_axiv
 
     def stress_tensor_contribution(self, a_xG, c_axi=1.0, q=-1):
         cache = {}
         things = []
@@ -380,15 +400,15 @@
 
         if isinstance(c_axi, float):
             c_axi = dict((a, c_axi) for a in range(len(self.pos_av)))
 
         G0_Gv = self.pd.get_reciprocal_vectors(q=q)
 
         stress_vv = np.zeros((3, 3))
-        for G1, G2 in self.block(ensure_same_number_of_blocks=True):
+        for G1, G2 in self.block(q, ensure_same_number_of_blocks=True):
             G_Gv = G0_Gv[G1:G2]
             Z_LvG = np.array([nablarlYL(L, G_Gv.T)
                               for L in range((lmax + 1)**2)])
             aa_xG = a_xG[..., G1:G2]
             for v1 in range(3):
                 for v2 in range(3):
                     stress_vv[v1, v2] += self._stress_tensor_contribution(
@@ -409,15 +429,15 @@
             f_IG[I1:I2] = (emiGR_Ga[:, a] * (-1.0j)**l *
                            (dfdGoG_G[G1:G2] * G_Gv[:, v1] * G_Gv[:, v2] *
                             Y_LG[L1:L2, G1:G2] +
                             f_G[G1:G2] * G_Gv[:, v1] * Z_LvG[L1:L2, v2]))
 
         c_xI = np.zeros(a_xG.shape[:-1] + (self.nI,), self.pd.dtype)
 
-        x = prod(c_xI.shape[:-1])
+        x = np.prod(c_xI.shape[:-1], dtype=int)
         b_xI = c_xI.reshape((x, self.nI))
         a_xG = a_xG.reshape((x, a_xG.shape[-1]))
 
         alpha = 1.0 / self.pd.gd.N_c.prod()
         if self.pd.dtype == float:
             alpha *= 2
             if G1 == 0 and self.pd.gd.comm.rank == 0:
```

### Comparing `gpaw-22.8.0/gpaw/core/uniform_grid.py` & `gpaw-23.6.0/gpaw/core/uniform_grid.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,37 +1,38 @@
 from __future__ import annotations
 
 from math import pi
 from typing import Sequence
 
+import numpy as np
+
 import _gpaw
 import gpaw.fftw as fftw
-import numpy as np
 from gpaw.core.arrays import DistributedArrays
 from gpaw.core.atom_centered_functions import UniformGridAtomCenteredFunctions
 from gpaw.core.domain import Domain
+from gpaw.gpu import as_xp
 from gpaw.grid_descriptor import GridDescriptor
 from gpaw.mpi import MPIComm, serial_comm
-from gpaw.new import cached_property
+from gpaw.new import cached_property, zip
 from gpaw.typing import (Array1D, Array2D, Array3D, Array4D, ArrayLike1D,
                          ArrayLike2D, Vector)
-from gpaw.new import zip
 
 
 class UniformGrid(Domain):
     def __init__(self,
                  *,
                  cell: ArrayLike1D | ArrayLike2D,
                  size: ArrayLike1D,
                  pbc=(True, True, True),
                  kpt: Vector = None,
                  comm: MPIComm = serial_comm,
                  decomp: Sequence[Sequence[int]] = None,
                  dtype=None):
-        """Description of 3-D uniform grid.
+        """Description of 3D uniform grid.
 
         parameters
         ----------
         cell:
             Unit cell given as three floats (orthorhombic grid), six floats
             (three lengths and the angles in degrees) or a 3x3 matrix.
         size:
@@ -65,15 +66,17 @@
                                for d_p, p
                                in zip(self.decomp_cp, self.mypos_c)])
         self.mysize_c = self.end_c - self.start_c
 
         Domain.__init__(self, cell, pbc, kpt, comm, dtype)
         self.myshape = tuple(self.mysize_c)
 
-        self.dv = abs(np.linalg.det(self.cell_cv)) / self.size_c.prod()
+        self.dv = self.volume / self.size_c.prod()
+
+        self.itemsize = 8 if self.dtype == float else 16
 
     @property
     def size(self):
         """Size of uniform grid."""
         return self.size_c.copy()
 
     def global_shape(self) -> tuple[int, ...]:
@@ -81,22 +84,25 @@
         return tuple(self.size_c - 1 + self.pbc_c)
 
     def __repr__(self):
         return Domain.__repr__(self).replace(
             'Domain(',
             f'UniformGrid(size={self.size_c.tolist()}, ')
 
+    def _short_string(self, global_shape):
+        return f'uniform wave function grid shape: {global_shape}'
+
     @cached_property
     def phase_factors_cd(self):
         """Phase factor for block-boundary conditions."""
-        delta_d = np.array([1, -1])
+        delta_d = np.array([-1, 1])
         disp_cd = np.empty((3, 2))
         for pos, pbc, size, disp_d in zip(self.mypos_c, self.pbc_c,
                                           self.parsize_c, disp_cd):
-            disp_d[:] = (pos + delta_d) // size
+            disp_d[:] = -((pos + delta_d) // size)
         return np.exp(2j * np.pi *
                       disp_cd *
                       self.kpt_c[:, np.newaxis])
 
     def new(self,
             size=None,
             pbc=None,
@@ -116,25 +122,26 @@
                            if kpt is None else kpt,
                            comm=comm or serial_comm,
                            decomp=decomp,
                            dtype=self.dtype if dtype is None else dtype)
 
     def empty(self,
               dims: int | tuple[int, ...] = (),
-              comm: MPIComm = serial_comm) -> UniformGridFunctions:
+              comm: MPIComm = serial_comm,
+              xp=np) -> UniformGridFunctions:
         """Create new UniformGridFunctions object.
 
         parameters
         ----------
         dims:
             Extra dimensions.
         comm:
             Distribute dimensions along this communicator.
         """
-        return UniformGridFunctions(self, dims, comm)
+        return UniformGridFunctions(self, dims, comm, xp=xp)
 
     def blocks(self, data: np.ndarray):
         """Yield views of blocks of data."""
         s0, s1, s2 = self.parsize_c
         d0_p, d1_p, d2_p = (d_p - d_p[0] for d_p in self.decomp_cp)
         for p0 in range(s0):
             b0, e0 = d0_p[p0:p0 + 2]
@@ -152,19 +159,24 @@
 
     def atom_centered_functions(self,
                                 functions,
                                 positions,
                                 *,
                                 atomdist=None,
                                 integral=None,
-                                cut=False):
+                                cut=False,
+                                xp=None):
         """Create UniformGridAtomCenteredFunctions object."""
-        return UniformGridAtomCenteredFunctions(functions, positions, self,
+        return UniformGridAtomCenteredFunctions(functions,
+                                                positions,
+                                                self,
                                                 atomdist=atomdist,
-                                                integral=integral, cut=cut)
+                                                integral=integral,
+                                                cut=cut,
+                                                xp=xp)
 
     def transformer(self, other: UniformGrid, stencil_range=3):
         """Create transformer from one grid to another.
 
         (for interpolation and restriction).
         """
         from gpaw.transformers import Transformer
@@ -229,35 +241,42 @@
                                    kpt: Vector = None,
                                    comm: MPIComm = serial_comm,
                                    dtype=None) -> UniformGrid:
         """Create UniformGrid from grid-spacing."""
         domain = Domain(cell, pbc, kpt, comm, dtype)
         return domain.uniform_grid_with_grid_spacing(grid_spacing)
 
-    def fft_plans(self, flags: int = fftw.MEASURE) -> fftw.FFTPlans:
+    def fft_plans(self,
+                  flags: int = fftw.MEASURE,
+                  xp=np) -> fftw.FFTPlans:
         """Create FFTW-plans."""
         if self.comm.rank == 0:
-            return fftw.create_plans(self.size_c, self.dtype, flags)
+            return fftw.create_plans(self.size_c, self.dtype, flags, xp)
         else:
-            return fftw.FFTPlans([0, 0, 0], self.dtype)
+            return fftw.create_plans([0, 0, 0], self.dtype)
 
     def ranks_from_fractional_positions(self,
                                         fracpos_ac: Array2D) -> Array1D:
         rank_ac = np.floor(fracpos_ac * self.parsize_c).astype(int)
         if (rank_ac < 0).any() or (rank_ac >= self.parsize_c).any():
             raise ValueError('Positions outside cell!')
         return np.ravel_multi_index(rank_ac.T, self.parsize_c)  # type: ignore
 
+    def ecut_max(self):
+        dv_cv = self.cell_cv / self.size_c[:, np.newaxis]
+        return 0.5 * np.pi**2 / (dv_cv**2).sum(1).max()
+
 
 class UniformGridFunctions(DistributedArrays[UniformGrid]):
     def __init__(self,
                  grid: UniformGrid,
                  dims: int | tuple[int, ...] = (),
                  comm: MPIComm = serial_comm,
-                 data: np.ndarray = None):
+                 data: np.ndarray = None,
+                 xp=None):
         """Object for storing function(s) on a uniform grid.
 
         parameters
         ----------
         grid:
             Description of uniform grid.
         dims:
@@ -265,33 +284,35 @@
         comm:
             Distribute dimensions along this communicator.
         data:
             Data array for storage.
         """
         DistributedArrays. __init__(self, dims, grid.myshape,
                                     comm, grid.comm, data, grid.dv,
-                                    grid.dtype)
+                                    grid.dtype, xp)
         self.desc = grid
 
     def __repr__(self):
         txt = f'UniformGridFunctions(grid={self.desc}, dims={self.dims}'
         if self.comm.size > 1:
             txt += f', comm={self.comm.rank}/{self.comm.size}'
+        if self.xp is not np:
+            txt += ', xp=cp'
         return txt + ')'
 
     def new(self, data=None):
         """Create new UniforGridFunctions object of same kind.
 
         Parameters
         ----------
         data:
             Array to use for storage.
         """
         if data is None:
-            data = np.empty_like(self.data)
+            data = self.xp.empty_like(self.data)
         return UniformGridFunctions(self.desc, self.dims, self.comm, data)
 
     def __getitem__(self, index):
         data = self.data[index]
         return UniformGridFunctions(data=data,
                                     dims=data.shape[:-3],
                                     grid=self.desc)
@@ -330,15 +351,15 @@
         index = tuple([slice(0, None) if axis is None else axis
                        for axis in axes])
         y = self.data[index]  # type: ignore
         c = axes[-3:].index(...)
         grid = self.desc
         dx = (grid.cell_cv[c]**2).sum()**0.5 / grid.size_c[c]
         x = np.arange(grid.start_c[c], grid.end_c[c]) * dx
-        return x, y
+        return x, as_xp(y, np)
 
     def scatter_from(self, data=None):
         """Scatter data from rank-0 to all ranks."""
         if isinstance(data, UniformGridFunctions):
             data = data.data
         comm = self.desc.comm
         if comm.size == 1:
@@ -369,30 +390,30 @@
         assert out is None
         comm = self.desc.comm
         if comm.size == 1:
             return self
 
         if broadcast or comm.rank == 0:
             grid = self.desc.new(comm=serial_comm)
-            out = grid.empty(self.dims)
+            out = grid.empty(self.dims, xp=self.xp)
 
         if comm.rank != 0:
             # There can be several sends before the corresponding receives
             # are posted, so use syncronous send here
             comm.ssend(self.data, 0, 301)
             if broadcast:
                 comm.broadcast(out.data, 0)
                 return out
             return
 
         # Put the subdomains from the slaves into the big array
         # for the whole domain:
         for rank, block in enumerate(self.desc.blocks(out.data)):
             if rank != 0:
-                buf = np.empty_like(block)
+                buf = self.xp.empty_like(block)
                 comm.receive(buf, rank, 301)
                 block[:] = buf
             else:
                 block[:] = self.data
 
         if broadcast:
             comm.broadcast(out.data, 0)
@@ -408,25 +429,23 @@
           / _  iG.r  _
           |dr e    f(r)
           /
         """
         assert self.dims == ()
         if out is None:
             assert pw is not None
-            out = pw.empty()
+            out = pw.empty(xp=self.xp)
         if pw is None:
             pw = out.desc
         input = self
         if self.desc.comm.size > 1:
             input = input.gather()
         if self.desc.comm.rank == 0:
-            plan = plan or self.desc.fft_plans()
-            plan.tmp_R[:] = input.data
-            plan.fft()
-            coefs = pw.cut(plan.tmp_Q) * (1 / plan.tmp_R.size)
+            plan = plan or self.desc.fft_plans(xp=self.xp)
+            coefs = plan.fft_sphere(input.data, pw)
         else:
             coefs = None
 
         out.scatter_from(coefs)
 
         return out
 
@@ -444,47 +463,48 @@
         for a_R in arrays_xR:
             norm_x.append(np.vdot(a_R, a_R).real * self.desc.dv)
         result = np.array(norm_x).reshape(self.mydims)
         self.desc.comm.sum(result)
         return result
 
     def integrate(self, other=None):
-        """Integral of self or self time cc(other)."""
+        """Integral of self or self times cc(other)."""
         if other is not None:
             assert self.desc.dtype == other.desc.dtype
             a_xR = self._arrays()
             b_yR = other._arrays()
             a_xR = a_xR.reshape((len(a_xR), -1))
             b_yR = b_yR.reshape((len(b_yR), -1))
             result = (a_xR @ b_yR.T.conj()).reshape(self.dims + other.dims)
         else:
-            result = self.data.sum(axis=(-3, -2, -1))
+            # Make sure we have an array and not a scalar!
+            result = self.xp.asarray(self.data.sum(axis=(-3, -2, -1)))
 
+        self.desc.comm.sum(result)
         if result.ndim == 0:
-            result = self.desc.comm.sum(result.item())
-        else:
-            self.desc.comm.sum(result)
-
+            result = result.item()  # convert to scalar
         return result * self.desc.dv
 
     def to_pbc_grid(self):
         """Convert to UniformGrud with ``pbc=(True, True, True)``."""
         if self.desc.pbc_c.all():
             return self
         grid = self.desc.new(pbc=True)
         new = grid.empty(self.dims)
         new.data[:] = 0.0
         i, j, k = self.desc.start_c
         new.data[..., i:, j:, k:] = self.data
         return new
 
-    def multiply_by_eikr(self, kpt_c=None):
+    def multiply_by_eikr(self, kpt_c: Vector = None) -> None:
         """Multiply by `exp(ik.r)`."""
         if kpt_c is None:
             kpt_c = self.desc.kpt_c
+        else:
+            kpt_c = np.asarray(kpt_c)
         if kpt_c.any():
             self.data *= self.desc.eikr(kpt_c)
 
     def interpolate(self,
                     plan1: fftw.FFTPlans = None,
                     plan2: fftw.FFTPlans = None,
                     grid: UniformGrid = None,
@@ -501,15 +521,15 @@
             Target grid.
         out:
             Target UniformGridFunctions object.
         """
         if out is None:
             if grid is None:
                 raise ValueError('Please specify "grid" or "out".')
-            out = grid.empty(self.dims)
+            out = grid.empty(self.dims, xp=self.xp)
 
         if not out.desc.pbc_c.all() or not self.desc.pbc_c.all():
             raise ValueError('Grids must have pbc=True!')
 
         if self.desc.comm.size > 1:
             input = self.gather()
             if input:
@@ -521,16 +541,16 @@
             return out
 
         size1_c = self.desc.size_c
         size2_c = out.desc.size_c
         if (size2_c <= size1_c).any():
             raise ValueError('Too few points in target grid!')
 
-        plan1 = plan1 or self.desc.fft_plans()
-        plan2 = plan2 or out.desc.fft_plans()
+        plan1 = plan1 or self.desc.fft_plans(xp=self.xp)
+        plan2 = plan2 or out.desc.fft_plans(xp=self.xp)
 
         if self.dims:
             for input, output in zip(self.flat(), out.flat()):
                 input.interpolate(plan1, plan2, grid, output)
             return out
 
         plan1.tmp_R[:] = self.data
@@ -550,15 +570,15 @@
             b2 = (b2 - a2) // 2 + 1
             a2 = 0
             axes = [0, 1]
         else:
             axes = [0, 1, 2]
 
         b_Q[:] = 0.0
-        b_Q[a0:b0, a1:b1, a2:b2] = np.fft.fftshift(a_Q, axes=axes)
+        b_Q[a0:b0, a1:b1, a2:b2] = self.xp.fft.fftshift(a_Q, axes=axes)
 
         if e0:
             b_Q[a0, a1:b1, a2:b2] *= 0.5
             b_Q[b0, a1:b1, a2:b2] = b_Q[a0, a1:b1, a2:b2]
             b0 += 1
         if e1:
             b_Q[a0:b0, a1, a2:b2] *= 0.5
@@ -568,15 +588,15 @@
             if e2:
                 b_Q[a0:b0, a1:b1, a2] *= 0.5
                 b_Q[a0:b0, a1:b1, b2] = b_Q[a0:b0, a1:b1, a2]
         else:
             if e2:
                 b_Q[a0:b0, a1:b1, b2 - 1] *= 0.5
 
-        b_Q[:] = np.fft.ifftshift(b_Q, axes=axes)
+        b_Q[:] = self.xp.fft.ifftshift(b_Q, axes=axes)
         plan2.ifft()
         out.data[:] = plan2.tmp_R
         out.data *= (1.0 / self.data.size)
         out.multiply_by_eikr()
         return out
 
     def fft_restrict(self,
@@ -596,15 +616,15 @@
             Target grid.
         out:
             Target UniformGridFunctions object.
         """
         if out is None:
             if grid is None:
                 raise ValueError('Please specify "grid" or "out".')
-            out = grid.empty()
+            out = grid.empty(xp=self.xp)
 
         if not out.desc.pbc_c.all() or not self.desc.pbc_c.all():
             raise ValueError('Grids must have pbc=True!')
 
         if self.desc.comm.size > 1:
             input = self.gather()
             if input:
@@ -633,15 +653,15 @@
             b2 = size2_c[2] // 2 + 1
             a2 = 0
             axes = [0, 1]
         else:
             axes = [0, 1, 2]
 
         plan1.fft()
-        b_Q[:] = np.fft.fftshift(b_Q, axes=axes)
+        b_Q[:] = self.xp.fft.fftshift(b_Q, axes=axes)
 
         if e0:
             b_Q[a0, a1:b1, a2:b2] += b_Q[b0 - 1, a1:b1, a2:b2]
             b_Q[a0, a1:b1, a2:b2] *= 0.5
             b0 -= 1
         if e1:
             b_Q[a0:b0, a1, a2:b2] += b_Q[a0:b0, b1 - 1, a2:b2]
@@ -649,15 +669,15 @@
             b1 -= 1
         if self.desc.dtype == complex and e2:
             b_Q[a0:b0, a1:b1, a2] += b_Q[a0:b0, a1:b1, b2 - 1]
             b_Q[a0:b0, a1:b1, a2] *= 0.5
             b2 -= 1
 
         a_Q[:] = b_Q[a0:b0, a1:b1, a2:b2]
-        a_Q[:] = np.fft.ifftshift(a_Q, axes=axes)
+        a_Q[:] = self.xp.fft.ifftshift(a_Q, axes=axes)
         plan2.ifft()
         out.data[:] = plan2.tmp_R
         out.data *= (1.0 / self.data.size)
         return out
 
     def abs_square(self,
                    weights: Array1D,
@@ -674,22 +694,25 @@
             return
 
         a_xR = self.gather()
 
         if a_xR is None:
             b_xR = None
         else:
+            if self.xp is not np:
+                a_xR = a_xR.to_xp(np)
             b_xR = a_xR.new()
             t_sc = (translation_sc * self.desc.size_c).round().astype(int)
             offset_c = 1 - self.desc.pbc_c
             for a_R, b_R in zip(a_xR._arrays(), b_xR._arrays()):
                 b_R[:] = 0.0
                 for r_cc, t_c in zip(rotation_scc, t_sc):
                     _gpaw.symmetrize_ft(a_R, b_R, r_cc, t_c, offset_c)
-
+            if self.xp is not np:
+                b_xR = b_xR.to_xp(self.xp)
         self.scatter_from(b_xR)
 
         self.data *= 1.0 / len(rotation_scc)
 
     def randomize(self) -> None:
         """Insert random numbers between -0.5 and 0.5 into data."""
         seed = [self.comm.rank, self.desc.comm.rank]
@@ -714,14 +737,16 @@
                 index_r %= size
                 index_r += corner
 
         rho_ijk = self.data
         rho_ij = rho_ijk.sum(axis=2)
         rho_ik = rho_ijk.sum(axis=1)
         rho_cr = [rho_ij.sum(axis=1), rho_ij.sum(axis=0), rho_ik.sum(axis=0)]
+        if self.xp is not np:
+            rho_cr = [rho_r.get() for rho_r in rho_cr]
 
         d_c = [index_r @ rho_r for index_r, rho_r in zip(index_cr, rho_cr)]
         d_v = (d_c / ug.size_c) @ ug.cell_cv * self.dv
         self.desc.comm.sum(d_v)
         return d_v
 
     def scaled(self, s: float, v: float = 1.0):
```

### Comparing `gpaw-22.8.0/gpaw/coulomb.py` & `gpaw-23.6.0/gpaw/coulomb.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/data/g2_1_ref.py` & `gpaw-23.6.0/gpaw/data/g2_1_ref.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/defects/__init__.py` & `gpaw-23.6.0/gpaw/defects/__init__.py`

 * *Files 2% similar despite different names*

```diff
@@ -3,14 +3,15 @@
 from scipy.optimize import minimize
 from scipy.integrate import simps
 from gpaw import GPAW, PW
 from ase.parallel import parprint
 import scipy.integrate as integrate
 from scipy.interpolate import InterpolatedUnivariateSpline
 from ase.units import Hartree as Ha
+from ase.units import Bohr
 
 
 class ElectrostaticCorrections():
     """
     Calculate the electrostatic corrections for charged defects.
     """
     def __init__(self, pristine, charged,
@@ -34,23 +35,21 @@
         self.q = q
         self.sigma = sigma
         self.dimensionality = dimensionality
 
         self.pd = self.calc.wfs.pd
         self.L = self.pd.gd.cell_cv[2, 2]
         if r0 is not None:
-            self.r0 = r0
+            self.r0 = np.array(r0) / Bohr
         elif dimensionality == '2d':
             self.r0 = np.array([0, 0, self.L / 2])
         else:
             self.r0 = np.array([0, 0, 0])
         self.z0 = self.r0[2]
-
-        self.G_Gv = self.pd.get_reciprocal_vectors(q=0,
-                                                   add_q=False)  # G in Bohr^-1
+        self.G_Gv = self.pd.get_reciprocal_vectors(q=0, add_q=False)
         self.G2_G = self.pd.G2_qG[0]  # |\vec{G}|^2 in Bohr^-2
         self.rho_G = self.calculate_gaussian_density()
         self.Omega = abs(np.linalg.det(self.calc.density.gd.cell_cv))
         self.data = None
         self.El = None
 
         # For the 2D case, we assume that the dielectric profile epsilon(z)
@@ -63,15 +62,15 @@
         self.density_1d = np.array([transformer(x) for x in fine_z])
 
         # We potentially have two z axes -- one on the original calculation,
         # and one on the calculator we just set up.
         self.z_g = fine_z
         self.density_z = coarse_z
 
-        self.G_z = find_G_z(self.pd)
+        self.G_z = find_G_z(self.G_Gv)
         self.G_parallel = np.unique(self.G_Gv[:, :2], axis=0)
         self.GG = np.outer(self.G_z, self.G_z)  # G * Gprime
 
         # We need the G_z vectors on the finely sampled grid, to calculate
         # epsilon(G - G'), which goes up to 2G_max in magnitude.
         self.G_z_fine = (np.fft.fftfreq(len(fine_z)) *
                          2 * np.pi / (self.L) * len(fine_z))
@@ -222,15 +221,15 @@
                     + np.dot(vector, vector) * self.epsilon_GG['in-plane'])
             if np.allclose(vector, 0):
                 A_GG[0, 0] = 1  # The d.c. potential is poorly defined
             V_G = np.linalg.solve(A_GG, rho_G)
             if np.allclose(vector, 0):
                 parprint('Skipping G^2=0 contribution to Elp')
                 V_G[0] = 0
-            Elp += (rho_G * V_G).sum()
+            Elp += (rho_G * V_G).sum().real
 
         Elp *= 2.0 * np.pi * Ha / self.Omega
 
         self.Elp = Elp
         return Elp
 
     def calculate_isolated_correction(self):
@@ -257,15 +256,15 @@
 
         def integrand(k):
             K_inv_G = ((self.eb[0] * k ** 2 + self.eb[1] * G_z ** 2) /
                        (1 - np.exp(-k * L / 2) * np.cos(L * G_z / 2)))
             K_inv_GG = np.diag(K_inv_G)
             D_GG = L * (K_inv_GG + dE_GG_perp * self.GG + dE_GG_par * k ** 2)
             return (k * np.exp(-k ** 2 * self.sigma ** 2) *
-                    (prefactor * np.linalg.inv(D_GG)).sum())
+                    (prefactor * np.linalg.inv(D_GG)).sum()).real
 
         I = integrate.quad(integrand, 0, np.inf, limit=500)
         Eli = self.q * self.q * I[0] * Ha
         self.Eli = Eli
         return Eli
 
     def calculate_potential_alignment(self):
@@ -297,44 +296,46 @@
         if self.dimensionality == '2d':
             phase = np.exp(1j * (self.G_z * self.z0))
             A_GG = (self.GG * self.epsilon_GG['out-of-plane'])
             A_GG[0, 0] = 1
             V_G = np.linalg.solve(A_GG,
                                   phase * np.array([0] + list(rho_Gz)))[1:]
         elif self.dimensionality == '3d':
-            V_G = rho_Gz / self.eb[1] / G_z ** 2
+            phase = np.exp(1j * (G_z * self.z0))
+            V_G = phase * rho_Gz / self.eb[1] / G_z ** 2
 
         for z in self.z_g:
             phase_G = np.exp(1j * (G_z * z))
-            V = (np.sum(phase_G * V_G)
+            V = (np.sum(phase_G * V_G).real
                  * Ha * 4.0 * np.pi / (self.Omega))
             Vs.append(V)
 
-        V = (np.sum(V_G) * Ha * 4.0 * np.pi / (self.Omega))
+        V = (np.sum(V_G.real) * Ha * 4.0 * np.pi / (self.Omega))
         zs = list(self.z_g) + [vox3[2]]
         Vs.append(V)
         return np.array(zs), np.array(Vs)
 
     def average(self, V, z):
         N = len(V)
         if self.dimensionality == '3d':
-            middle = N // 2
+            middle = np.argmin(np.abs(z - self.z0)) + N // 2
+            middle = middle % len(z)
             points = range(middle - N // 8, middle + N // 8 + 1)
             restricted = V[points]
         elif self.dimensionality == '2d':
             points = list(range(0, N // 8)) + list(range(7 * N // 8, N))
         restricted = V[points]
         V_mean = np.mean(restricted)
         return V_mean
 
     def calculate_corrected_formation_energy(self):
         E_0 = self.pristine.get_potential_energy()
         E_X = self.charged.get_potential_energy()
-        Eli = self.calculate_isolated_correction().real
-        Elp = self.calculate_periodic_correction().real
+        Eli = self.calculate_isolated_correction()
+        Elp = self.calculate_periodic_correction()
         Delta_V = self.calculate_potential_alignment()
         return E_X - E_0 - (Elp - Eli) + Delta_V * self.q
 
     def calculate_uncorrected_formation_energy(self):
         E_0 = self.pristine.get_potential_energy()
         E_X = self.charged.get_potential_energy()
         return E_X - E_0
@@ -348,24 +349,23 @@
                 'z': self.density_z,
                 'V_0': V_neutral,
                 'V_X': V_charged,
                 'Elc': self.Elp - self.Eli,
                 'D_V_mean': self.calculate_potential_alignment(),
                 'V_model': self.V_model,
                 'D_V': (self.V_model
-                        - V_neutral
-                        + V_charged)}
+                        + V_neutral
+                        - V_charged)}
         self.data = data
         return data
 
 
-def find_G_z(pd):
-    G_Gv = pd.get_reciprocal_vectors(q=0)
+def find_G_z(G_Gv):
     mask = (G_Gv[:, 0] == 0) & (G_Gv[:, 1] == 0)
-    G_z = G_Gv[mask][:, 2]  # G_z vectors in Bohr^{-1}
+    G_z = G_Gv[mask][:, 2]  # qG_z vectors in Bohr^{-1}
     return G_z
 
 
 def find_z(gd):
     r3_xyz = gd.get_grid_point_coordinates()
     nrz = r3_xyz.shape[3]
     return r3_xyz[2].flatten()[:nrz]
```

### Comparing `gpaw-22.8.0/gpaw/density.py` & `gpaw-23.6.0/gpaw/density.py`

 * *Files 1% similar despite different names*

```diff
@@ -424,14 +424,15 @@
            skip_core=True theoretically returns the
                           all-electron valence density (use with
                           care; will not in general integrate
                           to valence)
         """
         if spos_ac is None:
             spos_ac = atoms.get_scaled_positions() % 1.0
+        spos_ch = []    # for coreholes
 
         # Refinement of coarse grid, for representation of the AE-density
         # XXXXXXXXXXXX think about distribution depending on gridrefinement!
         if gridrefinement == 1:
             gd = self.redistributor.aux_gd
             n_sg = self.nt_sG.copy()
             # This will get the density with the same distribution
@@ -454,14 +455,20 @@
             if self.nt_sg is None:
                 self.interpolate_pseudo_density()
             for s in range(self.nspins):
                 interpolator.apply(self.nt_sg[s], n_sg[s])
         else:
             raise NotImplementedError
 
+        if self.nspins > 1 and not skip_core:
+            # Support for corehole in spin-polarized system
+            spos_ch = []
+            n_ch_a = []
+            n_ch = []
+
         # Add corrections to pseudo-density to get the AE-density
         splines = {}
         phi_aj = []
         phit_aj = []
         nc_a = []
         nct_a = []
         for a, id in enumerate(self.setups.id_a):
@@ -471,24 +478,41 @@
                 # Load splines:
                 phi_j, phit_j, nc, nct = self.setups[a].get_partial_waves()[:4]
                 splines[id] = (phi_j, phit_j, nc, nct)
             phi_aj.append(phi_j)
             phit_aj.append(phit_j)
             nc_a.append([nc])
             nct_a.append([nct])
+            if self.setups[a].data.has_corehole and not skip_core and \
+                    self.nspins > 1:
+                assert self.setups[a].data.lcorehole == 0
+                work_setup = self.setups[a].data
+                rmax = nc.get_cutoff()
+                # work_setup.phicorehole_g
+                phi_ch = work_setup.phicorehole_g
+                phi_ch = np.where(abs(phi_ch) < 1e-160, 0, phi_ch)
+                n_ch = np.dot(work_setup.fcorehole, phi_ch**2) / (4 * pi)
+                # n_ch[0] = n_ch[1] # ch is allready taylored
+                # fcorehole should divided by two - use scale for this
+                n_ch_spl = work_setup.rgd.spline(n_ch, rmax, points=1000)
+                n_ch_a.append([n_ch_spl])
+                spos_ch.append(spos_ac[a])
 
         # Create localized functions from splines
         phi = BasisFunctions(gd, phi_aj)
         phit = BasisFunctions(gd, phit_aj)
         nc = LFC(gd, nc_a)
         nct = LFC(gd, nct_a)
         phi.set_positions(spos_ac)
         phit.set_positions(spos_ac)
         nc.set_positions(spos_ac)
         nct.set_positions(spos_ac)
+        if spos_ch:
+            nch = LFC(gd, n_ch_a)
+            nch.set_positions(spos_ch)
 
         I_sa = np.zeros((self.nspins, len(spos_ac)))
         a_W = np.empty(len(phi.M_W), np.intc)
         W = 0
         for a in phi.atom_indices:
             nw = len(phi.sphere_a[a].M_w)
             a_W[W:W + nw] = a
@@ -513,14 +537,18 @@
                 else:
                     I_a[a] = ((setup.Nct) / self.nspins -
                               sqrt(4 * pi) *
                               np.dot(D_sp[s], setup.Delta_pL[:, 0]))
 
                     if not skip_core:
                         I_a[a] -= setup.Nc / self.nspins
+                        if self.setups[a].data.has_corehole and \
+                                self.nspins > 1:
+                            I_a[a] += pow(-1, s) * \
+                                self.setups[a].data.fcorehole / 2
 
                 rank = D_asp.partition.rank_a[a]
                 D_asp.partition.comm.broadcast(D_sp, rank)
                 M2 = M1 + ni
                 rho_MM[M1:M2, M1:M2] = unpack2(D_sp[s])
                 M1 = M2
 
@@ -539,15 +567,18 @@
             W += nw
         scale = 1.0 / self.nspins
 
         for s, I_a in enumerate(I_sa):
 
             if not skip_core:
                 nc.lfc.ae_core_density_correction(scale, n_sg[s], a_W, I_a)
-
+                # correct for ch here
+                if spos_ch:
+                    nch.lfc.ae_core_density_correction(- scale * pow(-1, s),
+                                                       n_sg[s], a_W, I_a)
             nct.lfc.ae_core_density_correction(-scale, n_sg[s], a_W, I_a)
             D_asp.partition.comm.sum(I_a)
             N_c = gd.N_c
             g_ac = np.around(N_c * spos_ac).astype(int) % N_c - gd.beg_c
 
             if not skip_core:
                 for I, g_c in zip(I_a, g_ac):
```

### Comparing `gpaw-22.8.0/gpaw/dfpt/__init__.py` & `gpaw-23.6.0/gpaw/dfpt/__init__.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/dfpt/dynamicalmatrix.py` & `gpaw-23.6.0/gpaw/dfpt/dynamicalmatrix.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/dfpt/electronphononcoupling.py` & `gpaw-23.6.0/gpaw/dfpt/electronphononcoupling.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/dfpt/linearsolver.py` & `gpaw-23.6.0/gpaw/dfpt/linearsolver.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/dfpt/mixer.py` & `gpaw-23.6.0/gpaw/dfpt/mixer.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/dfpt/perturbation.py` & `gpaw-23.6.0/gpaw/dfpt/perturbation.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/dfpt/phononcalculator.py` & `gpaw-23.6.0/gpaw/dfpt/phononcalculator.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/dfpt/phononperturbation.py` & `gpaw-23.6.0/gpaw/dfpt/phononperturbation.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/dfpt/phonons.py` & `gpaw-23.6.0/gpaw/dfpt/phonons.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/dfpt/poisson.py` & `gpaw-23.6.0/gpaw/dfpt/poisson.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/dfpt/preconditioner.py` & `gpaw-23.6.0/gpaw/dfpt/preconditioner.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/dfpt/responsecalculator.py` & `gpaw-23.6.0/gpaw/dfpt/responsecalculator.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/dfpt/scipylinearsolver.py` & `gpaw-23.6.0/gpaw/dfpt/scipylinearsolver.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/dfpt/sternheimeroperator.py` & `gpaw-23.6.0/gpaw/dfpt/sternheimeroperator.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/dfpt/wavefunctions.py` & `gpaw-23.6.0/gpaw/dfpt/wavefunctions.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/dipole_correction.py` & `gpaw-23.6.0/gpaw/dipole_correction.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/directmin/__init__.py` & `gpaw-23.6.0/gpaw/directmin/__init__.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,52 +1,75 @@
 """
 Exponential Transformation Direct Minimization
 """
 
 from gpaw.xc import xc_string_to_dict
 from gpaw.directmin.sd_etdm import SteepestDescent, FRcg, QuickMin, LBFGS, \
-    LBFGS_P, LSR1P
+    LBFGS_P, LSR1P, ModeFollowing
 from gpaw.directmin.ls_etdm import MaxStep, StrongWolfeConditions, Parabola
 
 
-def search_direction(method):
+def search_direction(method, etdm=None, pd=None):
     if isinstance(method, str):
         method = xc_string_to_dict(method)
 
     if isinstance(method, dict):
         kwargs = method.copy()
-        name = kwargs.pop('name')
+        names = kwargs.pop('name').replace('-', '').lower().split('_')
+        concave_step_length = 0.1
+        if 'concave_step_length' in kwargs.keys():
+            concave_step_length = kwargs.pop('concave_step_length')
 
         searchdir = {'sd': SteepestDescent,
-                     'fr-cg': FRcg,
-                     'quick-min': QuickMin,
-                     'l-bfgs': LBFGS,
-                     'l-bfgs-p': LBFGS_P,
-                     'l-sr1p': LSR1P
-                     }[name](**kwargs)
+                     'frcg': FRcg,
+                     'quickmin': QuickMin,
+                     'lbfgs': LBFGS,
+                     'lbfgsp': LBFGS_P,
+                     'lsr1p': LSR1P
+                     }[names[0]](**kwargs)
+
+        if len(names) == 2:
+            if names[1] == 'gmf':
+                pd['gmf'] = True
+                searchdir = ModeFollowing(partial_diagonalizer(pd, etdm),
+                                          searchdir, concave_step_length)
 
         return searchdir
     else:
         raise ValueError('Check keyword for search direction!')
 
 
 def line_search_algorithm(method, objective_function, searchdir_algo):
     if isinstance(method, str):
         method = xc_string_to_dict(method)
 
     if isinstance(method, dict):
         kwargs = method.copy()
-        name = kwargs.pop('name')
-        if name == 'swc-awc':
+        name = kwargs.pop('name').replace('-', '').lower()
+        if name == 'swcawc':
             # for swc-awc we need to know
             # what search. dir. algo is used
             if 'searchdirtype' not in kwargs:
                 kwargs['searchdirtype'] = searchdir_algo.type
 
-        ls_algo = {'max-step': MaxStep,
+        ls_algo = {'maxstep': MaxStep,
                    'parabola': Parabola,
-                   'swc-awc': StrongWolfeConditions
+                   'swcawc': StrongWolfeConditions
                    }[name](objective_function, **kwargs)
 
         return ls_algo
     else:
         raise ValueError('Check keyword for line search!')
+
+
+def partial_diagonalizer(method, domom):
+    from gpaw.directmin.derivatives import Davidson
+    if isinstance(method, str):
+        method = xc_string_to_dict(method)
+
+    if isinstance(method, dict):
+        kwargs = method.copy()
+        name = kwargs.pop('name')
+        if name == 'Davidson':
+            return Davidson(domom, **kwargs)
+        else:
+            raise ValueError('Check keyword for partial diagonalizer!')
```

### Comparing `gpaw-22.8.0/gpaw/directmin/etdm.py` & `gpaw-23.6.0/gpaw/directmin/etdm.py`

 * *Files 20% similar despite different names*

```diff
@@ -14,51 +14,56 @@
 import warnings
 from gpaw.directmin.tools import expm_ed, expm_ed_unit_inv
 from gpaw.directmin.lcao.directmin_lcao import DirectMinLCAO
 from scipy.linalg import expm
 from gpaw.directmin import search_direction, line_search_algorithm
 from gpaw.directmin.functional import get_functional
 from gpaw import BadParallelization
+from copy import deepcopy
 
 
 class ETDM:
 
     """
     Exponential Transformation Direct Minimization (ETDM)
     """
 
     def __init__(self,
                  searchdir_algo='l-bfgs-p',
                  linesearch_algo='swc-awc',
+                 partial_diagonalizer='Davidson',
                  update_ref_orbs_counter=20,
                  update_ref_orbs_canonical=False,
                  update_precond_counter=1000,
                  use_prec=True, matrix_exp='pade-approx',
                  representation='sparse',
                  functional='ks',
                  orthonormalization='gramschmidt',
                  randomizeorbitals=False,
                  checkgraderror=False,
                  localizationtype=None,
                  need_localization=True,
-                 need_init_orbs=True
+                 need_init_orbs=True,
+                 constraints=None,
                  ):
         """
         This class performs the exponential transformation
         direct minimization:
         E = E[C_ref e^{A}]
         C_ref are the reference orbitals
         A is a skew-Hermitian matrix
         We want to find A that optimizes the orbitals. The optimal orbitals
         are those corresponding to a minimum for the ground state or a saddle
         point for excited states.
 
         :param searchdir_algo: algorithm for calculating the search direction
         (e.g.LBFGS)
         :param linesearch_algo: line search (e.g. strong Wolfe conditions)
+        :param partial_diagonalizer: Algorithm to use for partial
+        diagonalization of the electronic Hessian if DO-GMF is used
         :param update_ref_orbs_counter: When to update C_ref
         :param update_ref_orbs_canonical: update C_ref to canonical orbitals
         :param update_precond_counter: when to update the preconditioner
         :param use_prec: use preconditioner or not
         :param matrix_exp: algorithm for calculating the matrix exponential and
         gradient. Can be one of 'pade-approx', 'egdecomp', 'egdecomp-u-invar'
         (used with u-invar representation)
@@ -70,14 +75,17 @@
         eigenstates of the Hamiltonian matrix. Can be one of 'gramschmidt',
         'loewdin', 'diag'
         :param randomizeorbitals: if True, add noise to the initial guess
         :param checkgraderror: check error in estimation of gradient
         :param localizationtype: Foster-Boys, Pipek-Mezey, Edm.-Rudenb.
         :param need_localization: use localized orbitals as initial guess
         :param need_init_orbs: if false, then use orbitals stored in kpt
+        :param constraints: List of constraints for each kpt. Can be given
+        either as pairs of orbital indices or single indices which are
+        converted to list of all pairs involving the single index
         """
 
         assert representation in ['sparse', 'u-invar', 'full'], 'Value Error'
         assert matrix_exp in ['egdecomp', 'egdecomp-u-invar', 'pade-approx'], \
             'Value Error'
         if matrix_exp == 'egdecomp-u-invar':
             assert representation == 'u-invar', 'Use u-invar representation ' \
@@ -97,18 +105,28 @@
         self.name = 'etdm'
         self.localizationtype = localizationtype
         self.need_localization = need_localization
         self.need_init_orbs = need_init_orbs
         self.randomizeorbitals = randomizeorbitals
         self.representation = representation
         self.orthonormalization = orthonormalization
+        self.constraints = constraints
 
-        self.searchdir_algo = search_direction(searchdir_algo)
-        if self.searchdir_algo.name == 'l-bfgs-p' and not self.use_prec:
+        self.gmf = False
+        self.searchdir_algo = search_direction(
+            searchdir_algo, self, partial_diagonalizer)
+        sd_name = self.searchdir_algo.name.split('_')
+        if sd_name[0] == 'l-bfgs-p' and not self.use_prec:
             raise ValueError('Use l-bfgs-p with use_prec=True')
+        if len(sd_name) == 2:
+            if sd_name[1] == 'gmf':
+                self.searchdir_algo.name = sd_name[0]
+                self.gmf = True
+                self.g_vec_u_original = None
+                self.pd = partial_diagonalizer
 
         self.line_search = line_search_algorithm(linesearch_algo,
                                                  self.evaluate_phi_and_der_phi,
                                                  self.searchdir_algo)
         self.func = get_functional(functional)
 
         self.checkgraderror = checkgraderror
@@ -142,32 +160,43 @@
         self.initialized = False
 
     def __repr__(self):
 
         sda_name = self.searchdir_algo.name
         lsa_name = self.line_search.name
 
+        add = ''
+        pd_add = ''
+        if self.gmf:
+            add = ' with minimum mode following'
+            pardi = {'Davidson': 'Finite difference generalized Davidson '
+                     'algorithm'}
+            pd_add = '       ' \
+                     'Partial diagonalizer: {}\n'.format(
+                         pardi[self.pd['name']])
+
         sds = {'sd': 'Steepest Descent',
                'fr-cg': 'Fletcher-Reeves conj. grad. method',
                'quick-min': 'Molecular-dynamics based algorithm',
                'l-bfgs': 'L-BFGS algorithm',
                'l-bfgs-p': 'L-BFGS algorithm with preconditioning',
                'l-sr1p': 'Limited-memory SR1P algorithm'}
 
         lss = {'max-step': 'step size equals one',
                'parabola': 'Parabolic line search',
                'swc-awc': 'Inexact line search based on cubic interpolation,\n'
                           '                    strong and approximate Wolfe '
                           'conditions'}
 
-        repr_string = 'Direct minimisation using exponential ' \
+        repr_string = 'Direct minimisation' + add + ' using exponential ' \
                       'transformation.\n'
         repr_string += '       ' \
                        'Search ' \
-                       'direction: {}\n'.format(sds[sda_name])
+                       'direction: {}\n'.format(sds[sda_name] + add)
+        repr_string += pd_add
         repr_string += '       ' \
                        'Line ' \
                        'search: {}\n'.format(lss[lsa_name])
         repr_string += '       ' \
                        'Preconditioning: {}\n'.format(self.use_prec)
         repr_string += '       ' \
                        'WARNING: do not use it for metals as ' \
@@ -309,44 +338,68 @@
             shape_of_arr = len(self.ind_up[u][0])
 
             self.a_vec_u[u] = np.zeros(shape=shape_of_arr, dtype=self.dtype)
             self.g_vec_u[u] = np.zeros(shape=shape_of_arr, dtype=self.dtype)
             self.evecs[u] = None
             self.evals[u] = None
 
+            # All constraints passed as a list of a single orbital index are
+            # converted to all lists of orbital pairs involving that orbital
+            # index
+            if self.constraints:
+                self.constraints[u] = convert_constraints(
+                    self.constraints[u], self.n_dim[u],
+                    len(kpt.f_n[kpt.f_n > 1e-10]), self.representation)
+
+        # This conversion makes it so that constraint-related functions can
+        # iterate through a list of no constraints rather than checking for
+        # None every time
+        if self.constraints is None:
+            self.constraints = [[] for _ in range(len(kpt_u))]
+
         self.iters = 1
 
     def iterate(self, ham, wfs, dens):
         """
         One iteration of direct optimization
         for occupied orbitals
 
         :param ham:
         :param wfs:
         :param dens:
         :return:
         """
         with wfs.timer('Direct Minimisation step'):
             self.update_ref_orbitals(wfs, ham, dens)
-            with wfs.timer('Preconditioning:'):
-                precond = self.get_preconditioning(wfs, self.use_prec)
 
             a_vec_u = self.a_vec_u
             n_dim = self.n_dim
             alpha = self.alpha
             phi_2i = self.phi_2i
             der_phi_2i = self.der_phi_2i
             c_ref = self.dm_helper.reference_orbitals
 
             if self.iters == 1:
                 phi_2i[0], g_vec_u = \
                     self.get_energy_and_gradients(a_vec_u, n_dim, ham, wfs,
                                                   dens, c_ref)
             else:
-                g_vec_u = self.g_vec_u
+                g_vec_u = self.g_vec_u_original if self.gmf else self.g_vec_u
+
+            make_pd = False
+            if self.gmf:
+                with wfs.timer('Partial Hessian diagonalization'):
+                    self.searchdir_algo.update_eigenpairs(
+                        g_vec_u, wfs, ham, dens)
+                # The diagonal Hessian approximation must be positive-definite
+                make_pd = True
+
+            with wfs.timer('Preconditioning:'):
+                precond = self.get_preconditioning(
+                    wfs, self.use_prec, make_pd=make_pd)
 
             with wfs.timer('Get Search Direction'):
                 # calculate search direction according to chosen
                 # optimization algorithm (e.g. L-BFGS)
                 p_vec_u = self.searchdir_algo.update_data(wfs, a_vec_u,
                                                           g_vec_u, precond)
 
@@ -418,15 +471,16 @@
             for kpt in wfs.kpt_u:
                 k = self.kpointval(kpt)
                 if n_dim[k] == 0:
                     g_vec_u[k] = np.zeros_like(a_vec_u[k])
                     continue
                 g_vec_u[k], error = self.dm_helper.calc_grad(
                     wfs, ham, kpt, self.func, self.evecs[k], self.evals[k],
-                    self.matrix_exp, self.representation, self.ind_up[k])
+                    self.matrix_exp, self.representation, self.ind_up[k],
+                    self.constraints[k])
 
                 self.error += error
             self.error = wfs.kd.comm.sum(self.error)
             self.e_sic = wfs.kd.comm.sum(self.e_sic)
 
         self.eg_count += 1
 
@@ -469,14 +523,20 @@
         :return:  phi, der_phi # floats
         """
         if phi is None or g_vec_u is None:
             x_mat_u = {k: a_vec_u[k] + alpha * p_mat_u[k] for k in a_vec_u}
             phi, g_vec_u = self.get_energy_and_gradients(x_mat_u, n_dim,
                                                          ham, wfs, dens, c_ref)
 
+            # If GMF is used save the original gradient and invert the parallel
+            # projection onto the eigenvectors with negative eigenvalues
+            if self.gmf:
+                self.g_vec_u_original = deepcopy(g_vec_u)
+                g_vec_u = self.searchdir_algo.invert_parallel_grad(g_vec_u)
+
         der_phi = 0.0
         for k in p_mat_u:
             der_phi += g_vec_u[k].conj() @ p_mat_u[k]
 
         der_phi = der_phi.real
         der_phi = wfs.kd.comm.sum(der_phi)
 
@@ -507,15 +567,15 @@
                 for kpt in wfs.kpt_u:
                     u = self.kpointval(kpt)
                     self.a_vec_u[u] = np.zeros_like(self.a_vec_u[u])
 
             # Erase memory of search direction algorithm
             self.searchdir_algo.reset()
 
-    def get_preconditioning(self, wfs, use_prec):
+    def get_preconditioning(self, wfs, use_prec, make_pd=False):
 
         if not use_prec:
             return None
 
         if self.searchdir_algo.name == 'l-bfgs-p':
             beta0 = self.searchdir_algo.beta_0
             gamma = 0.25
@@ -526,14 +586,20 @@
         counter = self.update_precond_counter
         precond = {}
         for kpt in wfs.kpt_u:
             k = self.kpointval(kpt)
             w = kpt.weight / (3.0 - wfs.nspins)
             if self.iters % counter == 0 or self.iters == 1:
                 self.hess[k] = self.get_hessian(kpt)
+                if make_pd:
+                    if self.dtype == float:
+                        self.hess[k] = np.abs(self.hess[k])
+                    else:
+                        self.hess[k] = np.abs(self.hess[k].real) \
+                            + 1.0j * np.abs(self.hess[k].imag)
             hess = self.hess[k]
             precond[k] = np.zeros_like(hess)
             correction = w * gamma * beta0 ** (-1)
             if self.searchdir_algo.name != 'l-bfgs-p':
                 correction = np.zeros_like(hess)
                 zeros = abs(hess) < 1.0e-4
                 correction[zeros] = 1.0
@@ -611,14 +677,15 @@
         """
         Sort orbitals according to the eigenvalues or
         the diagonal elements of the Hamiltonian matrix
         """
 
         with wfs.timer('Sort WFS'):
             for kpt in wfs.kpt_u:
+                k = self.kpointval(kpt)
                 if use_eps:
                     orbital_energies = kpt.eps_n
                 else:
                     orbital_energies = self.dm_helper.orbital_energies(
                         wfs, ham, kpt)
                 ind = np.argsort(orbital_energies)
                 # check if it is necessary to sort
@@ -630,24 +697,30 @@
                     kpt.f_n[np.arange(len(ind))] = kpt.f_n[ind]
                     kpt.eps_n[np.arange(len(ind))] = orbital_energies[ind]
                     occ_name = getattr(wfs.occupations, "name", None)
                     if occ_name == 'mom':
                         # OccupationsMOM.numbers needs to be updated after
                         # sorting
                         self.update_mom_numbers(wfs, kpt)
+                    if self.constraints:
+                        # Identity of the contrained orbitals has changed and
+                        # needs to be updated
+                        self.constraints[k] = update_constraints(
+                            self.constraints[k], list(ind))
 
     def sort_orbitals_mom(self, wfs):
         """
         Sort orbitals according to the occupation
         numbers so that there are no holes in the
         distribution of occupation numbers
         :return:
         """
         changedocc = False
         for kpt in wfs.kpt_u:
+            k = self.kpointval(kpt)
             occupied = kpt.f_n > 1.0e-10
             n_occ = len(kpt.f_n[occupied])
             if n_occ == 0.0:
                 continue
             if np.min(kpt.f_n[:n_occ]) == 0:
                 ind_occ = np.argwhere(occupied)
                 ind_unocc = np.argwhere(~occupied)
@@ -656,32 +729,43 @@
                 self.dm_helper.sort_orbitals(wfs, kpt, ind)
                 kpt.f_n = kpt.f_n[ind]
                 kpt.eps_n = kpt.eps_n[ind]
 
                 # OccupationsMOM.numbers needs to be updated after sorting
                 self.update_mom_numbers(wfs, kpt)
 
+                if self.constraints:
+                    # Identities of the contrained orbitals have changed and
+                    # needs to be updated
+                    self.constraints[k] = update_constraints(
+                        self.constraints[k], list(ind))
+
                 changedocc = True
 
         return changedocc
 
     def todict(self):
 
-        return {'name': self.name,
-                'searchdir_algo': self.searchdir_algo.todict(),
-                'linesearch_algo': self.line_search.todict(),
-                'localizationtype': self.localizationtype,
-                'update_ref_orbs_counter': self.update_ref_orbs_counter,
-                'update_precond_counter': self.update_precond_counter,
-                'use_prec': self.use_prec,
-                'matrix_exp': self.matrix_exp,
-                'representation': self.representation,
-                'functional': self.func.todict(),
-                'orthonormalization': self.orthonormalization
-                }
+        ret = {'name': self.name,
+               'searchdir_algo': self.searchdir_algo.todict(),
+               'linesearch_algo': self.line_search.todict(),
+               'localizationtype': self.localizationtype,
+               'update_ref_orbs_counter': self.update_ref_orbs_counter,
+               'update_precond_counter': self.update_precond_counter,
+               'use_prec': self.use_prec,
+               'matrix_exp': self.matrix_exp,
+               'representation': self.representation,
+               'functional': self.func.todict(),
+               'orthonormalization': self.orthonormalization,
+               'constraints': self.constraints
+               }
+        if self.gmf:
+            ret['partial_diagonalizer'] = \
+                self.searchdir_algo.partial_diagonalizer.todict()
+        return ret
 
     def rotate_wavefunctions(self, wfs, a_vec_u, n_dim, c_ref):
 
         """
         Apply unitary transformation U = exp(A) to
         the orbitals c_ref
 
@@ -795,14 +879,19 @@
         nst = self.nbands
         wt = kpt.weight * 0.01
         arand = wt * random_a((nst, nst), wfs.dtype)
         arand = arand - arand.T.conj()
         wfs.gd.comm.broadcast(arand, 0)
         self.dm_helper.appy_transformation_kpt(wfs, expm(arand), kpt)
 
+    def calculate_hamiltonian_matrix(self, hamiltonian, wfs, kpt):
+        H_MM = self.dm_helper.calculate_hamiltonian_matrix(
+            hamiltonian, wfs, kpt)
+        return H_MM
+
     def kpointval(self, kpt):
         return self.nkpts * kpt.s + kpt.q
 
     @property
     def error(self):
         return self._error
 
@@ -831,7 +920,128 @@
 def vec2skewmat(a_vec, dim, ind_up, dtype):
 
     a_mat = np.zeros(shape=(dim, dim), dtype=dtype)
     a_mat[ind_up] = a_vec
     a_mat -= a_mat.T.conj()
     np.fill_diagonal(a_mat, a_mat.diagonal() * 0.5)
     return a_mat
+
+
+def convert_constraints(constraints, n_dim, n_occ, representation):
+    """
+    Parses and checks the user input of constraints. If constraints are passed
+    as a list of a single orbital index all pairs of orbitals involving this
+    index are added to the constraints.
+
+    :param constraints: List of constraints for one K-point
+    :param n_dim:
+    :param n_occ:
+    :param representation: Unitary invariant, sparse or full representation
+                           determining the electronic degrees of freedom that
+                           need to be constrained
+
+    :return: Converted list of constraints
+    """
+
+    new = constraints.copy()
+    for con in constraints:
+        assert isinstance(con, list) or isinstance(con, int), \
+            'Check constraints.'
+        if isinstance(con, list):
+            assert len(con) < 3, 'Check constraints.'
+            if len(con) == 1:
+                con = con[0]  # List of single index
+            else:
+                # Make first index always smaller than second index
+                if representation != 'full' and con[1] < con[0]:
+                    temp = deepcopy(con[0])
+                    con[0] = deepcopy(con[1])
+                    con[1] = temp
+                check_indices(
+                    con[0], con[1], n_dim, n_occ, representation)
+                continue
+        # Add all pairs containing the single index
+        if isinstance(con, int):
+            new += find_all_pairs(con, n_dim, n_occ, representation)
+
+    # Delete all list containing a single index
+    done = False
+    while not done:
+        done = True
+        for i in range(len(new)):
+            if len(new[i]) < 2:
+                del new[i]
+                done = False
+                break
+    return new
+
+
+def check_indices(ind1, ind2, n_dim, n_occ, representation):
+    """
+    Makes sure the user input for the constraints makes sense.
+    """
+
+    assert ind1 != ind2, 'Check constraints.'
+    if representation == 'full':
+        assert ind1 < n_dim and ind2 < n_dim, 'Check constraints.'
+    elif representation == 'sparse':
+        assert ind1 < n_occ and ind2 < n_dim, 'Check constraints.'
+    elif representation == 'u-invar':
+        assert ind1 < n_occ and ind2 >= n_occ and ind2 < n_dim, \
+            'Check constraints.'
+
+
+def find_all_pairs(ind, n_dim, n_occ, representation):
+    """
+    Creates a list of all orbital pairs corresponding to degrees of freedom of
+    the system containing an orbital index.
+
+    :param ind: The orbital index
+    :param n_dim:
+    :param n_occ:
+    :param representation: Unitary invariant, sparse or full, defining what
+                           index pairs correspond to degrees of freedom of the
+                           system
+    """
+
+    pairs = []
+    if representation == 'u-invar':
+        # Only ov rotations are degrees of freedom
+        if ind < n_occ:
+            for i in range(n_occ, n_dim):
+                pairs.append([ind, i])
+        else:
+            for i in range(n_occ):
+                pairs.append([i, ind])
+    else:
+        if (ind < n_occ and representation == 'sparse') \
+                or representation == 'full':
+            # oo and ov rotations are degrees of freedom
+            for i in range(n_dim):
+                if i == ind:
+                    continue
+                pairs.append([i, ind] if i < ind else [ind, i])
+                if representation == 'full':
+                    # The orbital rotation matrix is not assumed to be
+                    # antihermitian, so the reverse order of indices must be
+                    # added as a second constraint
+                    pairs.append([ind, i] if i < ind else [i, ind])
+        else:
+            for i in range(n_occ):
+                pairs.append([i, ind])
+    return pairs
+
+
+def update_constraints(constraints, ind):
+    """
+    Change the constraint indices to match a new indexation, e.g. due to
+    sorting the orbitals
+
+    :param constraints: The list of constraints for one K-point
+    :param ind: List containing information about the change in indexation
+    """
+
+    new = deepcopy(constraints)
+    for i in range(len(constraints)):
+        for k in range(len(constraints[i])):
+            new[i][k] = ind.index(constraints[i][k])
+    return new
```

### Comparing `gpaw-22.8.0/gpaw/directmin/functional/__init__.py` & `gpaw-23.6.0/gpaw/directmin/functional/__init__.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/directmin/functional/ks.py` & `gpaw-23.6.0/gpaw/directmin/functional/ks.py`

 * *Files 24% similar despite different names*

```diff
@@ -13,25 +13,26 @@
     def __init__(self):
         self.name = 'ks'
 
     def todict(self):
         return {'name': self.name}
 
     def get_gradients(self, h_mm, c_nm, f_n, evec, evals, kpt, wfs, timer,
-                      matrix_exp, representation, ind_up):
+                      matrix_exp, representation, ind_up, constraints):
 
         with timer('Construct Gradient Matrix'):
             use_egdecomp = matrix_exp == 'egdecomp'
             
             hc_mn, h_ij, h_ia = self.get_ham_in_mol_orb_representation(
                 h_mm, c_nm, f_n, representation, use_egdecomp)
             
             with timer('Residual'):
                 error = self.get_residual_error(
-                    hc_mn, kpt.S_MM, c_nm, h_ij, f_n, wfs.nvalence)
+                    hc_mn, kpt.S_MM, c_nm, h_ij, f_n, wfs.nvalence,
+                    constraints)
 
             if not use_egdecomp:
                 if representation == 'u-invar':
                     h_ij = h_ia
                 else:
                     if representation == 'full' and wfs.dtype == complex:
                         indl = np.tril_indices(h_ij.shape[0], -1)
@@ -56,14 +57,17 @@
                     grad = self.get_exact_gradient_matrix(grad, evec, evals)
 
                 grad = grad[ind_up]
 
         if wfs.dtype == float:
             grad = grad.real
 
+        if constraints:
+            constrain_grad(grad, constraints, ind_up)
+
         return 2.0 * grad, error
 
     def get_ham_in_mol_orb_representation(self, h_mm, c_nm, f_n,
                                           representation, full_ham):
 
         """
         H = (C_nM @ H_MM @ C_nM.T.conj()).conj()
@@ -87,21 +91,29 @@
         else:
             hc_mn = h_mm.conj() @ c_nm.T
             h_ij = c_nm.conj() @ hc_mn
             h_ia = h_ij[:occ][:, occ:]
 
         return hc_mn, h_ij, h_ia
     
-    def get_residual_error(self, hc_mn, S_MM, c_nm, h_ij, f_n, nvalence):
+    def get_residual_error(
+            self, hc_mn, S_MM, c_nm, h_ij, f_n, nvalence, constraints=None):
         """
         Calculate residual error of KS equations
         """
         occ = sum(f_n > 1.0e-10)
         hc_mn = hc_mn[:, :occ] - \
             S_MM.conj() @ c_nm[:occ].T @ h_ij[:occ, :occ]
+        if constraints:
+            # Zero out the components of the residual that are constrained,
+            # so that the constrained degrees of freedom are always considered
+            # converged
+            for con in constraints:
+                con1 = con[0]
+                hc_mn[:, con1] = 0.0
         norm = sum(hc_mn.conj() * hc_mn * f_n[:occ])
         error = sum(norm.real) * Hartree ** 2 / nvalence
         
         return error
 
     def get_exact_gradient_matrix(self, h_ij, evec, evals):
  
@@ -117,7 +129,24 @@
         grad = evec.T.conj() @ h_ij @ evec
         grad = grad * d_matrix(evals)
         grad = evec @ grad @ evec.T.conj()
         for i in range(grad.shape[0]):
             grad[i][i] *= 0.5
         
         return grad
+
+
+def constrain_grad(grad, constraints, ind_up):
+    """
+    Zero out the components of the gradient that are constrained, so that no
+    optimization step is taken along the constrained degrees of freedom (It
+    would be better not to evaluate these components of the gradient to begin
+    with.).
+    """
+
+    for con in constraints:
+        num = -1
+        for ind1, ind2 in zip(ind_up[0], ind_up[1]):
+            num += 1
+            if con == [ind1, ind2]:
+                grad[num] = 0.0
+    return grad
```

### Comparing `gpaw-22.8.0/gpaw/directmin/lcao/directmin_lcao.py` & `gpaw-23.6.0/gpaw/directmin/lcao/directmin_lcao.py`

 * *Files 2% similar despite different names*

```diff
@@ -78,28 +78,28 @@
             super(DirectMinLCAO, self).iterate(ham, wfs)
         else:
             wfs.orthonormalize(type=orthname)
         wfs.coefficients_read_from_file = False
         self.need_init_orbs = False
 
     def calc_grad(self, wfs, ham, kpt, func, evecs, evals, matrix_exp,
-                  representation, ind_up):
+                  representation, ind_up, constraints):
 
         """
         Gradient w.r.t. skew-Hermitian matrices
         """
 
         h_mm = self.calculate_hamiltonian_matrix(ham, wfs, kpt)
         # make matrix hermitian
         tri2full(h_mm)
         # calc gradient and eigenstate error
         g_mat, error = func.get_gradients(
             h_mm, kpt.C_nM, kpt.f_n, evecs, evals,
             kpt, wfs, wfs.timer, matrix_exp,
-            representation, ind_up)
+            representation, ind_up, constraints)
 
         return g_mat, error
 
     def update_to_canonical_orbitals(self, wfs, ham, kpt,
                                      update_ref_orbs_canonical, restart):
         """
         Choose canonical orbitals
```

### Comparing `gpaw-22.8.0/gpaw/directmin/ls_etdm.py` & `gpaw-23.6.0/gpaw/directmin/ls_etdm.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/directmin/sd_etdm.py` & `gpaw-23.6.0/gpaw/directmin/sd_etdm.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,43 +1,177 @@
 """
 Search directions in space of skew-hermitian matrices
 
 LSR1 algorithm and application to excited states:
 arXiv:2006.15922 [physics.chem-ph]
 J. Chem. Theory Comput. 16, 6968 (2020).
-https://pubs.acs.org/doi/10.1021/acs.jctc.0c00597
+https://doi.org/10.1021/acs.jctc.0c00597
 """
 
 import numpy as np
 import copy
+from gpaw.directmin.tools import array_to_dict, dict_to_array
 
 
 class SearchDirectionBase(object):
+    """
+    Base class for search direction algorithms
+    """
+
     def __init__(self):
         self.iters = 0
         self.kp = None
         self.p = None
         self.k = None
         super(SearchDirectionBase, self).__init__()
 
     def __str__(self):
         raise NotImplementedError('Search direction class needs string '
-                                  'representation')
+                                  'representation.')
+
+    def todict(self):
+        raise NotImplementedError('Search direction class needs \'todict\' '
+                                  'method.')
 
     def update_data(self, wfs, x_k1, g_k1, precond=None):
         raise NotImplementedError('Search direction class needs '
-                                  '\'update_data\' method')
+                                  '\'update_data\' method.')
 
     def reset(self):
         self.iters = 0
         self.kp = {}
         self.p = 0
         self.k = 0
 
 
+class ModeFollowingBase(object):
+    """
+    Base gradient partitioning and negation implementation for minimum mode
+    following
+    """
+
+    def __init__(self, partial_diagonalizer, convex_step_length=0.1,
+                 reset_on_convex=False):
+        self.eigv = None
+        self.eigvec = None
+        self.eigvec_old = None
+        self.partial_diagonalizer = partial_diagonalizer
+        self.fixed_sp_order = None
+        self.was_convex = False
+        self.convex_step_length = convex_step_length
+        self.reset_on_convex = reset_on_convex
+
+    def update_eigenpairs(self, g_k1, wfs, ham, dens):
+        """
+        Performs a partial Hessian diagonalization to obtain the eigenvectors
+        with negative eigenvalues.
+
+        :param g_k1: Gradient.
+        :param wfs:
+        :param ham:
+        :param dens:
+        :return:
+        """
+
+        self.partial_diagonalizer.grad = g_k1
+        use_prev = False if self.eigv is None or (
+            self.was_convex and self.reset_on_convex) else True
+        self.partial_diagonalizer.run(wfs, ham, dens, use_prev)
+        self.eigv = copy.deepcopy(self.partial_diagonalizer.lambda_w)
+        self.eigvec_old = copy.deepcopy(self.eigvec)
+        self.eigvec = copy.deepcopy(self.partial_diagonalizer.x_w.T)
+        if wfs.dtype == complex:
+            dimtot = int(len(self.eigvec[0]) / 2)
+            eigvec = np.zeros(shape=(len(self.eigvec), dimtot),
+                              dtype=complex)
+            for i in range(len(self.eigvec)):
+                eigvec[i] += self.eigvec[i][: dimtot] \
+                    + 1.0j * self.eigvec[i][dimtot:]
+            self.eigvec = eigvec
+        self.fixed_sp_order = self.partial_diagonalizer.sp_order
+
+    def invert_parallel_grad(self, g_k1):
+        """
+        Uses the stored eigenpairs and inverts the projections of the gradient
+        parallel to the eigenvectors with negative eigenvalues.
+
+        :param g_k1: Gradient.
+        :return: Modified gradient.
+        """
+
+        grad, dim, dimtot = dict_to_array(g_k1)
+        get_dots = 0
+        if self.fixed_sp_order is None:
+            for i in range(len(self.eigv)):
+                if self.eigv[i] <= -1e-4:
+                    get_dots += 1
+                else:
+                    break
+        else:
+            neg_temp = 0
+            for i in range(len(self.eigv)):
+                if self.eigv[i] <= -1e-4:
+                    neg_temp += 1
+                else:
+                    break
+            get_dots = self.fixed_sp_order
+        grad_par = np.zeros_like(grad)
+        if self.fixed_sp_order is not None:
+            for i in range(get_dots):
+                grad_par += self.eigvec[i] * np.dot(self.eigvec[i].conj(),
+                                                    grad.T).real
+            grad_mod = grad - 2.0 * grad_par
+        else:
+            for i in range(get_dots):
+                grad_par += self.eigvec[i] \
+                    * np.dot(self.eigvec[i].conj(), grad.T).real
+            if get_dots == 0:
+                grad_mod = -self.convex_step_length * grad_par \
+                    / np.linalg.norm(grad_par)
+                self.partial_diagonalizer.etdm.searchdir_algo.reset()
+                self.was_convex = True
+            else:
+                grad_mod = grad - 2.0 * grad_par
+                if self.was_convex:
+                    self.partial_diagonalizer.etdm.searchdir_algo.reset()
+                    self.was_convex = False
+        return array_to_dict(grad_mod, dim)
+
+
+class ModeFollowing(ModeFollowingBase, SearchDirectionBase):
+    """
+    Minimum mode following class handling the GMF tag of the search direction
+    class for ETDM and negation of the gradient projection.
+    """
+
+    def __init__(self, partial_diagonalizer, search_direction,
+                 convex_step_length=0.1):
+        self.sd = search_direction
+        self.name = self.sd.name + '_gmf'
+        self.type = self.sd.type + '_gmf'
+        super(ModeFollowing, self).__init__(partial_diagonalizer,
+                                            convex_step_length)
+
+    @property
+    def beta_0(self):
+        return self.sd.beta_0
+
+    def __str__(self):
+        return self.sd.__str__() + ' with minimum mode following'
+
+    def todict(self):
+        res = self.sd.todict()
+        res['name'] += '_gmf'                    # tag will be removed in etdm
+        return res
+
+    def update_data(self, wfs, x_k1, g_k1, precond=None):
+        g_k1 = self.invert_parallel_grad(g_k1)
+        return self.sd.update_data(wfs, x_k1, g_k1, precond=precond)
+
+
 class SteepestDescent(SearchDirectionBase):
     """
     Steepest descent algorithm
     """
 
     def __init__(self):
         super(SteepestDescent, self).__init__()
@@ -284,15 +418,19 @@
 
     def todict(self):
 
         return {'name': self.name,
                 'memory': self.memory,
                 'beta_0': self.beta_0}
 
-    def update_data(self, wfs, x_k1, g_k1, hess_1=None):
+    def update_data(self, wfs, x_k1, g_k1, precond=None):
+        # For L-BFGS-P, the preconditioner passed here has to be differentiated
+        # from the preconditioner passed in ETDM. To keep the UI of this member
+        # function consistent, the term precond is still used in the signature
+        hess_1 = precond
         self.iters += 1
         if self.k == 0:
             self.kp[self.k] = self.p
             self.x_k = copy.deepcopy(x_k1)
             self.g_k = copy.deepcopy(g_k1)
             self.s_k[self.kp[self.k]] = zeros(g_k1)
             self.y_k[self.kp[self.k]] = zeros(g_k1)
@@ -348,15 +486,15 @@
             t = k
             dot_yy = dot_all_k_and_b(y_k[kp[t]], y_k[kp[t]], wfs)
             rhoyy = rho_k[kp[t]] * dot_yy
             if abs(rhoyy) > 1.0e-20:
                 self.beta_0 = 1.0 / rhoyy
             else:
                 self.beta_0 = 1.0e20
-            
+
             if hess_1 is not None:
                 r = apply_prec(hess_1, q)
             else:
                 r = multiply(q, self.beta_0)
 
             for i in range(np.maximum(0, k - m + 1), k + 1):
                 dot_yr = dot_all_k_and_b(y_k[kp[i]], r, wfs)
```

### Comparing `gpaw-22.8.0/gpaw/domain.py` & `gpaw-23.6.0/gpaw/domain.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/dos.py` & `gpaw-23.6.0/gpaw/dos.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,24 +1,26 @@
+from __future__ import annotations
 from pathlib import Path
 from typing import Union, List, Optional, Sequence, TYPE_CHECKING
 
 import numpy as np
 from ase.dft.dos import linear_tetrahedron_integration as lti
 
 from gpaw.setup import Setup
 from gpaw.spinorbit import soc_eigenstates, BZWaveFunctions
 from gpaw.typing import Array1D, Array2D, Array3D, ArrayLike1D
 
 if TYPE_CHECKING:
     from gpaw.calculator import GPAW
+    from gpaw.new.ase_interface import ASECalculator
 
 
 class IBZWaveFunctions:
     """Container for eigenvalues and PAW projections (only IBZ)."""
-    def __init__(self, calc: 'GPAW'):
+    def __init__(self, calc: ASECalculator | GPAW):
         self.calc = calc
         self.fermi_level = self.calc.get_fermi_level()
         self.size = calc.wfs.kd.N_c
         self.bz2ibz_map = calc.wfs.kd.bz2ibz_k
 
     def weights(self) -> Array1D:
         """Weigths of IBZ k-points (adds to 1.0)."""
@@ -149,25 +151,23 @@
                      npoints: int = 100):
         emin = emin if emin is not None else self.eig_skn.min()
         emax = emax if emax is not None else self.eig_skn.max()
         return np.linspace(emin, emax, npoints)
 
     @classmethod
     def from_calculator(cls,
-                        filename: Union['GPAW', Path, str],
+                        filename: ASECalculator | GPAW | Path | str,
                         soc=False, theta=0.0, phi=0.0,
                         shift_fermi_level=True):
         """Create DOSCalculator from a GPAW calculation.
 
         filename: str
             Name of restart-file or GPAW calculator object.
         """
-        from gpaw.calculator import GPAW
-
-        if isinstance(filename, GPAW):
+        if not isinstance(filename, (str, Path)):
             calc = filename
         else:
             calc = GPAW(filename, txt=None)
 
         wfs: Union[BZWaveFunctions, IBZWaveFunctions]
         if soc:
             wfs = soc_eigenstates(calc, theta=theta, phi=phi)
```

### Comparing `gpaw-22.8.0/gpaw/dscf.py` & `gpaw-23.6.0/gpaw/dscf.py`

 * *Files 2% similar despite different names*

```diff
@@ -48,14 +48,15 @@
 
     """
 
     # If the calculator has not been initialized the occupation object
     # is None
     if paw.wfs is None:
         paw.initialize(atoms)
+    assert paw.wfs.mode != 'pw'
     occ = paw.wfs.occupations
     if isinstance(occ, OccupationsDSCF):
         occ.orbitals = orbitals
     else:
         if occ.name == 'zero-width':
             occ = FermiDiracCalculator(1e-4, occ.parallel_layout)
         new_occ = OccupationsDSCF(occ, paw, orbitals)
```

### Comparing `gpaw-22.8.0/gpaw/eigensolvers/__init__.py` & `gpaw-23.6.0/gpaw/eigensolvers/__init__.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/eigensolvers/cg.py` & `gpaw-23.6.0/gpaw/eigensolvers/cg.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/eigensolvers/davidson.py` & `gpaw-23.6.0/gpaw/eigensolvers/davidson.py`

 * *Files 2% similar despite different names*

```diff
@@ -107,16 +107,15 @@
         P = kpt.projections
         P2 = P.new()
         P3 = P.new()
         M = wfs.work_matrix_nn
         dS = wfs.setups.dS
         comm = wfs.gd.comm
 
-        is_gridband_master: bool = (
-            comm.rank == 0) and (bd.comm.rank == 0)
+        is_gridband_master = (comm.rank == 0) and (bd.comm.rank == 0)
 
         if bd.comm.size > 1:
             M0 = M.new(dist=(bd.comm, 1, 1))
         else:
             M0 = M
 
         if comm.rank == 0:
@@ -183,17 +182,21 @@
                 S_NN[:B, :B] = np.eye(B)
 
             with self.timer('diagonalize'):
                 if is_gridband_master and debug:
                     H_NN[np.triu_indices(2 * B, 1)] = 42.0
                     S_NN[np.triu_indices(2 * B, 1)] = 42.0
 
-                self.diagonalizer_backend.diagonalize(
-                    H_NN, S_NN, eps_N, is_master=is_gridband_master,
-                    debug=debug)
+                try:
+                    self.diagonalizer_backend.diagonalize(
+                        H_NN, S_NN, eps_N, is_master=is_gridband_master,
+                        debug=debug)
+                except np.linalg.LinAlgError as ex:
+                    raise ValueError(
+                        'Too few plane waves or grid points') from ex
             if comm.rank == 0:
                 bd.distribute(eps_N[:B], kpt.eps_n)
             comm.broadcast(kpt.eps_n, 0)
 
             with self.timer('rotate_psi'):
                 if comm.rank == 0:
                     if bd.comm.rank == 0:
```

### Comparing `gpaw-22.8.0/gpaw/eigensolvers/diagonalizerbackend.py` & `gpaw-23.6.0/gpaw/eigensolvers/diagonalizerbackend.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/eigensolvers/direct.py` & `gpaw-23.6.0/gpaw/eigensolvers/direct.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/eigensolvers/eigensolver.py` & `gpaw-23.6.0/gpaw/eigensolvers/eigensolver.py`

 * *Files 0% similar despite different names*

```diff
@@ -100,15 +100,14 @@
 
                 if gap == 0.0:
                     cbm = efermi
                 else:
                     cbm = efermi + eps_skn[s, k, n]
 
                 ecut = cbm + delta
-
                 for weight_n, kpt in zip(weight_un, wfs.kpt_u):
                     weight_n[kpt.eps_n < ecut] = kpt.weight
 
                 if (eps_skn[:, :, -1] < ecut - efermi).any():
                     # We don't have enough bands!
                     weight_un[:] = np.inf
```

### Comparing `gpaw-22.8.0/gpaw/eigensolvers/rmmdiis.py` & `gpaw-23.6.0/gpaw/eigensolvers/rmmdiis.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/electrostatic_potential.py` & `gpaw-23.6.0/gpaw/electrostatic_potential.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,13 +1,15 @@
 from __future__ import annotations
 
 from math import pi, sqrt
 from typing import TYPE_CHECKING
 
+import numpy as np
 from ase.units import Bohr, Ha
+
 from gpaw.atom.shapefunc import shape_functions
 from gpaw.core.arrays import DistributedArrays
 from gpaw.core.atom_arrays import AtomArrays
 from gpaw.core.uniform_grid import UniformGridFunctions
 from gpaw.setup import Setups
 from gpaw.typing import Array1D, ArrayLike2D
 from gpaw.utilities import pack
@@ -48,14 +50,24 @@
                    calculation.setups)
 
     def atomic_potentials(self) -> Array1D:
         W_aL = self.W_aL.gather()
         assert W_aL is not None
         return W_aL.data[::9] * (Ha / (4 * pi)**0.5)
 
+    def atomic_corrections(self):
+        """Calculate PAW correction to average electrostatic potential."""
+        dEH_a = np.zeros(len(self.setups))
+        for a, D_sii in self.D_asii.items():
+            setup = self.setups[a]
+            D_p = pack(D_sii.sum(0))
+            dEH_a[a] = setup.dEH0 + setup.dEH_p @ D_p
+        self.D_asii.comm.sum(dEH_a)
+        return dEH_a * Ha * Bohr**3
+
     def pseudo_potential(self,
                          grid_spacing: float = 0.05,  # Ang
                          ) -> UniformGridFunctions:
         return self._pseudo_potential(grid_spacing / Bohr).scaled(Bohr, Ha)
 
     def _pseudo_potential(self,
                           grid_spacing: float,  # Bohr
```

### Comparing `gpaw-22.8.0/gpaw/elf.py` & `gpaw-23.6.0/gpaw/elf.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/elph/electronphonon.py` & `gpaw-23.6.0/gpaw/elph/electronphonon.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,67 +1,7 @@
-r"""Module for calculating electron-phonon couplings.
-
-Electron-phonon interaction::
-
-                  __
-                  \     l   +         +
-        H      =   )   g   c   c   ( a   + a  ),
-         el-ph    /_    ij  i   j     l     l
-                 l,ij
-
-where the electron phonon coupling is given by::
-
-                      ______
-             l       / hbar         ___
-            g   =   /-------  < i | \ /  V   * e  | j > .
-             ij   \/ 2 M w           'u   eff   l
-                          l
-
-Here, l denotes the vibrational mode, w_l and e_l is the frequency and
-mass-scaled polarization vector, respectively, M is an effective mass, i, j are
-electronic state indices and nabla_u denotes the gradient wrt atomic
-displacements. The implementation supports calculations of the el-ph coupling
-in both finite and periodic systems, i.e. expressed in a basis of molecular
-orbitals or Bloch states.
-
-The implementation is based on finite-difference calculations of the the atomic
-gradients of the effective potential expressed on a real-space grid. The el-ph
-couplings are obtained from LCAO representations of the atomic gradients of the
-effective potential and the electronic states.
-
-In PAW the matrix elements of the derivative of the effective potential is
-given by the sum of the following contributions::
-
-                  d                  d
-            < i | -- V | j > = < i | -- V | j>
-                  du  eff            du
-
-                               _
-                              \        ~a     d   .       ~a
-                            +  ) < i | p  >   -- /_\H   < p | j >
-                              /_        i     du     ij    j
-                              a,ij
-
-                               _
-                              \        d  ~a     .        ~a
-                            +  ) < i | -- p  >  /_\H    < p | j >
-                              /_       du  i        ij     j
-                              a,ij
-
-                               _
-                              \        ~a     .        d  ~a
-                            +  ) < i | p  >  /_\H    < -- p  | j >
-                              /_        i        ij    du  j
-                              a,ij
-
-where the first term is the derivative of the potential (Hartree + XC) and the
-last three terms originate from the PAW (pseudopotential) part of the effective
-DFT Hamiltonian.
-
-"""
 import numpy as np
 
 import ase.units as units
 from ase.parallel import parprint
 from ase.phonons import Displacement
 from ase.utils.filecache import MultiFileJSONCache
 
@@ -105,14 +45,16 @@
             Name to use for files (default: 'elph').
         delta: float
             Magnitude of displacements.
         calculate_forces: bool
             If true, also calculate and store the dynamical matrix.
         """
 
+        parprint("DEPRECATION WARNING: This module is deprecated.")
+
         # Init base class and make the center cell in the supercell the
         # reference cell
         Displacement.__init__(self, atoms, calc=calc, supercell=supercell,
                               name=name, delta=delta, center_refcell=True)
 
         self.calculate_forces = calculate_forces
         # LCAO calculator
```

### Comparing `gpaw-22.8.0/gpaw/external.py` & `gpaw-23.6.0/gpaw/external.py`

 * *Files 3% similar despite different names*

```diff
@@ -123,44 +123,56 @@
 class ConstantElectricField(ExternalPotential):
     def __init__(self, strength, direction=[0, 0, 1], tolerance=1e-7):
         """External constant electric field.
 
         strength: float
             Field strength in V/Ang.
         direction: vector
-            Polarisation direction.
+            Polarization direction.
         """
-        d_v = np.asarray(direction)
-        self.field_v = strength * d_v / (d_v**2).sum()**0.5 * Bohr / Ha
+        self.strength = strength * Bohr / Ha
+        self.direction_v = np.array(direction, dtype=float)
+        self.direction_v /= np.linalg.norm(self.direction_v)
+        self.field_v = self.strength * self.direction_v
         self.tolerance = tolerance
         self.name = 'ConstantElectricField'
 
     def __str__(self):
         return ('Constant electric field: '
                 '({:.3f}, {:.3f}, {:.3f}) V/Ang'
                 .format(*(self.field_v * Ha / Bohr)))
 
     def calculate_potential(self, gd):
-        # Currently skipped, PW mode is periodic in all directions
-        # d_v = self.field_v / (self.field_v**2).sum()**0.5
-        # for axis_v in gd.cell_cv[gd.pbc_c]:
-        #     if abs(np.dot(d_v, axis_v)) > self.tolerance:
-        #         raise ValueError(
-        #             'Field not perpendicular to periodic axis: {}'
-        #             .format(axis_v))
+        # Note that PW-mode is periodic in all directions!
+        L_c = abs(gd.cell_cv @ self.direction_v)
+        # eps = self.tolerance
+        # assert (L_c < eps).sum() == 2
 
         center_v = 0.5 * gd.cell_cv.sum(0)
         r_gv = gd.get_grid_point_coordinates().transpose((1, 2, 3, 0))
-        self.vext_g = np.dot(r_gv - center_v, self.field_v)
+        f_g = (r_gv - center_v) @ self.direction_v
+
+        # Set potential to zero at boundary of box (important for PW-mode).
+        # Say we have 8 grid points.  Instead of a potential like this:
+        #
+        # -4 -3 -2 -1  0  1  2  3
+        #
+        # we want:
+        #
+        #  0 -3 -2 -1  0  1  2  3
+
+        L = L_c.sum()
+        f_g[abs(abs(f_g) - L / 2) < 1e-5] = 0.0
+
+        self.vext_g = f_g * self.strength
 
     def todict(self):
-        strength = (self.field_v**2).sum()**0.5
         return {'name': self.name,
-                'strength': strength * Ha / Bohr,
-                'direction': self.field_v / strength}
+                'strength': self.strength * Ha / Bohr,
+                'direction': self.direction_v}
 
 
 class ProductPotential(ExternalPotential):
     def __init__(self, ext_i):
         self.ext_i = ext_i
 
     def calculate_potential(self, gd):
@@ -179,15 +191,15 @@
 
 class PointChargePotential(ExternalPotential):
     def __init__(self, charges, positions=None,
                  rc=0.2, rc2=np.inf, width=1.0):
         """Point-charge potential.
 
         charges: list of float
-            Charges.
+            Charges in units of `|e|`.
         positions: (N, 3)-shaped array-like of float
             Positions of charges in Angstrom.  Can be set later.
         rc: float
             Inner cutoff for Coulomb potential in Angstrom.
         rc2: float
             Outer cutoff for Coulomb potential in Angstrom.
         width: float
@@ -373,15 +385,15 @@
         Unit (e^2 Angstrom^2 / eV).
         Multiply with Bohr * Ha to get (Angstrom^3)
     """
     atoms.get_potential_energy()
     calc = atoms.calc
     assert calc.parameters.external is None
     dipole_gs = calc.get_dipole_moment()
-    
+
     alpha = np.zeros((3, 3))
     for c in range(3):
         axes = np.zeros(3)
         axes[c] = 1
         calc.set(external=ConstantElectricField(strength, axes))
         calc.get_potential_energy()
         alpha[c] = (calc.get_dipole_moment() - dipole_gs) / strength
```

### Comparing `gpaw-22.8.0/gpaw/fd_operators.py` & `gpaw-23.6.0/gpaw/fd_operators.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/fdtd/poisson_fdtd.py` & `gpaw-23.6.0/gpaw/fdtd/poisson_fdtd.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/fdtd/polarizable_material.py` & `gpaw-23.6.0/gpaw/fdtd/polarizable_material.py`

 * *Files 0% similar despite different names*

```diff
@@ -312,15 +312,15 @@
         ngv = r_gv.shape
 
         a = self.corners[0]
 
         mask = False * np.ones(ng)
 
         for p in self.corners[1:]:
-            #http://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line:
+            # http://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line:
             # d = |(a-p)-((a-p).n)n|   point p, line a+tn  (|n|=1)
             n = (p-a)/np.sqrt((p-a).dot((p-a)))
             v1 = np.array([a[w]-r_gv[:, :, :, w] for w in range(3)]).transpose((1, 2, 3, 0)) # a-p
 
             v2 = np.sum(np.array([v1[:, :, :, w]*n[w] for w in range(3)]), axis=0)  # (a-p).n
 
             v3 = np.array([v2*n[w] for w in range(3)]).transpose(1, 2, 3, 0)       # ((a-p).n)n
```

### Comparing `gpaw-22.8.0/gpaw/fdtd/potential_couplers.py` & `gpaw-23.6.0/gpaw/fdtd/potential_couplers.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/fftw.py` & `gpaw-23.6.0/gpaw/utilities/folder.py`

 * *Files 25% similar despite different names*

```diff
@@ -1,225 +1,209 @@
-"""
-Python wrapper for FFTW3 library
-================================
-
-.. autoclass:: FFTPlans
-
-"""
-from __future__ import annotations
-
 import numpy as np
-from scipy.fft import fftn, ifftn, irfftn, rfftn
-
-import _gpaw
-from gpaw.typing import Array3D, DTypeLike, IntVector
-
-ESTIMATE = 64
-MEASURE = 0
-PATIENT = 32
-EXHAUSTIVE = 8
 
+from gpaw.gauss import Gauss
 
-def have_fftw() -> bool:
-    """Did we compile with FFTW?"""
-    return hasattr(_gpaw, 'FFTWPlan')
 
+class Lorentz:
+    """Normalized Lorentzian distribution"""
+    def __init__(self, width=0.08):
+        self.dtype = float
+        self.set_width(width)
 
-def check_fft_size(n: int, factors=[2, 3, 5, 7]) -> bool:
-    """Check if n is an efficient fft size.
+    def get(self, x, x0=0):
+        return self.norm / ((x - x0)**2 + self.width2)
 
-    Efficient means that n can be factored into small primes (2, 3, 5, 7).
+    def set_width(self, width=0.08):
+        self.norm = width / np.pi
+        self.width2 = width**2
+        self._fwhm = 2. * width
 
-    >>> check_fft_size(17)
-    False
-    >>> check_fft_size(18)
-    True
-    """
-
-    if n == 1:
-        return True
-    for x in factors:
-        if n % x == 0:
-            return check_fft_size(n // x, factors)
-    return False
+    @property
+    def fwhm(self):
+        return self._fwhm
 
+    @fwhm.setter
+    def fwhm(self, value):
+        self.set_width(value / 2.)
 
-def get_efficient_fft_size(N: int, n=1, factors=[2, 3, 5, 7]) -> int:
-    """Return smallest efficient fft size.
 
-    Must be greater than or equal to N and divisible by n.
+class Voigt:
+    """Voigt profile.
 
-    >>> get_efficient_fft_size(17)
-    18
+    See http://reference.wolfram.com/language/ref/VoigtDistribution.html
     """
-    N = -(-N // n) * n
-    while not check_fft_size(N, factors):
-        N += n
-    return N
-
-
-def empty(shape, dtype=float):
-    """numpy.empty() equivalent with 16 byte alignment."""
-    assert dtype == complex
-    N = np.prod(shape)
-    a = np.empty(2 * N + 1)
-    offset = (a.ctypes.data % 16) // 8
-    a = a[offset:2 * N + offset].view(complex)
-    a.shape = shape
-    return a
-
-
-def create_plans(size_c: IntVector,
-                 dtype: DTypeLike,
-                 flags: int = MEASURE) -> FFTPlans:
-    """Create plan-objects for FFT and inverse FFT."""
-    if have_fftw():
-        return FFTWPlans(size_c, dtype, flags)
-    return NumpyFFTPlans(size_c, dtype)
-
-
-class FFTPlans:
-    def __init__(self,
-                 size_c: IntVector,
-                 dtype: DTypeLike):
-        if dtype == float:
-            rsize_c = (size_c[0], size_c[1], size_c[2] // 2 + 1)
-            self.tmp_Q = empty(rsize_c, complex)
-            self.tmp_R = self.tmp_Q.view(float)[:, :, :size_c[2]]
-        else:
-            self.tmp_Q = empty(size_c, complex)
-            self.tmp_R = self.tmp_Q
-
-    def fft(self) -> None:
-        """Do FFT from ``tmp_R`` to ``tmp_Q``.
-
-        >>> plans = create_plans([4, 1, 1], float)
-        >>> plans.tmp_R[:, 0, 0] = [1, 0, 1, 0]
-        >>> plans.fft()
-        >>> plans.tmp_Q[:, 0, 0]
-        array([2.+0.j, 0.+0.j, 2.+0.j, 0.+0.j])
+    def __init__(self, width=0.08):
+        self.dtype = float
+        self.set_width(width)
+
+    def get(self, x, x0=0):
+        from scipy.special import erfc
+        argm = (-1j * (x - x0) + self.delta) * self.argpre
+        argp = (1j * (x - x0) + self.delta) * self.argpre
+        res = np.exp(argm**2) * erfc(argm)
+        res += np.exp(argp**2) * erfc(argp)
+        return res.real * self.prefactor
+
+    def set_width(self, width=0.08):
+        """Width is interpreted as [delta, sigma]"""
+        if not hasattr(width, '__iter__'):
+            width = [width, width]
+        self.delta, self.sigma = width
+        self.width = np.linalg.norm(np.array(width))
+        self.prefactor = 1. / 2 / np.sqrt(2 * np.pi) / self.sigma
+        self.argpre = 1. / np.sqrt(2) / self.sigma
+
+        """Full width at half maximum approximation after
+        Olivero, J. J.; R. L. Longbothum
+        "Empirical fits to the Voigt line width: A brief review"
+        J. Quantitative Spectroscopy and Radiative Transfer. 17 (1977) 233-236
         """
+        fl = 2 * self.delta
+        fg = np.sqrt(8 * np.log(2)) * self.sigma
+        self._fwhm = 0.5346 * fl + np.sqrt(0.2166 * fl**2 + fg**2)
+
+    @property
+    def fwhm(self):
+        return self._fwhm
+
+    @fwhm.setter
+    def fwhm(self, value):
+        "setting fwhm is not uniquely defined"
         raise NotImplementedError
 
-    def ifft(self) -> None:
-        """Do inverse FFT from ``tmp_Q`` to ``tmp_R``.
 
-        >>> plans = create_plans([4, 1, 1], complex)
-        >>> plans.tmp_Q[:, 0, 0] = [0, 1j, 0, 0]
-        >>> plans.ifft()
-        >>> plans.tmp_R[:, 0, 0]
-        array([ 0.+1.j, -1.+0.j,  0.-1.j,  1.+0.j])
-        """
-        raise NotImplementedError
+class ComplexLorentz:
+    def __init__(self, width=0.08):
+        self.dtype = complex
+        self.set_width(width)
+
+    def get(self, x, x0):
+        return 0.5 / x0 * (((x + x0) / ((x + x0)**2 + self.width2) -
+                            (x - x0) / ((x - x0)**2 + self.width2)) -
+                           1.0j * self.width *
+                           (1 / ((x + x0)**2 + self.width2) -
+                            1 / ((x - x0)**2 + self.width2))
+                           )
+
+    def set_width(self, width=0.08):
+        self.width = width
+        self.width2 = width**2
+
+
+class ComplexGauss:
+    def __init__(self, width=0.08):
+        self.dtype = complex
+        self.set_width(width)
+
+    def get(self, x, x0):
+        from scipy.special import dawsn
+        return 0.5 / x0 * (2 * self.wm1 *
+                           (dawsn((x + x0) * self.wm1) -
+                            dawsn((x - x0) * self.wm1)) -
+                           1.0j * self.norm *
+                           (np.exp(-((x + x0) * self.wm1)**2) -
+                            np.exp(-((x - x0) * self.wm1)**2))
+                           )
+
+    def set_width(self, width=0.08):
+        self.norm = 1. / width * np.sqrt(np.pi / 2)
+        self.wm1 = np.sqrt(.5) / width
+
+
+class LorentzPole:
+    """Pole of a damped harmonic oscillator.
+
+    See: e.g. Frederick Wooten, Optical properties of solids,
+    Academic Press Inc. (1972)"""
+    def __init__(self, width=0.08, imag=True):
+        self.dtype = float
+        if imag:
+            self.get = self.get_imaginary
+        else:
+            self.get = self.get_real
+        self.set_width(width)
 
+    def get_real(self, x, x0):
+        return (x0**2 - x**2) / (
+            (x0**2 - x**2)**2 + self.width**2 * x**2)
 
-class FFTWPlans(FFTPlans):
-    """FFTW3 3d transforms."""
-    def __init__(self, size_c, dtype, flags=MEASURE):
-        if not have_fftw():
-            raise ImportError('Not compiled with FFTW.')
-        super().__init__(size_c, dtype)
-        self._fftplan = _gpaw.FFTWPlan(self.tmp_R, self.tmp_Q, -1, flags)
-        self._ifftplan = _gpaw.FFTWPlan(self.tmp_Q, self.tmp_R, 1, flags)
-
-    def fft(self):
-        _gpaw.FFTWExecute(self._fftplan)
-
-    def ifft(self):
-        _gpaw.FFTWExecute(self._ifftplan)
-
-    def __del__(self):
-        _gpaw.FFTWDestroy(self._fftplan)
-        _gpaw.FFTWDestroy(self._ifftplan)
-
-
-class NumpyFFTPlans(FFTPlans):
-    """Numpy fallback."""
-    def fft(self):
-        if self.tmp_R.dtype == float:
-            self.tmp_Q[:] = rfftn(self.tmp_R, overwrite_x=True)
-        else:
-            self.tmp_Q[:] = fftn(self.tmp_R, overwrite_x=True)
+    def get_imaginary(self, x, x0):
+        return self.width * x / (
+            (x0**2 - x**2)**2 + self.width**2 * x**2)
 
-    def ifft(self):
-        if self.tmp_R.dtype == float:
-            self.tmp_R[:] = irfftn(self.tmp_Q, self.tmp_R.shape,
-                                   norm='forward', overwrite_x=True)
-        else:
-            self.tmp_R[:] = ifftn(self.tmp_Q, self.tmp_R.shape,
-                                  norm='forward', overwrite_x=True)
+    def set_width(self, width=0.08):
+        self.width = width
 
 
-# The rest of this file will be removed in the future ...
+class Folder:
+    """Fold a function with normalised Gaussians or Lorentzians
 
-def check_fftw_inputs(in_R, out_R):
-    for arr in in_R, out_R:
-        # Note: Arrays not necessarily contiguous due to 16-byte alignment
-        assert arr.ndim == 3  # We can perhaps relax this requirement
-        assert arr.dtype == float or arr.dtype == complex
-
-    if in_R.dtype == out_R.dtype == complex:
-        assert in_R.shape == out_R.shape
-    else:
-        # One real and one complex:
-        R, C = (in_R, out_R) if in_R.dtype == float else (out_R, in_R)
-        assert C.dtype == complex
-        assert R.shape[:2] == C.shape[:2]
-        assert C.shape[2] == 1 + R.shape[2] // 2
-
-
-class FFTPlan:
-    """FFT 3d transform."""
-    def __init__(self,
-                 in_R: Array3D,
-                 out_R: Array3D,
-                 sign: int,
-                 flags: int = MEASURE):
-        check_fftw_inputs(in_R, out_R)
-        self.in_R = in_R
-        self.out_R = out_R
-        self.sign = sign
-        self.flags = flags
+    Example: fold a function y(x) by Lorentzians of 0.2 width
 
-    def execute(self) -> None:
-        raise NotImplementedError
+    >>> xlist = np.linspace(-1.0, 1.0, 101)  # list of x-values
+    >>> ylist = np.zeros_like(xlist)  # corresponding list of y(x)-values
+    >>> ylist[50] = 1.0
+    >>> from gpaw.utilities.folder import Folder
+    >>> fxlist, fylist = Folder(width=0.2, folding='Lorentz').fold(
+    ...     xlist, ylist, dx=0.1, xmin=-1, xmax=1)
+    """
+    def __init__(self, width,
+                 folding='Gauss'):
+        self.width = width
+        if folding == 'Gauss':
+            self.func = Gauss(width)
+        elif folding == 'Lorentz':
+            self.func = Lorentz(width)
+        elif folding == 'ComplexGauss':
+            self.func = ComplexGauss(width)
+        elif folding == 'ComplexLorentz':
+            self.func = ComplexLorentz(width)
+        elif folding == 'RealLorentzPole':
+            self.func = LorentzPole(width, imag=False)
+        elif folding == 'ImaginaryLorentzPole':
+            self.func = LorentzPole(width, imag=True)
+        elif folding == 'Voigt':
+            self.func = Voigt(width)
+        else:
+            raise RuntimeError('unknown folding "' + folding + '"')
 
+    def fold(self, x, y, dx=None, xmin=None, xmax=None):
+        X = np.array(x)
+        assert len(X.shape) == 1
+        Y = np.array(y)
+        assert X.shape[0] == Y.shape[0]
+
+        if xmin is None:
+            xmin = np.min(X) - 4 * self.width
+        if xmax is None:
+            xmax = np.max(X) + 4 * self.width
+        if dx is None:
+            try:
+                dx = self.func.width / 4.
+            except AttributeError:
+                dx = self.width / 4.
+
+        xl = np.arange(xmin, xmax + 0.5 * dx, dx)
+
+        return self.fold_values(x, y, xl)
+
+    def fold_values(self, x, y, xl=None):
+        X = np.array(x)
+        assert len(X.shape) == 1
+        Y = np.array(y)
+        assert X.shape[0] == Y.shape[0]
 
-class FFTWPlan(FFTPlan):
-    """FFTW3 3d transform."""
-    def __init__(self, in_R, out_R, sign, flags=MEASURE):
-        if not have_fftw():
-            raise ImportError('Not compiled with FFTW.')
-        self._ptr = _gpaw.FFTWPlan(in_R, out_R, sign, flags)
-        FFTPlan.__init__(self, in_R, out_R, sign, flags)
-
-    def execute(self):
-        _gpaw.FFTWExecute(self._ptr)
-
-    def __del__(self):
-        if getattr(self, '_ptr', None) and _gpaw is not None:
-            _gpaw.FFTWDestroy(self._ptr)
-        self._ptr = None
-
-
-class NumpyFFTPlan(FFTPlan):
-    """Numpy fallback."""
-    def execute(self):
-        if self.in_R.dtype == float:
-            self.out_R[:] = np.fft.rfftn(self.in_R)
-        elif self.out_R.dtype == float:
-            self.out_R[:] = np.fft.irfftn(self.in_R, self.out_R.shape)
-            self.out_R *= self.out_R.size
-        elif self.sign == 1:
-            self.out_R[:] = np.fft.ifftn(self.in_R, self.out_R.shape)
-            self.out_R *= self.out_R.size
+        if xl is None:
+            Xl = np.unique(X)
         else:
-            self.out_R[:] = np.fft.fftn(self.in_R)
+            Xl = np.array(xl)
+            assert len(Xl.shape) == 1
+
+        # weight matrix
+        weightm = np.empty((Xl.shape[0], X.shape[0]),
+                           dtype=self.func.dtype)
+        for i, x in enumerate(X):
+            weightm[:, i] = self.func.get(Xl, x)
 
+        yl = np.tensordot(weightm, Y, axes=(1, 0))
 
-def create_plan(in_R: Array3D,
-                out_R: Array3D,
-                sign: int,
-                flags: int = MEASURE) -> FFTPlan:
-    if have_fftw():
-        return FFTWPlan(in_R, out_R, sign, flags)
-    return NumpyFFTPlan(in_R, out_R, sign, flags)
+        return Xl, yl
```

### Comparing `gpaw-22.8.0/gpaw/forces.py` & `gpaw-23.6.0/gpaw/forces.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/fulldiag.py` & `gpaw-23.6.0/gpaw/fulldiag.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/gaunt.py` & `gpaw-23.6.0/gpaw/gaunt.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/gauss.py` & `gpaw-23.6.0/gpaw/gauss.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/grid_descriptor.py` & `gpaw-23.6.0/gpaw/grid_descriptor.py`

 * *Files 3% similar despite different names*

```diff
@@ -266,31 +266,28 @@
         for i in range(self.parsize_c[axis]):
             pos_c[axis] = i
             peer_ranks.append(self.get_rank_from_processor_position(pos_c))
         peer_comm = self.comm.new_communicator(peer_ranks)
         return peer_comm
 
     def integrate(self, a_xg, b_yg=None,
-                  global_integral=True, hermitian=False,
-                  _transposed_result=None):
+                  global_integral=True, hermitian=False):
         """Integrate function(s) over domain.
 
         a_xg: ndarray
             Function(s) to be integrated.
         b_yg: ndarray
             If present, integrate a_xg.conj() * b_yg.
         global_integral: bool
             If the array(s) are distributed over several domains, then the
             total sum will be returned.  To get the local contribution
             only, use global_integral=False.
         hermitian: bool
             Result is hermitian.
-        _transposed_result: ndarray
-            Long story.  Don't use this unless you are a method of the
-            MatrixOperator class ..."""
+        """
 
         xshape = a_xg.shape[:-3]
 
         if b_yg is None:
             # Only one array:
             result = a_xg.reshape(xshape + (-1,)).sum(axis=-1) * self.dv
             if global_integral:
@@ -300,19 +297,15 @@
                     self.comm.sum(result)
             return result
 
         gsize = prod(a_xg.shape[-3:])
         A_xg = np.ascontiguousarray(a_xg.reshape((-1, gsize)))
         B_yg = np.ascontiguousarray(b_yg.reshape((-1, gsize)))
 
-        if _transposed_result is None:
-            result_yx = np.zeros((len(B_yg), len(A_xg)), A_xg.dtype)
-        else:
-            result_yx = _transposed_result
-            global_integral = False
+        result_yx = np.zeros((len(B_yg), len(A_xg)), A_xg.dtype)
 
         if a_xg is b_yg:
             rk(self.dv, A_xg, 0.0, result_yx)
         elif hermitian:
             r2k(0.5 * self.dv, A_xg, B_yg, 0.0, result_yx)
         else:
             # gemm(self.dv, A_xg, B_yg, 0.0, result_yx, 'c')
```

### Comparing `gpaw-22.8.0/gpaw/hamiltonian.py` & `gpaw-23.6.0/gpaw/hamiltonian.py`

 * *Files 2% similar despite different names*

```diff
@@ -3,15 +3,14 @@
 import functools
 
 import numpy as np
 from ase.units import Ha
 
 from gpaw.arraydict import ArrayDict
 from gpaw.external import create_external_potential
-from gpaw.hubbard import hubbard
 from gpaw.lfc import LFC
 from gpaw.poisson import PoissonSolver
 from gpaw.spinorbit import soc
 from gpaw.transformers import Transformer
 from gpaw.utilities import (pack2, pack_atomic_matrices, unpack,
                             unpack_atomic_matrices)
 from gpaw.utilities.partition import AtomPartition
@@ -307,20 +306,18 @@
             if self.soc:
                 dH_vii = soc(setup, self.xc, D_sp)
                 dH_sp = np.zeros_like(D_sp, dtype=complex)
                 dH_sp[1:] = pack2(dH_vii)
             else:
                 dH_sp = np.zeros_like(D_sp)
 
-            if setup.HubU is not None:
-                # assert self.collinear
-                for l, U, scale in zip(setup.Hubl, setup.HubU, setup.Hubs):
-                    eU, dHU_sp = hubbard(setup, D_sp, l, U, scale)
-                    e_xc += eU
-                    dH_sp += dHU_sp
+            if setup.hubbard_u is not None:
+                eU, dHU_sp = setup.hubbard_u.calculate(setup, D_sp)
+                e_xc += eU
+                dH_sp += dHU_sp
 
             dH_sp[:self.nspins] += dH_p
 
             if self.vext is not None:
                 self.vext.paw_correction(setup.Delta_pL[:, 0], dH_sp)
 
             if self.vext and self.vext.get_name() == 'CDFTPotential':
@@ -738,14 +735,15 @@
         # npoisson is the number of iterations:
         self.npoisson = self.poisson.solve(self.vHt_g, dens.rhot_g,
                                            charge=-dens.charge,
                                            timer=self.timer)
         self.timer.stop('Poisson')
 
         self.timer.start('Hartree integrate/restrict')
+
         e_coulomb = 0.5 * self.finegd.integrate(self.vHt_g, dens.rhot_g,
                                                 global_integral=False)
 
         for vt_g in self.vt_sg:
             vt_g += self.vHt_g
 
         self.timer.stop('Hartree integrate/restrict')
```

### Comparing `gpaw-22.8.0/gpaw/helmholtz.py` & `gpaw-23.6.0/gpaw/helmholtz.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/hgh.py` & `gpaw-23.6.0/gpaw/hgh.py`

 * *Files 0% similar despite different names*

```diff
@@ -128,15 +128,15 @@
         # j ordering is significant, must be nl rather than ln
         for n, l in self.hghdata.nl_iter():
             n_j.append(n + 1)  # Note: actual n must be positive!
             l_j.append(l)
         assert nj == len(n_j)
         self.nj = nj
         self.l_j = l_j
-        self.l_orb_j = l_j
+        self.l_orb_J = l_j
         self.n_j = n_j
 
         self.rcut_j = []
         self.pt_jg = []
 
         for n, l in zip(n_j, l_j):
             # Note: even pseudopotentials without projectors will get one
```

### Comparing `gpaw-22.8.0/gpaw/hgh_parameters.py` & `gpaw-23.6.0/gpaw/hgh_parameters.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/hybrids/coulomb.py` & `gpaw-23.6.0/gpaw/hybrids/coulomb.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,31 +1,28 @@
 from math import pi
 
 import numpy as np
 
-from io import StringIO
-from gpaw.response.wstc import WignerSeitzTruncatedCoulomb as WSTC
+from gpaw.hybrids.wstc import WignerSeitzTruncatedCoulomb as WSTC
 
 
 def coulomb_interaction(omega, gd, kd):
     if omega:
         return ShortRangeCoulomb(omega)
-    # Wigner-Seitz truncated Coulomb:
-    output = StringIO()
-    coulomb = WSTC(gd.cell_cv, kd.N_c, txt=output)
-    coulomb.description = output.getvalue()
-    return coulomb
+    return WSTC(gd.cell_cv, kd.N_c)
 
 
 class ShortRangeCoulomb:
     def __init__(self, omega):
         self.omega = omega
-        self.description = (
-            f'Short-range Coulomb: erfc(omega*r)/r (omega = {omega} bohr^-1)')
 
+    def get_description(self):
+        return f'Short-range Coulomb: erfc(omega*r)/r (omega = {self.omega} ' \
+               'bohr^-1)'
+    
     def get_potential(self, pd):
         G2_G = pd.G2_qG[0]
         x_G = 1 - np.exp(-G2_G / (4 * self.omega**2))
         with np.errstate(invalid='ignore'):
             v_G = 4 * pi * x_G / G2_G
         G0 = G2_G.argmin()
         if G2_G[G0] < 1e-11:
```

### Comparing `gpaw-22.8.0/gpaw/hybrids/eigenvalues.py` & `gpaw-23.6.0/gpaw/hybrids/eigenvalues.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,40 +1,45 @@
 """Calculate non self-consistent eigenvalues for hybrid functionals."""
+from __future__ import annotations
 import functools
 import json
 from pathlib import Path
-from typing import List, Union, Tuple, Generator, Optional
+from typing import Generator, List, Optional, Tuple, Union
 
 import numpy as np
 from ase.units import Ha
-
-from gpaw.calculator import GPAW
-from gpaw.mpi import serial_comm
-from gpaw.xc import XC
-from gpaw.xc.tools import vxc
+from gpaw.calculator import GPAW as GPAWOld
+from gpaw import GPAW
+from gpaw.new.ase_interface import ASECalculator
 from gpaw.kpt_descriptor import KPointDescriptor
+from gpaw.mpi import serial_comm
 from gpaw.pw.descriptor import PWDescriptor
 from gpaw.pw.lfc import PWLFC
 from gpaw.typing import Array3D
+from gpaw.xc import XC
+from gpaw.xc.kernel import XCNull
+from gpaw.xc.tools import vxc
+
 from . import parse_name
 from .coulomb import coulomb_interaction
-from .kpts import RSKPoint, to_real_space, get_kpt
+from .kpts import RSKPoint, get_kpt, to_real_space
 from .paw import calculate_paw_stuff
 from .symmetry import Symmetry
 
 
-def non_self_consistent_eigenvalues(calc: Union[GPAW, str, Path],
-                                    xcname: str,
-                                    n1: int = 0,
-                                    n2: int = 0,
-                                    kpt_indices: List[int] = None,
-                                    snapshot: Union[str, Path] = None,
-                                    ftol: float = 1e-9) -> Tuple[Array3D,
-                                                                 Array3D,
-                                                                 Array3D]:
+def non_self_consistent_eigenvalues(
+        calc: Union[GPAWOld, ASECalculator, str, Path],
+        xcname: str,
+        n1: int = 0,
+        n2: int = 0,
+        kpt_indices: List[int] = None,
+        snapshot: Union[str, Path] = None,
+        ftol: float = 1e-9) -> tuple[Array3D,
+                                     Array3D,
+                                     Array3D]:
     """Calculate non self-consistent eigenvalues for a hybrid functional.
 
     Based on a self-consistent DFT calculation (calc).  Only eigenvalues n1 to
     n2 - 1 for the IBZ indices in kpt_indices are calculated
     (default is all bands and all k-points). EXX integrals involving
     states with occupation numbers less than ftol are skipped.  Use
     snapshot='name.json' to get snapshots for each k-point finished.
@@ -43,21 +48,22 @@
     with contributions to the eigenvalues in eV:
 
     >>> nsceigs = non_self_consistent_eigenvalues
     >>> eig_dft, vxc_dft, vxc_hyb = nsceigs('<gpw-file>', xcname='PBE0')
     >>> eig_hyb = eig_dft - vxc_dft + vxc_hyb
     """
 
-    if not isinstance(calc, GPAW):
+    if not isinstance(calc, (GPAWOld, ASECalculator)):
         if calc == '<gpw-file>':  # for doctest
             return (np.zeros((1, 1, 1)),
                     np.zeros((1, 1, 1)),
                     np.zeros((1, 1, 1)))
         calc = GPAW(Path(calc), txt=None, parallel={'band': 1, 'kpt': 1})
 
+    assert isinstance(calc, (GPAWOld, ASECalculator))
     wfs = calc.wfs
 
     if n2 <= 0:
         n2 += wfs.bd.nbands
 
     if kpt_indices is None:
         kpt_indices = np.arange(wfs.kd.nibzkpts).tolist()
@@ -78,15 +84,14 @@
 
     if v_dft_sin.size == 0:
         xc = XC(xcname)
         e_dft_sin, v_dft_sin, v_hyb_sl_sin = _semi_local(
             calc, xc, n1, n2, kpt_indices)
         write_snapshot(e_dft_sin, v_dft_sin, v_hyb_sl_sin, v_hyb_nl_sin,
                        path, wfs.world)
-
     # Non-local hybrid contribution
     if v_hyb_nl_sin is None:
         v_hyb_nl_sin = [[] for s in range(wfs.nspins)]
 
     # Find missing indices:
     kpt_indices_s = [kpt_indices[len(v_hyb_nl_in):]
                      for v_hyb_nl_in in v_hyb_nl_sin]
@@ -99,43 +104,46 @@
                            path, wfs.world)
 
     return (e_dft_sin * Ha,
             v_dft_sin * Ha,
             (v_hyb_sl_sin + v_hyb_nl_sin) * Ha)
 
 
-def _semi_local(calc: GPAW,
+def _semi_local(calc: GPAWOld | ASECalculator,
                 xc,
                 n1: int,
                 n2: int,
                 kpt_indices: List[int]
                 ) -> Tuple[np.ndarray, np.ndarray, np.ndarray]:
     wfs = calc.wfs
     nspins = wfs.nspins
     e_dft_sin = np.array([[calc.get_eigenvalues(k, spin)[n1:n2]
                            for k in kpt_indices]
                           for spin in range(nspins)])
-    v_dft_sin = vxc(calc.gs_adapter())[:, kpt_indices, n1:n2]
-    v_hyb_sl_sin = vxc(calc.gs_adapter(), xc)[:, kpt_indices, n1:n2]
+    v_dft_sin = vxc(calc.gs_adapter(), n1=n1, n2=n2)[:, kpt_indices]
+    if isinstance(xc.kernel, XCNull):
+        v_hyb_sl_sin = np.zeros_like(v_dft_sin)
+    else:
+        v_hyb_sl_sin = vxc(calc.gs_adapter(), xc, n1=n1, n2=n2)[:, kpt_indices]
     return e_dft_sin / Ha, v_dft_sin / Ha, v_hyb_sl_sin / Ha
 
 
-def _non_local(calc: GPAW,
+def _non_local(calc: GPAWOld | ASECalculator,
                n1: int,
                n2: int,
                kpt_indices_s: List[List[int]],
                ftol: float,
                omega: float) -> Generator[Tuple[int, np.ndarray], None, None]:
     wfs = calc.wfs
     kd = wfs.kd
     dens = calc.density
 
     nocc = max(((kpt.f_n / kpt.weight) > ftol).sum()
                for kpt in wfs.kpt_u)
-    nocc = kd.comm.max(int(nocc))
+    nocc = kd.comm.max(wfs.bd.comm.sum(int(nocc)))
 
     coulomb = coulomb_interaction(omega, wfs.gd, kd)
     sym = Symmetry(kd)
 
     paw_s = calculate_paw_stuff(wfs, dens)
 
     for spin, kpt_indices in enumerate(kpt_indices_s):
```

### Comparing `gpaw-22.8.0/gpaw/hybrids/energy.py` & `gpaw-23.6.0/gpaw/hybrids/energy.py`

 * *Files 0% similar despite different names*

```diff
@@ -55,15 +55,15 @@
     dens = calc.density
     kd = wfs.kd
     setups = wfs.setups
     nspins = wfs.nspins
 
     nocc = max(((kpt.f_n / kpt.weight) > ftol).sum()
                for kpt in wfs.kpt_u)
-    nocc = kd.comm.max(int(nocc))
+    nocc = kd.comm.max(wfs.bd.comm.sum(int(nocc)))
 
     xcname, exx_fraction, omega = parse_name(xcname)
 
     xc = XC(xcname)
     exc = 0.0
     for a, D_sp in dens.D_asp.items():
         exc += xc.calculate_paw_correction(setups[a], D_sp)
```

### Comparing `gpaw-22.8.0/gpaw/hybrids/forces.py` & `gpaw-23.6.0/gpaw/hybrids/forces.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/hybrids/kpts.py` & `gpaw-23.6.0/gpaw/hybrids/kpts.py`

 * *Files 9% similar despite different names*

```diff
@@ -91,15 +91,15 @@
         proj = Projections(n2 - n1,
                            nproj_a,
                            atom_partition,
                            spin=spin,
                            dtype=wfs.dtype,
                            data=P_nI)
 
-        rank_a = np.linspace(0, wfs.world.size, len(wfs.spos_ac),
+        rank_a = np.linspace(0, wfs.world.size, len(wfs.setups),
                              endpoint=False).astype(int)
         atom_partition = AtomPartition(wfs.world, rank_a)
         proj = proj.redist(atom_partition)
 
         f_n = wfs.collect_occupations(k, spin)
         if wfs.world.rank != 0:
             f_n = np.empty(n2 - n1)
```

### Comparing `gpaw-22.8.0/gpaw/hybrids/paw.py` & `gpaw-23.6.0/gpaw/hybrids/paw.py`

 * *Files 4% similar despite different names*

```diff
@@ -16,15 +16,15 @@
 def calculate_paw_stuff(wfs, dens) -> List[PAWThings]:
     D_asp = dens.D_asp
     comm = D_asp.partition.comm
     if comm.size != wfs.world.size:
         D_sP = pack_atomic_matrices(D_asp)
         D_sP = broadcast(D_sP if comm.rank == 0 else None, comm=comm)
         D_asp = unpack_atomic_matrices(D_sP, wfs.setups)
-        rank_a = np.linspace(0, wfs.world.size, len(wfs.spos_ac),
+        rank_a = np.linspace(0, wfs.world.size, len(wfs.setups),
                              endpoint=False).astype(int)
         D_asp = {a: D_sp for a, D_sp in D_asp.items()
                  if rank_a[a] == wfs.world.rank}
 
     VV_saii: List[Dict[int, np.ndarray]] = [{} for s in range(dens.nspins)]
     for a, D_sp in D_asp.items():
         data = wfs.setups[a]
```

### Comparing `gpaw-22.8.0/gpaw/hybrids/scf.py` & `gpaw-23.6.0/gpaw/hybrids/scf.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/hybrids/symmetry.py` & `gpaw-23.6.0/gpaw/hybrids/symmetry.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,9 +1,8 @@
 from math import pi
-from typing import Dict, Tuple
 from collections import defaultdict
 
 import numpy as np
 
 from gpaw.kpt_descriptor import KPointDescriptor
 from .kpts import RSKPoint, to_real_space
 
@@ -128,15 +127,15 @@
         symmetries_k = []
         for k in range(kd.nibzkpts):
             indices = np.where(kd.bz2ibz_k == k)[0]
             sindices = (kd.sym_k[indices] +
                         kd.time_reversal_k[indices] * nsym)
             symmetries_k.append(sindices)
 
-        pairs: Dict[Tuple[int, int, int], int]
+        # pairs: Dict[Tuple[int, int, int], int]
 
         pairs1 = defaultdict(int)
         for i1 in range(kd.nibzkpts):
             for s1 in symmetries_k[i1]:
                 for i2 in range(kd.nibzkpts):
                     for s2 in symmetries_k[i2]:
                         s3 = self.symmetry_map_ss[s1, s2]
```

### Comparing `gpaw-22.8.0/gpaw/hybrids/wrapper.py` & `gpaw-23.6.0/gpaw/hybrids/wrapper.py`

 * *Files 4% similar despite different names*

```diff
@@ -77,15 +77,15 @@
         return self.ekin
 
     def apply_orbital_dependent_hamiltonian(self, kpt, psit_xG,
                                             Htpsit_xG=None, dH_asp=None):
         wfs = self.wfs
         if self.coulomb is None:
             self.coulomb = coulomb_interaction(self.omega, wfs.gd, wfs.kd)
-            self.description += f'\n{self.coulomb.description}'
+            self.description += '\n' + self.coulomb.get_description()
             self.sym = Symmetry(wfs.kd)
 
         paw_s = calculate_paw_stuff(wfs, self.dens)  # ???????
 
         if kpt.f_n is None:
             # Just use LDA_X for first step:
             if self.vlda_sR is None:
```

### Comparing `gpaw-22.8.0/gpaw/hyperfine.py` & `gpaw-23.6.0/gpaw/hyperfine.py`

 * *Files 0% similar despite different names*

```diff
@@ -89,15 +89,15 @@
 def smooth_part(spin_density_R: Array3D,
                 gd: GridDescriptor,
                 spos_ac: Array2D,
                 ecut: float = None) -> Array3D:
     """Contribution from pseudo spin-density."""
     pd = PWDescriptor(ecut, gd)
     spin_density_G = pd.fft(spin_density_R)
-    G_Gv = pd.get_reciprocal_vectors()
+    G_Gv = pd.get_reciprocal_vectors(add_q=False)
     # eiGR_aG = np.exp(-1j * spos_ac.dot(gd.cell_cv).dot(G_Gv.T))
     eiGR_aG = np.exp(-1j * spos_ac @ gd.cell_cv @ G_Gv.T)
 
     # Isotropic term:
     W1_a = pd.integrate(spin_density_G, eiGR_aG) / gd.dv * (2 / 3)
 
     spin_density_G[0] = 0.0
```

### Comparing `gpaw-22.8.0/gpaw/inducedfield/inducedfield_base.py` & `gpaw-23.6.0/gpaw/inducedfield/inducedfield_base.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/inducedfield/inducedfield_fdtd.py` & `gpaw-23.6.0/gpaw/inducedfield/inducedfield_fdtd.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/inducedfield/inducedfield_lrtddft.py` & `gpaw-23.6.0/gpaw/inducedfield/inducedfield_lrtddft.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/inducedfield/inducedfield_tddft.py` & `gpaw-23.6.0/gpaw/inducedfield/inducedfield_tddft.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/io/fmf.py` & `gpaw-23.6.0/gpaw/io/fmf.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/io/logger.py` & `gpaw-23.6.0/gpaw/io/logger.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/io/old.py` & `gpaw-23.6.0/gpaw/io/old.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/io/tar.py` & `gpaw-23.6.0/gpaw/io/tar.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/jellium.py` & `gpaw-23.6.0/gpaw/jellium.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/kohnsham_layouts.py` & `gpaw-23.6.0/gpaw/kohnsham_layouts.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/kpoint.py` & `gpaw-23.6.0/gpaw/kpoint.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/kpt_descriptor.py` & `gpaw-23.6.0/gpaw/kpt_descriptor.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/kpt_refine.py` & `gpaw-23.6.0/gpaw/kpt_refine.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/lcao/analyse_basis.py` & `gpaw-23.6.0/gpaw/lcao/analyse_basis.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/lcao/atomic_correction.py` & `gpaw-23.6.0/gpaw/lcao/atomic_correction.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/lcao/bsse.py` & `gpaw-23.6.0/gpaw/lcao/bsse.py`

 * *Files 4% similar despite different names*

```diff
@@ -22,19 +22,20 @@
 nonzero_function = Spline(0, min_locfun_radius, [0.0, 1.0e-12, 0.0])  # XXX
 
 
 class GhostSetup(BaseSetup):
     def __init__(self, basis, data):
         self.symbol = data.symbol
         self.data = data
-        self.phit_j = basis.tosplines()
+        self.basis_functions_J = basis.tosplines()
+        self.pseudo_partial_waves_j = None  # XXX ?
+
         self.basis = basis
         self.nao = sum([2 * phit.get_angular_momentum_number() + 1
-                        for phit in self.phit_j])
-        self.HubU = None
+                        for phit in self.basis_functions_J])
         self.filename = None
         self.fingerprint = None
         self.type = 'ghost'
 
         self.Z = 0
         self.Nv = 0
         self.Nc = 0
@@ -64,15 +65,15 @@
         self.K_p = np.zeros(1)
         self.MB = 0.0
         self.MB_p = np.zeros(1)
         self.dO_ii = np.zeros((1, 1))
         self.f_j = [0.0]
         self.n_j = [0]
         self.l_j = [0]
-        self.l_orb_j = [0]
+        self.l_orb_J = [0]
         self.nj = 1
         self.lq = None  # XXXX
 
         self.rcutfilter = None
         self.rcore = None
         self.N0_p = np.zeros(1)
         self.nabla_iiv = np.zeros((self.ni, self.ni, 3))
```

### Comparing `gpaw-22.8.0/gpaw/lcao/eigensolver.py` & `gpaw-23.6.0/gpaw/lcao/eigensolver.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/lcao/el_ph.py` & `gpaw-23.6.0/gpaw/lcao/el_ph.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/lcao/generate_extended.py` & `gpaw-23.6.0/gpaw/lcao/generate_extended.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/lcao/generate_ngto_augmented.py` & `gpaw-23.6.0/gpaw/lcao/generate_ngto_augmented.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/lcao/overlap.py` & `gpaw-23.6.0/gpaw/lcao/overlap.py`

 * *Files 3% similar despite different names*

```diff
@@ -94,37 +94,14 @@
     g = np.zeros(m)
     for n in range(l + 1):
         g += (dr * 2 * m * k**(l - n) *
               ifft(C[l][n] * f * r**(1 + l - n), 2 * m)[:m].real)
     return g
 
 
-def spherical_harmonics(R_c, lmax=LMAX):
-    R_c = np.asarray(R_c)
-    rlY_lm = []
-    for l in range(lmax):
-        rlY_m = np.empty(2 * l + 1)
-        Yl(l, R_c, rlY_m)
-        rlY_lm.append(rlY_m)
-    return rlY_lm
-
-
-def spherical_harmonics_and_derivatives(R_c, lmax=LMAX):
-    R_c = np.asarray(R_c)
-    drlYdR_lmc = []
-    rlY_lm = spherical_harmonics(R_c, lmax)
-    for l, rlY_m in enumerate(rlY_lm):
-        drlYdR_mc = np.empty((2 * l + 1, 3))
-        for m in range(2 * l + 1):
-            L = l**2 + m
-            drlYdR_mc[m, :] = nablarlYL(L, R_c)
-        drlYdR_lmc.append(drlYdR_mc)
-    return rlY_lm, drlYdR_lmc
-
-
 class BaseOverlapExpansionSet:
     def __init__(self, shape):
         self.shape = shape
 
     def zeros(self, shape=(), dtype=float):
         return np.zeros(shape + self.shape, dtype=dtype)
 
@@ -136,67 +113,19 @@
         self.lb = lb
         self.lmaxgaunt = max(la, lb)
         self.spline_l = spline_l
         self.lmaxspline = (la + lb) % 2 + 2 * len(self.spline_l)
         BaseOverlapExpansionSet.__init__(self, (2 * la + 1, 2 * lb + 1))
         self.cspline_l = [spline.spline for spline in self.spline_l]
 
-    def get_gaunt(self, l):
-        la = self.la
-        lb = self.lb
-        G_LLL = gaunt(max(la, lb))
-        G_mmm = G_LLL[la**2:(la + 1)**2,
-                      lb**2:(lb + 1)**2,
-                      l**2:(l + 1)**2]
-        return G_mmm
-
-    def gaunt_iter(self):
-        la = self.la
-        lb = self.lb
-        l = (la + lb) % 2
-        for spline in self.spline_l:
-            G_mmm = self.get_gaunt(l)
-            yield l, spline, G_mmm
-            l += 2
-
-    def old_evaluate(self, r, rlY_lm):
-        """Get overlap between localized functions.
-
-        Apply Gaunt coefficients to the list of real-space splines
-        describing the overlap integral."""
-        timer.start('oe eval')
-        x_mi = self.zeros()
-        for l, spline, G_mmm in self.gaunt_iter():
-            s = spline(r)
-            if abs(s) > 1e-10:
-                x_mi += s * np.dot(G_mmm, rlY_lm[l])
-        timer.stop('oe eval')
-        return x_mi
-
     def evaluate(self, r, rlY_lm, G_LLL, x_mi, _nil=np.empty(0)):
         _gpaw.tci_overlap(self.la, self.lb, G_LLL, self.cspline_l,
                           r, rlY_lm, x_mi,
                           False, _nil, _nil, _nil)
 
-    def old_derivative(self, r, Rhat_c, rlY_lm, G_LLL, drlYdR_lmc):
-        """Get derivative of overlap between localized functions.
-
-        This function assumes r > 0.  If r = 0, i.e. if the functions
-        reside on the same atom, the derivative is zero in any case."""
-        timer.start('oldderiv')
-        dxdR_cmi = self.zeros((3,))
-        for l, spline, G_mmm in self.gaunt_iter():
-            x, dxdr = spline.get_value_and_derivative(r)
-            if abs(x) > 1e-10:
-                GrlY_mi = np.dot(G_mmm, rlY_lm[l])
-                dxdR_cmi += dxdr * Rhat_c[:, None, None] * GrlY_mi
-                dxdR_cmi += x * np.dot(G_mmm, drlYdR_lmc[l]).transpose(2, 0, 1)
-        timer.stop('oldderiv')
-        return dxdR_cmi
-
     def derivative(self, r, Rhat_c, rlY_L, G_LLL, drlYdR_Lc, dxdR_cmi,
                    _nil=np.empty(0)):
         # timer.start('deriv')
         _gpaw.tci_overlap(self.la, self.lb, G_LLL, self.cspline_l,
                           r, rlY_L, _nil,
                           True, Rhat_c, drlYdR_Lc, dxdR_cmi)
         # timer.stop('deriv')
@@ -301,16 +230,14 @@
     def evaluate_slice(self, disp, x_xqMM):
         if disp.a2 in self.local_indices:
             self.msoe.evaluate_slice(disp, x_xqMM)
 
 
 class ManySiteDictionaryWrapper(DomainDecomposedExpansions):
     # Used with dictionaries such as P_aqMi and dPdR_aqcMi
-    # Works only with NeighborPairs, not SimpleAtomIter, since it
-    # compensates for only seeing the atoms once
 
     def getslice(self, a1, a2, xdict_aqxMi):
         msoe = self.msoe
         tsoe = msoe.tsoe_II[msoe.I1_a[a1], msoe.I2_a[a2]]
         Mstart = self.msoe.M1_a[a1]
         Mend = Mstart + tsoe.shape[0]
         return xdict_aqxMi[a2][..., Mstart:Mend, :], tsoe
@@ -367,34 +294,14 @@
                 x_qxmm[..., Mstart1b - Mstart1:Mend1b - Mstart1, :]
         # This is all right as long as we are only interested in a2 <= a1
         # if a1 in self.local_indices and a2 < a1 and (self.astart <=
         #                                              a2 < self.aend):
         #     self.evaluate_slice(disp.reverse(), x_xqNM)
 
 
-class SimpleAtomIter:
-    def __init__(self, cell_cv, spos1_ac, spos2_ac, offsetsteps=0):
-        self.cell_cv = cell_cv
-        self.spos1_ac = spos1_ac
-        self.spos2_ac = spos2_ac
-        self.offsetsteps = offsetsteps
-
-    def iter(self):
-        """Yield all atom index pairs and corresponding displacements."""
-        offsetsteps = self.offsetsteps
-        offsetrange = range(-offsetsteps, offsetsteps + 1)
-        offsets = np.array([(i, j, k) for i in offsetrange for j in offsetrange
-                            for k in offsetrange])
-        for a1, spos1_c in enumerate(self.spos1_ac):
-            for a2, spos2_c in enumerate(self.spos2_ac):
-                for offset in offsets:
-                    R_c = np.dot(spos2_c - spos1_c + offset, self.cell_cv)
-                    yield a1, a2, R_c, offset
-
-
 class NeighborPairs:
     """Class for looping over pairs of atoms using a neighbor list."""
     def __init__(self, cutoff_a, cell_cv, pbc_c, self_interaction):
         self.neighbors = PrimitiveNeighborList(
             cutoff_a, skin=0, sorted=True,
             self_interaction=self_interaction,
             use_scaled_positions=True)
@@ -430,21 +337,14 @@
     def iter(self):
         for a1, a2, R_c, offset in self.pairs.iter():
             yield a1, a2, R_c, offset
             if a1 == a2 and offset.any():
                 yield a1, a1, -R_c, -offset
 
 
-class PairsBothWays(PairFilter):
-    def iter(self):
-        for a1, a2, R_c, offset in self.pairs.iter():
-            yield a1, a2, R_c, offset
-            yield a2, a1, -R_c, -offset
-
-
 class OppositeDirection(PairFilter):
     def iter(self):
         for a1, a2, R_c, offset in self.pairs.iter():
             yield a2, a1, -R_c, -offset
 
 
 class FourierTransformer:
@@ -734,15 +634,16 @@
         timer.start('tci init')
         cutoff_I = []
         setups_I = setups.setups.values()
         I_setup = {}
         for I, setup in enumerate(setups_I):
             I_setup[setup] = I
             cutoff_I.append(max([func.get_cutoff()
-                                 for func in setup.phit_j + setup.pt_j]))
+                                 for func
+                                 in setup.basis_functions_J + setup.pt_j]))
 
         I_a = []
         for setup in setups:
             I_a.append(I_setup[setup])
 
         cutoff_a = [cutoff_I[I] for I in I_a]
 
@@ -777,15 +678,15 @@
         # Range of basis functions for BLACS distribution of matrices:
         self.Mmystart = Mmystart
         self.mynao = mynao
         self.blacs = mynao is not None
 
     def calculate_expansions(self):
         timer.start('tci calc exp')
-        phit_Ij = [setup.phit_j for setup in self.setups_I]
+        phit_Ij = [setup.basis_functions_J for setup in self.setups_I]
         l_Ij = []
         for phit_j in phit_Ij:
             l_Ij.append([phit.get_angular_momentum_number()
                          for phit in phit_j])
 
         pt_l_Ij = [setup.l_j for setup in self.setups_I]
         pt_Ij = [setup.pt_j for setup in self.setups_I]
```

### Comparing `gpaw-22.8.0/gpaw/lcao/projected_wannier.py` & `gpaw-23.6.0/gpaw/lcao/projected_wannier.py`

 * *Files 1% similar despite different names*

```diff
@@ -58,15 +58,16 @@
 
 def eigvals(H, S):
     return np.sort(la.eigvals(la.solve(S, H)).real)
 
 
 def get_bfs(calc):
     wfs = calc.wfs
-    bfs = BasisFunctions(wfs.gd, [setup.phit_j for setup in wfs.setups],
+    bfs = BasisFunctions(wfs.gd,
+                         [setup.basis_functions_J for setup in wfs.setups],
                          wfs.kd, cut=True)
     bfs.set_positions(wfs.spos_ac)
     return bfs
 
 
 def get_lcao_projections_HSP(calc, bfs=None, spin=0, projectionsonly=True):
     """Some title.
```

### Comparing `gpaw-22.8.0/gpaw/lcao/pwf2.py` & `gpaw-23.6.0/gpaw/lcao/pwf2.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/lcao/scissors.py` & `gpaw-23.6.0/gpaw/lcao/scissors.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/lcao/tci.py` & `gpaw-23.6.0/gpaw/lcao/tci.py`

 * *Files 1% similar despite different names*

```diff
@@ -88,15 +88,15 @@
     def new_from_setups(cls, setups):
         I_setup = {}
         setups_I = list(setups.setups.values())
         for I, setup in enumerate(setups_I):
             I_setup[setup] = I
         I_a = [I_setup[setup] for setup in setups]
 
-        return TCIExpansions([s.phit_j for s in setups_I],
+        return TCIExpansions([s.basis_functions_J for s in setups_I],
                              [s.pt_j for s in setups_I],
                              I_a)
 
     def get_tci_calculator(self, cell_cv, spos_ac, pbc_c, ibzk_qc, dtype):
         return TCICalculator(self, cell_cv, spos_ac, pbc_c, ibzk_qc, dtype)
 
     def get_manytci_calculator(self, setups, gd, spos_ac, ibzk_qc, dtype,
```

### Comparing `gpaw-22.8.0/gpaw/lcao/tightbinding.py` & `gpaw-23.6.0/gpaw/lcao/tightbinding.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/lcao/tools.py` & `gpaw-23.6.0/gpaw/lcao/tools.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/lcaotddft/__init__.py` & `gpaw-23.6.0/gpaw/lcaotddft/__init__.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/lcaotddft/densitymatrix.py` & `gpaw-23.6.0/gpaw/lcaotddft/densitymatrix.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/lcaotddft/dipolemomentwriter.py` & `gpaw-23.6.0/gpaw/lcaotddft/dipolemomentwriter.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/lcaotddft/energywriter.py` & `gpaw-23.6.0/gpaw/lcaotddft/energywriter.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/lcaotddft/frequencydensitymatrix.py` & `gpaw-23.6.0/gpaw/lcaotddft/frequencydensitymatrix.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/lcaotddft/hamiltonian.py` & `gpaw-23.6.0/gpaw/lcaotddft/hamiltonian.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/lcaotddft/ksdecomposition.py` & `gpaw-23.6.0/gpaw/lcaotddft/ksdecomposition.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/lcaotddft/laser.py` & `gpaw-23.6.0/gpaw/lcaotddft/laser.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/lcaotddft/linedensity.py` & `gpaw-23.6.0/gpaw/lcaotddft/linedensity.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/lcaotddft/logger.py` & `gpaw-23.6.0/gpaw/lcaotddft/logger.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/lcaotddft/magneticmomentwriter.py` & `gpaw-23.6.0/gpaw/lcaotddft/magneticmomentwriter.py`

 * *Files 0% similar despite different names*

```diff
@@ -418,15 +418,15 @@
         lines = [f'{self.__class__.__name__}[version={self.version}]'
                  f'(**{json.dumps(kwargs)})',
                  'origin_v = [%.6f, %.6f, %.6f] Å' % tuple(origin_v * Bohr)]
         self._write('# ' + '\n# '.join(lines) + '\n')
         self._write(f'# {"time":>15} {"mmx":>17} {"mmy":>22} {"mmz":>22}\n')
 
     def _read_header(self, filename):
-        with open(filename, 'r') as fd:
+        with open(filename, 'r', encoding='utf-8') as fd:
             line = fd.readline()
         try:
             name, version, kwargs = parse_header(line[2:])
         except ValueError as e:
             raise ValueError(f'File {filename} cannot be parsed: {e}')
         if name != self.__class__.__name__:
             raise ValueError(f'File {filename} is not '
```

### Comparing `gpaw-22.8.0/gpaw/lcaotddft/observer.py` & `gpaw-23.6.0/gpaw/lcaotddft/observer.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/lcaotddft/propagators.py` & `gpaw-23.6.0/gpaw/lcaotddft/propagators.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/lcaotddft/qed.py` & `gpaw-23.6.0/gpaw/lcaotddft/qed.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/lcaotddft/quadrupolemomentwriter.py` & `gpaw-23.6.0/gpaw/lcaotddft/quadrupolemomentwriter.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/lcaotddft/restartfilewriter.py` & `gpaw-23.6.0/gpaw/lcaotddft/restartfilewriter.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/lcaotddft/tcm.py` & `gpaw-23.6.0/gpaw/lcaotddft/tcm.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,11 +1,8 @@
 import numpy as np
-import matplotlib as mpl
-import matplotlib.pyplot as plt
-from matplotlib.colors import Normalize, LogNorm
 
 
 def generate_gridspec(**kwargs):
     from matplotlib.gridspec import GridSpec
     width = 0.84
     bottom = 0.12
     left = 0.12
@@ -55,14 +52,15 @@
         self.energy_u = energy_u
         self.fermilevel = fermilevel
 
         self.base_o = np.zeros_like(energy_o)
         self.base_u = np.zeros_like(energy_u)
 
     def __getattr__(self, attr):
+        import matplotlib.pyplot as plt
         # Generate axis only when needed
         if attr in ['ax_occ_dos', 'ax_unocc_dos', 'ax_tcm']:
             gs = generate_gridspec(hspace=0.05, wspace=0.05)
             self.ax_occ_dos = plt.subplot(gs[0])
             self.ax_unocc_dos = plt.subplot(gs[3])
             self.ax_tcm = plt.subplot(gs[2])
             return getattr(self, attr)
@@ -74,14 +72,17 @@
             self.ax_cbar = plt.axes((0.15, 0.6, 0.02, 0.1))
             return getattr(self, attr)
         raise AttributeError('%s object has no attribute %s' %
                              (repr(self.__class__.__name__), repr(attr)))
 
     def plot_TCM(self, tcm_ou, vmax='80%', vmin='symmetrize', cmap='seismic',
                  log=False, colorbar=True, lw=None):
+        import matplotlib as mpl
+        import matplotlib.pyplot as plt
+        from matplotlib.colors import Normalize, LogNorm
         if lw is None:
             lw = mpl.rcParams['lines.linewidth']
         energy_o = self.energy_o
         energy_u = self.energy_u
         fermilevel = self.fermilevel
 
         tcmmax = np.max(np.absolute(tcm_ou))
@@ -123,15 +124,15 @@
                 linecolor = 'w'
             if log:
                 norm = LogNorm(vmin=vmin, vmax=vmax)
             else:
                 norm = Normalize(vmin=vmin, vmax=vmax)
             plt.pcolormesh(energy_o, energy_u, tcm_ou.T,
                            cmap=cmap, rasterized=True, norm=norm,
-                           )
+                           shading='auto')
         if colorbar:
             ax = self.ax_cbar
             ax.clear()
             cb = plt.colorbar(cax=ax)
             cb.outline.set_edgecolor(linecolor)
             ax.tick_params(axis='both', colors=linecolor)
             # ax.yaxis.label.set_color(linecolor)
```

### Comparing `gpaw-22.8.0/gpaw/lcaotddft/timedensitymatrix.py` & `gpaw-23.6.0/gpaw/lcaotddft/timedensitymatrix.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/lcaotddft/utilities.py` & `gpaw-23.6.0/gpaw/lcaotddft/utilities.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/lcaotddft/wfwriter.py` & `gpaw-23.6.0/gpaw/lcaotddft/wfwriter.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/lfc.py` & `gpaw-23.6.0/gpaw/lfc.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/lrtddft/__init__.py` & `gpaw-23.6.0/gpaw/lrtddft/__init__.py`

 * *Files 0% similar despite different names*

```diff
@@ -84,15 +84,15 @@
                 np.asarray(self.eh_comm))
 
         if calculator is not None and calculator.initialized:
             # XXXX not ready for k-points
             assert len(calculator.wfs.kd.bzk_kc) == 1
             if calculator.wfs.mode not in ['fd', 'lcao']:
                 raise RuntimeError('LrTDDFT supports only fd and lcao modes')
-            if calculator.parameters.mode != 'lcao':
+            if calculator.wfs.mode != 'lcao':
                 calculator.converge_wave_functions()
             if calculator.density.nct_G is None:
                 spos_ac = calculator.initialize_positions()
                 calculator.wfs.initialize(calculator.density,
                                           calculator.hamiltonian, spos_ac)
 
             self.forced_update()
```

### Comparing `gpaw-22.8.0/gpaw/lrtddft/apmb.py` & `gpaw-23.6.0/gpaw/lrtddft/apmb.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/lrtddft/convergence.py` & `gpaw-23.6.0/gpaw/lrtddft/convergence.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/lrtddft/dielectric.py` & `gpaw-23.6.0/gpaw/lrtddft/dielectric.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/lrtddft/excitation.py` & `gpaw-23.6.0/gpaw/lrtddft/excitation.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/lrtddft/excited_state.py` & `gpaw-23.6.0/gpaw/lrtddft/excited_state.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/lrtddft/finite_differences.py` & `gpaw-23.6.0/gpaw/lrtddft/finite_differences.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/lrtddft/kssingle.py` & `gpaw-23.6.0/gpaw/lrtddft/kssingle.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/lrtddft/omega_matrix.py` & `gpaw-23.6.0/gpaw/lrtddft/omega_matrix.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/lrtddft/spectrum.py` & `gpaw-23.6.0/gpaw/lrtddft/spectrum.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/lrtddft2/__init__.py` & `gpaw-23.6.0/gpaw/lrtddft2/__init__.py`

 * *Files 3% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 
 import os
 import datetime
 import glob
 
 import numpy as np
 
-import ase.units
+from ase.units import Hartree
 from ase.utils import IOContext
 
 from gpaw.xc import XC
 
 # a KS determinant with a single occ-uncc excitation
 # from gpaw.lrtddft2.ks_singles import KohnShamSingleExcitation
 
@@ -38,15 +38,15 @@
                  basefilename,
                  gs_calc,
                  fxc=None,
                  min_occ=None,
                  max_occ=None,
                  min_unocc=None,
                  max_unocc=None,
-                 max_energy_diff=1e9,
+                 max_energy_diff=None,
                  recalculate=None,
                  lr_communicators=None,
                  txt='-'):
         """Initialize linear response TDDFT without calculating anything.
 
         Note
         ----
@@ -108,15 +108,18 @@
         self.basefilename = basefilename
         self.fxc_name = fxc
         self.xc = XC(self.fxc_name)
         self.min_occ = min_occ
         self.max_occ = max_occ
         self.min_unocc = min_unocc
         self.max_unocc = max_unocc
-        self.max_energy_diff = max_energy_diff / ase.units.Hartree
+        if max_energy_diff is not None:
+            self.max_energy_diff = max_energy_diff / Hartree
+        else:
+            self.max_energy_diff = None
         self.recalculate = recalculate
         # Don't init calculator yet if it's not needed (to save memory)
         self.calc = gs_calc
         self.calc_ready = False
 
         # FIXME: SUPPORT ALSO SPIN POLARIZED
         self.kpt_ind = 0
@@ -134,29 +137,49 @@
         self.lr_comms.initialize(gs_calc)
 
         # Init text output
         self.iocontext = IOContext()
         self.txt = self.iocontext.openfile(txt, self.lr_comms.parent_comm)
 
         # Check and set unset params
+        kpt = self.calc.wfs.kpt_u[self.kpt_ind]
+        nbands = len(kpt.f_n)
+
+        # If min/max_occ/unocc were not given, but max_energy_diff was,
+        # check that calc has enough states for max_energy_diff
+        # (i.e., KS eigenvalue difference between HOMO and highest
+        # state is below max_energy_diff)
+        if ((self.min_occ is None or self.min_unocc is None
+             or self.max_occ is None or self.max_unocc is None)
+            and self.max_energy_diff is not None):
+            n_homo = np.sum(kpt.f_n > self.min_pop_diff) - 1
+            n_highest = nbands - 1  # XXX use highest converged state instead
+            eps_n = kpt.eps_n
+            eps_diff = eps_n[n_highest] - eps_n[n_homo]
+            if eps_diff <= self.max_energy_diff:
+                msg = ('Error in LrTDDFT2: not enough states in '
+                       'the calculator for the requested max_energy_diff='
+                       f'{self.max_energy_diff * Hartree:.4f} eV. '
+                       f'Max eigenvalue difference from HOMO (n={n_homo}) is '
+                       f'{eps_diff * Hartree:.4f} eV.')
+                raise RuntimeError(msg)
 
         # If min/max_occ/unocc were not given, initialized them to include
         # everything: min_occ/unocc => 0, max_occ/unocc to nubmer of wfs,
         # energy diff to numerical infinity
-        nbands = len(self.calc.wfs.kpt_u[self.kpt_ind].f_n)
         if self.min_occ is None:
             self.min_occ = 0
         if self.min_unocc is None:
             self.min_unocc = self.min_occ
         if self.max_occ is None:
             self.max_occ = nbands - 1
         if self.max_unocc is None:
             self.max_unocc = self.max_occ
         if self.max_energy_diff is None:
-            self.max_energy_diff = 1e9
+            self.max_energy_diff = np.inf
 
         self.min_occ = max(self.min_occ, 0)
         self.min_unocc = max(self.min_unocc, 0)
 
         if self.max_occ >= nbands:
             raise RuntimeError('Error in LrTDDFT2: max_occ >= nbands')
         if self.max_unocc >= nbands:
@@ -330,16 +353,16 @@
         direction_au = np.array(excitation_direction)
         direction_au = direction_au / np.sqrt(
             np.vdot(direction_au, direction_au))
 
         if units == 'au':
             pass
         elif units == 'eVang':
-            omega_au /= ase.units.Hartree
-            width_au /= ase.units.Hartree
+            omega_au /= Hartree
+            width_au /= Hartree
         else:
             raise RuntimeError(
                 'Error in calculate_response_wavefunction: Invalid units.')
 
         lr_response = LrResponse(self, omega_au, direction_au, width_au,
                                  self.sl_lrtddft)
         lr_response.solve()
```

### Comparing `gpaw-22.8.0/gpaw/lrtddft2/eta.py` & `gpaw-23.6.0/gpaw/lrtddft2/eta.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/lrtddft2/k_matrix.py` & `gpaw-23.6.0/gpaw/lrtddft2/k_matrix.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/lrtddft2/ks_singles.py` & `gpaw-23.6.0/gpaw/lrtddft2/ks_singles.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/lrtddft2/lr_communicators.py` & `gpaw-23.6.0/gpaw/lrtddft2/lr_communicators.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/lrtddft2/lr_layouts.py` & `gpaw-23.6.0/gpaw/lrtddft2/lr_layouts.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/lrtddft2/lr_response.py` & `gpaw-23.6.0/gpaw/lrtddft2/lr_response.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/lrtddft2/lr_transitions.py` & `gpaw-23.6.0/gpaw/lrtddft2/lr_transitions.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/lrtddft2/tools.py` & `gpaw-23.6.0/gpaw/lrtddft2/tools.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/matrix.py` & `gpaw-23.6.0/gpaw/matrix.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/matrix_descriptor.py` & `gpaw-23.6.0/gpaw/matrix_descriptor.py`

 * *Files 0% similar despite different names*

```diff
@@ -54,15 +54,15 @@
         if iu is None:
             n = len(H_mm)
             eigvals = None  # all
         else:
             n = iu
             eigvals = (0, n - 1)
         eps_M[:n], C_mm.T[:, :n] = eigh(H_mm, S_mm,
-                                        eigvals=eigvals,
+                                        subset_by_index=eigvals,
                                         overwrite_a=True,
                                         check_finite=debug)
         if C_mm.dtype == complex:
             np.negative(C_mm.imag, C_mm.imag)
 
     def my_blocks(self, array_mn):
         yield (0, self.shape[0], 0, self.shape[1], array_mn)
```

### Comparing `gpaw-22.8.0/gpaw/mixer.py` & `gpaw-23.6.0/gpaw/mixer.py`

 * *Files 3% similar despite different names*

```diff
@@ -51,21 +51,21 @@
             changes).
 
         """
 
         self.beta = beta
         self.nmaxold = nmaxold
         self.weight = weight
+        self.world = None
 
     def initialize_metric(self, gd):
         self.gd = gd
 
         if self.weight == 1:
             self.metric = None
-
         else:
             a = 0.125 * (self.weight + 7)
             b = 0.0625 * (self.weight - 1)
             c = 0.03125 * (self.weight - 1)
             d = 0.015625 * (self.weight - 1)
             self.metric = FDOperator([a,
                                       b, b, b, b, b, b,
@@ -79,111 +79,117 @@
                                       (1, -1, 0), (1, 0, -1), (0, 1, -1),
                                       (-1, 1, 0), (-1, 0, 1), (0, -1, 1),
                                       (-1, -1, 0), (-1, 0, -1), (0, -1, -1),
                                       (1, 1, 1), (1, 1, -1), (1, -1, 1),  # d
                                       (-1, 1, 1), (1, -1, -1), (-1, -1, 1),
                                       (-1, 1, -1), (-1, -1, -1)],
                                      gd, float).apply
-            self.mR_G = gd.empty()
+            self.mR_sG = gd.empty(4)
 
     def reset(self):
         """Reset Density-history.
 
         Called at initialization and after each move of the atoms.
 
         my_nuclei:   All nuclei in local domain.
         """
 
         # History for Pulay mixing of densities:
-        self.nt_iG = []  # Pseudo-electron densities
-        self.R_iG = []  # Residuals
+        self.nt_isG = []  # Pseudo-electron densities
+        self.R_isG = []  # Residuals
         self.A_ii = np.zeros((0, 0))
 
-        self.D_iap = []
-        self.dD_iap = []
+        self.D_iasp = []
+        self.dD_iasp = []
 
-    def calculate_charge_sloshing(self, R_G):
-        return self.gd.integrate(np.fabs(R_G))
-
-    def mix_single_density(self, nt_G, D_ap):
-        iold = len(self.nt_iG)
+    def calculate_charge_sloshing(self, R_sG) -> float:
+        return self.gd.integrate(np.fabs(R_sG)).sum()
 
+    def mix_density(self, nt_sG, D_asp, g_ss=None):
+        nt_isG = self.nt_isG
+        R_isG = self.R_isG
+        D_iasp = self.D_iasp
+        dD_iasp = self.dD_iasp
+        spin = len(nt_sG)
+        iold = len(self.nt_isG)
         dNt = np.inf
         if iold > 0:
             if iold > self.nmaxold:
                 # Throw away too old stuff:
-                del self.nt_iG[0]
-                del self.R_iG[0]
-                del self.D_iap[0]
-                del self.dD_iap[0]
+                del nt_isG[0]
+                del R_isG[0]
+                del D_iasp[0]
+                del dD_iasp[0]
                 # for D_p, D_ip, dD_ip in self.D_a:
                 #     del D_ip[0]
                 #     del dD_ip[0]
                 iold = self.nmaxold
 
             # Calculate new residual (difference between input and
             # output density):
-            R_G = nt_G - self.nt_iG[-1]
-            dNt = self.calculate_charge_sloshing(R_G)
-            self.R_iG.append(R_G)
-            self.dD_iap.append([])
-            for D_p, D_ip in zip(D_ap, self.D_iap[-1]):
-                self.dD_iap[-1].append(D_p - D_ip)
+            R_sG = nt_sG - nt_isG[-1]
+            dNt = self.calculate_charge_sloshing(R_sG)
+            R_isG.append(R_sG)
+            dD_iasp.append([])
+            for D_sp, D_isp in zip(D_asp, D_iasp[-1]):
+                dD_iasp[-1].append(D_sp - D_isp)
+
+            if self.metric is None:
+                mR_sG = R_sG
+            else:
+                mR_sG = self.mR_sG[:spin]
+                for s in range(spin):
+                    self.metric(R_sG[s], mR_sG[s])
+
+            if g_ss is not None:
+                mR_sG = np.tensordot(g_ss, mR_sG, axes=(1, 0))
 
             # Update matrix:
             A_ii = np.zeros((iold, iold))
             i2 = iold - 1
 
-            if self.metric is None:
-                mR_G = R_G
-            else:
-                mR_G = self.mR_G
-                self.metric(R_G, mR_G)
-
-            for i1, R_1G in enumerate(self.R_iG):
-                a = self.gd.comm.sum(self.dotprod(R_1G, mR_G, self.dD_iap[i1],
-                                                  self.dD_iap[-1]))
+            for i1, R_1sG in enumerate(R_isG):
+                a = self.gd.comm.sum(self.dotprod(R_1sG, mR_sG, dD_iasp[i1],
+                                                  dD_iasp[-1]))
                 A_ii[i1, i2] = a
                 A_ii[i2, i1] = a
             A_ii[:i2, :i2] = self.A_ii[-i2:, -i2:]
             self.A_ii = A_ii
 
             try:
                 B_ii = np.linalg.inv(A_ii)
-            except np.linalg.LinAlgError:
+                alpha_i = B_ii.sum(1)
+                alpha_i /= alpha_i.sum()
+            except (ZeroDivisionError, np.linalg.LinAlgError):
                 alpha_i = np.zeros(iold)
                 alpha_i[-1] = 1.0
-            else:
-                alpha_i = B_ii.sum(1)
-                try:
-                    # Normalize:
-                    alpha_i /= alpha_i.sum()
-                except ZeroDivisionError:
-                    alpha_i[:] = 0.0
-                    alpha_i[-1] = 1.0
+
+            if self.world:
+                self.world.broadcast(alpha_i, 0)
 
             # Calculate new input density:
-            nt_G[:] = 0.0
+            nt_sG[:] = 0.0
             # for D_p, D_ip, dD_ip in self.D_a:
-            for D in D_ap:
+            for D in D_asp:
                 D[:] = 0.0
             beta = self.beta
             for i, alpha in enumerate(alpha_i):
-                axpy(alpha, self.nt_iG[i], nt_G)
-                axpy(alpha * beta, self.R_iG[i], nt_G)
-                for D_p, D_ip, dD_ip in zip(D_ap, self.D_iap[i],
-                                            self.dD_iap[i]):
-                    axpy(alpha, D_ip, D_p)
-                    axpy(alpha * beta, dD_ip, D_p)
+                axpy(alpha, nt_isG[i], nt_sG)
+                axpy(alpha * beta, R_isG[i], nt_sG)
+
+                for D_sp, D_isp, dD_isp in zip(D_asp, D_iasp[i],
+                                               dD_iasp[i]):
+                    axpy(alpha, D_isp, D_sp)
+                    axpy(alpha * beta, dD_isp, D_sp)
 
         # Store new input density (and new atomic density matrices):
-        self.nt_iG.append(nt_G.copy())
-        self.D_iap.append([])
-        for D_p in D_ap:
-            self.D_iap[-1].append(D_p.copy())
+        nt_isG.append(nt_sG.copy())
+        D_iasp.append([])
+        for D_sp in D_asp:
+            D_iasp[-1].append(D_sp.copy())
         return dNt
 
     # may presently be overridden by passing argument in constructor
     def dotprod(self, R1_G, R2_G, dD1_ap, dD2_ap):
         return np.vdot(R1_G, R2_G).real
 
     def estimate_memory(self, mem, gd):
@@ -236,35 +242,38 @@
     def initialize_metric(self, gd):
         self.gd = gd
 
         if gd.comm.rank == 0:
             self.gd1 = gd.new_descriptor(comm=mpi.serial_comm)
             k2_Q, _ = construct_reciprocal(self.gd1)
             self.metric = ReciprocalMetric(self.weight, k2_Q)
-            self.mR_G = self.gd1.empty(dtype=complex)
+            self.mR_sG = self.gd1.empty(1, dtype=complex)
         else:
             self.metric = lambda R_Q, mR_Q: None
-            self.mR_G = np.empty((0, 0, 0), dtype=complex)
+            self.mR_sG = np.empty((1, 0, 0, 0), dtype=complex)
 
-    def calculate_charge_sloshing(self, R_Q):
+    def calculate_charge_sloshing(self, R_sQ):
         if self.gd.comm.rank == 0:
-            cs = self.gd1.integrate(np.fabs(ifftn(R_Q).real))
+            assert R_sQ.ndim == 4 and len(R_sQ) == 1
+            cs = self.gd1.integrate(np.fabs(ifftn(R_sQ[0]).real))
         else:
             cs = 0.0
         return self.gd.comm.sum(cs)
 
-    def mix_single_density(self, nt_G, D_ap):
+    def mix_density(self, nt_sG, D_asp):
         # Transform real-space density to Fourier space
+        nt_G, = nt_sG
         nt1_G = self.gd.collect(nt_G)
         if self.gd.comm.rank == 0:
             nt_Q = np.ascontiguousarray(fftn(nt1_G))
         else:
             nt_Q = np.empty((0, 0, 0), dtype=complex)
 
-        dNt = BaseMixer.mix_single_density(self, nt_Q, D_ap)
+        dNt = BaseMixer.mix_density(self, nt_Q[np.newaxis],
+                                    [D_1p[0] for D_1p in D_asp])
 
         # Return density in real space
         if self.gd.comm.rank == 0:
             nt1_G = ifftn(nt_Q).real
         self.gd.distribute(nt1_G, nt_G)
 
         return dNt
@@ -293,15 +302,17 @@
         self.nt_iG = []
         self.D_iap = []
         self.c_G = []
         self.v_G = []
         self.u_G = []
         self.u_D = []
 
-    def mix_single_density(self, nt_G, D_ap):
+    def mix_density(self, nt_sG, D_asp):
+        nt_G = nt_sG[0]
+        D_ap = [D_sp[0] for D_sp in D_asp]
         dNt = np.inf
         if self.step > 2:
             del self.R_iG[0]
             for d_Dp in self.dD_iap:
                 del d_Dp[0]
         if self.step > 0:
             self.R_iG.append(nt_G - self.nt_iG[-1])
@@ -414,29 +425,29 @@
 
         Called at initialization and after each move of the atoms.
 
         my_nuclei:   All nuclei in local domain.
         """
 
         # Previous density:
-        self.nt_iG = []  # Pseudo-electron densities
+        self.nt_isG = []  # Pseudo-electron densities
 
-    def calculate_charge_sloshing(self, R_G):
-        return self.gd.integrate(np.fabs(R_G))
+    def calculate_charge_sloshing(self, R_sG):
+        return self.gd.integrate(np.fabs(R_sG)).sum()
 
-    def mix_single_density(self, nt_G, D_ap):
-        iold = len(self.nt_iG)
+    def mix_density(self, nt_sG, D_asp):
+        iold = len(self.nt_isG)
 
         dNt = np.inf
         if iold > 0:
             # Calculate new residual (difference between input and
             # output density):
-            dNt = self.calculate_charge_sloshing(nt_G - self.nt_iG[-1])
+            dNt = self.calculate_charge_sloshing(nt_sG - self.nt_isG[-1])
         # Store new input density:
-        self.nt_iG = [nt_G.copy()]
+        self.nt_isG = [nt_sG.copy()]
 
         return dNt
 
     # may presently be overridden by passing argument in constructor
     def dotprod(self, R1_G, R2_G, dD1_ap, dD2_ap):
         pass
 
@@ -462,20 +473,19 @@
     def get_basemixers(self, nspins):
         return [self.basemixerclass(self.beta, self.nmaxold, self.weight)
                 for _ in range(nspins)]
 
     def mix(self, basemixers, nt_sG, D_asp):
         """Mix pseudo electron densities."""
         D_asp = D_asp.values()
-        D_sap = []
-        for s in range(len(nt_sG)):
-            D_sap.append([D_sp[s] for D_sp in D_asp])
         dNt = 0.0
-        for nt_G, D_ap, basemixer in zip(nt_sG, D_sap, basemixers):
-            dNt += basemixer.mix_single_density(nt_G, D_ap)
+        for s, (nt_G, basemixer) in enumerate(zip(nt_sG, basemixers)):
+            D_a1p = [D_sp[s:s + 1] for D_sp in D_asp]
+            nt_1G = nt_G[np.newaxis]
+            dNt += basemixer.mix_density(nt_1G, D_a1p)
         return dNt
 
 
 class SpinSumMixerDriver:
     name = 'sum'
     mix_atomic_density_matrices = False
 
@@ -496,40 +506,40 @@
         basemixer = basemixers[0]
         D_asp = D_asp.values()
 
         collinear = len(nt_sG) == 2
 
         # Mix density
         if collinear:
-            nt_G = nt_sG.sum(0)
+            nt_1G = nt_sG.sum(0)[np.newaxis]
         else:
-            nt_G = nt_sG[0]
+            nt_1G = nt_sG[:1]
 
         if self.mix_atomic_density_matrices:
             if collinear:
-                D_ap = [D_sp[0] + D_sp[1] for D_sp in D_asp]
+                D_a1p = [D_sp[:1] + D_sp[1:] for D_sp in D_asp]
             else:
-                D_ap = [D_sp[0] for D_sp in D_asp]
-            dNt = basemixer.mix_single_density(nt_G, D_ap)
+                D_a1p = [D_sp[:1] for D_sp in D_asp]
+            dNt = basemixer.mix_density(nt_1G, D_a1p)
             if collinear:
                 dD_ap = [D_sp[0] - D_sp[1] for D_sp in D_asp]
-                for D_sp, D_p, dD_p in zip(D_asp, D_ap, dD_ap):
-                    D_sp[0] = 0.5 * (D_p + dD_p)
-                    D_sp[1] = 0.5 * (D_p - dD_p)
+                for D_sp, D_1p, dD_p in zip(D_asp, D_a1p, dD_ap):
+                    D_sp[0] = 0.5 * (D_1p[0] + dD_p)
+                    D_sp[1] = 0.5 * (D_1p[0] - dD_p)
         else:
-            dNt = basemixer.mix_single_density(nt_G, D_asp)
+            dNt = basemixer.mix_density(nt_1G, D_asp)
 
         if collinear:
             dnt_G = nt_sG[0] - nt_sG[1]
             # Only new magnetization for spin density
             # dD_ap = [D_sp[0] - D_sp[1] for D_sp in D_asp]
 
             # Construct new spin up/down densities
-            nt_sG[0] = 0.5 * (nt_G + dnt_G)
-            nt_sG[1] = 0.5 * (nt_G - dnt_G)
+            nt_sG[0] = 0.5 * (nt_1G[0] + dnt_G)
+            nt_sG[1] = 0.5 * (nt_1G[0] - dnt_G)
 
         return dNt
 
 
 class SpinSumMixerDriver2(SpinSumMixerDriver):
     name = 'sum2'
     mix_atomic_density_matrices = True
@@ -572,54 +582,82 @@
             basemixer, basemixer_m = basemixers
         else:
             assert len(nt_sG) == 4
             basemixer, basemixer_x, basemixer_y, basemixer_z = basemixers
 
         if len(nt_sG) == 2:
             # Mix density
-            nt_G = nt_sG.sum(0)
-            D_ap = [D_sp[0] + D_sp[1] for D_sp in D_asp]
-            dNt = basemixer.mix_single_density(nt_G, D_ap)
+            nt_1G = nt_sG.sum(0)[np.newaxis]
+            D_a1p = [D_sp[:1] + D_sp[1:] for D_sp in D_asp]
+            dNt = basemixer.mix_density(nt_1G, D_a1p)
 
             # Mix magnetization
-            dnt_G = nt_sG[0] - nt_sG[1]
-            dD_ap = [D_sp[0] - D_sp[1] for D_sp in D_asp]
-            basemixer_m.mix_single_density(dnt_G, dD_ap)
+            dnt_1G = nt_sG[:1] - nt_sG[1:]
+            dD_a1p = [D_sp[:1] - D_sp[1:] for D_sp in D_asp]
+            basemixer_m.mix_density(dnt_1G, dD_a1p)
             # (The latter is not counted in dNt)
 
             # Construct new spin up/down densities
-            nt_sG[0] = 0.5 * (nt_G + dnt_G)
-            nt_sG[1] = 0.5 * (nt_G - dnt_G)
-            for D_sp, D_p, dD_p in zip(D_asp, D_ap, dD_ap):
-                D_sp[0] = 0.5 * (D_p + dD_p)
-                D_sp[1] = 0.5 * (D_p - dD_p)
+            nt_sG[:1] = 0.5 * (nt_1G + dnt_1G)
+            nt_sG[1:] = 0.5 * (nt_1G - dnt_1G)
+            for D_sp, D_1p, dD_1p in zip(D_asp, D_a1p, dD_a1p):
+                D_sp[:1] = 0.5 * (D_1p + dD_1p)
+                D_sp[1:] = 0.5 * (D_1p - dD_1p)
         else:
             # Mix density
-            nt_G = nt_sG[0]
-            D_ap = [D_sp[0] for D_sp in D_asp]
-            dNt = basemixer.mix_single_density(nt_G, D_ap)
+            nt_1G = nt_sG[:1]
+            D_a1p = [D_sp[:1] for D_sp in D_asp]
+            dNt = basemixer.mix_density(nt_1G, D_a1p)
 
             # Mix magnetization
-            Dx_ap = [D_sp[1] for D_sp in D_asp]
-            Dy_ap = [D_sp[2] for D_sp in D_asp]
-            Dz_ap = [D_sp[3] for D_sp in D_asp]
-            basemixer_x.mix_single_density(nt_sG[1], Dx_ap)
-            basemixer_y.mix_single_density(nt_sG[2], Dy_ap)
-            basemixer_z.mix_single_density(nt_sG[3], Dz_ap)
+            Dx_a1p = [D_sp[1:2] for D_sp in D_asp]
+            Dy_a1p = [D_sp[2:3] for D_sp in D_asp]
+            Dz_a1p = [D_sp[3:4] for D_sp in D_asp]
+
+            basemixer_x.mix_density(nt_sG[1:2], Dx_a1p)
+            basemixer_y.mix_density(nt_sG[2:3], Dy_a1p)
+            basemixer_z.mix_density(nt_sG[3:4], Dz_a1p)
+        return dNt
+
+
+class FullSpinMixerDriver:
+    name = 'fullspin'
+
+    def __init__(self, basemixerclass, beta, nmaxold, weight, g=None):
+        self.basemixerclass = basemixerclass
+        self.beta = beta
+        self.nmaxold = nmaxold
+        self.weight = weight
+        self.g_ss = g
+
+    def get_basemixers(self, nspins):
+        if nspins == 1:
+            raise ValueError('Full-spin mixer expects 2 or 4 spin channels')
+
+        basemixer = self.basemixerclass(self.beta, self.nmaxold, self.weight)
+        return [basemixer]
+
+    def mix(self, basemixers, nt_sG, D_asp):
+        D_asp = D_asp.values()
+        basemixer = basemixers[0]
+        if self.g_ss is None:
+            self.g_ss = np.identity(len(nt_sG))
+
+        dNt = basemixer.mix_density(nt_sG, D_asp, self.g_ss)
 
         return dNt
 
 
 # Dictionaries to get mixers by name:
 _backends = {}
 _methods = {}
 for cls in [FFTBaseMixer, BroydenBaseMixer, BaseMixer, NotMixingMixer]:
     _backends[cls.name] = cls  # type:ignore
 for dcls in [SeparateSpinMixerDriver, SpinSumMixerDriver,
-             SpinSumMixerDriver2,
+             FullSpinMixerDriver, SpinSumMixerDriver2,
              SpinDifferenceMixerDriver, DummyMixer]:
     _methods[dcls.name] = dcls  # type:ignore
 
 
 # This function is used by Density to decide mixer parameters
 # that the user did not explicitly provide, i.e., it fills out
 # everything that is missing and returns a mixer "driver".
@@ -671,41 +709,48 @@
                    nmaxold=kwargs['history'], weight=kwargs['weight'],
                    **mixerkwargs)
     return mixer
 
 
 # This is the only object which will be used by Density, sod the others
 class MixerWrapper:
-    def __init__(self, driver, nspins, gd):
+    def __init__(self, driver, nspins, gd, world=None):
         self.driver = driver
 
         self.beta = driver.beta
         self.nmaxold = driver.nmaxold
         self.weight = driver.weight
         assert self.weight is not None, driver
 
         self.basemixers = self.driver.get_basemixers(nspins)
         for basemixer in self.basemixers:
             basemixer.initialize_metric(gd)
+            basemixer.world = world
 
     def mix(self, nt_sR, D_asp=None):
         if D_asp is not None:
             return self.driver.mix(self.basemixers, nt_sR, D_asp)
 
         # new interface:
         density = nt_sR
         nspins = density.nt_sR.dims[0]
+        nt_sR = density.nt_sR.to_xp(np)
+        D_asii = density.D_asii.to_xp(np)
         D_asp = {a: D_sii.copy().reshape((nspins, -1))
-                 for a, D_sii in density.D_asii.items()}
+                 for a, D_sii in D_asii.items()}
         error = self.driver.mix(self.basemixers,
-                                density.nt_sR.data,
+                                nt_sR.data,
                                 D_asp)
-        for a, D_sii in density.D_asii.items():
+        for a, D_sii in D_asii.items():
             ni = D_sii.shape[1]
-            D_sii[:] = D_asp[a].reshape((-1, ni, ni))
+            D_sii[:] = D_asp[a].reshape((nspins, ni, ni))
+        xp = density.nt_sR.xp
+        if xp is not np:
+            density.nt_sR.data[:] = xp.asarray(nt_sR.data)
+            density.D_asii.data[:] = xp.asarray(D_asii.data)
         return error
 
     def estimate_memory(self, mem, gd):
         for i, basemixer in enumerate(self.basemixers):
             basemixer.estimate_memory(mem.subnode('Mixer %d' % i), gd)
 
     def reset(self):
@@ -735,14 +780,15 @@
     return getmixer
 
 
 Mixer = _definemixerfunc('separate', 'pulay')
 MixerSum = _definemixerfunc('sum', 'pulay')
 MixerSum2 = _definemixerfunc('sum2', 'pulay')
 MixerDif = _definemixerfunc('difference', 'pulay')
+MixerFull = _definemixerfunc('fullspin', 'pulay')
 FFTMixer = _definemixerfunc('separate', 'fft')
 FFTMixerSum = _definemixerfunc('sum', 'fft')
 FFTMixerSum2 = _definemixerfunc('sum2', 'fft')
 FFTMixerDif = _definemixerfunc('difference', 'fft')
 BroydenMixer = _definemixerfunc('separate', 'broyden')
 BroydenMixerSum = _definemixerfunc('sum', 'broyden')
 BroydenMixerSum2 = _definemixerfunc('sum2', 'broyden')
```

### Comparing `gpaw-22.8.0/gpaw/mom.py` & `gpaw-23.6.0/gpaw/mom.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/mpi.py` & `gpaw-23.6.0/gpaw/mpi.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,23 +1,23 @@
 # Copyright (C) 2003  CAMP
 # Please see the accompanying LICENSE file for further information.
-
+from __future__ import annotations
 import sys
 import time
 import traceback
 import atexit
 import pickle
 from contextlib import contextmanager
 from typing import Any
 
-from ase.parallel import world as aseworld
+from ase.parallel import world as aseworld, MPI as ASE_MPI
 import numpy as np
 
 import gpaw
-from .broadcast_imports import world
+from .broadcast_imports import world as _world
 import _gpaw
 
 MASTER = 0
 MPIComm = Any  # for type hints
 
 
 def is_contiguous(*args, **kwargs):
@@ -115,20 +115,25 @@
             operation is valid. A root rank of -1 signifies that the result
             will be distributed back to all processes, i.e. a broadcast.
 
         """
         if isinstance(a, (int, float, complex)):
             return self.comm.sum(a, root)
         else:
+            # assert a.ndim != 0
             tc = a.dtype
             assert tc == int or tc == float or tc == complex
             assert is_contiguous(a, tc)
             assert root == -1 or 0 <= root < self.size
             self.comm.sum(a, root)
 
+    def sum_scalar(self, a, root=-1):
+        assert isinstance(a, (int, float, complex))
+        return self.comm.sum_scalar(a, root)
+
     def product(self, a, root=-1):
         """Do multiplication by MPI reduce operations of numerical data.
 
         Parameters:
 
         a: ndarray or value (type int or float)
             Numerical data to multiply across all ranks in the communicator
@@ -177,14 +182,18 @@
         else:
             tc = a.dtype
             assert tc == int or tc == float
             assert is_contiguous(a, tc)
             assert root == -1 or 0 <= root < self.size
             self.comm.max(a, root)
 
+    def max_scalar(self, a, root=-1):
+        assert isinstance(a, (int, float))
+        return self.comm.max_scalar(a, root)
+
     def min(self, a, root=-1):
         """Find minimal value by an MPI reduce operation of numerical data.
 
         Parameters:
 
         a: ndarray or value (type int or float)
             Numerical data to find the minimal value of across all ranks in
@@ -204,14 +213,18 @@
             return self.comm.min(a, root)
         else:
             tc = a.dtype
             assert tc == int or tc == float
             assert is_contiguous(a, tc)
             assert root == -1 or 0 <= root < self.size
             self.comm.min(a, root)
+    
+    def min_scalar(self, a, root=-1):
+        assert isinstance(a, (int, float))
+        return self.comm.min_scalar(a, root)
 
     def scatter(self, a, b, root):
         """Distribute data from one rank to all other processes in a group.
 
         Parameters:
 
         a: ndarray (ignored on all ranks different from root; use None)
@@ -611,28 +624,37 @@
 
     def __init__(self, parent=None):
         self.parent = parent
 
     def sum(self, array, root=-1):
         if isinstance(array, (int, float, complex)):
             return array
+    
+    def sum_scalar(self, a, root=-1):
+        return a
 
     def scatter(self, s, r, root):
         r[:] = s
 
     def min(self, value, root=-1):
         return value
 
+    def min_scalar(self, value, root=-1):
+        return value
+
     def max(self, value, root=-1):
         return value
+    
+    def max_scalar(self, value, root=-1):
+        return value
 
     def broadcast(self, buf, root):
         pass
 
-    def send(self, buff, root, tag=123, block=True):
+    def send(self, buff, dest, tag=123, block=True):
         pass
 
     def barrier(self):
         pass
 
     def gather(self, a, root, b):
         b[:] = a
@@ -691,35 +713,58 @@
         return np.array([other.rank for rank in ranks])
         raise NotImplementedError(
             'Translate non-trivial ranks with serial comm')
 
     def get_c_object(self):
         if gpaw.dry_run:
             return None  # won't actually be passed to C
-        raise NotImplementedError('Should not get C-object for serial comm')
+        return _world
 
 
-serial_comm = SerialCommunicator()
+world: SerialCommunicator | _Communicator | _gpaw.Communicator
+serial_comm: SerialCommunicator | _Communicator = SerialCommunicator()
 
-have_mpi = world is not None
+have_mpi = _world is not None
 
-if world is None:
+if not have_mpi or _world.size == 1:
     world = serial_comm
+else:
+    world = _world
 
 if gpaw.debug:
-    serial_comm = _Communicator(serial_comm)  # type: ignore
-    world = _Communicator(world)  # type: ignore
+    serial_comm = _Communicator(serial_comm)
+    world = _Communicator(world)
 
 rank = world.rank
 size = world.size
 parallel = (size > 1)
 
-assert aseworld is not None
-if world.size != aseworld.size:
-    raise RuntimeError('Please use "gpaw python" to run in parallel')
+
+def verify_ase_world():
+    # ASE does not like that GPAW uses world.size at import time.
+    # .... because of GPAW's own import time communicator mish-mash.
+    # Now, GPAW wants to verify world.size and cannot do so,
+    # because of what ASE does for GPAW's sake.
+    # This really needs improvement!
+    assert aseworld is not None
+
+    if isinstance(aseworld, ASE_MPI):
+        # We only want to check if the communicator was already initialized.
+        # Otherwise the communicator will be initialized as a side effect
+        # of accessing the .size attribute,
+        # which ASE's tests will complain about.
+        check_size = aseworld.comm is not None
+    else:
+        check_size = True  # A real communicator, so we want to check that
+
+    if check_size and world.size != aseworld.size:
+        raise RuntimeError('Please use "gpaw python" to run in parallel')
+
+
+verify_ase_world()
 
 
 def broadcast(obj, root=0, comm=world):
     """Broadcast a Python object across an MPI communicator and return it."""
     if comm.rank == root:
         assert obj is not None
         b = pickle.dumps(obj, pickle.HIGHEST_PROTOCOL)
```

### Comparing `gpaw-22.8.0/gpaw/new/__init__.py` & `gpaw-23.6.0/gpaw/new/__init__.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/new/ase_interface.py` & `gpaw-23.6.0/gpaw/new/ase_interface.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,26 +1,29 @@
 from __future__ import annotations
 
 import warnings
 from pathlib import Path
 from types import SimpleNamespace
 from typing import IO, Any, Union
 
+import numpy as np
 from ase import Atoms
 from ase.units import Bohr, Ha
-
 from gpaw import __version__
+from gpaw.core.uniform_grid import UniformGridFunctions
+from gpaw.dos import DOSCalculator
 from gpaw.new import Timer, cached_property
 from gpaw.new.builder import builder as create_builder
-from gpaw.new.calculation import DFTCalculation, DFTState, units
+from gpaw.new.calculation import (DFTCalculation, DFTState,
+                                  ReuseWaveFunctionsError, units)
 from gpaw.new.gpw import read_gpw, write_gpw
 from gpaw.new.input_parameters import InputParameters
 from gpaw.new.logger import Logger
 from gpaw.new.pw.fulldiag import diagonalize
-from gpaw.new.xc import XC
+from gpaw.new.xc import XCFunctional
 from gpaw.typing import Array1D, Array2D, Array3D
 from gpaw.utilities import pack
 from gpaw.utilities.memory import maxrss
 
 
 def GPAW(filename: Union[str, Path, IO[str]] = None,
          **kwargs) -> ASECalculator:
@@ -38,16 +41,44 @@
                                                  params.parallel)
         return ASECalculator(params, log, calculation, atoms)
 
     write_header(log, world, params)
     return ASECalculator(params, log)
 
 
+def write_header(log, world, params):
+    from gpaw.io.logger import write_header as header
+    log(f'#  __  _  _\n# | _ |_)|_||  |\n# |__||  | ||/\\| - {__version__}\n')
+    header(log, world)
+    log('---')
+    with log.indent('input parameters:'):
+        log(**{k: v for k, v in params.items()})
+
+
+def compare_atoms(a1: Atoms, a2: Atoms) -> set[str]:
+    if len(a1.numbers) != len(a2.numbers) or (a1.numbers != a2.numbers).any():
+        return {'numbers'}
+
+    if (a1.pbc != a2.pbc).any():
+        return {'pbc'}
+
+    if abs(a1.cell - a2.cell).max() > 0.0:
+        return {'cell'}
+
+    if abs(a1.positions - a2.positions).max() > 0.0:
+        return {'positions'}
+
+    return set()
+
+
 class ASECalculator:
     """This is the ASE-calculator frontend for doing a GPAW calculation."""
+
+    name = 'gpaw'
+
     def __init__(self,
                  params: InputParameters,
                  log: Logger,
                  calculation=None,
                  atoms=None):
         self.params = params
         self.log = log
@@ -65,34 +96,51 @@
             params.append((key, val))
         p = ', '.join(f'{key}: {val}' for key, val in params)
         return f'ASECalculator({p})'
 
     def calculate_property(self, atoms: Atoms, prop: str) -> Any:
         """Calculate (if not already calculated) a property.
 
-        Must be one of
+        The ``prop`` string must be one of
 
         * energy
         * forces
         * stress
         * magmom
         * magmoms
         * dipole
         """
         if self.calculation is not None:
             changes = compare_atoms(self.atoms, atoms)
             if changes & {'numbers', 'pbc', 'cell'}:
-                # Start from scratch:
                 if 'numbers' not in changes:
                     # Remember magmoms if there are any:
                     magmom_a = self.calculation.results.get('magmoms')
-                    if magmom_a is not None:
+                    if magmom_a is not None and magmom_a.any():
                         atoms = atoms.copy()
                         atoms.set_initial_magnetic_moments(magmom_a)
-                self.calculation = None
+
+                if changes & {'numbers', 'pbc'}:
+                    # Start from scratch:
+                    self.calculation = None
+                else:
+                    ibzwfs = self.calculation.state.ibzwfs
+                    kpt_parallel_only = (ibzwfs.band_comm.size == 1 and
+                                         ibzwfs.domain_comm.size == 1)
+                    if kpt_parallel_only:
+                        try:
+                            self.create_new_calculation_from_old(atoms)
+                        except ReuseWaveFunctionsError:
+                            self.calculation = None
+                        else:
+                            self.converge()
+                            changes = set()
+                    else:
+                        # Not implemented: just start from scratch
+                        self.calculation = None
 
         if self.calculation is None:
             self.create_new_calculation(atoms)
             assert self.calculation is not None
             self.converge()
         elif changes:
             self.move_atoms(atoms)
@@ -104,52 +152,81 @@
                     self.calculation.forces()
             elif prop == 'stress':
                 with self.timer('Stress'):
                     self.calculation.stress()
             elif prop == 'dipole':
                 self.calculation.dipole()
             else:
-                raise ValueError('Unknown property:', prop)
+                raise KeyError('Unknown property:', prop)
 
         return self.calculation.results[prop] * units[prop]
 
+    def get_property(self,
+                     name: str,
+                     atoms: Atoms | None = None,
+                     allow_calculation: bool = True) -> Any:
+        if not allow_calculation and name not in self.calculation.results:
+            return None
+        if atoms is None:
+            atoms = self.atoms
+        return self.calculate_property(atoms, name)
+
+    @property
+    def results(self):
+        if self.calculation is None:
+            return {}
+        return {name: value * units[name]
+                for name, value in self.calculation.results.items()}
+
     def create_new_calculation(self, atoms: Atoms) -> None:
         with self.timer('Init'):
             self.calculation = DFTCalculation.from_parameters(
                 atoms, self.params, self.log)
         self.atoms = atoms.copy()
 
+    def create_new_calculation_from_old(self, atoms: Atoms) -> None:
+        with self.timer('Morph'):
+            self.calculation = self.calculation.new(
+                atoms, self.params, self.log)
+        self.atoms = atoms.copy()
+
     def move_atoms(self, atoms):
         with self.timer('Move'):
             self.calculation = self.calculation.move_atoms(atoms)
         self.atoms = atoms.copy()
 
     def converge(self):
         """Iterate to self-consistent solution.
 
         Will also calculate "cheap" properties: energy, magnetic moments
         and dipole moment.
         """
         with self.timer('SCF'):
-            self.calculation.converge()
+            self.calculation.converge(calculate_forces=self._calculate_forces)
 
         # Calculate all the cheap things:
         self.calculation.energies()
         self.calculation.dipole()
         self.calculation.magmoms()
 
         self.calculation.write_converged()
 
+    def _calculate_forces(self) -> Array2D:  # units: Ha/Bohr
+        """Helper method for force-convergence criterium."""
+        with self.timer('Forces'):
+            self.calculation.forces(silent=True)
+        return self.calculation.results['forces']
+
     def __del__(self):
         try:
             self.log('---')
             self.timer.write(self.log)
             mib = maxrss() / 1024**2
             self.log(f'\nMax RSS: {mib:.3f}  # MiB')
-        except NameError:
+        except (NameError, AttributeError):
             pass
 
     def get_potential_energy(self,
                              atoms: Atoms,
                              force_consistent: bool = False) -> float:
         return self.calculate_property(atoms,
                                        'free_energy' if force_consistent else
@@ -184,63 +261,122 @@
         self.log(f'# Writing to {filename} (mode={mode!r})\n')
 
         write_gpw(filename, self.atoms, self.params,
                   self.calculation, skip_wfs=mode != 'all')
 
     # Old API:
 
-    def get_pseudo_wave_function(self, band, kpt=0, spin=0) -> Array3D:
+    implemented_properties = ['energy', 'free_energy',
+                              'forces', 'stress',
+                              'dipole', 'magmom', 'magmoms']
+
+    def new(self, **kwargs) -> ASECalculator:
+        kwargs = {**dict(self.params.items()), **kwargs}
+        return GPAW(**kwargs)
+
+    def get_pseudo_wave_function(self, band, kpt=0, spin=0,
+                                 periodic=False) -> Array3D:
         state = self.calculation.state
         wfs = state.ibzwfs.get_wfs(spin=spin, kpt=kpt, n1=band, n2=band + 1)
         basis = getattr(self.calculation.scf_loop.hamiltonian, 'basis', None)
         grid = state.density.nt_sR.desc
         wfs = wfs.to_uniform_grid_wave_functions(grid, basis)
         psit_R = wfs.psit_nX[0]
         if not psit_R.desc.pbc.all():
             psit_R = psit_R.to_pbc_grid()
+        if periodic:
+            psit_R.multiply_by_eikr(-psit_R.desc.kpt_c)
         return psit_R.data * Bohr**-1.5
 
     def get_atoms(self):
         atoms = self.atoms.copy()
         atoms.calc = self
         return atoms
 
     def get_fermi_level(self) -> float:
         state = self.calculation.state
         fl = state.ibzwfs.fermi_levels * Ha
         assert len(fl) == 1
         return fl[0]
 
+    def get_fermi_levels(self) -> float:
+        state = self.calculation.state
+        fl = state.ibzwfs.fermi_levels * Ha
+        assert len(fl) == 2
+        return fl
+
     def get_homo_lumo(self, spin: int = None) -> Array1D:
         state = self.calculation.state
         return state.ibzwfs.get_homo_lumo(spin) * Ha
 
     def get_number_of_electrons(self):
         state = self.calculation.state
         return state.ibzwfs.nelectrons
 
     def get_number_of_bands(self):
         state = self.calculation.state
         return state.ibzwfs.nbands
 
+    def get_number_of_grid_points(self):
+        return self.calculation.state.density.nt_sR.desc.size
+
+    def get_effective_potential(self, spin=0):
+        assert spin == 0
+        vt_R = self.calculation.state.potential.vt_sR[spin]
+        return vt_R.to_pbc_grid().data * Ha
+
+    def get_electrostatic_potential(self):
+        density = self.calculation.state.density
+        potential, vHt_x, W_aL = self.calculation.pot_calc.calculate(density)
+        if isinstance(vHt_x, UniformGridFunctions):
+            return vHt_x.to_pbc_grid().data * Ha
+
+        return vHt_x.interpolate(
+            grid=self.calculation.pot_calc.fine_grid).data * Ha
+
     def get_atomic_electrostatic_potentials(self):
         return self.calculation.electrostatic_potential().atomic_potentials()
 
-    def get_pseudo_density(self, spin=None):
-        return self.calculation.densities().pseudo_densities().data
+    def get_electrostatic_corrections(self):
+        return self.calculation.electrostatic_potential().atomic_corrections()
 
-    def get_all_electron_density(self, spin=None, gridrefinement=1):
+    def get_pseudo_density(self, spin=None, gridrefinement=1):
         assert spin is None
-        n_sr = self.calculation.densities().all_electron_densities(
+        nt_sr = self.calculation.densities().pseudo_densities(
             grid_refinement=gridrefinement)
-        return n_sr.data.sum(0)
+        return nt_sr.to_pbc_grid().data.sum(0)
 
-    def get_eigenvalues(self, kpt=0, spin=0):
-        state = self.calculation.state
-        return state.ibzwfs.get_eigs_and_occs(k=kpt, s=spin)[0] * Ha
+    def get_all_electron_density(self,
+                                 spin=None,
+                                 gridrefinement=1,
+                                 skip_core=False):
+        assert spin is None
+        n_sr = self.calculation.densities().all_electron_densities(
+            grid_refinement=gridrefinement,
+            skip_core=skip_core)
+        return n_sr.to_pbc_grid().data.sum(0)
+
+    def get_eigenvalues(self, kpt=0, spin=0, broadcast=True):
+        state = self.calculation.state
+        eig_n = state.ibzwfs.get_eigs_and_occs(k=kpt, s=spin)[0] * Ha
+        if broadcast:
+            if self.world.rank != 0:
+                eig_n = np.empty(state.ibzwfs.nbands)
+            self.world.broadcast(eig_n, 0)
+        return eig_n
+
+    def get_occupation_numbers(self, kpt=0, spin=0, broadcast=True):
+        state = self.calculation.state
+        weight = state.ibzwfs.ibz.weight_k[kpt] * state.ibzwfs.spin_degeneracy
+        occ_n = state.ibzwfs.get_eigs_and_occs(k=kpt, s=spin)[1] * weight
+        if broadcast:
+            if self.world.rank != 0:
+                occ_n = np.empty(state.ibzwfs.nbands)
+            self.world.broadcast(occ_n, 0)
+        return occ_n
 
     def get_reference_energy(self):
         return self.calculation.setups.Eref * Ha
 
     def get_number_of_iterations(self):
         return self.calculation.scf_loop.niter
 
@@ -248,16 +384,21 @@
         state = self.calculation.state
         return state.ibzwfs.ibz.bz.kpt_Kc.copy()
 
     def get_ibz_k_points(self):
         state = self.calculation.state
         return state.ibzwfs.ibz.kpt_kc.copy()
 
-    def calculate(self, atoms):
-        self.get_potential_energy(atoms)
+    def calculate(self, atoms, properties=None, system_changes=None):
+        if properties is None:
+            properties = ['energy']
+
+        for name in properties:
+            self.calculate_property(atoms, name)
+        # self.get_potential_energy(atoms)
 
     @cached_property
     def wfs(self):
         from gpaw.new.backwards_compatibility import FakeWFS
         return FakeWFS(self.calculation, self.atoms)
 
     @property
@@ -285,21 +426,23 @@
     @property
     def initialized(self):
         return self.calculation is not None
 
     def get_xc_difference(self, xcparams):
         """Calculate non-selfconsistent XC-energy difference."""
         state = self.calculation.state
-        xc = XC(xcparams, state.density.ncomponents)
+        xc = XCFunctional(xcparams, state.density.ncomponents)
         exct = self.calculation.pot_calc.calculate_non_selfconsistent_exc(
             state.density.nt_sR, xc)
         dexc = 0.0
         for a, D_sii in state.density.D_asii.items():
             setup = self.setups[a]
-            dexc += xc.calculate_paw_correction(setup, pack(D_sii))
+            dexc += xc.calculate_paw_correction(
+                setup,
+                np.array([pack(D_ii) for D_ii in D_sii]))
         return (exct + dexc - state.potential.energies['xc']) * Ha
 
     def diagonalize_full_hamiltonian(self,
                                      nbands: int = None,
                                      scalapack=None,
                                      expert: bool = None) -> None:
         if expert is not None:
@@ -320,52 +463,65 @@
         from gpaw.response.groundstate import ResponseGroundStateAdapter
         return ResponseGroundStateAdapter(self)
 
     def fixed_density(self, **kwargs):
         kwargs = {**dict(self.params.items()), **kwargs}
         params = InputParameters(kwargs)
         txt = params.txt
+        if txt == '?':
+            txt = '-'
         world = params.parallel['world']
         log = Logger(txt, world)
         builder = create_builder(self.atoms, params)
         basis_set = builder.create_basis_set()
         state = self.calculation.state
-        ibzwfs = builder.create_ibz_wave_functions(basis_set, state.potential)
+        ibzwfs = builder.create_ibz_wave_functions(basis_set, state.potential,
+                                                   log=log)
         ibzwfs.fermi_levels = state.ibzwfs.fermi_levels
         state = DFTState(ibzwfs, state.density, state.potential)
         scf_loop = builder.create_scf_loop()
         scf_loop.update_density_and_potential = False
 
         calculation = DFTCalculation(
             state,
             builder.setups,
             scf_loop,
-            SimpleNamespace(fracpos_ac=self.calculation.fracpos_ac),
+            SimpleNamespace(fracpos_ac=self.calculation.fracpos_ac,
+                            poisson_solver=None),
             log)
 
         calculation.converge()
 
         return ASECalculator(params, log, calculation, self.atoms)
 
     def initialize(self, atoms):
         self.create_new_calculation(atoms)
 
+    def converge_wave_functions(self):
+        self.calculation.state.ibzwfs.make_sure_wfs_are_read_from_gpw_file()
 
-def write_header(log, world, params):
-    from gpaw.io.logger import write_header as header
-    log(f'#  __  _  _\n# | _ |_)|_||  |\n# |__||  | ||/\\| - {__version__}\n')
-    header(log, world)
-    log('---')
-    with log.indent('input parameters:'):
-        log(**{k: v for k, v in params.items()})
+    def get_number_of_spins(self):
+        return self.calculation.state.density.ndensities
 
+    @property
+    def parameters(self):
+        return self.params
 
-def compare_atoms(a1: Atoms, a2: Atoms) -> set[str]:
-    if len(a1.numbers) != len(a2.numbers) or (a1.numbers != a2.numbers).any():
-        return {'numbers'}
-    if (a1.pbc != a2.pbc).any():
-        return {'pbc'}
-    if abs(a1.cell - a2.cell).max() > 0.0:
-        return {'cell'}
-    if abs(a1.positions - a2.positions).max() > 0.0:
-        return {'positions'}
-    return set()
+    def dos(self,
+            soc: bool = False,
+            theta: float = 0.0,  # degrees
+            phi: float = 0.0,  # degrees
+            shift_fermi_level: bool = True) -> DOSCalculator:
+        """Create DOS-calculator.
+
+        Default is to ``shift_fermi_level`` to 0.0 eV.  For ``soc=True``,
+        angles can be given in degrees.
+        """
+        return DOSCalculator.from_calculator(
+            self, soc=soc,
+            theta=theta, phi=phi,
+            shift_fermi_level=shift_fermi_level)
+
+    def band_structure(self):
+        """Create band-structure object for plotting."""
+        from ase.spectrum.band_structure import get_band_structure
+        return get_band_structure(calc=self)
```

### Comparing `gpaw-22.8.0/gpaw/new/backwards_compatibility.py` & `gpaw-23.6.0/gpaw/new/backwards_compatibility.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,17 +1,20 @@
 import numpy as np
 from ase import Atoms
+from ase.units import Bohr
+
 from gpaw.band_descriptor import BandDescriptor
 from gpaw.kpt_descriptor import KPointDescriptor
 from gpaw.new import cached_property, prod
 from gpaw.new.calculation import DFTCalculation
 from gpaw.new.pwfd.wave_functions import PWFDWaveFunctions
 from gpaw.projections import Projections
 from gpaw.pw.descriptor import PWDescriptor
 from gpaw.utilities import pack
+from gpaw.wavefunctions.arrays import PlaneWaveExpansionWaveFunctions
 
 
 class FakeWFS:
     def __init__(self, calculation: DFTCalculation, atoms: Atoms):
         self.setups = calculation.setups
         self.state = calculation.state
         ibzwfs = self.state.ibzwfs
@@ -26,29 +29,37 @@
         self.atom_partition = calculation._atom_partition
         self.setups.set_symmetry(ibzwfs.ibz.symmetries.symmetry)
         self.occupations = calculation.scf_loop.occ_calc.occ
         self.nvalence = int(round(ibzwfs.nelectrons))
         assert self.nvalence == ibzwfs.nelectrons
         self.world = calculation.scf_loop.world
         if ibzwfs.fermi_levels is not None:
-            self.fermi_level, = ibzwfs.fermi_levels
+            self.fermi_levels = ibzwfs.fermi_levels
+            if len(self.fermi_levels) == 1:
+                self.fermi_level = self.fermi_levels[0]
         self.nspins = ibzwfs.nspins
         self.dtype = ibzwfs.dtype
         wfs = ibzwfs.wfs_qs[0][0]
-        assert isinstance(wfs, PWFDWaveFunctions)
-        if hasattr(wfs.psit_nX.desc, 'ecut'):
-            self.mode = 'pw'
-            self.pd = PWDescriptor(wfs.psit_nX.desc.ecut,
-                                   self.gd, self.dtype, self.kd)
-            self.pwgrid = grid.new(dtype=self.dtype)
+        self.pd = None
+        if isinstance(wfs, PWFDWaveFunctions):
+            if hasattr(wfs.psit_nX.desc, 'ecut'):
+                self.mode = 'pw'
+                self.pd = PWDescriptor(wfs.psit_nX.desc.ecut,
+                                       self.gd, self.dtype, self.kd)
+                self.pwgrid = grid.new(dtype=self.dtype)
+            else:
+                self.mode = 'fd'
         else:
-            self.mode = 'fd'
+            self.mode = 'lcao'
 
     def _get_wave_function_array(self, u, n, realspace):
-        return self.kpt_u[u].wfs.psit_nX[n].ifft(grid=self.pwgrid).data
+        psit_X = self.kpt_u[u].wfs.psit_nX[n]
+        if hasattr(psit_X, 'ifft'):
+            return psit_X.ifft(grid=self.pwgrid).data
+        return psit_X.data
 
     def get_wave_function_array(self, n, k, s, realspace=True, periodic=False):
         assert realspace
         psit_X = self.kpt_qs[k][s].wfs.psit_nX[n]
         if self.mode == 'pw':
             psit_R = psit_X.ifft(grid=self.pwgrid, periodic=periodic)
         else:
@@ -56,64 +67,78 @@
             if periodic:
                 psit_R.multiply_by_eikr(-psit_R.desc.kpt_c)
         return psit_R.data
 
     def collect_projections(self, k, s):
         return self.kpt_qs[k][s].projections.collect()
 
+    def collect_eigenvalues(self, k, s):
+        return self.state.ibzwfs.wfs_qs[k][s].eig_n.copy()
+
     @cached_property
     def kpt_u(self):
         return [kpt
                 for kpt_s in self.kpt_qs
                 for kpt in kpt_s]
 
     @cached_property
     def kpt_qs(self):
         ngpts = prod(self.gd.N_c)
-        return [[KPT(wfs, self.atom_partition, ngpts)
+        return [[KPT(wfs, self.atom_partition, ngpts, self.pd)
                  for wfs in wfs_s]
                 for wfs_s in self.state.ibzwfs.wfs_qs]
 
 
 class KPT:
-    def __init__(self, wfs, atom_partition, ngpts):
+    def __init__(self, wfs, atom_partition, ngpts, pd):
         self.ngpts = ngpts
         self.wfs = wfs
+        self.pd = pd
         self.projections = Projections(
             wfs.nbands,
             [I2 - I1 for (a, I1, I2) in wfs.P_ani.layout.myindices],
             atom_partition,
             wfs.P_ani.comm,
             wfs.ncomponents < 4,
             wfs.spin,
             data=wfs.P_ani.data)
         self.eps_n = wfs.eig_n
         self.s = wfs.spin if wfs.ncomponents < 4 else None
         self.k = wfs.k
         self.q = wfs.q
         self.weight = wfs.spin_degeneracy * wfs.weight
         self.f_n = wfs.occ_n * self.weight
-        self.psit_nX = wfs.psit_nX
         self.P_ani = wfs.P_ani
+        if isinstance(wfs, PWFDWaveFunctions):
+            self.psit_nX = wfs.psit_nX
 
     @property
     def psit_nG(self):
         a_nG = self.psit_nX.data
         if a_nG.ndim == 4:
             return a_nG
         return a_nG * self.ngpts
 
+    @cached_property
+    def psit(self):
+        return PlaneWaveExpansionWaveFunctions(
+            self.wfs.nbands, self.pd, self.wfs.dtype,
+            self.psit_nX.data * self.ngpts,
+            kpt=self.q,
+            dist=(),  # self.bd.comm, self.bd.comm.size),
+            spin=self.s,
+            collinear=self.wfs.ncomponents != 4)
+
 
 class FakeDensity:
     def __init__(self, calculation: DFTCalculation):
         self.setups = calculation.setups
         self.state = calculation.state
         self.D_asii = self.state.density.D_asii
         self.atom_partition = calculation._atom_partition
-        self.nt_sg = None
         self.interpolate = calculation.pot_calc._interpolate_density
         self.nt_sR = self.state.density.nt_sR
         self.nt_sG = self.nt_sR.data
         self.gd = self.nt_sR.desc._gd
         self.finegd = calculation.pot_calc.fine_grid._gd
         self._densities = calculation.densities()
         self.ncomponents = len(self.nt_sG)
@@ -123,33 +148,39 @@
     def D_asp(self):
         D_asp = self.setups.empty_atomic_matrix(self.ncomponents,
                                                 self.atom_partition)
         D_asp.update({a: np.array([pack(D_ii) for D_ii in D_sii])
                       for a, D_sii in self.D_asii.items()})
         return D_asp
 
+    @cached_property
+    def nt_sg(self):
+        return self.interpolate(self.nt_sR)[0].data
+
     def interpolate_pseudo_density(self):
-        self.nt_sg = self.interpolate(self.nt_sR)[0].data
+        pass
 
     def get_all_electron_density(self, *, atoms, gridrefinement):
         n_sr = self._densities.all_electron_densities(
-            grid_refinement=gridrefinement)
+            grid_refinement=gridrefinement).scaled(1 / Bohr, Bohr**3)
         return n_sr.data, n_sr.desc._gd
 
 
 class FakeHamiltonian:
     def __init__(self, calculation: DFTCalculation):
         self.pot_calc = calculation.pot_calc
         self.finegd = self.pot_calc.fine_grid._gd
         self.grid = calculation.state.potential.vt_sR.desc
+        self.e_total_free = calculation.results.get('free_energy')
+        self.e_xc = calculation.state.potential.energies['xc']
+        # self.poisson = calculation.pot_calc.poisson_solver.solver
 
     def restrict_and_collect(self, vxct_sg):
         fine_grid = self.pot_calc.fine_grid
         vxct_sr = fine_grid.empty(len(vxct_sg))
         vxct_sr.data[:] = vxct_sg
-        vxct_sR = self.grid.zeros(vxct_sr.dims)
-        self.pot_calc._restrict(vxct_sr, vxct_sR)
+        vxct_sR = self.pot_calc.restrict(vxct_sr)
         return vxct_sR.data
 
     @property
     def xc(self):
         return self.pot_calc.xc.xc
```

### Comparing `gpaw-22.8.0/gpaw/new/basis.py` & `gpaw-23.6.0/gpaw/new/basis.py`

 * *Files 18% similar despite different names*

```diff
@@ -17,13 +17,13 @@
     kd = KPointDescriptor(ibz.bz.kpt_Kc, nspins)
     kd.set_symmetry(SimpleNamespace(pbc=pbc_c),
                     ibz.symmetries.symmetry,
                     comm=world)
     kd.set_communicator(kpt_comm)
 
     basis = BasisFunctions(grid._gd,
-                           [setup.phit_j for setup in setups],
+                           [setup.basis_functions_J for setup in setups],
                            kd,
                            dtype=dtype,
                            cut=True)
     basis.set_positions(fracpos_ac)
     return basis
```

### Comparing `gpaw-22.8.0/gpaw/new/brillouin.py` & `gpaw-23.6.0/gpaw/new/brillouin.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/new/builder.py` & `gpaw-23.6.0/gpaw/new/builder.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,34 +1,39 @@
 from __future__ import annotations
 
 import importlib
-from types import SimpleNamespace
+import os
+from types import ModuleType, SimpleNamespace
 from typing import Any, Union
 
+import _gpaw
 import numpy as np
 from ase import Atoms
 from ase.calculators.calculator import kpts2sizeandoffsets
 from ase.units import Bohr
-
 from gpaw.core import UniformGrid
 from gpaw.core.atom_arrays import (AtomArrays, AtomArraysLayout,
                                    AtomDistribution)
+from gpaw.core.domain import Domain
+from gpaw.gpu.mpi import CuPyMPI
 from gpaw.mixer import MixerWrapper, get_mixer_from_keywords
-from gpaw.mpi import MPIComm, Parallelization, serial_comm, world
+from gpaw.mpi import (MPIComm, Parallelization, serial_comm, synchronize_atoms,
+                      world)
 from gpaw.new import cached_property, prod
 from gpaw.new.basis import create_basis
 from gpaw.new.brillouin import BZPoints, MonkhorstPackKPoints
 from gpaw.new.density import Density
+from gpaw.new.ibzwfs import IBZWaveFunctions
 from gpaw.new.input_parameters import InputParameters
 from gpaw.new.scf import SCFLoop
 from gpaw.new.smearing import OccupationNumberCalculator
 from gpaw.new.symmetry import create_symmetries_object
 from gpaw.new.xc import XCFunctional
 from gpaw.setup import Setups
-from gpaw.typing import DTypeLike, Array2D, ArrayLike1D, ArrayLike2D
+from gpaw.typing import Array2D, ArrayLike1D, ArrayLike2D
 from gpaw.utilities.gpts import get_number_of_grid_points
 
 
 def builder(atoms: Atoms,
             params: dict[str, Any] | InputParameters) -> DFTComponentsBuilder:
     """Create DFT-components builder.
 
@@ -57,14 +62,15 @@
         self.atoms = atoms.copy()
         self.mode = params.mode['name']
         self.params = params
 
         parallel = params.parallel
         world = parallel['world']
 
+        synchronize_atoms(atoms, world)
         self.check_cell(atoms.cell)
 
         self.initial_magmom_av, self.ncomponents = normalize_initial_magmoms(
             atoms, params.magmoms, params.spinpol or params.hund)
 
         self.soc = params.soc
         self.nspins = self.ncomponents % 3
@@ -72,15 +78,15 @@
 
         self.xc = self.create_xc_functional()
 
         self.setups = Setups(atoms.numbers,
                              params.setups,
                              params.basis,
                              self.xc.setup_name,
-                             world)
+                             world=world)
 
         if params.hund:
             c = params.charge / len(atoms)
             for a, setup in enumerate(self.setups):
                 self.initial_magmom_av[a, 2] = setup.get_hunds_rule_moment(c)
 
         symmetries = create_symmetries_object(atoms,
@@ -91,15 +97,15 @@
         bz = create_kpts(params.kpts, atoms)
         self.ibz = symmetries.reduce(bz, strict=False)
 
         d = parallel.get('domain', None)
         k = parallel.get('kpt', None)
         b = parallel.get('band', None)
         self.communicators = create_communicators(world, len(self.ibz),
-                                                  d, k, b)
+                                                  d, k, b, self.xp)
 
         if self.mode == 'fd':
             pass  # filter = create_fourier_filter(grid)
             # setups = stups.filter(filter)
 
         self.nelectrons = self.setups.nvalence - params.charge
 
@@ -107,21 +113,23 @@
                                                 self.setups,
                                                 params.charge,
                                                 self.initial_magmom_av,
                                                 self.mode == 'lcao')
         if self.ncomponents == 4:
             self.nbands *= 2
 
-        self.dtype: DTypeLike
-        if params.force_complex_dtype:
-            self.dtype = complex
-        elif self.ibz.bz.gamma_only:
-            self.dtype = float
-        else:
-            self.dtype = complex
+        self.dtype = params.dtype
+        if self.dtype is None:
+            if self.ibz.bz.gamma_only:
+                self.dtype = float
+            else:
+                self.dtype = complex
+        elif not self.ibz.bz.gamma_only and self.dtype != complex:
+            raise ValueError('Can not use dtype=float for non gamma-point '
+                             'calculation')
 
         self.grid, self.fine_grid = self.create_uniform_grids()
 
         self.fracpos_ac = self.atoms.get_scaled_positions()
         self.fracpos_ac %= 1
         self.fracpos_ac %= 1
 
@@ -141,23 +149,36 @@
     @cached_property
     def atomdist(self) -> AtomDistribution:
         return AtomDistribution(
             self.grid.ranks_from_fractional_positions(self.fracpos_ac),
             self.grid.comm)
 
     @cached_property
-    def wf_desc(self):
+    def wf_desc(self) -> Domain:
         return self.create_wf_description()
 
+    @cached_property
+    def xp(self) -> ModuleType:
+        """Array module: Numpy or Cupy."""
+        if self.params.parallel['gpu']:
+            from gpaw.gpu import cupy, cupy_is_fake
+            assert not cupy_is_fake or os.environ.get('GPAW_CPUPY')
+            return cupy
+        else:
+            return np
+
+    def create_wf_description(self) -> Domain:
+        raise NotImplementedError
+
     def __repr__(self):
         return f'{self.__class__.__name__}({self.atoms}, {self.params})'
 
     @cached_property
     def nct_R(self):
-        out = self.grid.empty()
+        out = self.grid.empty(xp=self.xp)
         nct_aX = self.get_pseudo_core_densities()
         nct_aX.to_uniform_grid(out=out,
                                scale=1.0 / (self.ncomponents % 3))
         return out
 
     def create_basis_set(self):
         return create_basis(self.ibz,
@@ -195,43 +216,46 @@
     def create_scf_loop(self):
         hamiltonian = self.create_hamiltonian_operator()
         eigensolver = self.create_eigensolver(hamiltonian)
 
         mixer = MixerWrapper(
             get_mixer_from_keywords(self.atoms.pbc.any(),
                                     self.ncomponents, **self.params.mixer),
-            self.ncomponents, self.grid._gd)
+            self.ncomponents,
+            self.grid._gd,
+            world=self.communicators['w'])
 
         occ_calc = self.create_occupation_number_calculator()
-
         return SCFLoop(hamiltonian, occ_calc,
                        eigensolver, mixer, self.communicators['w'],
-                       self.params.convergence,
+                       {key: value
+                        for key, value in self.params.convergence.items()
+                        if key != 'bands'},
                        self.params.maxiter)
 
     def read_ibz_wave_functions(self, reader):
         raise NotImplementedError
 
     def create_potential_calculator(self):
         raise NotImplementedError
 
-    def read_wavefunction_values(self, reader, ibzwfs):
+    def read_wavefunction_values(self,
+                                 reader,
+                                 ibzwfs: IBZWaveFunctions) -> None:
         """ Read eigenvalues, occuptions and projections and fermi levels
 
         The values are read using reader and set as the appropriate properties
         of (the already instantiated) wavefunctions contained in ibzwfs
         """
         ha = reader.ha
 
         eig_skn = reader.wave_functions.eigenvalues
         occ_skn = reader.wave_functions.occupations
         P_sknI = reader.wave_functions.projections
-
-        if self.params.force_complex_dtype:
-            P_sknI = P_sknI.astype(complex)
+        P_sknI = P_sknI.astype(ibzwfs.dtype)
 
         for wfs in ibzwfs:
             wfs._eig_n = eig_skn[wfs.spin, wfs.k] / ha
             wfs._occ_n = occ_skn[wfs.spin, wfs.k]
             layout = AtomArraysLayout([(setup.ni,) for setup in self.setups],
                                       dtype=self.dtype)
             if self.ncomponents < 4:
@@ -239,30 +263,45 @@
                                         dims=(self.nbands,),
                                         data=P_sknI[wfs.spin, wfs.k])
             else:
                 wfs._P_ani = AtomArrays(layout,
                                         dims=(self.nbands, 2),
                                         data=P_sknI[wfs.k])
 
-        ibzwfs.fermi_levels = reader.wave_functions.fermi_levels / ha
+        try:
+            ibzwfs.fermi_levels = reader.wave_functions.fermi_levels / ha
+        except AttributeError:
+            # old gpw-file
+            ibzwfs.fermi_levels = np.array(
+                [reader.occupations.fermilevel / ha])
 
 
 def create_communicators(comm: MPIComm = None,
                          nibzkpts: int = 1,
                          domain: Union[int, tuple[int, int, int]] = None,
                          kpt: int = None,
-                         band: int = None) -> dict[str, MPIComm]:
+                         band: int = None,
+                         xp: ModuleType = np) -> dict[str, MPIComm]:
     parallelization = Parallelization(comm or world, nibzkpts)
     if domain is not None and not isinstance(domain, int):
         domain = prod(domain)
     parallelization.set(kpt=kpt,
                         domain=domain,
                         band=band)
     comms = parallelization.build_communicators()
     comms['w'] = comm
+
+    # We replace size=1 MPI communications with serial_comm so that
+    # serial_comm.sum(<cupy-array>) works: XXX
+    comms = {key: comm if comm.size > 1 else serial_comm
+             for key, comm in comms.items()}
+
+    if xp is not np and not getattr(_gpaw, 'gpu_aware_mpi', False):
+        comms = {key: CuPyMPI(comm) for key, comm in comms.items()}
+
     return comms
 
 
 def create_fourier_filter(grid):
     gamma = 1.6
 
     h = ((grid.icell**2).sum(1)**-0.5 / grid.size).max()
@@ -309,17 +348,17 @@
         not magmom_av[:, 2].any()):
         ncomponents = 1
 
     return magmom_av, ncomponents
 
 
 def create_kpts(kpts: dict[str, Any], atoms: Atoms) -> BZPoints:
-    if 'points' in kpts:
+    if 'kpts' in kpts:
         assert len(kpts) == 1, kpts
-        return BZPoints(kpts['points'])
+        return BZPoints(kpts['kpts'])
     size, offset = kpts2sizeandoffsets(**kpts, atoms=atoms)
     return MonkhorstPackKPoints(size, offset)
 
 
 def calculate_number_of_bands(nbands: int | str | None,
                               setups: Setups,
                               charge: float,
```

### Comparing `gpaw-22.8.0/gpaw/new/calculation.py` & `gpaw-23.6.0/gpaw/new/calculation.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,32 +1,42 @@
 from __future__ import annotations
 
 from typing import Any, Union
 
+import numpy as np
 from ase import Atoms
 from ase.geometry import cell_to_cellpar
 from ase.units import Bohr, Ha
 from gpaw.core.arrays import DistributedArrays
-from gpaw.core.uniform_grid import UniformGridFunctions
+from gpaw.densities import Densities
 from gpaw.electrostatic_potential import ElectrostaticPotential
-from gpaw.new import cached_property
+from gpaw.gpu import as_xp
+from gpaw.mpi import broadcast_float
+from gpaw.new import cached_property, zip
 from gpaw.new.builder import builder as create_builder
 from gpaw.new.density import Density
-from gpaw.new.ibzwfs import IBZWaveFunctions
+from gpaw.new.ibzwfs import IBZWaveFunctions, create_ibz_wave_functions
 from gpaw.new.input_parameters import InputParameters
 from gpaw.new.logger import Logger
 from gpaw.new.potential import Potential
 from gpaw.new.scf import SCFLoop
 from gpaw.output import plot
 from gpaw.setup import Setups
 from gpaw.typing import Array1D, Array2D
 from gpaw.utilities import (check_atoms_too_close,
                             check_atoms_too_close_to_boundary)
 from gpaw.utilities.partition import AtomPartition
-from gpaw.densities import Densities
+
+
+class ReuseWaveFunctionsError(Exception):
+    """Reusing the old wave functions after cell change failed.
+
+    Most likekly, the number of k-points changed.
+    """
+
 
 units = {'energy': Ha,
          'free_energy': Ha,
          'forces': Ha / Bohr,
          'stress': Ha / Bohr**3,
          'dipole': Bohr,
          'magmom': 1.0,
@@ -35,16 +45,15 @@
 
 
 class DFTState:
     def __init__(self,
                  ibzwfs: IBZWaveFunctions,
                  density: Density,
                  potential: Potential,
-                 vHt_x: DistributedArrays = None,
-                 nct_R: UniformGridFunctions = None):
+                 vHt_x: DistributedArrays = None):
         """State of a Kohn-Sham calculation."""
         self.ibzwfs = ibzwfs
         self.density = density
         self.potential = potential
         self.vHt_x = vHt_x  # initial guess for Hartree potential
 
     def __repr__(self):
@@ -91,26 +100,31 @@
             params = {}
         if isinstance(params, dict):
             params = InputParameters(params)
 
         builder = builder or create_builder(atoms, params)
 
         if not isinstance(log, Logger):
-            log = Logger(log, builder.world)
+            log = Logger(log, params.parallel['world'])
 
         basis_set = builder.create_basis_set()
 
         density = builder.density_from_superposition(basis_set)
         density.normalize()
 
+        # The SCF-loop has a hamiltonian that has an fft-plan that is
+        # cached for later use, so best to create the SCF-loop first
+        # FIX this!
+        scf_loop = builder.create_scf_loop()
+
         pot_calc = builder.create_potential_calculator()
         potential, vHt_x, _ = pot_calc.calculate(density)
-        ibzwfs = builder.create_ibz_wave_functions(basis_set, potential)
+        ibzwfs = builder.create_ibz_wave_functions(basis_set, potential,
+                                                   log=log)
         state = DFTState(ibzwfs, density, potential, vHt_x)
-        scf_loop = builder.create_scf_loop()
 
         write_atoms(atoms, builder.initial_magmom_av, log)
         log(state)
         log(builder.setups)
         log(scf_loop)
         log(pot_calc)
 
@@ -119,67 +133,74 @@
                    scf_loop,
                    pot_calc,
                    log)
 
     def move_atoms(self, atoms) -> DFTCalculation:
         check_atoms_too_close(atoms)
 
-        self.fracpos_ac = atoms.get_scaled_positions()
+        self.fracpos_ac = np.ascontiguousarray(atoms.get_scaled_positions())
+        self.scf_loop.world.broadcast(self.fracpos_ac, 0)
 
-        atomdist = ...
+        atomdist = self.state.density.D_asii.layout.atomdist
 
         delta_nct_R = self.pot_calc.move(self.fracpos_ac,
                                          atomdist,
                                          self.state.density.ndensities)
         self.state.move(self.fracpos_ac, atomdist, delta_nct_R)
 
         mm_av = self.results['non_collinear_magmoms']
         write_atoms(atoms, mm_av, self.log)
 
         self.results = {}
 
         return self
 
-    def iconverge(self, convergence=None, maxiter=None):
+    def iconverge(self, convergence=None, maxiter=None, calculate_forces=None):
         self.state.ibzwfs.make_sure_wfs_are_read_from_gpw_file()
         for ctx in self.scf_loop.iterate(self.state,
                                          self.pot_calc,
                                          convergence,
                                          maxiter,
+                                         calculate_forces,
                                          log=self.log):
             yield ctx
 
     def converge(self,
                  convergence=None,
                  maxiter=None,
-                 steps=99999999999999999):
+                 steps=99999999999999999,
+                 calculate_forces=None):
         """Converge to self-consistent solution of Kohn-Sham equation."""
-        for step, _ in enumerate(self.iconverge(convergence, maxiter),
+        for step, _ in enumerate(self.iconverge(convergence,
+                                                maxiter,
+                                                calculate_forces),
                                  start=1):
             if step == steps:
                 break
         else:  # no break
             self.log(scf_steps=step)
 
     def energies(self):
-        energies1 = self.state.potential.energies.copy()
-        energies2 = self.state.ibzwfs.energies
-        energies1['kinetic'] += energies2['band']
-        energies1['entropy'] = energies2['entropy']
-        free_energy = sum(energies1.values())
-        extrapolated_energy = free_energy + energies2['extrapolation']
+        energies = combine_energies(self.state.potential, self.state.ibzwfs)
 
         self.log('energies:  # eV')
-        for name, e in energies1.items():
-            self.log(f'  {name + ":":10}   {e * Ha:14.6f}')
-        self.log(f'  total:       {free_energy * Ha:14.6f}')
-        self.log(f'  extrapolated:{extrapolated_energy * Ha:14.6f}\n')
+        for name, e in energies.items():
+            if not name.startswith('total'):
+                self.log(f'  {name + ":":10}   {e * Ha:14.6f}')
+        total_free = energies['total_free']
+        total_extrapolated = energies['total_extrapolated']
+        self.log(f'  total:       {total_free * Ha:14.6f}')
+        self.log(f'  extrapolated:{total_extrapolated * Ha:14.6f}\n')
+
+        world = self.scf_loop.world
+        total_free = broadcast_float(total_free, world)
+        total_extrapolated = broadcast_float(total_extrapolated, world)
 
-        self.results['free_energy'] = free_energy
-        self.results['energy'] = extrapolated_energy
+        self.results['free_energy'] = total_free
+        self.results['energy'] = total_extrapolated
 
     def dipole(self):
         dipole_v = self.state.density.calculate_dipole_moment(self.fracpos_ac)
         x, y, z = dipole_v * Bohr
         self.log(f'dipole moment: [{x:.6f}, {y:.6f}, {z:.6f}]  # |e|*Ang\n')
         self.results['dipole'] = dipole_v
 
@@ -197,22 +218,22 @@
                 x, y, z = m_v
                 c = ',' if a < len(mm_av) - 1 else ']'
                 self.log(f'  [{x:9.6f}, {y:9.6f}, {z:9.6f}]{c}'
                          f'  # {setup.symbol:2} {a}')
             self.log()
         return mm_v, mm_av
 
-    def forces(self):
-        """Return atomic force contributions."""
+    def forces(self, silent=False):
+        """Calculate atomic forces."""
         xc = self.pot_calc.xc
         assert not xc.no_forces
         assert not hasattr(xc.xc, 'setup_force_corrections')
 
         # Force from projector functions (and basis set):
-        F_av = self.state.ibzwfs.forces(self.state.potential.dH_asii)
+        F_av = self.state.ibzwfs.forces(self.state.potential)
 
         pot_calc = self.pot_calc
         Fcc_avL, Fnct_av, Fvbar_av = pot_calc.force_contributions(
             self.state)
 
         # Force from compensation charges:
         ccc_aL = \
@@ -224,31 +245,35 @@
         for a, dF_v in Fnct_av.items():
             F_av[a] += dF_v[:, 0]
 
         # Force from zero potential:
         for a, dF_v in Fvbar_av.items():
             F_av[a] += dF_v[:, 0]
 
+        F_av = as_xp(F_av, np)
+
         domain_comm = ccc_aL.layout.atomdist.comm
         domain_comm.sum(F_av)
 
         F_av = self.state.ibzwfs.ibz.symmetries.symmetrize_forces(F_av)
 
-        self.log('\nforces: [  # eV/Ang')
-        s = Ha / Bohr
-        for a, setup in enumerate(self.setups):
-            x, y, z = F_av[a] * s
-            c = ',' if a < len(F_av) - 1 else ']'
-            self.log(f'  [{x:9.3f}, {y:9.3f}, {z:9.3f}]{c}'
-                     f'  # {setup.symbol:2} {a}')
+        if not silent:
+            self.log('\nforces: [  # eV/Ang')
+            s = Ha / Bohr
+            for a, setup in enumerate(self.setups):
+                x, y, z = F_av[a] * s
+                c = ',' if a < len(F_av) - 1 else ']'
+                self.log(f'  [{x:9.3f}, {y:9.3f}, {z:9.3f}]{c}'
+                         f'  # {setup.symbol:2} {a}')
 
+        self.scf_loop.world.broadcast(F_av, 0)
         self.results['forces'] = F_av
 
     def stress(self):
-        stress_vv = self.pot_calc.stress_contribution(self.state)
+        stress_vv = self.pot_calc.stress(self.state)
         self.log('\nstress tensor: [  # eV/Ang^3')
         for (x, y, z), c in zip(stress_vv * (Ha / Bohr**3), ',,]'):
             self.log(f'  [{x:13.6f}, {y:13.6f}, {z:13.6f}]{c}')
         self.results['stress'] = stress_vv.flat[[0, 4, 8, 5, 2, 1]]
 
     def write_converged(self):
         self.state.ibzwfs.write_summary(self.log)
@@ -262,14 +287,88 @@
 
     @cached_property
     def _atom_partition(self):
         # Backwards compatibility helper
         atomdist = self.state.density.D_asii.layout.atomdist
         return AtomPartition(atomdist.comm, atomdist.rank_a)
 
+    def new(self,
+            atoms: Atoms,
+            params: InputParameters,
+            log=None) -> DFTCalculation:
+        """Create new DFTCalculation object."""
+
+        if params.mode['name'] != 'pw':
+            raise ReuseWaveFunctionsError
+
+        if not self.state.density.nt_sR.desc.pbc_c.all():
+            raise ReuseWaveFunctionsError
+
+        check_atoms_too_close(atoms)
+        check_atoms_too_close_to_boundary(atoms)
+
+        builder = create_builder(atoms, params)
+
+        kpt_kc = builder.ibz.kpt_kc
+        old_kpt_kc = self.state.ibzwfs.ibz.kpt_kc
+        if len(kpt_kc) != len(old_kpt_kc):
+            raise ReuseWaveFunctionsError
+        if abs(kpt_kc - old_kpt_kc).max() > 1e-9:
+            raise ReuseWaveFunctionsError
+
+        density = self.state.density.new(builder.grid)
+        density.normalize()
+        self.scf_loop.world.broadcast(density.nt_sR.data, 0)
+
+        scf_loop = builder.create_scf_loop()
+        pot_calc = builder.create_potential_calculator()
+        potential, vHt_x, _ = pot_calc.calculate(density)
+
+        old_ibzwfs = self.state.ibzwfs
+
+        def create_wfs(spin, q, k, kpt_c, weight):
+            wfs = old_ibzwfs.wfs_qs[q][spin]
+            return wfs.morph(
+                builder.wf_desc,
+                builder.fracpos_ac,
+                builder.atomdist)
+
+        ibzwfs = create_ibz_wave_functions(
+            builder.ibz,
+            nelectrons=old_ibzwfs.nelectrons,
+            ncomponents=old_ibzwfs.ncomponents,
+            create_wfs_func=create_wfs,
+            kpt_comm=old_ibzwfs.kpt_comm)
+
+        state = DFTState(ibzwfs, density, potential, vHt_x)
+
+        write_atoms(atoms, builder.initial_magmom_av, log)
+        log(state)
+        log(builder.setups)
+        log(scf_loop)
+        log(pot_calc)
+
+        return DFTCalculation(state,
+                              builder.setups,
+                              scf_loop,
+                              pot_calc,
+                              log)
+
+
+def combine_energies(potential: Potential,
+                     ibzwfs: IBZWaveFunctions) -> dict[str, float]:
+    """Add up energy contributions."""
+    energies = potential.energies.copy()
+    energies['kinetic'] += ibzwfs.energies['band']
+    energies['entropy'] = ibzwfs.energies['entropy']
+    energies['total_free'] = sum(energies.values())
+    energies['total_extrapolated'] = (energies['total_free'] +
+                                      ibzwfs.energies['extrapolation'])
+    return energies
+
 
 def write_atoms(atoms: Atoms,
                 magmom_av: Array2D,
                 log) -> None:
     log()
     with log.comment():
         log(plot(atoms))
```

### Comparing `gpaw-22.8.0/gpaw/new/density.py` & `gpaw-23.6.0/gpaw/new/density.py`

 * *Files 15% similar despite different names*

```diff
@@ -2,22 +2,26 @@
 from math import sqrt, pi
 import numpy as np
 from ase.units import Bohr
 from gpaw.typing import Vector
 from gpaw.core.atom_centered_functions import AtomArraysLayout
 from gpaw.utilities import unpack2, unpack
 from gpaw.core.atom_arrays import AtomArrays
+from gpaw.core.uniform_grid import UniformGridFunctions
+from gpaw.gpu import as_xp
+from gpaw.new import zip
+from gpaw.core.plane_waves import PlaneWaves
 
 
 class Density:
     def __init__(self,
-                 nt_sR,
-                 D_asii,
-                 charge,
-                 delta_aiiL,
+                 nt_sR: UniformGridFunctions,
+                 D_asii: AtomArrays,
+                 charge: float,
+                 delta_aiiL: list,
                  delta0_a,
                  N0_aii,
                  l_aj):
         self.nt_sR = nt_sR
         self.D_asii = D_asii
         self.delta_aiiL = delta_aiiL
         self.delta0_a = delta0_a
@@ -35,57 +39,80 @@
 
     def __str__(self) -> str:
         return (f'density:\n'
                 f'  components: {self.ncomponents}\n'
                 f'  grid points: {self.nt_sR.desc.size}\n'
                 f'  charge: {self.charge}  # |e|\n')
 
+    def new(self, grid):
+        old_grid = self.nt_sR.desc
+        nt_sR = grid.empty(self.ncomponents, xp=self.nt_sR.xp)
+        ecut = 0.999 * min(grid.ecut_max(), old_grid.ecut_max())
+        pw = PlaneWaves(ecut=ecut, cell=old_grid.cell, comm=grid.comm)
+        for nt_R, old_nt_R in zip(nt_sR, self.nt_sR):
+            old_nt_R.fft(pw=pw).ifft(out=nt_R)
+
+        return Density(nt_sR,
+                       self.D_asii,
+                       self.charge,
+                       self.delta_aiiL,
+                       self.delta0_a,
+                       self.N0_aii,
+                       self.l_aj)
+
     def calculate_compensation_charge_coefficients(self) -> AtomArrays:
+        xp = self.D_asii.layout.xp
         ccc_aL = AtomArraysLayout(
             [delta_iiL.shape[2] for delta_iiL in self.delta_aiiL],
-            atomdist=self.D_asii.layout.atomdist).empty()
+            atomdist=self.D_asii.layout.atomdist,
+            xp=xp).empty()
 
         for a, D_sii in self.D_asii.items():
-            Q_L = np.einsum('sij, ijL -> L',
+            Q_L = xp.einsum('sij, ijL -> L',
                             D_sii[:self.ndensities], self.delta_aiiL[a])
             Q_L[0] += self.delta0_a[a]
             ccc_aL[a] = Q_L
 
         return ccc_aL
 
     def normalize(self):
-        comp_charge = self.charge
+        comp_charge = 0.0
+        xp = self.D_asii.layout.xp
         for a, D_sii in self.D_asii.items():
-            comp_charge += np.einsum('sij, ij ->',
+            comp_charge += xp.einsum('sij, ij ->',
                                      D_sii[:self.ndensities],
                                      self.delta_aiiL[a][:, :, 0])
             comp_charge += self.delta0_a[a]
-        comp_charge = self.nt_sR.desc.comm.sum(comp_charge * sqrt(4 * pi))
+        # comp_charge could be cupy.ndarray:
+        comp_charge = float(comp_charge) * sqrt(4 * pi)
+        comp_charge = self.nt_sR.desc.comm.sum(comp_charge)
         charge = comp_charge + self.charge
         pseudo_charge = self.nt_sR[:self.ndensities].integrate().sum()
-        x = -charge / pseudo_charge
-        self.nt_sR.data *= x
+        if pseudo_charge != 0.0:
+            x = -charge / pseudo_charge
+            self.nt_sR.data *= x
 
     def update(self, nct_R, ibzwfs):
         self.nt_sR.data[:] = 0.0
         self.D_asii.data[:] = 0.0
         ibzwfs.add_to_density(self.nt_sR, self.D_asii)
         self.nt_sR.data[:self.ndensities] += nct_R.data
         self.symmetrize(ibzwfs.ibz.symmetries)
 
     def symmetrize(self, symmetries):
         self.nt_sR.symmetrize(symmetries.rotation_scc,
                               symmetries.translation_sc)
-
+        xp = self.nt_sR.xp
         D_asii = self.D_asii.gather(broadcast=True, copy=True)
         for a1, D_sii in self.D_asii.items():
             D_sii[:] = 0.0
+            rotation_sii = symmetries.rotations(self.l_aj[a1], xp)
             for a2, rotation_ii in zip(symmetries.a_sa[:, a1],
-                                       symmetries.rotations(self.l_aj[a1])):
-                D_sii += np.einsum('ij, sjk, lk -> sil',
+                                       rotation_sii):
+                D_sii += xp.einsum('ij, sjk, lk -> sil',
                                    rotation_ii, D_asii[a2], rotation_ii)
         self.D_asii.data *= 1.0 / len(symmetries)
 
     def move(self, delta_nct_R):
         self.nt_sR.data[:self.ndensities] += delta_nct_R.data
 
     @classmethod
@@ -105,53 +132,58 @@
                                               hund,
                                               charge / len(setups))
                  for a, (setup, magmom_v) in enumerate(zip(setups, magmom_av))}
 
         nt_sR = nct_R.desc.zeros(ncomponents)
         basis_set.add_to_density(nt_sR.data, f_asi)
         ndensities = ncomponents % 3
-        nt_sR.data[:ndensities] += nct_R.data
+        nt_sR.data[:ndensities] += nct_R.to_xp(np).data
 
         atom_array_layout = AtomArraysLayout([(setup.ni, setup.ni)
                                               for setup in setups],
                                              atomdist=atomdist)
         D_asii = atom_array_layout.empty(ncomponents)
         for a, D_sii in D_asii.items():
             D_sii[:] = unpack2(setups[a].initialize_density_matrix(f_asi[a]))
 
-        return cls.from_data_and_setups(nt_sR,
-                                        D_asii,
+        xp = nct_R.xp
+        return cls.from_data_and_setups(nt_sR.to_xp(xp),
+                                        D_asii.to_xp(xp),
                                         charge,
                                         setups)
 
     @classmethod
     def from_data_and_setups(cls,
                              nt_sR,
                              D_asii,
                              charge,
                              setups):
+        xp = nt_sR.xp
         return cls(nt_sR,
                    D_asii,
                    charge,
-                   [setup.Delta_iiL for setup in setups],
+                   [xp.asarray(setup.Delta_iiL) for setup in setups],
                    [setup.Delta0 for setup in setups],
                    [unpack(setup.N0_p) for setup in setups],
                    [setup.l_j for setup in setups])
 
     def calculate_dipole_moment(self, fracpos_ac):
         dip_v = np.zeros(3)
         ccc_aL = self.calculate_compensation_charge_coefficients()
+        ccc_aL = ccc_aL.to_cpu()
         pos_av = fracpos_ac @ self.nt_sR.desc.cell_cv
         for a, ccc_L in ccc_aL.items():
-            c, y, z, x = ccc_L[:4]
+            c = ccc_L[0]
             dip_v -= c * (4 * pi)**0.5 * pos_av[a]
-            dip_v -= np.array([x, y, z]) * (4 * pi / 3)**0.5
+            if len(ccc_L) > 1:
+                y, z, x = ccc_L[1:4]
+                dip_v -= np.array([x, y, z]) * (4 * pi / 3)**0.5
         self.nt_sR.desc.comm.sum(dip_v)
         for nt_R in self.nt_sR:
-            dip_v -= nt_R.moment()
+            dip_v -= as_xp(nt_R.moment(), np)
         return dip_v
 
     def calculate_magnetic_moments(self):
         magmom_av = np.zeros((self.natoms, 3))
         magmom_v = np.zeros(3)
         domain_comm = self.nt_sR.desc.comm
 
@@ -179,16 +211,16 @@
             domain_comm.sum(magmom_av)
             domain_comm.sum(magmom_v)
             magmom_v += self.nt_sR.integrate()[1:]
 
         return magmom_v, magmom_av
 
     def write(self, writer):
-        D_asp = self.D_asii.to_lower_triangle().gather()
-        nt_sR = self.nt_sR.gather()
+        D_asp = self.D_asii.to_cpu().to_lower_triangle().gather()
+        nt_sR = self.nt_sR.to_xp(np).gather()
         if D_asp is None:
             return
 
         writer.write(
             density=nt_sR.data * Bohr**-3,
             atomic_density_matrices=D_asp.data)
```

### Comparing `gpaw-22.8.0/gpaw/new/fd/builder.py` & `gpaw-23.6.0/gpaw/new/fd/builder.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,17 +1,19 @@
 from __future__ import annotations
+
 from gpaw.core import UniformGrid
-from gpaw.new.builder import create_uniform_grid
-from gpaw.new.pwfd.builder import PWFDDFTComponentsBuilder
-from gpaw.new.poisson import PoissonSolverWrapper, PoissonSolver
-from gpaw.poisson import PoissonSolver as make_poisson_solver
+from gpaw.core.uniform_grid import UniformGridFunctions
 from gpaw.fd_operators import Laplace
+from gpaw.new import zip
+from gpaw.new.builder import create_uniform_grid
 from gpaw.new.fd.pot_calc import UniformGridPotentialCalculator
-from gpaw.core.uniform_grid import UniformGridFunctions
 from gpaw.new.hamiltonian import Hamiltonian
+from gpaw.new.poisson import PoissonSolver, PoissonSolverWrapper
+from gpaw.new.pwfd.builder import PWFDDFTComponentsBuilder
+from gpaw.poisson import PoissonSolver as make_poisson_solver
 
 
 class FDDFTComponentsBuilder(PWFDDFTComponentsBuilder):
     def __init__(self, atoms, params, nn=3, interpolation=3):
         super().__init__(atoms, params)
         assert not self.soc
         self.kin_stencil_range = nn
```

### Comparing `gpaw-22.8.0/gpaw/new/fd/pot_calc.py` & `gpaw-23.6.0/gpaw/new/fd/pot_calc.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,20 +1,24 @@
-from gpaw.new.pot_calc import PotentialCalculator
+from math import pi
+
 from gpaw.core import UniformGrid
+from gpaw.new import zip
+from gpaw.new.pot_calc import PotentialCalculator
 
 
 class UniformGridPotentialCalculator(PotentialCalculator):
     def __init__(self,
                  wf_grid: UniformGrid,
                  fine_grid: UniformGrid,
                  setups,
                  xc,
                  poisson_solver,
                  nct_aR, nct_R,
                  interpolation_stencil_range=3):
+        self.fine_grid = fine_grid
         self.nct_aR = nct_aR
 
         fracpos_ac = nct_aR.fracpos_ac
         atomdist = nct_aR.atomdist
 
         self.vbar_ar = setups.create_local_potentials(fine_grid, fracpos_ac,
                                                       atomdist)
@@ -40,43 +44,51 @@
                 ' # %d. degree polynomial\n' % degree)
         return txt
 
     def calculate_charges(self, vHt_r):
         return self.ghat_aLr.integrate(vHt_r)
 
     def calculate_non_selfconsistent_exc(self, nt_sR, xc):
-        nt_sr = self._interpolate_density(nt_sR)
+        nt_sr, _, _ = self._interpolate_density(nt_sR)
         vxct_sr = nt_sr.desc.zeros(nt_sr.dims)
         e_xc = xc.calculate(nt_sr, vxct_sr)
         return e_xc
 
     def _interpolate_density(self, nt_sR):
         nt_sr = self.interpolate(nt_sR)
         if not nt_sR.desc.pbc_c.all():
             Nt1_s = nt_sR.integrate()
             Nt2_s = nt_sr.integrate()
             for Nt1, Nt2, nt_r in zip(Nt1_s, Nt2_s, nt_sr):
                 if Nt2 > 1e-14:
                     nt_r.data *= Nt1 / Nt2
-        return nt_sr
-
-    def _calculate(self, density, vHt_r):
-        nt_sr = self._interpolate_density(density.nt_sR)
+        return nt_sr, None, None
 
+    def calculate_pseudo_potential(self, density, vHt_r):
+        nt_sr, _, _ = self._interpolate_density(density.nt_sR)
         grid2 = nt_sr.desc
 
         vxct_sr = grid2.zeros(nt_sr.dims)
         e_xc = self.xc.calculate(nt_sr, vxct_sr)
 
         charge_r = grid2.empty()
         charge_r.data[:] = nt_sr.data[:density.ndensities].sum(axis=0)
         e_zero = self.vbar_r.integrate(charge_r)
 
         ccc_aL = density.calculate_compensation_charge_coefficients()
+
+        # Normalize: (LCAO basis functions may extend outside box)
+        comp_charge = (4 * pi)**0.5 * sum(ccc_L[0]
+                                          for ccc_L in ccc_aL.values())
+        comp_charge = ccc_aL.layout.atomdist.comm.sum(comp_charge)
+        pseudo_charge = charge_r.integrate()
+        charge_r.data *= -(comp_charge + density.charge) / pseudo_charge
+
         self.ghat_aLr.add_to(charge_r, ccc_aL)
+
         if vHt_r is None:
             vHt_r = grid2.zeros()
         self.poisson_solver.solve(vHt_r, charge_r)
         e_coulomb = 0.5 * vHt_r.integrate(charge_r)
 
         vt_sr = vxct_sr
         vt_sr.data += vHt_r.data + self.vbar_r.data
```

### Comparing `gpaw-22.8.0/gpaw/new/gpw.py` & `gpaw-23.6.0/gpaw/new/gpw.py`

 * *Files 21% similar despite different names*

```diff
@@ -1,24 +1,31 @@
 from __future__ import annotations
+
 from pathlib import Path
-from typing import Any, IO, Union
+from typing import IO, Any, Union
+
 import ase.io.ulm as ulm
 import gpaw
+import gpaw.mpi as mpi
 import numpy as np
 from ase.io.trajectory import read_atoms, write_atoms
 from ase.units import Bohr, Ha
 from gpaw.core.atom_arrays import AtomArraysLayout
 from gpaw.new.builder import builder as create_builder
 from gpaw.new.calculation import DFTCalculation, DFTState, units
 from gpaw.new.density import Density
 from gpaw.new.input_parameters import InputParameters
+from gpaw.new.logger import Logger
 from gpaw.new.potential import Potential
 from gpaw.utilities import unpack, unpack2
-from gpaw.new.logger import Logger
-import gpaw.mpi as mpi
+from gpaw.typing import DTypeLike
+
+ENERGY_NAMES = ['kinetic', 'coulomb', 'zero', 'external', 'xc', 'entropy',
+                'total_free', 'total_extrapolated',
+                'band']
 
 
 def write_gpw(filename: str,
               atoms,
               params,
               calculation: DFTCalculation,
               skip_wfs: bool = True) -> None:
@@ -34,24 +41,31 @@
     with writer:
         writer.write(version=4,
                      gpaw_version=gpaw.__version__,
                      ha=Ha,
                      bohr=Bohr)
 
         write_atoms(writer.child('atoms'), atoms)
+
+        # Note that 'non_collinear_magmoms' is not an ASE standard name!
         results = {key: value * units[key]
-                   for key, value in calculation.results.items()}
+                   for key, value in calculation.results.items()
+                   if key != 'non_collinear_magmoms'}
         writer.child('results').write(**results)
-        writer.child('parameters').write(
-            **{k: v for k, v in params.items()
-               if k not in ['txt', 'parallel']})
+
+        p = {k: v for k, v in params.items() if k not in ['txt', 'parallel']}
+        # ULM does not know about numpy dtypes:
+        if 'dtype' in p:
+            p['dtype'] = np.dtype(p['dtype']).name
+        writer.child('parameters').write(**p)
 
         state = calculation.state
         state.density.write(writer.child('density'))
-        state.potential.write(writer.child('hamiltonian'))
+        state.potential._write_gpw(writer.child('hamiltonian'),
+                                   calculation.state.ibzwfs)
         wf_writer = writer.child('wave_functions')
         state.ibzwfs.write(wf_writer, skip_wfs)
 
         if not skip_wfs and params.mode['name'] == 'pw':
             write_wave_function_indices(wf_writer,
                                         state.ibzwfs,
                                         state.density.nt_sR.desc)
@@ -63,15 +77,15 @@
     if ibzwfs.band_comm.rank != 0:
         return
     if ibzwfs.domain_comm.rank != 0:
         return
 
     kpt_comm = ibzwfs.kpt_comm
     ibz = ibzwfs.ibz
-    (nG,) = ibzwfs.get_max_shape(global_shape=True)
+    nG = ibzwfs.get_max_shape(global_shape=True)[-1]
 
     writer.add_array('indices', (len(ibz), nG), np.int32)
 
     index_G = np.zeros(nG, np.int32)
     size = tuple(grid.size)
     if ibzwfs.dtype == float:
         size = (size[0], size[1], size[2] // 2 + 1)
@@ -90,15 +104,15 @@
             kpt_comm.receive(index_G, rank)
             writer.fill(index_G)
 
 
 def read_gpw(filename: Union[str, Path, IO[str]],
              log: Union[Logger, str, Path, IO[str]] = None,
              parallel: dict[str, Any] = None,
-             force_complex_dtype: bool = False):
+             dtype: DTypeLike = None):
     """
     Read gpw file
 
     Returns
     -------
     atoms, calculation, params, builder
     """
@@ -111,37 +125,50 @@
     log(f'Reading from {filename}')
 
     reader = ulm.Reader(filename)
     bohr = reader.bohr
     ha = reader.ha
 
     atoms = read_atoms(reader.atoms)
-
     kwargs = reader.parameters.asdict()
     kwargs['parallel'] = parallel
 
-    if force_complex_dtype:
-        kwargs['force_complex_dtype'] = True
+    if 'dtype' in kwargs:
+        kwargs['dtype'] = np.dtype(kwargs['dtype'])
+
+    # kwargs['nbands'] = reader.wave_functions.eigenvalues.shape[-1]
 
     params = InputParameters(kwargs, warn=False)
     builder = create_builder(atoms, params)
 
-    (kpt_comm, band_comm, domain_comm, kpt_band_comm) = (
-        builder.communicators[x] for x in 'kbdD')
-
     if world.rank == 0:
         nt_sR_array = reader.density.density * bohr**3
         vt_sR_array = reader.hamiltonian.potential / ha
         D_sap_array = reader.density.atomic_density_matrices
         dH_sap_array = reader.hamiltonian.atomic_hamiltonian_matrices / ha
+        shape = nt_sR_array.shape[1:]
     else:
         nt_sR_array = None
         vt_sR_array = None
         D_sap_array = None
         dH_sap_array = None
+        shape = None
+
+    if builder.grid.global_shape() != mpi.broadcast(shape, comm=world):
+        # old gpw-file:
+        kwargs.pop('h', None)
+        kwargs['gpts'] = nt_sR_array.shape[1:]
+        params = InputParameters(kwargs, warn=False)
+        builder = create_builder(atoms, params)
+
+    if dtype is not None:
+        params.mode['dtype'] = dtype
+
+    (kpt_comm, band_comm, domain_comm, kpt_band_comm) = (
+        builder.communicators[x] for x in 'kbdD')
 
     nt_sR = builder.grid.empty(builder.ncomponents)
     vt_sR = builder.grid.empty(builder.ncomponents)
 
     atom_array_layout = AtomArraysLayout([(setup.ni * (setup.ni + 1) // 2)
                                           for setup in builder.setups],
                                          atomdist=builder.atomdist)
@@ -163,17 +190,30 @@
     kpt_band_comm.broadcast(vt_sR.data, 0)
     kpt_band_comm.broadcast(D_asp.data, 0)
     kpt_band_comm.broadcast(dH_asp.data, 0)
 
     density = Density.from_data_and_setups(nt_sR, D_asp.to_full(),
                                            builder.params.charge,
                                            builder.setups)
-    potential = Potential(vt_sR, dH_asp.to_full(), {})
+    energies = {name: reader.hamiltonian.get(f'e_{name}', np.nan) / ha
+                for name in ENERGY_NAMES}
+    penergies = {key: e for key, e in energies.items()
+                 if not key.startswith('total')}
+    e_band = penergies.pop('band', np.nan)
+    e_entropy = penergies.pop('entropy')
+    penergies['kinetic'] -= e_band
+
+    potential = Potential(vt_sR, dH_asp.to_full(), penergies)
 
     ibzwfs = builder.read_ibz_wave_functions(reader)
+    ibzwfs.energies = {
+        'band': e_band,
+        'entropy': e_entropy,
+        'extrapolation': (energies['total_extrapolated'] -
+                          energies['total_free'])}
 
     calculation = DFTCalculation(
         DFTState(ibzwfs, density, potential),
         builder.setups,
         builder.create_scf_loop(),
         pot_calc=builder.create_potential_calculator(),
         log=log)
```

### Comparing `gpaw-22.8.0/gpaw/new/ibzwfs.py` & `gpaw-23.6.0/gpaw/new/ibzwfs.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,21 +1,26 @@
 from __future__ import annotations
+
 from typing import Generator
 
+import _gpaw
 import numpy as np
 from ase.dft.bandgap import bandgap
 from ase.io.ulm import Writer
 from ase.units import Bohr, Ha
-from gpaw.core.atom_arrays import AtomArrays
+from gpaw.gpu import synchronize
+from gpaw.gpu.mpi import CuPyMPI
 from gpaw.mpi import MPIComm, serial_comm
+from gpaw.new import zip
 from gpaw.new.brillouin import IBZ
 from gpaw.new.lcao.wave_functions import LCAOWaveFunctions
+from gpaw.new.potential import Potential
 from gpaw.new.pwfd.wave_functions import PWFDWaveFunctions
 from gpaw.new.wave_functions import WaveFunctions
-from gpaw.typing import Array1D
+from gpaw.typing import Array1D, Array2D
 
 
 def create_ibz_wave_functions(ibz: IBZ,
                               nelectrons: float,
                               ncomponents: int,
                               create_wfs_func,
                               kpt_comm: MPIComm = serial_comm
@@ -31,14 +36,15 @@
     for q, k in enumerate(k_q):
         wfs_s = []
         for spin in range(nspins):
             wfs = create_wfs_func(spin, q, k,
                                   ibz.kpt_kc[k], ibz.weight_k[k])
             wfs_s.append(wfs)
         wfs_qs.append(wfs_s)
+
     return IBZWaveFunctions(ibz,
                             nelectrons,
                             ncomponents,
                             wfs_qs,
                             kpt_comm)
 
 
@@ -67,17 +73,22 @@
             self.q_k[wfs.k] = wfs.q
 
         self.band_comm = wfs.band_comm
         self.domain_comm = wfs.domain_comm
         self.dtype = wfs.dtype
         self.nbands = wfs.nbands
 
-        self.fermi_levels: Array1D | None = None
+        self.fermi_levels: Array1D | None = None  # hartree
+
+        self.energies: dict[str, float] = {}  # hartree
 
-        self.energies: dict[str, float] = {}
+        self.xp = self.wfs_qs[0][0].xp
+        if self.xp is not np:
+            if not getattr(_gpaw, 'gpu_aware_mpi', False):
+                self.kpt_comm = CuPyMPI(self.kpt_comm)
 
     def get_max_shape(self, global_shape: bool = False) -> tuple[int, ...]:
         """Find the largest wave function array shape.
 
         For a PW-calculation, this shape could depend on k-point.
         """
         if global_shape:
@@ -89,18 +100,40 @@
 
     def is_master(self):
         return (self.domain_comm.rank == 0 and
                 self.band_comm.rank == 0 and
                 self.kpt_comm.rank == 0)
 
     def __str__(self):
+        shape = self.get_max_shape(global_shape=True)
+        wfs = self.wfs_qs[0][0]
+        nbytes = (len(self.ibz) *
+                  self.nbands *
+                  len(self.wfs_qs[0]) *
+                  wfs.bytes_per_band)
+        ncores = (self.kpt_comm.size *
+                  self.domain_comm.size *
+                  self.band_comm.size)
         return (f'{self.ibz.symmetries}\n'
                 f'{self.ibz}\n'
+                f'{wfs._short_string(shape)}\n'
+                f'spin-components: {self.ncomponents}'
+                '  # (' +
+                ('' if self.collinear else 'non-') + 'collinear spins)\n'
+                f'bands: {self.nbands}\n'
                 f'valence electrons: {self.nelectrons}\n'
-                f'spin-degeneracy: {self.spin_degeneracy}\n')
+                f'spin-degeneracy: {self.spin_degeneracy}\n'
+                f'dtype: {self.dtype}\n\n'
+                'memory:\n'
+                f'    wave functions: {nbytes:_}  # bytes '
+                f' ({nbytes // ncores:_} per core)\n\n'
+                'parallelization:\n'
+                f'    kpt:    {self.kpt_comm.size}\n'
+                f'    domain: {self.domain_comm.size}\n'
+                f'    band:   {self.band_comm.size}\n')
 
     def __iter__(self) -> Generator[WaveFunctions, None, None]:
         for wfs_s in self.wfs_qs:
             yield from wfs_s
 
     def move(self, fracpos_ac, atomdist):
         self.ibz.symmetries.check_positions(fracpos_ac)
@@ -132,25 +165,29 @@
         for occ_n, wfs in zip(occ_un, self):
             wfs._occ_n = occ_n
 
         e_entropy *= degeneracy / Ha
         e_band = 0.0
         for wfs in self:
             e_band += wfs.occ_n @ wfs.eig_n * wfs.weight * degeneracy
-        e_band = self.kpt_comm.sum(e_band)
+        e_band = self.kpt_comm.sum(float(e_band))  # XXX CPU float?
+
         self.energies = {
             'band': e_band,
             'entropy': e_entropy,
             'extrapolation': e_entropy * occ_calc.extrapolate_factor}
 
     def add_to_density(self, nt_sR, D_asii) -> None:
         """Compute density from wave functions and add to ``nt_sR``
         and ``D_asii``."""
         for wfs in self:
             wfs.add_to_density(nt_sR, D_asii)
+
+        if self.xp is not np:
+            synchronize()
         self.kpt_comm.sum(nt_sR.data)
         self.kpt_comm.sum(D_asii.data)
 
     def get_all_electron_wave_function(self,
                                        band,
                                        kpt=0,
                                        spin=0,
@@ -221,18 +258,20 @@
             for s in range(self.nspins):
                 eig_n, occ_n = self.get_eigs_and_occs(k, s)
                 if self.is_master():
                     eig_skn[s, k, :] = eig_n
                     occ_skn[s, k, :] = occ_n
         return eig_skn, occ_skn
 
-    def forces(self, dH_asii: AtomArrays):
-        F_av = np.zeros((dH_asii.natoms, 3))
+    def forces(self, potential: Potential) -> Array2D:
+        F_av = self.xp.zeros((potential.dH_asii.natoms, 3))
         for wfs in self:
-            wfs.force_contribution(dH_asii, F_av)
+            wfs.force_contribution(potential, F_av)
+        if self.xp is not np:
+            synchronize()
         self.kpt_comm.sum(F_av)
         return F_av
 
     def write(self,
               writer: Writer,
               skip_wfs: bool) -> None:
         """Write fermi-level(s), eigenvalues, occupation numbers, ...
@@ -269,15 +308,15 @@
 
         writer.add_array('projections', spin_k_shape + proj_shape, self.dtype)
 
         for spin in range(self.nspins):
             for k, rank in enumerate(self.rank_k):
                 if rank == self.kpt_comm.rank:
                     wfs = self.wfs_qs[self.q_k[k]][spin]
-                    P_ani = wfs.P_ani.gather()  # gather atoms
+                    P_ani = wfs.P_ani.to_cpu().gather()  # gather atoms
                     if P_ani is not None:
                         P_nI = P_ani.matrix.gather()  # gather bands
                         if self.domain_comm.rank == 0:
                             if rank == 0:
                                 writer.fill(P_nI.data.reshape(proj_shape))
                             else:
                                 self.kpt_comm.send(P_nI.data, 0)
@@ -333,28 +372,38 @@
 
         if not self.is_master():
             return
 
         eig_skn *= Ha
 
         D = self.spin_degeneracy
+        nbands = eig_skn.shape[2]
 
         for k, (x, y, z) in enumerate(ibz.kpt_kc):
-            if k == 4:
-                log(f'(only showing first 4 out of {len(ibz)} k-points)')
+            if k == 3:
+                log(f'(only showing first 3 out of {len(ibz)} k-points)')
                 break
 
             log(f'\nkpt = [{x:.3f}, {y:.3f}, {z:.3f}], '
                 f'weight = {ibz.weight_k[k]:.3f}:')
 
             if self.nspins == 1:
+                skipping = False
                 log(f'  Band      eig [eV]   occ [0-{D}]')
-                for n, (e, f) in enumerate(zip(eig_skn[0, k],
-                                               occ_skn[0, k])):
-                    log(f'  {n:4} {e:13.3f}   {D * f:9.3f}')
+                eig_n = eig_skn[0, k]
+                n0 = (eig_n < fl[0]).sum() - 0.5
+                for n, (e, f) in enumerate(zip(eig_n, occ_skn[0, k])):
+                    # First, last and +-8 bands window around fermi level:
+                    if n == 0 or abs(n - n0) < 8 or n == nbands - 1:
+                        log(f'  {n:4} {e:13.3f}   {D * f:9.3f}')
+                        skipping = False
+                    else:
+                        if not skipping:
+                            log('   ...')
+                            skipping = True
             else:
                 log('  Band      eig [eV]   occ [0-1]'
                     '      eig [eV]   occ [0-1]')
                 for n, (e1, f1, e2, f2) in enumerate(zip(eig_skn[0, k],
                                                          occ_skn[0, k],
                                                          eig_skn[1, k],
                                                          occ_skn[1, k])):
```

### Comparing `gpaw-22.8.0/gpaw/new/input_parameters.py` & `gpaw-23.6.0/gpaw/new/input_parameters.py`

 * *Files 3% similar despite different names*

```diff
@@ -2,14 +2,15 @@
 from pathlib import Path
 import warnings
 
 from typing import Any, IO, Sequence
 
 import numpy as np
 from gpaw.mpi import world
+from gpaw.typing import DTypeLike
 
 parameter_functions = {}
 
 """
 background_charge
 external
 reuse_wfs_method
@@ -44,17 +45,17 @@
 
 
 class InputParameters:
     basis: Any
     charge: float
     communicator: Any
     convergence: dict[str, Any]
+    dtype: DTypeLike | None
     eigensolver: dict[str, Any]
     experimental: dict[str, Any]
-    force_complex_dtype: bool
     gpts: None | Sequence[int]
     h: float | None
     hund: bool
     kpts: dict[str, Any]
     magmoms: Any
     mode: dict[str, Any]
     nbands: None | int | str
@@ -67,14 +68,16 @@
     txt: str | Path | IO[str] | None
     xc: dict[str, Any]
 
     def __init__(self, params: dict[str, Any], warn: bool = True):
         self.keys = sorted(params)
 
         for key in params:
+            if key == 'fixdensity':
+                continue  # ignore old parameter
             if key not in parameter_functions:
                 raise ValueError(
                     f'Unknown parameter {key!r}.  Must be one of: ' +
                     ', '.join(parameter_functions))
         for key, func in parameter_functions.items():
             if key in params:
                 param = params[key]
@@ -95,31 +98,24 @@
                 warnings.warn('Please use new "soc" parameter.')
                 self.soc = self.experimental.pop('soc')
             if 'magmoms' in self.experimental:
                 warnings.warn('Please use new "magmoms" parameter.')
                 self.magmoms = self.experimental.pop('magmoms')
             assert not self.experimental
 
-        bands = self.convergence.pop('bands', None)
-        if bands is not None:
-            self.eigensolver['converge_bands'] = bands
-            if warn:
-                warnings.warn(f'Please use eigensolver={self.eigensolver!r}',
-                              stacklevel=4)
-
         force_complex_dtype = self.mode.pop('force_complex_dtype', None)
         if force_complex_dtype is not None:
             if warn:
+                self.dtype = complex if force_complex_dtype else None
                 warnings.warn(
                     'Please use '
-                    f'GPAW(force_complex_dtype={bool(force_complex_dtype)}, '
+                    f'GPAW(dtype={self.dtype}, '
                     '...)',
                     stacklevel=3)
-            self.force_complex_dtype = force_complex_dtype
-            self.keys.append('force_complex_dtype')
+            self.keys.append('dtype')
             self.keys.sort()
 
         if self.communicator is not None:
             self.parallel['world'] = self.communicator
             warnings.warn('Please use parallel={''world'': ...} '
                           'instead of communicator=...')
 
@@ -152,14 +148,19 @@
 @input_parameter
 def convergence(value=None):
     """Accuracy of the self-consistency cycle."""
     return value or {}
 
 
 @input_parameter
+def dtype(value=None):
+    return value
+
+
+@input_parameter
 def eigensolver(value=None) -> dict:
     """Eigensolver."""
     if isinstance(value, str):
         value = {'name': value}
     if value and value['name'] != 'dav':
         warnings.warn(f'{value["name"]} not implemented.  Using dav instead')
         return {'name': 'dav'}
@@ -168,19 +169,14 @@
 
 @input_parameter
 def experimental(value=None):
     return value
 
 
 @input_parameter
-def force_complex_dtype(value: bool = False):
-    return value
-
-
-@input_parameter
 def gpts(value=None):
     """Number of grid points."""
     return value
 
 
 @input_parameter
 def h(value=None):
@@ -196,18 +192,19 @@
 
 @input_parameter
 def kpts(value=None) -> dict[str, Any]:
     """Brillouin-zone sampling."""
     if value is None:
         value = {'size': (1, 1, 1)}
     elif not isinstance(value, dict):
-        if len(value) == 3 and isinstance(value[0], int):
-            value = {'size': value}
+        kpts = np.array(value)
+        if kpts.shape == (3,):
+            value = {'size': kpts}
         else:
-            value = {'points': np.array(value)}
+            value = {'kpts': kpts}
     return value
 
 
 @input_parameter
 def magmoms(value=None):
     return value
 
@@ -221,15 +218,19 @@
 @input_parameter
 def mixer(value=None):
     return value or {}
 
 
 @input_parameter
 def mode(value='fd'):
-    return {'name': value} if isinstance(value, str) else value
+    if isinstance(value, str):
+        return {'name': value}
+    gc = value.pop('gammacentered', False)
+    assert not gc
+    return value
 
 
 @input_parameter
 def nbands(value: str | int | None = None) -> str | int | None:
     """Number of electronic bands."""
     return value
 
@@ -252,15 +253,16 @@
                        'sl_diagonalize': None,
                        'sl_inverse_cholesky': None,
                        'sl_lcao': None,
                        'sl_lrtddft': None,
                        'use_elpa': False,
                        'elpasolver': '2stage',
                        'buffer_size': None,
-                       'world': None},
+                       'world': None,
+                       'gpu': False},
                       value)
     dct['world'] = dct['world'] or world
     return dct
 
 
 @input_parameter
 def poissonsolver(value=None):
@@ -272,15 +274,15 @@
 def random(value=False):
     return value
 
 
 @input_parameter
 def setups(value='paw'):
     """PAW datasets or pseudopotentials."""
-    return value if isinstance(value, dict) else {None: value}
+    return value if isinstance(value, dict) else {'default': value}
 
 
 @input_parameter
 def soc(value=False):
     return value
```

### Comparing `gpaw-22.8.0/gpaw/new/lcao/builder.py` & `gpaw-23.6.0/gpaw/new/lcao/builder.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,15 +1,17 @@
 from functools import partial
 
 import numpy as np
 from gpaw.core.matrix import Matrix
 from gpaw.lcao.tci import TCIExpansions
+from gpaw.new import zip
 from gpaw.new.fd.builder import FDDFTComponentsBuilder
 from gpaw.new.ibzwfs import create_ibz_wave_functions as create_ibzwfs
 from gpaw.new.lcao.eigensolver import LCAOEigensolver
+from gpaw.new.lcao.forces import TCIDerivatives
 from gpaw.new.lcao.hamiltonian import LCAOHamiltonian
 from gpaw.new.lcao.hybrids import HybridLCAOEigensolver, HybridXCFunctional
 from gpaw.new.lcao.wave_functions import LCAOWaveFunctions
 from gpaw.utilities.timing import NullTimer
 
 
 class LCAODFTComponentsBuilder(FDDFTComponentsBuilder):
@@ -52,21 +54,27 @@
         potential = self.create_potential_calculator()
         if 'coefficients' in reader.wave_functions:
             coefficients = reader.wave_functions.proxy('coefficients')
             coefficients.scale = c
         else:
             coefficients = None
 
-        ibzwfs = self.create_ibz_wave_functions(basis, potential, coefficients)
+        ibzwfs = self.create_ibz_wave_functions(basis, potential,
+                                                coefficients=coefficients)
 
         # Set eigenvalues, occupations, etc..
         self.read_wavefunction_values(reader, ibzwfs)
         return ibzwfs
 
-    def create_ibz_wave_functions(self, basis, potential, coefficients=None):
+    def create_ibz_wave_functions(self,
+                                  basis,
+                                  potential,
+                                  *,
+                                  log=None,
+                                  coefficients=None):
         ibzwfs, _ = create_lcao_ibzwfs(
             basis, potential,
             self.ibz, self.communicators, self.setups,
             self.fracpos_ac, self.grid, self.dtype,
             self.nbands, self.ncomponents, self.atomdist, self.nelectrons,
             coefficients)
         return ibzwfs
@@ -110,23 +118,27 @@
     domain_comm.sum(S_qMM)
 
     # self.atomic_correction= self.atomic_correction_cls.new_from_wfs(self)
     # self.atomic_correction.add_overlap_correction(newS_qMM)
 
     nao = setups.nao
 
+    tci_derivatives = TCIDerivatives(manytci, atomdist, nao)
+
     def create_wfs(spin, q, k, kpt_c, weight):
         C_nM = Matrix(nbands, 2 * nao if ncomponents == 4 else nao,
                       dtype,
                       dist=(band_comm, band_comm.size, 1))
         if coefficients is not None:
             C_nM.data[:] = coefficients.proxy(spin, k)
         return LCAOWaveFunctions(
             setups=setups,
             density_adder=partial(basis.construct_density, q=q),
+            tci_derivatives=tci_derivatives,
+            basis=basis,
             C_nM=C_nM,
             S_MM=Matrix(nao, nao, data=S_qMM[q],
                         dist=(band_comm, band_comm.size, 1)),
             T_MM=T_qMM[q],
             P_aMi=P_qaMi[q],
             kpt_c=kpt_c,
             fracpos_ac=fracpos_ac,
```

### Comparing `gpaw-22.8.0/gpaw/new/lcao/eigensolver.py` & `gpaw-23.6.0/gpaw/new/lcao/eigensolver.py`

 * *Files 0% similar despite different names*

```diff
@@ -17,15 +17,14 @@
             self.iterate1(wfs, matrix_calculator)
         return 0.0
 
     def iterate1(self,
                  wfs: LCAOWaveFunctions,
                  matrix_calculator: HamiltonianMatrixCalculator):
         H_MM = matrix_calculator.calculate_matrix(wfs)
-
         eig_M = H_MM.eighg(wfs.L_MM, wfs.domain_comm)
         N = min(len(eig_M), wfs.nbands)
         wfs._eig_n = np.empty(wfs.nbands)
         wfs._eig_n[:N] = eig_M[:N]
         wfs.C_nM.data[:N] = H_MM.data.T[:N]
 
         # Make sure wfs.C_nM and (lazy) wfs.P_ani are in sync:
```

### Comparing `gpaw-22.8.0/gpaw/new/lcao/hamiltonian.py` & `gpaw-23.6.0/gpaw/new/lcao/hamiltonian.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,13 +1,14 @@
 from __future__ import annotations
 
 import numpy as np
 from gpaw.core.matrix import Matrix
 from gpaw.external import ExternalPotential
 from gpaw.lfc import BasisFunctions
+from gpaw.new import zip
 from gpaw.new.calculation import DFTState
 from gpaw.new.fd.pot_calc import UniformGridPotentialCalculator
 from gpaw.new.hamiltonian import Hamiltonian
 from gpaw.new.lcao.wave_functions import LCAOWaveFunctions
 from gpaw.typing import Array2D, Array3D
 
 
@@ -125,18 +126,19 @@
                  basis: BasisFunctions):
         self.basis = basis
 
     def create_hamiltonian_matrix_calculator(self,
                                              state: DFTState
                                              ) -> HamiltonianMatrixCalculator:
         V_sxMM = [self.basis.calculate_potential_matrices(vt_R.data)
-                  for vt_R in state.potential.vt_sR]
+                  for vt_R in state.potential.vt_sR.to_xp(np)]
 
         dH_saii = [{a: dH_sii[s]
-                    for a, dH_sii in state.potential.dH_asii.items()}
+                    for a, dH_sii
+                    in state.potential.dH_asii.to_xp(np).items()}
                    for s in range(len(V_sxMM))]
 
         matcalc = CollinearHamiltonianMatrixCalculator(V_sxMM, dH_saii,
                                                        self.basis,
                                                        include_kinetic=True)
         if len(V_sxMM) < 4:
             return matcalc
```

### Comparing `gpaw-22.8.0/gpaw/new/lcao/hybrids.py` & `gpaw-23.6.0/gpaw/new/lcao/hybrids.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/new/lcao/wave_functions.py` & `gpaw-23.6.0/gpaw/new/lcao/wave_functions.py`

 * *Files 7% similar despite different names*

```diff
@@ -8,21 +8,26 @@
 from gpaw.core.matrix import Matrix
 from gpaw.mpi import MPIComm, serial_comm
 from gpaw.new import cached_property
 from gpaw.new.pwfd.wave_functions import PWFDWaveFunctions
 from gpaw.new.wave_functions import WaveFunctions
 from gpaw.setup import Setups
 from gpaw.typing import Array2D, Array3D
+from gpaw.new.potential import Potential
 
 
 class LCAOWaveFunctions(WaveFunctions):
+    xp = np
+
     def __init__(self,
                  *,
                  setups: Setups,
                  density_adder: Callable[[Array2D, Array3D], None],
+                 tci_derivatives,
+                 basis,
                  C_nM: Matrix,
                  S_MM: Matrix,
                  T_MM: Array2D,
                  P_aMi,
                  fracpos_ac: Array2D,
                  atomdist: AtomDistribution,
                  kpt_c=(0.0, 0.0, 0.0),
@@ -42,19 +47,24 @@
                          fracpos_ac=fracpos_ac,
                          atomdist=atomdist,
                          ncomponents=ncomponents,
                          dtype=C_nM.dtype,
                          domain_comm=domain_comm,
                          band_comm=C_nM.dist.comm)
         self.density_adder = density_adder
+        self.tci_derivatives = tci_derivatives
+        self.basis = basis
         self.C_nM = C_nM
         self.T_MM = T_MM
         self.S_MM = S_MM
         self.P_aMi = P_aMi
 
+        self.bytes_per_band = (self.array_shape(global_shape=True)[0] *
+                               C_nM.data.itemsize)
+
         # This is for TB-mode (and MYPY):
         self.V_MM: Matrix
 
     @cached_property
     def L_MM(self):
         S_MM = self.S_MM.copy()
         S_MM.invcholesky()
@@ -63,14 +73,17 @@
         M, M = S_MM.shape
         L_sMsM = Matrix(2 * M, 2 * M, dtype=complex)
         L_sMsM.data[:] = 0.0
         L_sMsM.data[:M, :M] = S_MM.data
         L_sMsM.data[M:, M:] = S_MM.data
         return L_sMsM
 
+    def _short_string(self, global_shape):
+        return f'basis functions: {global_shape[0]}'
+
     def array_shape(self, global_shape=False):
         if global_shape:
             return self.C_nM.shape[1:]
         1 / 0
 
     @property
     def P_ani(self):
@@ -102,15 +115,15 @@
 
     def gather_wave_function_coefficients(self) -> np.ndarray:
         C_nM = self.C_nM.gather()
         if C_nM is not None:
             return C_nM.data
         return None
 
-    def calculate_density_matrix(self) -> np.ndarray:
+    def calculate_density_matrix(self, eigs=False) -> np.ndarray:
         """Calculate the density matrix.
 
         The density matrix is:::
 
                 -- *
           ρ   = > C  C   f
            μν   -- nμ nν  n
@@ -118,14 +131,16 @@
 
         Returns
         -------
         The density matrix in the LCAO basis
         """
         if self.domain_comm.rank == 0:
             f_n = self.weight * self.spin_degeneracy * self.myocc_n
+            if eigs:
+                f_n *= self.myeig_n
             C_nM = self.C_nM.data
             rho_MM = (C_nM.T.conj() * f_n) @ C_nM
             self.band_comm.sum(rho_MM)
         else:
             rho_MM = np.empty_like(self.T_MM)
         self.domain_comm.broadcast(rho_MM, 0)
 
@@ -156,21 +171,33 @@
         # We should generalize the PW+FD method
         assert self.band_comm.size == 1
         assert self.domain_comm.size == 1
         n2 = n2 or self.nbands + n2
         return LCAOWaveFunctions(
             setups=self.setups,
             density_adder=self.density_adder,
+            tci_derivatives=self.tci_derivatives,
+            basis=self.basis,
             C_nM=Matrix(n2 - n1,
                         self.C_nM.shape[1],
                         data=self.C_nM.data[n1:n2].copy()),
             S_MM=self.S_MM,
             T_MM=self.T_MM,
             P_aMi=self.P_aMi,
             fracpos_ac=self.fracpos_ac,
             atomdist=self.atomdist,
             kpt_c=self.kpt_c,
             spin=self.spin,
             q=self.q,
             k=self.k,
             weight=self.weight,
             ncomponents=self.ncomponents)
+
+    def move(self,
+             fracpos_ac: Array2D,
+             atomdist: AtomDistribution) -> None:
+        ...
+
+    def force_contribution(self, potential: Potential, F_av: Array2D):
+        from gpaw.new.lcao.forces import add_force_contributions
+        add_force_contributions(self, potential, F_av)
+        return F_av
```

### Comparing `gpaw-22.8.0/gpaw/new/logger.py` & `gpaw-23.6.0/gpaw/new/logger.py`

 * *Files 15% similar despite different names*

```diff
@@ -15,21 +15,21 @@
                  filename: str | Path | IO[str] | None = '-',
                  comm: MPIComm = None):
         comm = comm or world
 
         self.fd: IO[str]
 
         if comm.rank > 0 or filename is None:
-            self.fd = open(os.devnull, 'w')
+            self.fd = open(os.devnull, 'w', encoding='utf-8')
             self.close_fd = True
         elif filename == '-':
             self.fd = sys.stdout
             self.close_fd = False
         elif isinstance(filename, (str, Path)):
-            self.fd = open(filename, 'w')
+            self.fd = open(filename, 'w', encoding='utf-8')
             self.close_fd = True
         else:
             self.fd = filename
             self.close_fd = False
 
         self.indentation = ''
```

### Comparing `gpaw-22.8.0/gpaw/new/poisson.py` & `gpaw-23.6.0/gpaw/new/poisson.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/new/pot_calc.py` & `gpaw-23.6.0/gpaw/new/pot_calc.py`

 * *Files 20% similar despite different names*

```diff
@@ -12,22 +12,26 @@
 
 from __future__ import annotations
 
 from collections import defaultdict
 from typing import DefaultDict
 
 import numpy as np
+from gpaw.core.arrays import DistributedArrays
+from gpaw.core.atom_arrays import AtomArrays
 from gpaw.core.uniform_grid import UniformGridFunctions
+from gpaw.new import zip
 from gpaw.new.potential import Potential
 from gpaw.new.xc import XCFunctional
 from gpaw.setup import Setup
 from gpaw.spinorbit import soc as soc_terms
 from gpaw.typing import Array1D, Array2D, Array3D
 from gpaw.utilities import pack, pack2, unpack
 from gpaw.yml import indent
+from gpaw.mpi import serial_comm
 
 
 class PotentialCalculator:
     def __init__(self,
                  xc: XCFunctional,
                  poisson_solver,
                  setups: list[Setup],
@@ -41,61 +45,89 @@
         self.fracpos_ac = fracpos_ac
         self.soc = soc
 
     def __str__(self):
         return (f'{self.poisson_solver}\n'
                 f'xc functional:\n{indent(self.xc)}\n')
 
-    def calculate(self, density, vHt_x=None):
-        energies, vt_sR, vHt_x = self._calculate(density, vHt_x)
+    def calculate_pseudo_potential(self,
+                                   density,
+                                   vHt_x: DistributedArrays | None
+                                   ) -> tuple[dict[str, float],
+                                              UniformGridFunctions,
+                                              DistributedArrays]:
+        raise NotImplementedError
+
+    def calculate_charges(self, vHt_x):
+        raise NotImplementedError
+
+    def calculate(self,
+                  density,
+                  vHt_x: DistributedArrays | None = None,
+                  kpt_comm=serial_comm
+                  ) -> tuple[Potential, DistributedArrays, AtomArrays]:
+        energies, vt_sR, vHt_x = self.calculate_pseudo_potential(
+            density, vHt_x)
 
         Q_aL = self.calculate_charges(vHt_x)
         dH_asii, corrections = calculate_non_local_potential(
-            self.setups, density, self.xc, Q_aL, self.soc)
+            self.setups, density, self.xc, Q_aL, self.soc, kpt_comm)
 
         for key, e in corrections.items():
-            # print(f'{key:10} {e:15.9f} {energies[key]:15.9f}')
+            # print(f'{key:10} {energies[key]:15.9f} {e:15.9f}')
             energies[key] += e
 
         return Potential(vt_sR, dH_asii, energies), vHt_x, Q_aL
 
-    def move(self, fracpos_ac, atomdist, ndensities):
+    def move(self, fracpos_ac, atomdist, ndensities) -> UniformGridFunctions:
+        """Move things and return change in pseudo core density."""
         delta_nct_R = self.nct_R.new()
-        delta_nct_R.data = -self.nct_R.data
+        delta_nct_R.data[:] = self.nct_R.data
+        delta_nct_R.data *= -1
         self._move(fracpos_ac, atomdist, ndensities)
         delta_nct_R.data += self.nct_R.data
         return delta_nct_R
 
+    def _move(self, fracpos_ac, atomdist, ndensities) -> None:
+        raise NotImplementedError
+
 
 def calculate_non_local_potential(setups,
                                   density,
                                   xc,
                                   Q_aL,
-                                  soc: bool):
+                                  soc: bool,
+                                  comm) -> tuple[AtomArrays,
+                                                 dict[str, float]]:
     dtype = float if density.ncomponents < 4 else complex
-    dH_asii = density.D_asii.layout.new(dtype=dtype).empty(density.ncomponents)
+    D_asii = density.D_asii.to_xp(np)
+    dH_asii = D_asii.layout.new(dtype=dtype).empty(density.ncomponents)
+    Q_aL = Q_aL.to_xp(np)
     energy_corrections: DefaultDict[str, float] = defaultdict(float)
-    for a, D_sii in density.D_asii.items():
+    for a, D_sii in D_asii.items():
+        if a % comm.size != comm.rank:
+            dH_asii[a][:] = 0.0
+            continue
         Q_L = Q_aL[a]
         setup = setups[a]
         dH_sii, corrections = calculate_non_local_potential1(
             setup, xc, D_sii, Q_L, soc)
         dH_asii[a][:] = dH_sii
         for key, e in corrections.items():
             energy_corrections[key] += e
 
+    comm.sum(dH_asii.data)
     # Sum over domain:
-    names = ['kinetic',
-             'coulomb',
-             'zero',
-             'xc',
-             'external']
+    names = ['kinetic', 'coulomb', 'zero', 'xc', 'external']
     energies = np.array([energy_corrections[name] for name in names])
     density.D_asii.layout.atomdist.comm.sum(energies)
-    return dH_asii, {name: e for name, e in zip(names, energies)}
+    comm.sum(energies)
+
+    return (dH_asii.to_xp(density.D_asii.layout.xp),
+            {name: e for name, e in zip(names, energies)})
 
 
 def calculate_non_local_potential1(setup: Setup,
                                    xc: XCFunctional,
                                    D_sii: Array3D,
                                    Q_L: Array1D,
                                    soc: bool) -> tuple[Array3D,
```

### Comparing `gpaw-22.8.0/gpaw/new/potential.py` & `gpaw-23.6.0/gpaw/new/potential.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,19 +1,19 @@
 from __future__ import annotations
 
 import numpy as np
 from ase.units import Ha
-from gpaw.core.arrays import DistributedArrays
+from gpaw.core.uniform_grid import UniformGridFunctions
 from gpaw.core.atom_arrays import AtomArrays
 from gpaw.new import zip
 
 
 class Potential:
     def __init__(self,
-                 vt_sR: DistributedArrays,
+                 vt_sR: UniformGridFunctions,
                  dH_asii: AtomArrays,
                  energies: dict[str, float]):
         self.vt_sR = vt_sR
         self.dH_asii = dH_asii
         self.energies = energies
 
     def __repr__(self):
@@ -21,34 +21,43 @@
 
     def __str__(self) -> str:
         return (f'potential:\n'
                 f'  grid points: {self.vt_sR.desc.size}\n')
 
     def dH(self, P_ani, out_ani, spin):
         if len(P_ani.dims) == 1:  # collinear wave functions
-            for (a, P_ni), out_ni in zip(P_ani.items(), out_ani.values()):
-                dH_ii = self.dH_asii[a][spin]
-                np.einsum('ni, ij -> nj', P_ni, dH_ii, out=out_ni)
-            return out_ani
+            xp = P_ani.layout.xp
+            if xp is np:
+                for (a, P_ni), out_ni in zip(P_ani.items(), out_ani.values()):
+                    dH_ii = self.dH_asii[a][spin]
+                    np.einsum('ni, ij -> nj', P_ni, dH_ii, out=out_ni)
+            else:
+                for (a, P_ni), out_ni in zip(P_ani.items(), out_ani.values()):
+                    dH_ii = xp.asarray(self.dH_asii[a][spin])
+                    out_ni[:] = xp.einsum('ni, ij -> nj', P_ni, dH_ii)
+            return  # out_ani.to_xp(to_xp)
 
         # Non-collinear wave functions:
         P_ansi = P_ani
         out_ansi = out_ani
 
         for (a, P_nsi), out_nsi in zip(P_ansi.items(), out_ansi.values()):
             v_ii, x_ii, y_ii, z_ii = (dh_ii.T for dh_ii in self.dH_asii[a])
             assert v_ii.dtype == complex
             out_nsi[:, 0] = (P_nsi[:, 0] @ (v_ii + z_ii) +
                              P_nsi[:, 1] @ (x_ii - 1j * y_ii))
             out_nsi[:, 1] = (P_nsi[:, 1] @ (v_ii - z_ii) +
                              P_nsi[:, 0] @ (x_ii + 1j * y_ii))
         return out_ansi
 
-    def write(self, writer):
-        dH_asp = self.dH_asii.to_lower_triangle().gather()
-        vt_sR = self.vt_sR.gather()
+    def _write_gpw(self, writer, ibzwfs):
+        from gpaw.new.calculation import combine_energies
+        energies = combine_energies(self, ibzwfs)
+        energies['band'] = ibzwfs.energies['band']
+        dH_asp = self.dH_asii.to_cpu().to_lower_triangle().gather()
+        vt_sR = self.vt_sR.to_xp(np).gather()
         if dH_asp is None:
             return
         writer.write(
             potential=vt_sR.data * Ha,
             atomic_hamiltonian_matrices=dH_asp.data * Ha,
-            energies={name: val * Ha for name, val in self.energies.items()})
+            **{f'e_{name}': val * Ha for name, val in energies.items()})
```

### Comparing `gpaw-22.8.0/gpaw/new/pw/builder.py` & `gpaw-23.6.0/gpaw/new/pw/builder.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,20 +1,22 @@
 from math import pi
+
 from ase.units import Ha
 from gpaw.core import PlaneWaves, UniformGrid
+from gpaw.core.domain import Domain
 from gpaw.core.matrix import Matrix
 from gpaw.core.plane_waves import PlaneWaveExpansions
+from gpaw.new import zip
 from gpaw.new.builder import create_uniform_grid
 from gpaw.new.pw.hamiltonian import PWHamiltonian, SpinorPWHamiltonian
-from gpaw.new.pw.poisson import ReciprocalSpacePoissonSolver
+from gpaw.new.pw.poisson import make_poisson_solver
 from gpaw.new.pw.pot_calc import PlaneWavePotentialCalculator
 from gpaw.new.pwfd.builder import PWFDDFTComponentsBuilder
 from gpaw.new.spinors import SpinorWaveFunctionDescriptor
 from gpaw.typing import Array1D
-from gpaw.core.domain import Domain
 
 
 class PWDFTComponentsBuilder(PWFDDFTComponentsBuilder):
     interpolation = 'fft'
 
     def __init__(self, atoms, params, ecut=340, qspiral=None):
         self.ecut = ecut / Ha
@@ -55,40 +57,45 @@
 
     def get_pseudo_core_densities(self):
         if self._nct_ag is None:
             pw = PlaneWaves(ecut=2 * self.ecut,
                             cell=self.grid.cell,
                             comm=self.grid.comm)
             self._nct_ag = self.setups.create_pseudo_core_densities(
-                pw, self.fracpos_ac, self.atomdist)
+                pw, self.fracpos_ac, self.atomdist, xp=self.xp)
         return self._nct_ag
 
-    def create_poisson_solver(self, fine_grid_pw, params):
-        return ReciprocalSpacePoissonSolver(fine_grid_pw)
+    def create_poisson_solver(self, fine_pw, params):
+        return make_poisson_solver(fine_pw,
+                                   self.fine_grid,
+                                   self.atoms.pbc,
+                                   self.params.charge,
+                                   **params)
 
     def create_potential_calculator(self):
         nct_ag = self.get_pseudo_core_densities()
         pw = nct_ag.pw
         fine_pw = pw.new(ecut=8 * self.ecut)
         poisson_solver = self.create_poisson_solver(
             fine_pw,
-            self.params.poissonsolver)
+            self.params.poissonsolver or {'strength': 1.0})
         return PlaneWavePotentialCalculator(self.grid,
                                             self.fine_grid,
                                             pw,
                                             fine_pw,
                                             self.setups,
                                             self.xc,
                                             poisson_solver,
                                             nct_ag, self.nct_R,
-                                            self.soc)
+                                            self.soc,
+                                            self.xp)
 
     def create_hamiltonian_operator(self, blocksize=10):
         if self.ncomponents < 4:
-            return PWHamiltonian()
+            return PWHamiltonian(self.grid, self.wf_desc, self.xp)
         return SpinorPWHamiltonian()
 
     def convert_wave_functions_from_uniform_grid(self,
                                                  C_nM: Matrix,
                                                  basis_set,
                                                  kpt_c,
                                                  q):
@@ -119,15 +126,15 @@
             for psit_sG, C_sM in zip(psit_nG, C_nsM):
                 psit_sR.data[:] = 0.0
                 basis_set.lcao_to_grid(C_sM, psit_sR.data, q)
                 psit_sR.data *= emikr_R
                 for psit_G, psit_R in zip(psit_sG, psit_sR):
                     psit_R.fft(out=psit_G)
 
-        return psit_nG
+        return psit_nG.to_xp(self.xp)
 
     def read_ibz_wave_functions(self, reader):
         ibzwfs = super().read_ibz_wave_functions(reader)
 
         if 'coefficients' not in reader.wave_functions:
             return ibzwfs
```

### Comparing `gpaw-22.8.0/gpaw/new/pw/fulldiag.py` & `gpaw-23.6.0/gpaw/new/pw/fulldiag.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/new/pw/hamiltonian.py` & `gpaw-23.6.0/gpaw/new/pw/hamiltonian.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,41 +1,101 @@
+from typing import Callable
+
 import _gpaw
 import numpy as np
-from gpaw.new.hamiltonian import Hamiltonian
-from gpaw.core.uniform_grid import UniformGridFunctions
 from gpaw.core.plane_waves import PlaneWaveExpansions
+from gpaw.core.uniform_grid import UniformGridFunctions
+from gpaw.gpu import cupy as cp
+from gpaw.new import zip
+from gpaw.new.hamiltonian import Hamiltonian
 
 
 class PWHamiltonian(Hamiltonian):
+    def __init__(self, grid, pw, xp):
+        self.plan = grid.new(dtype=pw.dtype).fft_plans(xp=xp)
+        self.pw_cache = {}
+
     def apply(self,
               vt_sR: UniformGridFunctions,
               psit_nG: PlaneWaveExpansions,
               out: PlaneWaveExpansions,
-              spin: int):
+              spin: int) -> PlaneWaveExpansions:
         out_nG = out
-        vt_R = vt_sR.data[spin]
-        np.multiply(psit_nG.desc.ekin_G, psit_nG.data, out_nG.data)
-        grid = vt_sR.desc
-        if psit_nG.desc.dtype == complex:
-            grid = grid.new(dtype=complex)
-        f_R = grid.empty()
-        for p_G, o_G in zip(psit_nG, out_nG):
-            f_R = p_G.ifft(out=f_R)
-            f_R.data *= vt_R
-            o_G.data += f_R.fft(pw=p_G.desc).data
+        vt_R = vt_sR[spin].gather(broadcast=True)
+        xp = psit_nG.xp
+        grid = vt_R.desc.new(comm=None, dtype=psit_nG.desc.dtype)
+        tmp_R = grid.empty(xp=xp)
+        pw = psit_nG.desc
+        if pw.comm.size == 1:
+            pw_local = pw
+        else:
+            key = tuple(pw.kpt_c)
+            pw_local = self.pw_cache.get(key)
+            if pw_local is None:
+                pw_local = pw.new(comm=None)
+                self.pw_cache[key] = pw_local
+        psit_G = pw_local.empty(xp=xp)
+        e_kin_G = xp.asarray(psit_G.desc.ekin_G)
+        domain_comm = psit_nG.desc.comm
+        mynbands = psit_nG.mydims[0]
+        for n1 in range(0, mynbands, domain_comm.size):
+            n2 = min(n1 + domain_comm.size, mynbands)
+            psit_nG[n1:n2].gather_all(psit_G)
+            psit_G.ifft(out=tmp_R)
+            tmp_R.data *= vt_R.data
+            vtpsit_G = tmp_R.fft(pw=psit_G.desc)
+            psit_G.data *= e_kin_G
+            vtpsit_G.data += psit_G.data
+            out_nG[n1:n2].scatter_from_all(vtpsit_G)
         return out_nG
 
-    def create_preconditioner(self, blocksize):
+    def create_preconditioner(self,
+                              blocksize: int
+                              ) -> Callable[[PlaneWaveExpansions,
+                                             PlaneWaveExpansions,
+                                             PlaneWaveExpansions], None]:
         return precondition
 
 
-def precondition(psit, residuals, out):
-    G2 = psit.desc.ekin_G * 2
-    for r, o, ekin in zip(residuals.data, out.data, psit.norm2('kinetic')):
-        _gpaw.pw_precond(G2, r, ekin, o)
+def precondition(psit_nG: PlaneWaveExpansions,
+                 residual_nG: PlaneWaveExpansions,
+                 out: PlaneWaveExpansions) -> None:
+    """Preconditioner for KS equation.
+
+    From:
+
+      Teter, Payne and Allen, Phys. Rev. B 40, 12255 (1989)
+
+    as modified by:
+
+      Kresse and Furthmüller, Phys. Rev. B 54, 11169 (1996)
+    """
+
+    xp = psit_nG.xp
+    G2_G = xp.asarray(psit_nG.desc.ekin_G * 2)
+    ekin_n = psit_nG.norm2('kinetic')
+
+    if xp is np:
+        for r_G, o_G, ekin in zip(residual_nG.data,
+                                  out.data,
+                                  ekin_n):
+            _gpaw.pw_precond(G2_G, r_G, ekin, o_G)
+        return
+
+    out.data[:] = gpu_prec(ekin_n[:, np.newaxis],
+                           G2_G[np.newaxis],
+                           residual_nG.data)
+
+
+@cp.fuse()
+def gpu_prec(ekin, G2, residual):
+    x = 1 / ekin / 3 * G2
+    a = 27.0 + x * (18.0 + x * (12.0 + x * 8.0))
+    xx = x * x
+    return -4.0 / 3 / ekin * a / (a + 16.0 * xx * xx) * residual
 
 
 def spinor_precondition(psit_nsG, residual_nsG, out):
     G2_G = psit_nsG.desc.ekin_G * 2
     for r_sG, o_sG, ekin in zip(residual_nsG.data,
                                 out.data,
                                 psit_nsG.norm2('kinetic').sum(1)):
@@ -76,34 +136,7 @@
             g_R.data = a * (x + iy) + b * (v - z)
             o_sG.data[1] += g_R.fft(pw=pw).data
 
         return out_nsG
 
     def create_preconditioner(self, blocksize):
         return spinor_precondition
-
-
-"""
-        N = len(psit_xG)
-        S = self.gd.comm.size
-
-        vt_R = self.gd.collect(ham.vt_sG[kpt.s], broadcast=True)
-        Q_G = self.pd.Q_qG[kpt.q]
-        T_G = 0.5 * self.pd.G2_qG[kpt.q]
-
-        for n1 in range(0, N, S):
-            n2 = min(n1 + S, N)
-            psit_G = self.pd.alltoall1(psit_xG[n1:n2], kpt.q)
-            with self.timer('HMM T'):
-                np.multiply(T_G, psit_xG[n1:n2], Htpsit_xG[n1:n2])
-            if psit_G is not None:
-                psit_R = self.pd.ifft(psit_G, kpt.q, local=True, safe=False)
-                psit_R *= vt_R
-                self.pd.fftplan.execute()
-                vtpsit_G = self.pd.tmp_Q.ravel()[Q_G]
-            else:
-                vtpsit_G = self.pd.tmp_G
-            self.pd.alltoall2(vtpsit_G, kpt.q, Htpsit_xG[n1:n2])
-
-        ham.xc.apply_orbital_dependent_hamiltonian(
-            kpt, psit_xG, Htpsit_xG, ham.dH_asp)
-"""
```

#### encoding

```diff
@@ -1 +1 @@
-us-ascii
+utf-8
```

### Comparing `gpaw-22.8.0/gpaw/new/pw/poisson.py` & `gpaw-23.6.0/gpaw/pw/poisson.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,53 +1,64 @@
 from math import pi
-from gpaw.new.poisson import PoissonSolver
-from gpaw.core import PlaneWaves
 
+import numpy as np
+from ase.utils import seterr
+from scipy.special import erf
 
-class ReciprocalSpacePoissonSolver(PoissonSolver):
+from gpaw.pw.density import ReciprocalSpaceDensity
+from gpaw.pw.descriptor import PWDescriptor
+from gpaw.typing import Array1D
+
+
+class ReciprocalSpacePoissonSolver:
     def __init__(self,
-                 pw: PlaneWaves,
-                 charge: float = 0.0):
-        self.pw = pw
+                 pd: PWDescriptor,
+                 charge: float = 0.0,
+                 strength: float = 1.0):
+        self.pd = pd
         self.charge = charge
+        self.strength = strength
 
-        self.ekin_g = pw.ekin_G.copy()
-        if pw.comm.rank == 0:
+        self.G2_q = pd.G2_qG[0].copy()
+        if pd.gd.comm.rank == 0:
             # Avoid division by zero:
-            self.ekin_g[0] = 1.0
+            self.G2_q[0] = 1.0
 
     def __str__(self):
-        return f'# Uniform background charge: {self.charge:.3f} electrons'
+        return f'Uniform background charge: {self.charge:.3f} electrons'
+
+    def estimate_memory(self, mem):
+        pass
 
     def solve(self,
-              vHt_g,
-              rhot_g) -> float:
+              vHt_q: Array1D,
+              dens: ReciprocalSpaceDensity) -> float:
         """Solve Poisson equeation.
 
         Places result in vHt_q ndarray.
         """
-        epot = self._solve(vHt_g, rhot_g)
+        assert dens.rhot_q is not None
+        epot = self._solve(vHt_q, dens.rhot_q)
         return epot
 
     def _solve(self,
-               vHt_g,
-               rhot_g) -> float:
-        vHt_g.data[:] = 2 * pi * rhot_g.data
-        if self.pw.comm.rank == 0:
+               vHt_q: Array1D,
+               rhot_q: Array1D) -> float:
+        vHt_q[:] = 4 * pi * self.strength * rhot_q
+        if self.pd.gd.comm.rank == 0:
             # Use uniform backgroud charge in case we have a charged system:
-            vHt_g.data[0] = 0.0
-        vHt_g.data /= self.ekin_g
-        epot = 0.5 * vHt_g.integrate(rhot_g)
+            vHt_q[0] = 0.0
+        vHt_q /= self.G2_q
+        epot = 0.5 * self.pd.integrate(vHt_q, rhot_q)
         return epot
 
 
-'''
 class ChargedReciprocalSpacePoissonSolver(ReciprocalSpacePoissonSolver):
     def __init__(self,
-                 pw: PlaneWaves,
+                 pd: PWDescriptor,
                  charge: float,
                  alpha: float = None,
                  eps: float = 1e-5):
         """Reciprocal-space Poisson solver for charged molecules.
 
         * Add a compensating Guassian-shaped charge to the density
           in order to make the total charge neutral (placed in the
@@ -108,8 +119,7 @@
         vHt_q[:] = 4 * pi * neutral_q
         vHt_q /= self.G2_q
         epot = 0.5 * self.pd.integrate(vHt_q, neutral_q)
         epot -= self.pd.integrate(self.potential_q, rhot_q)
         epot -= self.charge**2 * (self.alpha / 2 / pi)**0.5
         vHt_q -= self.potential_q
         return epot
-'''
```

### Comparing `gpaw-22.8.0/gpaw/new/pwfd/builder.py` & `gpaw-23.6.0/gpaw/new/pwfd/builder.py`

 * *Files 25% similar despite different names*

```diff
@@ -1,46 +1,44 @@
 from types import SimpleNamespace
 
 import numpy as np
 
-from gpaw.band_descriptor import BandDescriptor
-from gpaw.kohnsham_layouts import get_KohnSham_layouts
-from gpaw.lcao.eigensolver import DirectLCAO
 from gpaw.new.builder import DFTComponentsBuilder
 from gpaw.new.calculation import DFTState
 from gpaw.new.ibzwfs import create_ibz_wave_functions as create_ibzwfs
 from gpaw.new.lcao.eigensolver import LCAOEigensolver
 from gpaw.new.lcao.hamiltonian import LCAOHamiltonian
-from gpaw.new.potential import Potential
 from gpaw.new.pwfd.davidson import Davidson
 from gpaw.new.pwfd.wave_functions import PWFDWaveFunctions
-from gpaw.wavefunctions.lcao import LCAOWaveFunctions
 
 
 class PWFDDFTComponentsBuilder(DFTComponentsBuilder):
     def create_eigensolver(self, hamiltonian):
-        eigsolv_params = self.params.eigensolver
+        eigsolv_params = self.params.eigensolver.copy()
         name = eigsolv_params.pop('name', 'dav')
         assert name == 'dav'
-        return Davidson(self.nbands,
-                        self.wf_desc,
-                        self.communicators['b'],
-                        hamiltonian.create_preconditioner,
-                        **eigsolv_params)
+        return Davidson(
+            self.nbands,
+            self.wf_desc,
+            self.communicators['b'],
+            hamiltonian.create_preconditioner,
+            converge_bands=self.params.convergence.get('bands', 'occupied'),
+            **eigsolv_params)
 
     def read_ibz_wave_functions(self, reader):
         kpt_comm, band_comm, domain_comm = (self.communicators[x]
                                             for x in 'kbd')
 
         def create_wfs(spin: int, q: int, k: int, kpt_c, weight: float):
             psit_nG = SimpleNamespace(
                 comm=domain_comm,
                 dims=(self.nbands,),
                 desc=self.wf_desc.new(kpt=kpt_c),
-                data=None)
+                data=None,
+                xp=np)
             wfs = PWFDWaveFunctions(
                 spin=spin,
                 q=q,
                 k=k,
                 weight=weight,
                 psit_nX=psit_nG,  # type: ignore
                 setups=self.setups,
@@ -57,41 +55,22 @@
                                self.communicators['k'])
 
         # Set eigenvalues, occupations, etc..
         self.read_wavefunction_values(reader, ibzwfs)
 
         return ibzwfs
 
-    def create_ibz_wave_functions(self, basis, potential):
+    def create_ibz_wave_functions(self, basis, potential, *, log):
         from gpaw.new.lcao.builder import create_lcao_ibzwfs
 
         if self.params.random:
-            self.log('Initializing wave functions with random numbers')
-            raise NotImplementedError
+            return self.create_random_ibz_wave_functions(log)
 
-        sl_default = self.params.parallel['sl_default']
-        sl_lcao = self.params.parallel['sl_lcao'] or sl_default
-
-        if 0:
-            return initialize_from_lcao_old(
-                self.setups,
-                self.communicators,
-                self.nbands,
-                self.ncomponents,
-                self.nelectrons,
-                self.fracpos_ac,
-                self.atomdist,
-                self.dtype,
-                self.grid,
-                self.wf_desc,
-                self.ibz,
-                sl_lcao,
-                basis,
-                potential,
-                self.convert_wave_functions_from_uniform_grid)
+        # sl_default = self.params.parallel['sl_default']
+        # sl_lcao = self.params.parallel['sl_lcao'] or sl_default
 
         lcao_ibzwfs, _ = create_lcao_ibzwfs(
             basis, potential,
             self.ibz, self.communicators, self.setups,
             self.fracpos_ac, self.grid, self.dtype,
             self.nbands, self.ncomponents, self.atomdist, self.nelectrons)
 
@@ -125,89 +104,36 @@
                 ncomponents=self.ncomponents)
             wfs._eig_n = eig_n
             return wfs
 
         return create_ibzwfs(self.ibz, self.nelectrons, self.ncomponents,
                              create_wfs, self.communicators['k'])
 
+    def create_random_ibz_wave_functions(self, log):
+        log('Initializing wave functions with random numbers')
 
-def initialize_from_lcao_old(setups,
-                             communicators,
-                             nbands,
-                             ncomponents,
-                             nelectrons,
-                             fracpos_ac,
-                             atomdist,
-                             dtype,
-                             grid,
-                             wf_desc,
-                             ibz,
-                             sl_lcao,
-                             basis_set,
-                             potential: Potential,
-                             convert_wfs):
-    from gpaw.utilities import pack2
-    from gpaw.utilities.partition import AtomPartition
-    from gpaw.utilities.timing import nulltimer
-
-    (band_comm, domain_comm, kpt_comm, world,
-     domainband_comm, kptband_comm) = (communicators[x] for x in 'bdkwKD')
-
-    lcaonbands = min(nbands, setups.nao)
-    gd = grid._gd
-    nspins = ncomponents % 3
-
-    lcaobd = BandDescriptor(lcaonbands, band_comm)
-    lcaoksl = get_KohnSham_layouts(sl_lcao, 'lcao',
-                                   gd, lcaobd, domainband_comm,
-                                   dtype, nao=setups.nao)
-
-    atom_partition = AtomPartition(domain_comm, atomdist.rank_a)
-
-    lcaowfs = LCAOWaveFunctions(lcaoksl, gd, nelectrons,
-                                setups, lcaobd, dtype,
-                                world, basis_set.kd, kptband_comm,
-                                nulltimer)
-    lcaowfs.basis_functions = basis_set
-    lcaowfs.set_positions(fracpos_ac, atom_partition)
-
-    if ncomponents != 4:
-        eigensolver = DirectLCAO()
-    else:
-        from gpaw.xc.noncollinear import NonCollinearLCAOEigensolver
-        eigensolver = NonCollinearLCAOEigensolver()
-
-    eigensolver.initialize(gd, dtype, setups.nao, lcaoksl)
-
-    dH_asp = setups.empty_atomic_matrix(ncomponents,
-                                        atom_partition,
-                                        dtype=dtype)
-    for a, dH_sii in potential.dH_asii.items():
-        dH_asp[a][:] = [pack2(dH_ii) for dH_ii in dH_sii]
-    ham = SimpleNamespace(vt_sG=potential.vt_sR.data,
-                          dH_asp=dH_asp)
-    eigensolver.iterate(ham, lcaowfs)
-
-    def create_wfs(spin, q, k, kpt_c, weight):
-        u = spin + nspins * q
-        lcaokpt = lcaowfs.kpt_u[u]
-        assert lcaokpt.s == spin
-        mynbands = len(lcaokpt.C_nM)
-        assert mynbands == lcaonbands
-
-        # Convert to PW-coefs in PW-mode:
-        psit_nX = convert_wfs(lcaokpt.C_nM, basis_set, kpt_c, q)
-
-        if lcaonbands < nbands:
-            psit_nX[lcaonbands:].randomize()
-
-        return PWFDWaveFunctions(psit_nX=psit_nX,
-                                 spin=spin,
-                                 q=q,
-                                 k=k,
-                                 weight=weight,
-                                 setups=setups,
-                                 fracpos_ac=fracpos_ac,
-                                 atomdist=atomdist,
-                                 ncomponents=ncomponents)
+        def create_wfs(spin, q, k, kpt_c, weight):
+            desc = self.wf_desc.new(kpt=kpt_c)
+            psit_nX = desc.empty(
+                dims=(self.nbands,),
+                comm=self.communicators['b'],
+                xp=self.xp)
+            psit_nX.randomize()
 
-    return create_ibzwfs(ibz, nelectrons, ncomponents, create_wfs, kpt_comm)
+            wfs = PWFDWaveFunctions(
+                psit_nX=psit_nX,
+                spin=spin,
+                q=q,
+                k=k,
+                weight=weight,
+                setups=self.setups,
+                fracpos_ac=self.fracpos_ac,
+                atomdist=self.atomdist,
+                ncomponents=self.ncomponents)
+
+            eig_n = self.xp.empty(self.nbands)
+            eig_n[:] = np.inf
+            wfs._eig_n = eig_n
+            return wfs
+
+        return create_ibzwfs(self.ibz, self.nelectrons, self.ncomponents,
+                             create_wfs, self.communicators['k'])
```

### Comparing `gpaw-22.8.0/gpaw/new/pwfd/davidson.py` & `gpaw-23.6.0/gpaw/new/pwfd/davidson.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,104 +1,125 @@
 from __future__ import annotations
 
 from functools import partial
 from typing import Callable
 
 import numpy as np
-from gpaw import debug
+from ase.units import Ha
 from gpaw.core.arrays import DistributedArrays as DA
 from gpaw.core.atom_centered_functions import AtomArrays as AA
 from gpaw.core.matrix import Matrix
+from gpaw.gpu import as_xp
+from gpaw.mpi import broadcast_float
+from gpaw.new import zip
 from gpaw.new.calculation import DFTState
 from gpaw.new.eigensolver import Eigensolver
 from gpaw.new.hamiltonian import Hamiltonian
+from gpaw.new.ibzwfs import IBZWaveFunctions
 from gpaw.new.pwfd.wave_functions import PWFDWaveFunctions
 from gpaw.typing import Array1D, Array2D
 from gpaw.utilities.blas import axpy
 from gpaw.yml import obj2yaml as o2y
-from scipy.linalg import eigh
 
 AAFunc = Callable[[AA, AA], AA]
 
 
 class Davidson(Eigensolver):
     def __init__(self,
-                 nbands,
+                 nbands: int,
                  wf_grid,
                  band_comm,
                  preconditioner_factory,
                  niter=2,
                  blocksize=10,
                  converge_bands='occupied',
                  scalapack_parameters=None):
         self.niter = niter
         self.converge_bands = converge_bands
 
-        B = nbands
-        domain_comm = wf_grid.comm
-        if domain_comm.rank == 0 and band_comm.rank == 0:
-            self.H_NN = Matrix(2 * B, 2 * B, wf_grid.dtype)
-            self.S_NN = Matrix(2 * B, 2 * B, wf_grid.dtype)
-        else:
-            self.H_NN = self.S_NN = EmptyMatrix()
-
-        self.M_nn = Matrix(B, B, wf_grid.dtype,
-                           dist=(band_comm, band_comm.size))
-
+        self.H_NN = None
+        self.S_NN = None
+        self.M_nn = None
         self.work_arrays: np.ndarray | None = None
 
         self.preconditioner = preconditioner_factory(blocksize)
 
     def __str__(self):
         return o2y(dict(name='Davidson',
                         niter=self.niter,
                         converge_bands=self.converge_bands))
 
+    def _initialize(self, ibzwfs):
+        # First time: allocate work-arrays
+        wfs = ibzwfs.wfs_qs[0][0]
+        assert isinstance(wfs, PWFDWaveFunctions)
+        xp = wfs.psit_nX.xp
+        B = ibzwfs.nbands
+        domain_comm = wfs.psit_nX.desc.comm
+        band_comm = wfs.band_comm
+        shape = ibzwfs.get_max_shape()
+        shape = (2, B) + shape
+        dtype = wfs.psit_nX.data.dtype
+        self.work_arrays = xp.empty(shape, dtype)
+
+        dtype = wfs.psit_nX.desc.dtype
+        if domain_comm.rank == 0 and band_comm.rank == 0:
+            self.H_NN = Matrix(2 * B, 2 * B, dtype, xp=xp)
+            self.S_NN = Matrix(2 * B, 2 * B, dtype, xp=xp)
+        else:
+            self.H_NN = self.S_NN = Matrix(0, 0)
+
+        self.M_nn = Matrix(B, B, dtype,
+                           dist=(band_comm, band_comm.size),
+                           xp=xp)
+
     def iterate(self, state: DFTState, hamiltonian: Hamiltonian) -> float:
         """Iterate on state given fixed hamiltonian.
 
         Returns
         -------
         float:
             Weighted error of residuals:::
 
                    ~     ~ ~
               R = (H - ε S)ψ
                n        n   n
         """
+
         if self.work_arrays is None:
-            # First time: allocate work-arrays
-            shape = state.ibzwfs.get_max_shape()
-            shape = (2, state.ibzwfs.nbands) + shape
-            wfs = state.ibzwfs.wfs_qs[0][0]
-            assert isinstance(wfs, PWFDWaveFunctions)
-            dtype = wfs.psit_nX.data.dtype
-            self.work_arrays = np.empty(shape, dtype)
+            self._initialize(state.ibzwfs)
+
+        assert self.M_nn is not None
 
         dS = state.ibzwfs.wfs_qs[0][0].setups.overlap_correction
         dH = state.potential.dH
         Ht = partial(hamiltonian.apply, state.potential.vt_sR)
         ibzwfs = state.ibzwfs
         error = 0.0
-        for wfs in ibzwfs:
-            e = self.iterate1(wfs, Ht, dH, dS)
+
+        weight_un = calculate_weights(self.converge_bands, ibzwfs)
+
+        for wfs, weight_n in zip(ibzwfs, weight_un):
+            e = self.iterate1(wfs, Ht, dH, dS, weight_n)
             error += wfs.weight * e
-        return ibzwfs.kpt_comm.sum(error) * ibzwfs.spin_degeneracy
+        return ibzwfs.kpt_comm.sum(float(error)) * ibzwfs.spin_degeneracy
 
-    def iterate1(self, wfs, Ht, dH, dS):
+    def iterate1(self, wfs, Ht, dH, dS, weight_n):
         H_NN = self.H_NN
         S_NN = self.S_NN
         M_nn = self.M_nn
 
+        xp = M_nn.xp
+
         psit_nX = wfs.psit_nX
         psit2_nX = psit_nX.new(data=self.work_arrays[0])
         psit3_nX = psit_nX.new(data=self.work_arrays[1])
 
         B = psit_nX.dims[0]  # number of bands
-        eig_N = np.empty(2 * B)
+        eig_N = xp.empty(2 * B)
 
         wfs.subspace_diagonalize(Ht, dH,
                                  work_array=psit2_nX.data,
                                  Htpsit_nX=psit3_nX)
         residual_nX = psit3_nX  # will become (H-e*S)|psit> later
 
         P_ani = wfs.P_ani
@@ -109,15 +130,15 @@
         band_comm = psit_nX.comm
         is_domain_band_master = domain_comm.rank == 0 and band_comm.rank == 0
 
         M0_nn = M_nn
         assert band_comm.size == 1
 
         if domain_comm.rank == 0:
-            eig_N[:B] = wfs.eig_n
+            eig_N[:B] = xp.asarray(wfs.eig_n)
 
         def me(a, b, function=None):
             """Matrix elements"""
             return a.matrix_elements(b,
                                      domain_sum=False,
                                      out=M_nn,
                                      function=function,
@@ -134,19 +155,18 @@
                 M_nn.redist(M0_nn)
                 if band_comm.rank == 0:
                     C_nn[:] = M0_nn.data
 
         for i in range(self.niter):
             if i == self.niter - 1:  # last iteration
                 # Calulate error before we destroy residuals:
-                weight_n = calculate_weights(self.converge_bands, wfs)
                 if weight_n is None:
                     error = np.inf
                 else:
-                    error = weight_n @ residual_nX.norm2()
+                    error = weight_n @ as_xp(residual_nX.norm2(), np)
                     if wfs.ncomponents == 4:
                         error = error.sum()
 
             self.preconditioner(psit_nX, residual_nX, out=psit2_nX)
 
             # Calculate projections
             wfs.pt_aiX.integrate(psit2_nX, out=P2_ani)
@@ -172,41 +192,36 @@
 
             # <psi2 | S | psi>
             me(psit2_nX, psit_nX)
             P3_ani.matrix.multiply(P_ani, opb='C', beta=1.0, out=M_nn)
             copy(S_NN.data[B:, :B])
 
             if is_domain_band_master:
-                H_NN.data[:B, :B] = np.diag(eig_N[:B])
-                S_NN.data[:B, :B] = np.eye(B)
-                if debug:
-                    H_NN.data[np.triu_indices(2 * B, 1)] = 42.0
-                    S_NN.data[np.triu_indices(2 * B, 1)] = 42.0
-
-                eig_N[:], H_NN.data[:] = eigh(H_NN.data, S_NN.data,
-                                              lower=True,
-                                              check_finite=debug,
-                                              overwrite_b=True)
-                wfs._eig_n = eig_N[:B]
+                H_NN.data[:B, :B] = xp.diag(eig_N[:B])
+                S_NN.data[:B, :B] = xp.eye(B)
+                eig_N[:] = H_NN.eigh(S_NN)
+                wfs._eig_n = as_xp(eig_N[:B], np)
             if domain_comm.rank == 0:
                 band_comm.broadcast(wfs.eig_n, 0)
             domain_comm.broadcast(wfs.eig_n, 0)
 
             if domain_comm.rank == 0:
                 if band_comm.rank == 0:
-                    M0_nn.data[:] = H_NN.data[:B, :B]
+                    # M0_nn.data[:] = H_NN.data[:B, :B]
+                    M0_nn.data[:] = H_NN.data[:B, :B].T
                 M0_nn.redist(M_nn)
             domain_comm.broadcast(M_nn.data, 0)
 
             M_nn.multiply(psit_nX, opa='C', out=residual_nX)
             M_nn.multiply(P_ani, opa='C', out=P3_ani)
 
             if domain_comm.rank == 0:
                 if band_comm.rank == 0:
-                    M0_nn.data[:] = H_NN.data[B:, :B]
+                    # M0_nn.data[:] = H_NN.data[B:, :B]
+                    M0_nn.data[:] = H_NN.data[:B, B:].T
                 M0_nn.redist(M_nn)
             domain_comm.broadcast(M_nn.data, 0)
 
             M_nn.multiply(psit2_nX, opa='C', beta=1.0, out=residual_nX)
             M_nn.multiply(P2_ani, opa='C', beta=1.0, out=P3_ani)
             psit_nX.data[:] = residual_nX.data
             P_ani, P3_ani = P3_ani, P_ani
@@ -215,101 +230,111 @@
             if i < self.niter - 1:
                 Ht(psit_nX)
                 calculate_residuals(residual_nX, dH, dS, wfs, P2_ani, P3_ani)
 
         return error
 
 
-def calculate_residuals(residuals_nX: DA,
+def calculate_residuals(residual_nX: DA,
                         dH: AAFunc,
                         dS: AAFunc,
                         wfs: PWFDWaveFunctions,
                         P1_ani: AA,
                         P2_ani: AA) -> None:
-    for r, e, p in zip(residuals_nX.data, wfs.myeig_n, wfs.psit_nX.data):
-        axpy(-e, p, r)
+
+    eig_n = wfs.myeig_n
+    xp = residual_nX.xp
+    if xp is np:
+        for r, e, p in zip(residual_nX.data, wfs.myeig_n, wfs.psit_nX.data):
+            axpy(-e, p, r)
+    else:
+        eig_n = xp.asarray(eig_n)
+        for r, e, p in zip(residual_nX.data, eig_n, wfs.psit_nX.data):
+            r -= p * e
 
     dH(wfs.P_ani, P1_ani)
     if wfs.ncomponents < 4:
         subscripts = 'nI, n -> nI'
     else:
         subscripts = 'nsI, n -> nsI'
-    np.einsum(subscripts, wfs.P_ani.data, wfs.myeig_n, out=P2_ani.data)
+    if xp is np:
+        np.einsum(subscripts, wfs.P_ani.data, eig_n, out=P2_ani.data)
+    else:
+        P2_ani.data[:] = xp.einsum(subscripts, wfs.P_ani.data, eig_n)
     dS(P2_ani, P2_ani)
     P1_ani.data -= P2_ani.data
-    wfs.pt_aiX.add_to(residuals_nX, P1_ani)
+    wfs.pt_aiX.add_to(residual_nX, P1_ani)
 
 
 def calculate_weights(converge_bands: int | str,
-                      wfs: PWFDWaveFunctions) -> Array1D | None:
+                      ibzwfs: IBZWaveFunctions) -> list[Array1D | None]:
     """Calculate convergence weights for all eigenstates."""
+    assert ibzwfs.band_comm.size == 1, 'not implemented!'
+    weight_un = []
+    nu = len(ibzwfs.wfs_qs) * ibzwfs.nspins
+    nbands = ibzwfs.nbands
+
     if converge_bands == 'occupied':
         # Converge occupied bands:
-        try:
-            # Methfessel-Paxton distribution can give negative
-            # occupation numbers - so we take the absolute value:
-            return np.abs(wfs.occ_n)
-        except ValueError:
-            # No eigenvalues yet:
-            return None
+        for wfs in ibzwfs:
+            try:
+                # Methfessel-Paxton or cold-smearing distributions can give
+                # negative occupation numbers - so we take the absolute value:
+                weight_n = np.abs(wfs.occ_n)
+            except ValueError:
+                # No eigenvalues yet:
+                return [None] * nu
+            weight_un.append(weight_n)
+        return weight_un
+
+    if converge_bands == 'all':
+        return [np.ones(nbands)] * nu
 
     if isinstance(converge_bands, int):
         # Converge fixed number of bands:
         n = converge_bands
-        if wfs.psit_nX.comm.size > 1:
-            raise NotImplementedError
-
-        nbands = wfs.psit_nX.mydims[0]
-        weight_n = np.zeros(nbands)
-        if n < 0:
-            n += nbands
-        weight_n[:n] = 1.0
-        return weight_n
 
+        for wfs in ibzwfs:
+            weight_n = np.zeros(nbands)
+            if n < 0:
+                n += nbands
+            weight_n[:n] = 1.0
+            weight_un.append(weight_n)
+        return weight_un
+
+    # Converge states with energy up to CBM + delta:
+    assert converge_bands.startswith('CBM+')
+    delta = float(converge_bands[4:]) / Ha
+
+    if ibzwfs.fermi_levels is None:
+        return [None] * nu
+
+    efermi = np.mean(ibzwfs.fermi_levels)
+
+    # Find CBM:
+    cbm = np.inf
+    nocc_u = np.empty(nu, int)
+    for u, wfs in enumerate(ibzwfs):
+        n = (wfs.eig_n < efermi).sum()  # number of occupied bands
+        nocc_u[u] = n
+        if n < nbands:
+            cbm = min(cbm, wfs.eig_n[n])
+
+    # If all k-points don't have the same number of occupied bands,
+    # then it's a metal:
+    n0 = int(broadcast_float(float(nocc_u[0]), ibzwfs.kpt_comm))
+    metal = bool(ibzwfs.kpt_comm.sum_scalar(float((nocc_u != n0).any())))
+    if metal:
+        cbm = efermi
     else:
-        assert False
-        # Converge state with energy up to CBM + delta:
-        assert converge_bands.startswith('CBM+')
-        # delta = float(converge_bands[4:]) / Ha
-        return None
+        cbm = ibzwfs.kpt_comm.min_scalar(cbm)
 
-        """
-        if wfs.kpt_u[0].f_n is None:
-            weight_un[:] = np.inf  # no eigenvalues yet
-        else:
-            # Collect all eigenvalues and calculate band gap:
-            efermi = np.mean(wfs.fermi_levels)
-            eps_skn = np.array(
-                [[wfs.collect_eigenvalues(k, spin) - efermi
-                  for k in range(wfs.kd.nibzkpts)]
-                 for spin in range(wfs.nspins)])
-            if wfs.world.rank > 0:
-                eps_skn = np.empty((wfs.nspins,
-                                    wfs.kd.nibzkpts,
-                                    wfs.bd.nbands))
-            wfs.world.broadcast(eps_skn, 0)
-            try:
-                # Find bandgap + positions of CBM:
-                gap, _, (s, k, n) = _bandgap(eps_skn,
-                                             spin=None, direct=False)
-            except ValueError:
-                gap = 0.0
-
-            if gap == 0.0:
-                cbm = efermi
-            else:
-                cbm = efermi + eps_skn[s, k, n]
-
-            ecut = cbm + delta
-
-            for weight_n, kpt in zip(weight_un, wfs.kpt_u):
-                weight_n[kpt.eps_n < ecut] = kpt.weight
-
-            if (eps_skn[:, :, -1] < ecut - efermi).any():
-                # We don't have enough bands!
-                weight_un[:] = np.inf
-        """
-    return None
+    ecut = cbm + delta
 
+    for wfs in ibzwfs:
+        weight_n = (wfs.eig_n < ecut).astype(float)
+        if wfs.eig_n[-1] < ecut:
+            # We don't have enough bands!
+            weight_n[:] = np.inf
+        weight_un.append(weight_n)
 
-class EmptyMatrix:
-    data = np.empty((0, 0))
+    return weight_un
```

### Comparing `gpaw-22.8.0/gpaw/new/pwfd/wave_functions.py` & `gpaw-23.6.0/gpaw/new/pwfd/wave_functions.py`

 * *Files 14% similar despite different names*

```diff
@@ -7,14 +7,17 @@
 import numpy as np
 from gpaw.core.arrays import DistributedArrays
 from gpaw.core.atom_arrays import AtomArrays, AtomDistribution
 from gpaw.core.atom_centered_functions import AtomCenteredFunctions
 from gpaw.core.plane_waves import PlaneWaveExpansions
 from gpaw.core.uniform_grid import UniformGrid, UniformGridFunctions
 from gpaw.fftw import get_efficient_fft_size
+from gpaw.gpu import as_xp
+from gpaw.new import prod, zip
+from gpaw.new.potential import Potential
 from gpaw.new.wave_functions import WaveFunctions
 from gpaw.setup import Setups
 from gpaw.typing import Array2D, Array3D, ArrayND, Vector
 
 
 class PWFDWaveFunctions(WaveFunctions):
     def __init__(self,
@@ -25,36 +28,43 @@
                  setups: Setups,
                  fracpos_ac: Array2D,
                  atomdist: AtomDistribution,
                  weight: float = 1.0,
                  ncomponents: int = 1):
         assert isinstance(atomdist, AtomDistribution)
         self.psit_nX = psit_nX
+        nbands = psit_nX.dims[0]
         super().__init__(setups=setups,
-                         nbands=psit_nX.dims[0],
+                         nbands=nbands,
                          spin=spin,
                          q=q,
                          k=k,
                          kpt_c=psit_nX.desc.kpt_c,
                          fracpos_ac=fracpos_ac,
                          atomdist=atomdist,
                          weight=weight,
                          ncomponents=ncomponents,
                          dtype=psit_nX.desc.dtype,
                          domain_comm=psit_nX.desc.comm,
                          band_comm=psit_nX.comm)
         self._pt_aiX: Optional[AtomCenteredFunctions] = None
         self.orthonormalized = False
+        self.bytes_per_band = (prod(self.array_shape(global_shape=True)) *
+                               psit_nX.desc.itemsize)
+        self.xp = self.psit_nX.xp
 
     def __del__(self):
         # We could be reading from a gpw-file
         data = self.psit_nX.data
         if hasattr(data, 'fd'):
             data.fd.close()
 
+    def _short_string(self, global_shape: tuple[int]) -> str:
+        return self.psit_nX.desc._short_string(global_shape)
+
     def array_shape(self, global_shape=False):
         if global_shape:
             shape = self.psit_nX.desc.global_shape()
         else:
             shape = self.psit_nX.desc.myshape
         if self.ncomponents == 4:
             shape = (2,) + shape
@@ -62,15 +72,16 @@
 
     @property
     def pt_aiX(self) -> AtomCenteredFunctions:
         if self._pt_aiX is None:
             self._pt_aiX = self.psit_nX.desc.atom_centered_functions(
                 [setup.pt_j for setup in self.setups],
                 self.fracpos_ac,
-                atomdist=self.atomdist)
+                atomdist=self.atomdist,
+                xp=self.psit_nX.xp)
         return self._pt_aiX
 
     @property
     def P_ani(self):
         if self._P_ani is None:
             self._P_ani = self.pt_aiX.empty(self.psit_nX.dims,
                                             self.psit_nX.comm)
@@ -141,15 +152,14 @@
                  n
 
         """
         if self.orthonormalized:
             return
         psit_nX = self.psit_nX
         domain_comm = psit_nX.desc.comm
-
         P_ani = self.P_ani
 
         P2_ani = P_ani.new()
         psit2_nX = psit_nX.new(data=work_array_nX)
 
         dS = self.setups.overlap_correction
 
@@ -172,15 +182,15 @@
         self.orthonormalized = True
 
     def subspace_diagonalize(self,
                              Ht,
                              dH,
                              work_array: ArrayND = None,
                              Htpsit_nX=None,
-                             scalapack_parameters=(None, 1, 1, -1)):
+                             scalapack_parameters=(None, 1, 1, None)):
         """
 
         Ht(in, out):::
 
            ~   ^   ~
            H = T + v
 
@@ -207,15 +217,15 @@
                               out=H, beta=1.0)
         domain_comm.sum(H.data, 0)
 
         if domain_comm.rank == 0:
             slcomm, r, c, b = scalapack_parameters
             if r == c == 1:
                 slcomm = None
-            self._eig_n = H.eigh(scalapack=(slcomm, r, c, b))
+            self._eig_n = as_xp(H.eigh(scalapack=(slcomm, r, c, b)), np)
             H.complex_conjugate()
             # H.data[n, :] now contains the n'th eigenvector and eps_n[n]
             # the n'th eigenvalue
         else:
             self._eig_n = np.empty(psit_nX.dims)
 
         domain_comm.broadcast(H.data, 0)
@@ -224,28 +234,60 @@
             H.multiply(psit2_nX, out=Htpsit_nX)
 
         H.multiply(psit_nX, out=psit2_nX)
         psit_nX.data[:] = psit2_nX.data
         H.multiply(P_ani, out=P2_ani)
         P_ani.data[:] = P2_ani.data
 
-    def force_contribution(self, dH_asii: AtomArrays, F_av: Array2D):
+    def force_contribution(self,
+                           potential: Potential,
+                           F_av: Array2D) -> None:
+        xp = self.xp
+        dH_asii = potential.dH_asii
+        myeig_n = xp.asarray(self.myeig_n)
+        myocc_n = xp.asarray(
+            self.weight * self.spin_degeneracy * self.myocc_n)
+
+        if self.ncomponents == 4:
+            self._non_collinear_force_contribution(dH_asii, myocc_n, F_av)
+            return
+
         F_avni = self.pt_aiX.derivative(self.psit_nX)
-        myocc_n = self.weight * self.spin_degeneracy * self.myocc_n
         for a, F_vni in F_avni.items():
             F_vni = F_vni.conj()
             F_vni *= myocc_n[:, np.newaxis]
             dH_ii = dH_asii[a][self.spin]
             P_ni = self.P_ani[a]
-            F_vii = np.einsum('vni, nj, jk -> vik', F_vni, P_ni, dH_ii)
-            F_vni *= self.myeig_n[:, np.newaxis]
-            dO_ii = self.setups[a].dO_ii
-            F_vii -= np.einsum('vni, nj, jk -> vik', F_vni, P_ni, dO_ii)
+            F_vii = xp.einsum('vni, nj, jk -> vik', F_vni, P_ni, dH_ii)
+            F_vni *= myeig_n[:, np.newaxis]
+            dO_ii = xp.asarray(self.setups[a].dO_ii)
+            F_vii -= xp.einsum('vni, nj, jk -> vik', F_vni, P_ni, dO_ii)
             F_av[a] += 2 * F_vii.real.trace(0, 1, 2)
 
+    def _non_collinear_force_contribution(self,
+                                          dH_asii,
+                                          myocc_n,
+                                          F_av):
+        F_avnsi = self.pt_aiX.derivative(self.psit_nX)
+        for a, F_vnsi in F_avnsi.items():
+            F_vnsi = F_vnsi.conj()
+            F_vnsi *= myocc_n[:, np.newaxis, np.newaxis]
+            dH_sii = dH_asii[a]
+            dH_ii = dH_sii[0]
+            dH_vii = dH_sii[1:]
+            dH_ssii = np.array(
+                [[dH_ii + dH_vii[2], dH_vii[0] - 1j * dH_vii[1]],
+                 [dH_vii[0] + 1j * dH_vii[1], dH_ii - dH_vii[2]]])
+            P_nsi = self.P_ani[a]
+            F_v = np.einsum('vnsi, stij, ntj -> v', F_vnsi, dH_ssii, P_nsi)
+            F_vnsi *= self.myeig_n[:, np.newaxis, np.newaxis]
+            dO_ii = self.setups[a].dO_ii
+            F_v -= np.einsum('vnsi, ij, nsj -> v', F_vnsi, dO_ii, P_nsi)
+            F_av[a] += 2 * F_v.real
+
     def collect(self,
                 n1: int = 0,
                 n2: int = 0) -> PWFDWaveFunctions | None:
         """Collect range of bands to master of band and domain
         communicators."""
         # Also collect projections instead of recomputing XXX
         n2 = n2 or self.nbands + n2
@@ -396,7 +438,29 @@
             self.q,
             self.k,
             self.setups,
             self.fracpos_ac,
             self.atomdist,
             self.weight,
             self.ncomponents)
+
+    def morph(self, desc, fracpos_ac, atomdist):
+        desc = desc.new(kpt=self.psit_nX.desc.kpt_c)
+        psit_nX = self.psit_nX.morph(desc)
+
+        # Save memory:
+        self.psit_nX.data = None
+        self._P_ani = None
+        self._pt_aiX = None
+
+        wfs = PWFDWaveFunctions(
+            psit_nX,
+            self.spin,
+            self.q,
+            self.k,
+            self.setups,
+            fracpos_ac,
+            atomdist,
+            self.weight,
+            self.ncomponents)
+
+        return wfs
```

### Comparing `gpaw-22.8.0/gpaw/new/rttddft.py` & `gpaw-23.6.0/gpaw/new/rttddft.py`

 * *Files 1% similar despite different names*

```diff
@@ -249,15 +249,15 @@
     @classmethod
     def from_dft_file(cls,
                       filepath: str,
                       propagator: TDAlgorithm | None = None):
         _, calculation, params, builder = read_gpw(filepath,
                                                    '-',
                                                    {'world': world},
-                                                   force_complex_dtype=True)
+                                                   dtype=complex)
 
         state = calculation.state
         pot_calc = calculation.pot_calc
         hamiltonian = builder.create_hamiltonian_operator()
         history = RTTDDFTHistory()
 
         return cls(state, pot_calc, hamiltonian, propagator=propagator,
```

### Comparing `gpaw-22.8.0/gpaw/new/scf.py` & `gpaw-23.6.0/gpaw/new/scf.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,27 +1,34 @@
 from __future__ import annotations
 
 import itertools
 import warnings
+from math import inf
 from types import SimpleNamespace
-from typing import TYPE_CHECKING, Any
+from typing import TYPE_CHECKING, Any, Callable
 
+import numpy as np
 from gpaw.convergence_criteria import (Criterion, check_convergence,
                                        dict2criterion)
 from gpaw.scf import write_iteration
+from gpaw.typing import Array2D
 from gpaw.yml import indent
 
 if TYPE_CHECKING:
     from gpaw.new.calculation import DFTState
 
 
 class SCFConvergenceError(Exception):
     ...
 
 
+class TooFewBandsError(SCFConvergenceError):
+    """Not enough bands for CBM+x convergence cfriterium."""
+
+
 class SCFLoop:
     def __init__(self,
                  hamiltonian,
                  occ_calc,
                  eigensolver,
                  mixer,
                  world,
@@ -46,14 +53,15 @@
                 f'occupation numbers:\n{indent(self.occ_calc)}\n')
 
     def iterate(self,
                 state: DFTState,
                 pot_calc,
                 convergence=None,
                 maxiter=None,
+                calculate_forces=None,
                 log=None):
 
         cc = create_convergence_criteria(convergence or self.convergence)
         maxiter = maxiter or self.maxiter
 
         if log:
             log('convergence criteria:')
@@ -74,57 +82,83 @@
             state.ibzwfs.calculate_occs(
                 self.occ_calc,
                 fixed_fermi_level=not self.update_density_and_potential)
 
             ctx = SCFContext(
                 state, self.niter,
                 wfs_error, dens_error,
-                self.world)
+                self.world, calculate_forces,
+                pot_calc)
 
             yield ctx
 
             converged, converged_items, entries = check_convergence(cc, ctx)
+            nconverged = self.world.sum(int(converged))
+            assert nconverged in [0, self.world.size], converged_items
+
             if log:
                 with log.comment():
                     write_iteration(cc, converged_items, entries, ctx, log)
             if converged:
                 break
             if self.niter == maxiter:
-                raise SCFConvergenceError
+                if wfs_error < inf:
+                    raise SCFConvergenceError
+                raise TooFewBandsError
 
             if self.update_density_and_potential:
                 state.density.update(pot_calc.nct_R, state.ibzwfs)
                 dens_error = self.mixer.mix(state.density)
                 state.potential, state.vHt_x, _ = pot_calc.calculate(
-                    state.density, state.vHt_x)
+                    state.density, state.vHt_x,
+                    state.ibzwfs.kpt_comm)
 
 
 class SCFContext:
     def __init__(self,
                  state: DFTState,
                  niter: int,
                  wfs_error: float,
                  dens_error: float,
-                 world):
+                 world,
+                 calculate_forces: Callable[[], Array2D],
+                 pot_calc):
         self.state = state
         self.niter = niter
-        energy = (sum(state.potential.energies.values()) +
-                  sum(state.ibzwfs.energies.values()))
-        self.ham = SimpleNamespace(e_total_extrapolated=energy)
+        energy = np.array([sum(state.potential.energies.values()) +
+                           sum(state.ibzwfs.energies.values())])
+        world.broadcast(energy, 0)
+        self.ham = SimpleNamespace(e_total_extrapolated=energy[0],
+                                   get_workfunctions=self._get_workfunctions)
         self.wfs = SimpleNamespace(nvalence=state.ibzwfs.nelectrons,
                                    world=world,
                                    eigensolver=SimpleNamespace(
                                        error=wfs_error),
                                    nspins=state.density.ndensities,
                                    collinear=state.density.collinear)
         self.dens = SimpleNamespace(
             calculate_magnetic_moments=state.density
             .calculate_magnetic_moments,
             fixed=False,
             error=dens_error)
+        self.calculate_forces = calculate_forces
+        self.poisson_solver = pot_calc.poisson_solver
+
+    def _get_workfunctions(self, _):
+        """
+        vHt_g = self.state.vHt_x
+        axes = (c, (c + 1) % 3, (c + 2) % 3)
+        potential.vt_sRself.pd3.ifft(v_q, local=True).transpose(axes)
+        vacuum = v_g[0].mean()
+        vacuum_level =
+        (fermi_level,) = self.state.ibzwfs.fermi_levels
+        wf = vacuum_level - fermi_level
+        delta = self.poisson_solver.correction
+        return np.array([wf + 0.5 * delta, wf - 0.5 * delta])
+        """
 
 
 def create_convergence_criteria(criteria: dict[str, Any]
                                 ) -> dict[str, Criterion]:
     for k, v in [('energy', 0.0005),        # eV / electron
                  ('density', 1.0e-4),       # electrons / electron
                  ('eigenstates', 4.0e-8)]:  # eV^2 / electron
```

### Comparing `gpaw-22.8.0/gpaw/new/smearing.py` & `gpaw-23.6.0/gpaw/new/smearing.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/new/spinors.py` & `gpaw-23.6.0/gpaw/new/spinors.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,7 +1,9 @@
+from __future__ import annotations
+
 import numpy as np
 from gpaw.core.domain import Domain
 from gpaw.typing import Vector
 
 
 class SpinorWaveFunctionDescriptor(Domain):
     def __init__(self,
@@ -9,18 +11,22 @@
                  qspiral_v: Vector = None):
         self.desc = desc
         self.qspiral_v = (np.asarray(qspiral_v) if qspiral_v is not None else
                           None)
         Domain.__init__(self, desc.cell_cv, desc.pbc_c, desc.kpt_c, desc.comm,
                         complex)
         self.myshape = (2,) + desc.myshape
+        self.itemsize = desc.itemsize
 
     def __repr__(self):
         return f'{self.__class__.__name__}({self.desc}, {self.qspiral_v})'
 
     def new(self, *, kpt):
         desc = self.desc.new(kpt=kpt)
         desc.qspiral_v = self.qspiral_v
         return SpinorWaveFunctionDescriptor(desc, self.qspiral_v)
 
-    def empty(self, nbands, band_comm):
+    def empty(self, nbands, band_comm, xp=None):
         return self.desc.empty((nbands, 2), band_comm)
+
+    def global_shape(self) -> tuple[int, ...]:
+        return (2,) + self.desc.global_shape()
```

### Comparing `gpaw-22.8.0/gpaw/new/spinspiral.py` & `gpaw-23.6.0/gpaw/new/spinspiral.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/new/symmetry.py` & `gpaw-23.6.0/gpaw/new/symmetry.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,11 +1,12 @@
 import warnings
 
 import numpy as np
 from gpaw.mpi import MPIComm
+from gpaw.new import zip
 from gpaw.new.brillouin import IBZ, BZPoints
 from gpaw.rotation import rotation
 from gpaw.symmetry import Symmetry as OldSymmetry
 
 
 def create_symmetries_object(atoms, ids=None, magmoms=None, parameters=None):
     ids = ids or [()] * len(atoms)
@@ -73,14 +74,24 @@
         lines[-1] = lines[-1][:-1] + ']\n'
         return '\n'.join(lines)
 
     def reduce(self,
                bz: BZPoints,
                comm: MPIComm = None,
                strict: bool = True) -> IBZ:
+        """Find irreducible set of k-points."""
+        if not (self.symmetry.time_reversal or
+                self.symmetry.point_group):
+            N = len(bz)
+            return IBZ(self,
+                       bz,
+                       ibz2bz=np.arange(N),
+                       bz2ibz=np.arange(N),
+                       weights=np.ones(N) / N)
+
         (_, weight_k, sym_k, time_reversal_k, bz2ibz_K, ibz2bz_k,
          bz2bz_Ks) = self.symmetry.reduce(bz.kpt_Kc, comm)
 
         if -1 in bz2bz_Ks:
             msg = 'Note: your k-points are not as symmetric as your crystal!'
             if strict:
                 raise ValueError(msg)
@@ -90,20 +101,21 @@
 
     def check_positions(self, fracpos_ac):
         self.symmetry.check(fracpos_ac)
 
     def symmetrize_forces(self, F_av):
         return self.symmetry.symmetrize_forces(F_av)
 
-    def rotations(self, l_j):
+    def rotations(self, l_j, xp=np):
         ells = tuple(l_j)
         rotation_sii = self._rotations.get(ells)
         if rotation_sii is None:
             ni = sum(2 * l + 1 for l in l_j)
             rotation_sii = np.zeros((len(self), ni, ni))
             i1 = 0
             for l in l_j:
                 i2 = i1 + 2 * l + 1
                 rotation_sii[:, i1:i2, i1:i2] = self.rotation_lsmm[l]
                 i1 = i2
+            rotation_sii = xp.asarray(rotation_sii)
             self._rotations[ells] = rotation_sii
         return rotation_sii
```

### Comparing `gpaw-22.8.0/gpaw/new/tb/builder.py` & `gpaw-23.6.0/gpaw/new/tb/builder.py`

 * *Files 5% similar despite different names*

```diff
@@ -61,15 +61,15 @@
             get_grid_spacings=lambda: [0, 0, 0],
             cell_cv=self.cell_cv,
             pbc_c=self.pbc_c,
             N_c=[0, 0, 0],
             dv=0.0)
         self.size = (0, 0, 0)
 
-    def empty(self, shape=(), comm=serial_comm):
+    def empty(self, shape=(), comm=serial_comm, xp=None):
         return DummyFunctions(self, shape, comm)
 
     def ranks_from_fractional_positions(self, fracpos_ac):
         return np.zeros(len(fracpos_ac), int)
 
 
 class DummyFunctions(DistributedArrays[NoGrid]):
@@ -90,14 +90,17 @@
 
     def __getitem__(self, index):
         return DummyFunctions(self.desc, comm=self.comm)
 
     def moment(self):
         return np.zeros(3)
 
+    def to_xp(self, xp):
+        return self
+
 
 class PSCoreDensities:
     def __init__(self, grid, fracpos_ac):
         self.layout = AtomArraysLayout([1] * len(fracpos_ac),
                                        grid.comm)
 
     def to_uniform_grid(self, out, scale):
@@ -113,17 +116,19 @@
         super().__init__(xc, None, setups, nct_R,
                          atoms.get_scaled_positions())
         self.atoms = atoms.copy()
         self.force_av = None
         self.stress_vv = None
 
     def calculate_charges(self, vHt_r):
-        return {a: np.zeros(9) for a, setup in enumerate(self.setups)}
+        return AtomArraysLayout(
+            [9] * len(self.atoms),
+            self.nct_R.comm).zeros()
 
-    def _calculate(self, density, vHt_r):
+    def calculate_pseudo_potential(self, density, vHt_r):
         vt_sR = density.nt_sR
 
         atoms = self.atoms
         energy, force_av, stress_vv = pairpot(atoms)
         energy /= Ha
         self.force_av = force_av * Bohr / Ha
 
@@ -154,24 +159,26 @@
     xc = None
 
     def calculate_paw_correction(self, setup, D_sp, dH_sp):
         return 0.0
 
 
 class TBSCFLoop:
-    def __init__(self, hamiltonian, occ_calc, eigensolver):
+    def __init__(self, hamiltonian, occ_calc, eigensolver, world):
         self.hamiltonian = hamiltonian
         self.occ_calc = occ_calc
         self.eigensolver = eigensolver
+        self.world = world
 
     def iterate(self,
                 state,
                 pot_calc,
                 convergence=None,
                 maxiter=None,
+                calculate_forces=None,
                 log=None):
         self.eigensolver.iterate(state, self.hamiltonian)
         state.ibzwfs.calculate_occs(self.occ_calc)
         yield
         state.potential, state.vHt_x, _ = pot_calc.calculate(
             state.density, state.vHt_x)
 
@@ -213,17 +220,23 @@
         xc = DummyXC()
         return TBPotentialCalculator(xc, self.setups, self.nct_R, self.atoms)
 
     def create_scf_loop(self):
         occ_calc = self.create_occupation_number_calculator()
         hamiltonian = self.create_hamiltonian_operator()
         eigensolver = self.create_eigensolver(hamiltonian)
-        return TBSCFLoop(hamiltonian, occ_calc, eigensolver)
+        return TBSCFLoop(hamiltonian, occ_calc, eigensolver,
+                         self.communicators['w'])
 
-    def create_ibz_wave_functions(self, basis, potential):
+    def create_ibz_wave_functions(self,
+                                  basis: BasisFunctions,
+                                  potential,
+                                  *,
+                                  log=None,
+                                  coefficients=None):
         assert self.communicators['w'].size == 1
 
         ibzwfs, tciexpansions = create_lcao_ibzwfs(
             basis, potential,
             self.ibz, self.communicators, self.setups,
             self.fracpos_ac, self.grid, self.dtype,
             self.nbands, self.ncomponents, self.atomdist, self.nelectrons)
@@ -235,23 +248,24 @@
                 vt_r = setup.vt_g
             except AttributeError:
                 vt_r = calculate_pseudo_potential(setup, self.xc.xc)[0]
 
             vt_r[-1] = 0.0  # ???
             vt = setup.rgd.spline(vt_r, points=300)
             vtphit_j = []
-            for phit in setup.phit_j:
+            for phit in setup.basis_functions_J:
                 rc = phit.get_cutoff()
                 r_g = np.linspace(0, rc, 150)
                 vt_g = vt.map(r_g) / (4 * pi)**0.5
                 phit_g = phit.map(r_g)
                 vtphit_j.append(Spline(phit.l, rc, vt_g * phit_g))
             vtphit[setup] = vtphit_j
 
-        vtciexpansions = TCIExpansions([s.phit_j for s in self.setups],
+        vtciexpansions = TCIExpansions([s.basis_functions_J
+                                        for s in self.setups],
                                        [vtphit[s] for s in self.setups],
                                        tciexpansions.I_a)
 
         kpt_qc = np.array([wfs.kpt_c for wfs in ibzwfs])
         manytci = vtciexpansions.get_manytci_calculator(
             self.setups, self.grid._gd, self.fracpos_ac,
             kpt_qc, self.dtype, NullTimer())
```

### Comparing `gpaw-22.8.0/gpaw/new/wave_functions.py` & `gpaw-23.6.0/gpaw/new/wave_functions.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,18 +1,25 @@
 from __future__ import annotations
 
+from types import ModuleType
+
 import numpy as np
 from gpaw.core.atom_arrays import AtomArrays, AtomDistribution
+from gpaw.core.uniform_grid import UniformGridFunctions
+from gpaw.mpi import MPIComm, serial_comm
+from gpaw.new import zip
+from gpaw.new.potential import Potential
 from gpaw.setup import Setups
 from gpaw.typing import Array1D, Array2D, ArrayND
-from gpaw.mpi import MPIComm, serial_comm
-from gpaw.core.uniform_grid import UniformGridFunctions
 
 
 class WaveFunctions:
+    bytes_per_band: int
+    xp: ModuleType  # numpy or cupy
+
     def __init__(self,
                  *,
                  setups: Setups,
                  nbands: int,
                  fracpos_ac: Array2D,
                  atomdist: AtomDistribution,
                  spin: int = 0,
@@ -102,31 +109,34 @@
     def P_ani(self) -> AtomArrays:
         assert self._P_ani is not None
         return self._P_ani
 
     def add_to_atomic_density_matrices(self,
                                        occ_n,
                                        D_asii: AtomArrays) -> None:
+        xp = D_asii.layout.xp
+        occ_n = xp.asarray(occ_n)
         if self.ncomponents < 4:
-            for D_sii, P_ni in zip(D_asii.values(), self.P_ani.values()):
-                D_sii[self.spin] += np.einsum('ni, n, nj -> ij',
+            P_ani = self.P_ani
+            for D_sii, P_ni in zip(D_asii.values(), P_ani.values()):
+                D_sii[self.spin] += xp.einsum('ni, n, nj -> ij',
                                               P_ni.conj(), occ_n, P_ni).real
         else:
             for D_xii, P_nsi in zip(D_asii.values(), self.P_ani.values()):
-                D_ssii = np.einsum('nsi, n, nzj -> szij',
+                D_ssii = xp.einsum('nsi, n, nzj -> szij',
                                    P_nsi.conj(), occ_n, P_nsi)
                 D_xii[0] += (D_ssii[0, 0] + D_ssii[1, 1]).real
                 D_xii[1] += 2 * D_ssii[0, 1].real
                 D_xii[2] += 2 * D_ssii[0, 1].imag
                 D_xii[3] += (D_ssii[0, 0] - D_ssii[1, 1]).real
 
     def send(self, kpt_comm, rank):
         raise NotImplementedError
 
     def receive(self, kpt_comm, rank):
         raise NotImplementedError
 
-    def force_contribution(self, dH_asii: AtomArrays, F_av: Array2D):
+    def force_contribution(self, potential: Potential, F_av: Array2D):
         raise NotImplementedError
 
     def gather_wave_function_coefficients(self) -> np.ndarray | None:
         raise NotImplementedError
```

### Comparing `gpaw-22.8.0/gpaw/nlopt/linear.py` & `gpaw-23.6.0/gpaw/nlopt/linear.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/nlopt/matrixel.py` & `gpaw-23.6.0/gpaw/nlopt/matrixel.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/nlopt/shg.py` & `gpaw-23.6.0/gpaw/nlopt/shg.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/nlopt/shift.py` & `gpaw-23.6.0/gpaw/nlopt/shift.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,162 +1,172 @@
-
-import numpy as np
-from ase.units import Bohr, _hbar, _e, _me
-from ase.utils.timing import Timer
-from ase.parallel import parprint
-from gpaw.mpi import world
-from gpaw.nlopt.basic import load_data
-from gpaw.nlopt.matrixel import get_rml, get_derivative
-from gpaw.utilities.progressbar import ProgressBar
-
-
-def get_shift(
-        freqs=[1.0],
-        eta=0.05,
-        pol='yyy',
-        eshift=0.0,
-        ftol=1e-4, Etol=1e-6,
-        band_n=None,
-        out_name='shift.npy',
-        mml_name='mml.npz'):
-    """
-    Calculate RPA shift current for nonmagnetic semiconductors
-
-    Input:
-        freqs           Excitation frequency array (a numpy array or list)
-        eta             Broadening, a number or an array (default 0.05 eV)
-        pol             Tensor element (default 'yyy')
-        Etol, ftol      Tol. in energy and fermi to consider degeneracy
-        band_n          List of bands in the sum (default 0 to nb)
-        out_name        Output filename (default 'shift.npy')
-        mml_name        The momentum filename (default 'mml.npz')
-    Output:
-        shift.npy       Numpy array containing the spectrum and frequencies
-    """
-
-    # Start a timer
-    timer = Timer()
-    parprint('Calculating shift current (in {:d} cores).'.format(world.size))
-
-    # Useful variables
-    pol_v = ['xyz'.index(ii) for ii in pol]
-    w_l = np.array(freqs)
-    nw = len(freqs)
-    parprint('Calculation for element {}.'.format(pol))
-
-    # Load the required data
-    with timer('Load and distribute the data'):
-        k_info = load_data(mml_name=mml_name)
-        if k_info:
-            tmp = list(k_info.values())[0]
-            nb = len(tmp[1])
-            nk = len(k_info) * world.size  # Approximately
-            if band_n is None:
-                band_n = list(range(nb))
-            mem = 6 * 3 * nk * nb**2 * 16 / 2**20
-            parprint(f'At least {mem:.2f} MB of memory is required.')
-
-    # Initial call to print 0% progress
-    count = 0
-    ncount = len(k_info)
-    if world.rank == 0:
-        pb = ProgressBar()
-
-    # Initialize the outputs
-    sum2_l = np.zeros((nw), complex)
-
-    # Do the calculations
-    for _, (we, f_n, E_n, p_vnn) in k_info.items():
-        with timer('Position matrix elements calculation'):
-            r_vnn, D_vnn = get_rml(E_n, p_vnn, pol_v, Etol=Etol)
-
-        with timer('Compute generalized derivative'):
-            rd_vvnn = get_derivative(E_n, r_vnn, D_vnn, pol_v, Etol=Etol)
-
-        with timer('Sum over bands'):
-            tmp = shift_current(
-                eta, w_l, f_n, E_n, r_vnn, rd_vvnn, pol_v,
-                band_n, ftol, Etol, eshift)
-
-        # Add it to previous with a weight
-        sum2_l += tmp * we
-
-        # Print the progress
-        if world.rank == 0:
-            pb.update(count / ncount)
-        count += 1
-
-    if world.rank == 0:
-        pb.finish()
-        
-    with timer('Gather data from cores'):
-        world.sum(sum2_l)
-
-    # Make the output in SI unit
-    dim_init = -1j * _e**3 / (2 * _hbar * (2.0 * np.pi)**3)
-    dim_sum = (_hbar / (Bohr * 1e-10))**3 / \
-        (_e**4 * (Bohr * 1e-10)**3) * (_hbar / _me)**3
-    dim_SI = 1j * dim_init * dim_sum  # 1j due to imag in loop
-    sigma_l = dim_SI * sum2_l.real
-
-    # A multi-col output
-    shift = np.vstack((freqs, sigma_l))
-
-    # Save it to the file
-    if world.rank == 0:
-        np.save(out_name, shift)
-
-        # Print the timing
-        timer.write()
-
-    return shift
-
-
-def shift_current(
-        eta, w_l, f_n, E_n, r_vnn, rd_vvnn, pol_v,
-        band_n=None, ftol=1e-4, Etol=1e-6, eshift=0):
-    """
-    Loop over bands for computing in length gauge
-
-    Input:
-        eta             Broadening
-        w_l             Complex frequency array
-        f_n             Fermi levels
-        E_n             Energies
-        r_vnn           Momentum matrix elements
-        rd_vvnn         Generalized derivative of position
-        pol_v           Tensor element
-        band_n          Band list
-        Etol, ftol      Tol. in energy and fermi to consider degeneracy
-        eshift          Bandgap correction
-    Output:
-        sum2_l          Output array
-    """
-
-    # Initialize variable
-    nb = len(f_n)
-    if band_n is None:
-        band_n = list(range(nb))
-    sum2_l = np.zeros((w_l.size), complex)
-
-    # Loop over bands
-    for nni in band_n:
-        for mmi in band_n:
-            # Remove the non important term (use TRS)
-            if mmi <= nni:
-                continue
-            fnm = f_n[nni] - f_n[mmi]
-            Emn = E_n[mmi] - E_n[nni] + fnm * eshift
-
-            # Two band part
-            if np.abs(fnm) > ftol:
-                tmp = np.imag(
-                    r_vnn[pol_v[1], mmi, nni]
-                    * rd_vvnn[pol_v[0], pol_v[2], nni, mmi]
-                    + r_vnn[pol_v[2], mmi, nni]
-                    * rd_vvnn[pol_v[0], pol_v[1], nni, mmi]) \
-                    * (eta / (np.pi * ((w_l - Emn) ** 2 + eta ** 2))
-                        - eta / (np.pi * ((w_l + Emn) ** 2 + eta ** 2)))
-
-                sum2_l += fnm * tmp
-
-    return sum2_l
+
+import numpy as np
+from ase.units import Bohr, _hbar, _e, _me
+from ase.utils.timing import Timer
+from ase.parallel import parprint
+from gpaw.mpi import world
+from gpaw.nlopt.basic import load_data
+from gpaw.nlopt.matrixel import get_rml, get_derivative
+from gpaw.utilities.progressbar import ProgressBar
+
+
+def get_shift(
+        freqs=[1.0],
+        eta=0.05,
+        pol='yyy',
+        eshift=0.0,
+        ftol=1e-4, Etol=1e-6,
+        band_n=None,
+        out_name='shift.npy',
+        mml_name='mml.npz'):
+    """Calculate RPA shift current for nonmagnetic semiconductors.
+
+    Parameters
+    ==========
+    freqs:
+        Excitation frequency array (a numpy array or list).
+    eta:
+        Broadening, a number or an array (default 0.05 eV).
+    pol:
+        Tensor element (default 'yyy').
+    Etol, ftol:
+        Tol. in energy and fermi to consider degeneracy.
+    band_n:
+        List of bands in the sum (default 0 to nb).
+    out_name:
+        Output filename (default 'shift.npy').
+    mml_name:
+        The momentum filename (default 'mml.npz').
+
+    Returns
+    =======
+    np.ndarray
+        Numpy array containing the spectrum and frequencies.
+    """
+
+    # Start a timer
+    timer = Timer()
+    parprint('Calculating shift current (in {:d} cores).'.format(world.size))
+
+    # Useful variables
+    pol_v = ['xyz'.index(ii) for ii in pol]
+    w_l = np.array(freqs)
+    nw = len(freqs)
+    parprint('Calculation for element {}.'.format(pol))
+
+    # Load the required data
+    with timer('Load and distribute the data'):
+        k_info = load_data(mml_name=mml_name)
+        if k_info:
+            tmp = list(k_info.values())[0]
+            nb = len(tmp[1])
+            nk = len(k_info) * world.size  # Approximately
+            if band_n is None:
+                band_n = list(range(nb))
+            mem = 6 * 3 * nk * nb**2 * 16 / 2**20
+            parprint(f'At least {mem:.2f} MB of memory is required.')
+
+    # Initial call to print 0% progress
+    count = 0
+    ncount = len(k_info)
+    if world.rank == 0:
+        pb = ProgressBar()
+
+    # Initialize the outputs
+    sum2_l = np.zeros((nw), complex)
+
+    # Do the calculations
+    for _, (we, f_n, E_n, p_vnn) in k_info.items():
+        with timer('Position matrix elements calculation'):
+            r_vnn, D_vnn = get_rml(E_n, p_vnn, pol_v, Etol=Etol)
+
+        with timer('Compute generalized derivative'):
+            rd_vvnn = get_derivative(E_n, r_vnn, D_vnn, pol_v, Etol=Etol)
+
+        with timer('Sum over bands'):
+            tmp = shift_current(
+                eta, w_l, f_n, E_n, r_vnn, rd_vvnn, pol_v,
+                band_n, ftol, Etol, eshift)
+
+        # Add it to previous with a weight
+        sum2_l += tmp * we
+
+        # Print the progress
+        if world.rank == 0:
+            pb.update(count / ncount)
+        count += 1
+
+    if world.rank == 0:
+        pb.finish()
+
+    with timer('Gather data from cores'):
+        world.sum(sum2_l)
+
+    # Make the output in SI unit
+    dim_init = -1j * _e**3 / (2 * _hbar * (2.0 * np.pi)**3)
+    dim_sum = (_hbar / (Bohr * 1e-10))**3 / \
+        (_e**4 * (Bohr * 1e-10)**3) * (_hbar / _me)**3
+    dim_SI = 1j * dim_init * dim_sum  # 1j due to imag in loop
+    sigma_l = dim_SI * sum2_l.real
+
+    # A multi-col output
+    shift = np.vstack((freqs, sigma_l))
+
+    # Save it to the file
+    if world.rank == 0:
+        np.save(out_name, shift)
+
+        # Print the timing
+        timer.write()
+
+    return shift
+
+
+def shift_current(
+        eta, w_l, f_n, E_n, r_vnn, rd_vvnn, pol_v,
+        band_n=None, ftol=1e-4, Etol=1e-6, eshift=0):
+    """
+    Loop over bands for computing in length gauge
+
+    Input:
+        eta             Broadening
+        w_l             Complex frequency array
+        f_n             Fermi levels
+        E_n             Energies
+        r_vnn           Momentum matrix elements
+        rd_vvnn         Generalized derivative of position
+        pol_v           Tensor element
+        band_n          Band list
+        Etol, ftol      Tol. in energy and fermi to consider degeneracy
+        eshift          Bandgap correction
+    Output:
+        sum2_l          Output array
+    """
+
+    # Initialize variable
+    nb = len(f_n)
+    if band_n is None:
+        band_n = list(range(nb))
+    sum2_l = np.zeros((w_l.size), complex)
+
+    # Loop over bands
+    for nni in band_n:
+        for mmi in band_n:
+            # Remove the non important term (use TRS)
+            if mmi <= nni:
+                continue
+            fnm = f_n[nni] - f_n[mmi]
+            Emn = E_n[mmi] - E_n[nni] + fnm * eshift
+
+            # Two band part
+            if np.abs(fnm) > ftol:
+                tmp = np.imag(
+                    r_vnn[pol_v[1], mmi, nni]
+                    * rd_vvnn[pol_v[0], pol_v[2], nni, mmi]
+                    + r_vnn[pol_v[2], mmi, nni]
+                    * rd_vvnn[pol_v[0], pol_v[1], nni, mmi]) \
+                    * (eta / (np.pi * ((w_l - Emn) ** 2 + eta ** 2))
+                        - eta / (np.pi * ((w_l + Emn) ** 2 + eta ** 2)))
+
+                sum2_l += fnm * tmp
+
+    return 2 * np.pi * sum2_l
```

### Comparing `gpaw-22.8.0/gpaw/occupations.py` & `gpaw-23.6.0/gpaw/occupations.py`

 * *Files 0% similar despite different names*

```diff
@@ -275,16 +275,16 @@
 
     def _calculate(self,
                    nelectrons,
                    eig_qn,
                    weight_q,
                    f_qn,
                    fermi_level_guess):
-
-        if np.isnan(fermi_level_guess) or self._width == 0.0:
+        # Guess can be nan or inf:
+        if not np.isfinite(fermi_level_guess) or self._width == 0.0:
             zero = ZeroWidth(self.parallel_layout)
             fermi_level_guess, _ = zero._calculate(
                 nelectrons, eig_qn, weight_q, f_qn)
             if self._width == 0.0 or np.isinf(fermi_level_guess):
                 return fermi_level_guess, 0.0
 
         x = fermi_level_guess
@@ -366,14 +366,17 @@
     """Function used for locating Fermi level.
 
     The function should return a (value, derivative) tuple:
 
     >>> x, _ = findroot(lambda x: (x, 1.0), 1.0)
     >>> assert abs(x) < 1e-10
     """
+
+    assert np.isfinite(x), x
+
     xmin = -np.inf
     xmax = np.inf
 
     # Try 10 step using the gradient:
     niter = 0
     while True:
         f, dfdx = func(x)
```

### Comparing `gpaw-22.8.0/gpaw/output.py` & `gpaw-23.6.0/gpaw/output.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/overlap.py` & `gpaw-23.6.0/gpaw/overlap.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/pair_density.py` & `gpaw-23.6.0/gpaw/pair_density.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/pair_overlap.py` & `gpaw-23.6.0/gpaw/pair_overlap.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/pes/__init__.py` & `gpaw-23.6.0/gpaw/pes/__init__.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/pes/continuum.py` & `gpaw-23.6.0/gpaw/pes/continuum.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/pes/dos.py` & `gpaw-23.6.0/gpaw/pes/dos.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/pes/ds_beta.py` & `gpaw-23.6.0/gpaw/pes/ds_beta.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/pes/state.py` & `gpaw-23.6.0/gpaw/pes/state.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/pes/tddft.py` & `gpaw-23.6.0/gpaw/pes/tddft.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/point_groups/check.py` & `gpaw-23.6.0/gpaw/point_groups/check.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/point_groups/cli.py` & `gpaw-23.6.0/gpaw/point_groups/cli.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,28 +1,26 @@
 import argparse
 from typing import List, Union
 
-from ase import Atoms
 import numpy as np
-
-from gpaw.calculator import GPAW
+from ase import Atoms
+from gpaw.new.ase_interface import ASECalculator, GPAW
 from gpaw.point_groups import SymmetryChecker, point_group_names
 from gpaw.typing import Array1D, Array3D
 
 
 class CubeCalc:
     """Wrap cube-file in a calculator."""
     def __init__(self, function: Array3D, atoms: Atoms):
         self.function = function
         self.atoms = atoms
 
     def get_pseudo_wave_function(self,
                                  band: int,
-                                 spin: int,
-                                 pad: bool = True) -> Array3D:
+                                 spin: int) -> Array3D:
         return self.function
 
     def get_eigenvalues(self, spin: int) -> Array1D:
         return np.zeros(1)
 
     def get_number_of_spins(self):
         return 1
@@ -44,15 +42,15 @@
         help='Cutoff radius (in Å) used for wave function overlaps.')
     add('-b', '--bands', default=':', metavar='N1:N2',
         help='Band range.')
     add('-a', '--axes', default='',
         help='Example: "-a z=x,x=-y".')
     args = parser.parse_intermixed_args(argv)
 
-    calc: Union[None, GPAW, CubeCalc]
+    calc: Union[None, ASECalculator, CubeCalc]
 
     if args.file.endswith('.gpw'):
         calc = GPAW(args.file)
         atoms = calc.atoms
         n1, n2 = (int(x) if x else 0 for x in args.bands.split(':'))
     elif args.file.endswith('.cube'):
         from ase.io.cube import read_cube
```

### Comparing `gpaw-22.8.0/gpaw/point_groups/group.py` & `gpaw-23.6.0/gpaw/point_groups/group.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/point_groups/groups.py` & `gpaw-23.6.0/gpaw/point_groups/groups.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/poisson.py` & `gpaw-23.6.0/gpaw/poisson.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/poisson_extravacuum.py` & `gpaw-23.6.0/gpaw/poisson_extravacuum.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/poisson_moment.py` & `gpaw-23.6.0/gpaw/poisson_moment.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/preconditioner.py` & `gpaw-23.6.0/gpaw/preconditioner.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/projections.py` & `gpaw-23.6.0/gpaw/projections.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,20 +1,21 @@
 from typing import Any, Optional, Dict
+from collections.abc import Mapping
 
 import numpy as np
 
 from gpaw.matrix import Matrix
 from gpaw.mpi import serial_comm
 from gpaw.utilities.partition import AtomPartition
 from gpaw.typing import Array2D, ArrayLike1D
 
 MPIComm = Any
 
 
-class Projections:
+class Projections(Mapping):
     def __init__(self,
                  nbands: int,
                  nproj_a: ArrayLike1D,
                  atom_partition: AtomPartition,
                  bcomm: MPIComm = None,
                  collinear=True,
                  spin=0,
@@ -78,24 +79,23 @@
 
     def view(self, n1: int, n2: int) -> 'Projections':
         return Projections(n2 - n1, self.nproj_a,
                            self.atom_partition,
                            self.bcomm, self.collinear, self.spin,
                            self.matrix.dtype, self.matrix.array[n1:n2])
 
-    def items(self):
-        for a, I1, I2 in self.indices:
-            yield a, self.array[..., I1:I2]
-
     def __getitem__(self, a):
         I1, I2 = self.map[a]
         return self.array[..., I1:I2]
 
-    def __contains__(self, a):
-        return a in self.map
+    def __iter__(self):
+        return iter(self.map)
+
+    def __len__(self):
+        return len(self.map)
 
     def broadcast(self) -> 'Projections':
         ap = AtomPartition(serial_comm, np.zeros(len(self.nproj_a), int))
         P = self.new(atom_partition=ap)
         comm = self.atom_partition.comm
         for a, rank in enumerate(self.atom_partition.rank_a):
             P1_ni = P[a]
@@ -176,8 +176,9 @@
         if P_nI is None:
             return {}
         I1 = 0
         P_ani = {}
         for a, ni in enumerate(self.nproj_a):
             I2 = I1 + ni
             P_ani[a] = P_nI[n1:n2, I1:I2]
+            I1 = I2
         return P_ani
```

### Comparing `gpaw-22.8.0/gpaw/pseudopotential.py` & `gpaw-23.6.0/gpaw/pseudopotential.py`

 * *Files 2% similar despite different names*

```diff
@@ -155,16 +155,16 @@
             gauss_g = np.exp(-(rgd.r_g / rcgauss)**2.0)
             for l in l_j:
                 phit_g = rgd.r_g**l * gauss_g
                 norm = (rgd.integrate(phit_g**2) / (4 * np.pi))**0.5
                 phit_g /= norm
                 bf = BasisFunction(None, l, rgd.r_g[-1], phit_g, 'gaussian')
                 bf_j.append(bf)
-    # l_orb_j = [state.l for state in self.data['states']]
-    b1 = SimpleBasis(ppdata.symbol, ppdata.l_orb_j)
+    # l_orb_J = [state.l for state in self.data['states']]
+    b1 = SimpleBasis(ppdata.symbol, ppdata.l_orb_J)
     apaw = AtomPAW(ppdata.symbol, [ppdata.f_ln], h=0.05, rcut=9.0,
                    basis={ppdata.symbol: b1},
                    setups={ppdata.symbol: ppdata},
                    maxiter=60,
                    txt=None)
     basis = apaw.extract_basis_functions()
     return basis
@@ -212,30 +212,29 @@
 
 
 class PseudoPotential(BaseSetup):
     def __init__(self, data, basis=None, filter=None):
         self.data = data
 
         self.R_sii = None
-        self.HubU = None
         self.lq = None
 
         self.filename = None
         self.fingerprint = None
         self.symbol = data.symbol
         self.type = data.name
 
         self.Z = data.Z
         self.Nv = data.Nv
         self.Nc = data.Nc
 
         self.f_j = data.f_j
         self.n_j = data.n_j
         self.l_j = data.l_j
-        self.l_orb_j = data.l_orb_j
+        self.l_orb_J = data.l_orb_J
         self.nj = len(data.l_j)
 
         self.ni = sum([2 * l + 1 for l in data.l_j])
         # self.pt_j = projectors_to_splines(data.rgd, data.l_j, data.pt_jg,
         #                                   filter=filter)
         self.pt_j = data.get_projectors()
 
@@ -243,18 +242,25 @@
             assert False  # not sure yet about the consequences of
             # cleaning this up in the other classes
             self.l_j = [0]
             self.pt_j = [null_spline]
 
         if basis is None:
             basis = data.create_basis_functions()
-        self.phit_j = basis.tosplines()
+
+        self.basis_functions_J = basis.tosplines()
+
+        # We declare (for the benefit of the wavefunctions reuse method)
+        # that we have no PAW projectors as such.  This makes the
+        # 'paw' wfs reuse method a no-op.
+        self.pseudo_partial_waves_j = []
+
         self.basis = basis
         self.nao = sum([2 * phit.get_angular_momentum_number() + 1
-                        for phit in self.phit_j])
+                        for phit in self.basis_functions_J])
 
         self.Nct = 0.0
         self.nct = null_spline
 
         self.lmax = 0
 
         self.xc_correction = None
@@ -297,15 +303,15 @@
         self.N0_p = np.zeros(_np)  # not really implemented
         self.nabla_iiv = None
         self.rxnabla_iiv = None
         self.phicorehole_g = None
         self.rgd = data.rgd
         self.rcut_j = data.rcut_j
         self.tauct = None
-        self.Delta_iiL = None
+        self.Delta_iiL = np.zeros((self.ni, self.ni, 1))
         self.B_ii = None
         self.dC_ii = None
         self.X_p = None
         self.X_wp = {}
         self.X_pg = None
         self.ExxC = None
         self.ExxC_w = {}
```

### Comparing `gpaw-22.8.0/gpaw/pw/density.py` & `gpaw-23.6.0/gpaw/pw/density.py`

 * *Files 0% similar despite different names*

```diff
@@ -1,9 +1,8 @@
 from math import pi
-
 import numpy as np
 
 from gpaw.density import Density
 from gpaw.pw.descriptor import PWDescriptor, PWMapping
 from gpaw.pw.lfc import PWLFC
 
 
@@ -19,15 +18,14 @@
 class ReciprocalSpaceDensity(Density):
     def __init__(self, ecut,
                  gd, finegd, nspins, collinear, charge, redistributor,
                  background_charge=None):
         Density.__init__(self, gd, finegd, nspins, collinear, charge,
                          redistributor=redistributor,
                          background_charge=background_charge)
-
         ecut0 = 0.5 * pi**2 / (gd.h_cv**2).sum(1).max()
         ecut = min(ecut, ecut0)
         self.pd2 = PWDescriptor(ecut, gd)
         self.pd3 = PWDescriptor(4 * ecut, finegd)
 
         self.map23 = PWMapping(self.pd2, self.pd3)
```

### Comparing `gpaw-22.8.0/gpaw/pw/descriptor.py` & `gpaw-23.6.0/gpaw/pw/descriptor.py`

 * *Files 0% similar despite different names*

```diff
@@ -1,14 +1,15 @@
 import numbers
 from math import pi
 import numpy as np
 
 import _gpaw
 import gpaw.fftw as fftw
 from gpaw.utilities.blas import mmm, r2k, rk
+from gpaw.gpu import cupy as cp
 
 
 class PWDescriptor:
     ndim = 1  # all 3d G-vectors are stored in a 1d ndarray
 
     def __init__(self, ecut, gd, dtype=None, kd=None,
                  fftwflags=fftw.MEASURE, gammacentered=False):
@@ -571,11 +572,14 @@
     True
     """
     if array is None:
         return None
     n = len(array)
     if n == N:
         return array
-    b = np.empty(N, complex)
+    if isinstance(array, np.ndarray):
+        b = np.empty(N, complex)
+    else:
+        b = cp.empty(N, complex)
     b[:n] = array
     b[n:] = 0
     return b
```

### Comparing `gpaw-22.8.0/gpaw/pw/hamiltonian.py` & `gpaw-23.6.0/gpaw/pw/hamiltonian.py`

 * *Files 2% similar despite different names*

```diff
@@ -88,15 +88,14 @@
 
         self.vt_Q = self.vbar_Q.copy()
 
         dens.map23.add_to1(self.vt_Q, self.vHt_q)
 
         # vt_sG[:] = pd2.ifft(vt_Q)
         eext = self.vext.update_potential_pw(self, dens)
-        eext /= self.finegd.comm.size
 
         self.timer.start('XC 3D grid')
 
         nt_xg = dens.nt_xg
 
         # If we have a redistributor, we want to do the
         # good old distribute-calculate-collect:
```

### Comparing `gpaw-22.8.0/gpaw/pw/lfc.py` & `gpaw-23.6.0/gpaw/core/pwacf.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,454 +1,509 @@
-from math import factorial as fac
+from __future__ import annotations
 from math import pi
 
 import _gpaw
+import gpaw.gpu.kernels as gpu_kernels
 import numpy as np
-from gpaw.lcao.overlap import fbt
+from gpaw.core.atom_arrays import AtomArraysLayout, AtomDistribution
+from gpaw.core.atom_centered_functions import AtomCenteredFunctions
+from gpaw.core.uniform_grid import UniformGridFunctions
+from gpaw.gpu import cupy_is_fake
 from gpaw.lfc import BaseLFC
+from gpaw.new import prod
+from gpaw.pw.lfc import ft
 from gpaw.spherical_harmonics import Y, nablarlYL
-from gpaw.spline import Spline
 from gpaw.utilities.blas import mmm
+from typing import TYPE_CHECKING
+if TYPE_CHECKING:
+    from gpaw.core.plane_waves import PlaneWaves
+
+
+class PlaneWaveAtomCenteredFunctions(AtomCenteredFunctions):
+    def __init__(self,
+                 functions,
+                 fracpos,
+                 pw,
+                 atomdist=None,
+                 xp=None):
+        AtomCenteredFunctions.__init__(self, functions, fracpos, atomdist)
+        self.pw = pw
+        self.xp = xp or np
 
+    def _lazy_init(self):
+        if self._lfc is not None:
+            return
+
+        self._lfc = PWLFC(self.functions, self.pw, xp=self.xp)
 
-def ft(spline, N=2**10):
-    l = spline.get_angular_momentum_number()
-    rc = 50.0
-    assert spline.get_cutoff() <= rc
-
-    dr = rc / N
-    r_r = np.arange(N) * dr
-    dk = pi / 2 / rc
-    k_q = np.arange(2 * N) * dk
-    f_r = spline.map(r_r) * (4 * pi)
-
-    f_q = fbt(l, f_r, r_r, k_q)
-    f_q[1:] /= k_q[1:]**(2 * l + 1)
-    f_q[0] = (np.dot(f_r, r_r**(2 + 2 * l)) *
-              dr * 2**l * fac(l) / fac(2 * l + 1))
+        if self._atomdist is None:
+            self._atomdist = AtomDistribution.from_number_of_atoms(
+                len(self.fracpos_ac), self.pw.comm)
+        else:
+            assert self.pw.comm is self._atomdist.comm
 
-    return Spline(l, k_q[-1], f_q)
+        self._lfc.set_positions(self.fracpos_ac, self._atomdist)
+        self._layout = AtomArraysLayout([sum(2 * f.l + 1 for f in funcs)
+                                         for funcs in self.functions],
+                                        self._atomdist,
+                                        self.pw.dtype,
+                                        xp=self.xp)
+
+    def __repr__(self):
+        s = super().__repr__()
+        if self.xp is np:
+            return s
+        return s[:-1] + ', xp=cp)'
+
+    def to_uniform_grid(self,
+                        out: UniformGridFunctions,
+                        scale: float = 1.0) -> UniformGridFunctions:
+        out_G = self.pw.zeros(xp=out.xp)
+        self.add_to(out_G, scale)
+        return out_G.ifft(out=out)
 
 
 class PWLFC(BaseLFC):
-    def __init__(self, spline_aj, pd, blocksize=5000, comm=None):
+    def __init__(self,
+                 functions,
+                 pw: PlaneWaves,
+                 blocksize=5000, *, xp):
         """Reciprocal-space plane-wave localized function collection.
 
         spline_aj: list of list of spline objects
             Splines.
         pd: PWDescriptor
             Plane-wave descriptor object.
         blocksize: int
             Block-size to use when looping over G-vectors.  Use None for
             doing all G-vectors in one big block.
-        comm: communicator
-            Communicator for operations that support parallelization
-            over planewaves (only integrate so far)."""
+        """
 
-        self.pd = pd
-        self.spline_aj = spline_aj
+        self.xp = xp
+        self.pw = pw
+        self.spline_aj = functions
 
-        self.dtype = pd.dtype
+        self.dtype = pw.dtype
 
         self.initialized = False
 
         # These will be filled in later:
-        self.Y_qGL = []
-        self.emiGR_qGa = []
-        self.f_qGs = []
+        self.Y_GL = None
+        self.emiGR_Ga = None
+        self.f_Gs = None
         self.l_s = None
         self.a_J = None
         self.s_J = None
         self.lmax = None
 
         if blocksize is not None:
-            if pd.ngmax <= blocksize:
+            if pw.maxmysize <= blocksize:
                 # No need to block G-vectors
                 blocksize = None
         self.blocksize = blocksize
 
         # These are set later in set_potitions():
-        self.eikR_qa = None
+        self.eikR_a = None
         self.my_atom_indices = None
         self.my_indices = None
         self.pos_av = None
         self.nI = None
 
-        if comm is None:
-            comm = pd.gd.comm
-        else:
-            assert False
-        self.comm = comm
+        self.comm = pw.comm
 
     def initialize(self):
         """Initialize position-independent stuff."""
         if self.initialized:
             return
 
+        xp = self.xp
+
         splines = {}  # Dict[Spline, int]
         for spline_j in self.spline_aj:
             for spline in spline_j:
                 if spline not in splines:
                     splines[spline] = len(splines)
         nsplines = len(splines)
 
         nJ = sum(len(spline_j) for spline_j in self.spline_aj)
 
-        self.f_qGs = [np.empty((mynG, nsplines)) for mynG in self.pd.myng_q]
+        self.f_Gs = xp.empty(self.pw.myshape + (nsplines,))
         self.l_s = np.empty(nsplines, np.int32)
         self.a_J = np.empty(nJ, np.int32)
         self.s_J = np.empty(nJ, np.int32)
-
+        self.I_J = np.empty(nJ, np.int32)
         # Fourier transform radial functions:
         J = 0
         done = set()  # Set[Spline]
+        I = 0
         for a, spline_j in enumerate(self.spline_aj):
             for spline in spline_j:
                 s = splines[spline]  # get spline index
                 if spline not in done:
                     f = ft(spline)
-                    for f_Gs, G2_G in zip(self.f_qGs, self.pd.G2_qG):
-                        G_G = G2_G**0.5
-                        f_Gs[:, s] = f.map(G_G)
+                    G_G = (2 * self.pw.ekin_G)**0.5
+                    self.f_Gs[:, s] = xp.asarray(f.map(G_G))
                     self.l_s[s] = spline.get_angular_momentum_number()
                     done.add(spline)
                 self.a_J[J] = a
                 self.s_J[J] = s
+                self.I_J[J] = I
+                I += 2 * spline.get_angular_momentum_number() + 1
                 J += 1
 
         self.lmax = max(self.l_s, default=-1)
 
         # Spherical harmonics:
-        for q, K_v in enumerate(self.pd.K_qv):
-            G_Gv = self.pd.get_reciprocal_vectors(q=q)
-            Y_GL = np.empty((len(G_Gv), (self.lmax + 1)**2))
-            for L in range((self.lmax + 1)**2):
-                Y_GL[:, L] = Y(L, *G_Gv.T)
-            self.Y_qGL.append(Y_GL)
+        G_Gv = self.pw.G_plus_k_Gv
+        self.Y_GL = xp.empty((len(G_Gv), (self.lmax + 1)**2))
+        for L in range((self.lmax + 1)**2):
+            self.Y_GL[:, L] = xp.asarray(Y(L, *G_Gv.T))
+
+        self.l_s = xp.asarray(self.l_s)
+        self.a_J = xp.asarray(self.a_J)
+        self.s_J = xp.asarray(self.s_J)
+        self.I_J = xp.asarray(self.I_J)
 
         self.initialized = True
 
-    def estimate_memory(self, mem):
-        splines = set()
-        lmax = -1
-        for spline_j in self.spline_aj:
-            for spline in spline_j:
-                splines.add(spline)
-                l = spline.get_angular_momentum_number()
-                lmax = max(lmax, l)
-        nbytes = ((len(splines) + (lmax + 1)**2) *
-                  sum(G2_G.nbytes for G2_G in self.pd.G2_qG))
-        mem.subnode('Arrays', nbytes)
-
     def get_function_count(self, a):
         return sum(2 * spline.get_angular_momentum_number() + 1
                    for spline in self.spline_aj[a])
 
-    def set_positions(self, spos_ac, atom_partition=None):
+    def set_positions(self, spos_ac, atomdist):
         self.initialize()
-        kd = self.pd.kd
-        if kd is None or kd.gamma:
-            self.eikR_qa = np.ones((1, len(spos_ac)))
-        else:
-            self.eikR_qa = np.exp(2j * pi * np.dot(kd.ibzk_qc, spos_ac.T))
 
-        self.pos_av = np.dot(spos_ac, self.pd.gd.cell_cv)
+        xp = self.xp
 
-        del self.emiGR_qGa[:]
-        G_Qv = self.pd.G_Qv
-        for Q_G in self.pd.myQ_qG:
-            GR_Ga = np.dot(G_Qv[Q_G], self.pos_av.T)
-            self.emiGR_qGa.append(np.exp(-1j * GR_Ga))
-
-        if atom_partition is None:
-            assert self.comm.size == 1
-            rank_a = np.zeros(len(spos_ac), int)
+        if self.pw.dtype == float:
+            self.eikR_a = xp.ones(len(spos_ac))
         else:
-            rank_a = atom_partition.rank_a
+            self.eikR_a = xp.asarray(
+                np.exp(2j * pi * (spos_ac @ self.pw.kpt_c)))
+
+        self.pos_av = np.dot(spos_ac, self.pw.cell)
+
+        Gk_Gv = xp.asarray(self.pw.G_plus_k_Gv)
+        GkR_Ga = Gk_Gv @ xp.asarray(self.pos_av.T)
+        self.emiGR_Ga = xp.exp(-1j * GkR_Ga) * self.eikR_a
+
+        rank_a = atomdist.rank_a
 
         self.my_atom_indices = []
         self.my_indices = []
         I1 = 0
         for a, rank in enumerate(rank_a):
             I2 = I1 + self.get_function_count(a)
             if rank == self.comm.rank:
                 self.my_atom_indices.append(a)
                 self.my_indices.append((a, I1, I2))
             I1 = I2
         self.nI = I1
 
-    def expand(self, q=-1, G1=0, G2=None, cc=False):
+    def expand(self, G1=0, G2=None, cc=False):
         """Expand functions in plane-waves.
 
         q: int
             k-point index.
         G1: int
             Start G-vector index.
         G2: int
             End G-vector index.
         cc: bool
             Complex conjugate.
         """
+        xp = self.xp
+
         if G2 is None:
-            G2 = self.Y_qGL[q].shape[0]
+            G2 = self.Y_GL.shape[0]
 
-        emiGR_Ga = self.emiGR_qGa[q][G1:G2]
-        f_Gs = self.f_qGs[q][G1:G2]
-        Y_GL = self.Y_qGL[q][G1:G2]
+        emiGR_Ga = self.emiGR_Ga[G1:G2]
+        f_Gs = self.f_Gs[G1:G2]
+        Y_GL = self.Y_GL[G1:G2]
 
-        if self.pd.dtype == complex:
-            f_GI = np.empty((G2 - G1, self.nI), complex)
+        if self.dtype == complex:
+            f_GI = xp.empty((G2 - G1, self.nI), complex)
         else:
             # Special layout because BLAS does not have real-complex
             # multiplications.  f_GI(G,I) layout:
             #
             #    real(G1, 0),   real(G1, 1),   ...
             #    imag(G1, 0),   imag(G1, 1),   ...
             #    real(G1+1, 0), real(G1+1, 1), ...
             #    imag(G1+1, 0), imag(G1+1, 1), ...
             #    ...
 
-            f_GI = np.empty((2 * (G2 - G1), self.nI))
+            f_GI = xp.empty((2 * (G2 - G1), self.nI))
 
-        if True:
+        if xp is np:
             # Fast C-code:
             _gpaw.pwlfc_expand(f_Gs, emiGR_Ga, Y_GL,
                                self.l_s, self.a_J, self.s_J,
                                cc, f_GI)
             return f_GI
+        elif cupy_is_fake or getattr(_gpaw, 'gpu_aware_mpi', False):
+            gpu_kernels.pwacf_expand(f_Gs, emiGR_Ga, Y_GL,
+                                     self.l_s, self.a_J, self.s_J,
+                                     cc, f_GI, self.I_J)
+            return f_GI
 
         # Equivalent slow Python code:
-        f_GI = np.empty((G2 - G1, self.nI), complex)
+        f_GI = xp.empty((G2 - G1, self.nI), complex)
         I1 = 0
         for J, (a, s) in enumerate(zip(self.a_J, self.s_J)):
             l = self.l_s[s]
             I2 = I1 + 2 * l + 1
             f_GI[:, I1:I2] = (f_Gs[:, s] *
                               emiGR_Ga[:, a] *
                               Y_GL[:, l**2:(l + 1)**2].T *
                               (-1.0j)**l).T
             I1 = I2
         if cc:
             f_GI = f_GI.conj()
-        if self.pd.dtype == float:
+        if self.dtype == float:
             f_GI = f_GI.T.copy().view(float).T.copy()
 
         return f_GI
 
-    def block(self, q=-1, ensure_same_number_of_blocks=False):
-        nG = self.Y_qGL[q].shape[0]
+    def block(self, ensure_same_number_of_blocks=False):
+        nG = self.Y_GL.shape[0]
         B = self.blocksize
         if B:
             G1 = 0
             while G1 < nG:
                 G2 = min(G1 + B, nG)
                 yield G1, G2
                 G1 = G2
             if ensure_same_number_of_blocks:
                 # Make sure we yield the same number of times:
-                nb = (self.pd.maxmyng + B - 1) // B
+                nb = (self.pw.maxmysize + B - 1) // B
                 mynb = (nG + B - 1) // B
                 if mynb < nb:
                     yield nG, nG  # empty block
         else:
             yield 0, nG
 
-    def add(self, a_xG, c_axi=1.0, q=-1, f0_IG=None):
-        c_xI = np.empty(a_xG.shape[:-1] + (self.nI,), self.pd.dtype)
+    def add(self, a_xG, c_axi=1.0, q=None):
+        if self.nI == 0:
+            return
+        c_xI = self.xp.empty(a_xG.shape[:-1] + (self.nI,), self.dtype)
 
         if isinstance(c_axi, float):
-            assert q == -1 and a_xG.ndim == 1
+            assert a_xG.ndim == 1
             c_xI[:] = c_axi
         else:
-            assert q != -1 or self.pd.only_one_k_point
             if self.comm.size != 1:
                 c_xI[:] = 0.0
             for a, I1, I2 in self.my_indices:
-                c_xI[..., I1:I2] = c_axi[a] * self.eikR_qa[q][a].conj()
+                c_xI[..., I1:I2] = c_axi[a] * self.eikR_a[a].conj()
             if self.comm.size != 1:
                 self.comm.sum(c_xI)
 
-        nx = np.prod(c_xI.shape[:-1], dtype=int)
+        nx = prod(c_xI.shape[:-1])
         c_xI = c_xI.reshape((nx, self.nI))
-        a_xG = a_xG.reshape((nx, a_xG.shape[-1])).view(self.pd.dtype)
+        a_xG = a_xG.reshape((nx, a_xG.shape[-1])).view(self.dtype)
 
-        for G1, G2 in self.block(q):
-            if f0_IG is None:
-                f_GI = self.expand(q, G1, G2, cc=False)
-            else:
-                1 / 0
-                # f_IG = f0_IG
+        for G1, G2 in self.block():
+            f_GI = self.expand(G1, G2, cc=False)
 
-            if self.pd.dtype == float:
+            if self.dtype == float:
                 # f_IG = f_IG.view(float)
                 G1 *= 2
                 G2 *= 2
 
-            mmm(1.0 / self.pd.gd.dv, c_xI, 'N', f_GI, 'T',
-                1.0, a_xG[:, G1:G2])
+            if self.xp is np:
+                mmm(1.0 / self.pw.dv, c_xI, 'N', f_GI, 'T',
+                    1.0, a_xG[:, G1:G2])
+            else:
+                self.xp.cublas.gemm('N', 'T',
+                                    c_xI, f_GI, a_xG[:, G1:G2],
+                                    1.0 / self.pw.dv, 1.0)
 
     def integrate(self, a_xG, c_axi=None, q=-1):
-        c_xI = np.zeros(a_xG.shape[:-1] + (self.nI,), self.pd.dtype)
+        xp = self.xp
+        if self.nI == 0:
+            return c_axi
+        c_xI = xp.zeros(a_xG.shape[:-1] + (self.nI,), self.dtype)
 
-        nx = np.prod(c_xI.shape[:-1], dtype=int)
+        nx = prod(c_xI.shape[:-1])
         b_xI = c_xI.reshape((nx, self.nI))
         a_xG = a_xG.reshape((nx, a_xG.shape[-1]))
 
-        alpha = 1.0 / self.pd.gd.N_c.prod()
-        if self.pd.dtype == float:
+        alpha = 1.0  # / self.pd.gd.N_c.prod()
+        if self.dtype == float:
             alpha *= 2
             a_xG = a_xG.view(float)
 
         if c_axi is None:
             c_axi = self.dict(a_xG.shape[:-1])
 
         x = 0.0
-        for G1, G2 in self.block(q):
-            f_GI = self.expand(q, G1, G2, cc=self.pd.dtype == complex)
-            if self.pd.dtype == float:
+        for G1, G2 in self.block():
+            f_GI = self.expand(G1, G2, cc=self.dtype == complex)
+            if self.dtype == float:
                 if G1 == 0 and self.comm.rank == 0:
                     f_GI[0] *= 0.5
                 G1 *= 2
                 G2 *= 2
-            mmm(alpha, a_xG[:, G1:G2], 'N', f_GI, 'N', x, b_xI)
+            if xp is np:
+                mmm(alpha, a_xG[:, G1:G2], 'N', f_GI, 'N', x, b_xI)
+            else:
+                xp.cublas.gemm('N', 'N',
+                               a_xG[:, G1:G2], f_GI, b_xI,
+                               alpha, x)
             x = 1.0
 
         self.comm.sum(b_xI)
         for a, I1, I2 in self.my_indices:
-            c_axi[a][:] = self.eikR_qa[q][a] * c_xI[..., I1:I2]
+            c_axi[a][:] = self.eikR_a[a] * c_xI[..., I1:I2]
 
         return c_axi
 
-    def matrix_elements(self, psit, out):
-        P_ani = {a: P_in.T for a, P_in in out.items()}
-        self.integrate(psit.array, P_ani, psit.kpt)
-
     def derivative(self, a_xG, c_axiv=None, q=-1):
-        c_vxI = np.zeros((3,) + a_xG.shape[:-1] + (self.nI,), self.pd.dtype)
-        nx = np.prod(c_vxI.shape[1:-1], dtype=int)
+        xp = self.xp
+        c_vxI = xp.zeros((3,) + a_xG.shape[:-1] + (self.nI,), self.dtype)
+        nx = prod(c_vxI.shape[1:-1])
         b_vxI = c_vxI.reshape((3, nx, self.nI))
-        a_xG = a_xG.reshape((nx, a_xG.shape[-1])).view(self.pd.dtype)
+        a_xG = a_xG.reshape((nx, a_xG.shape[-1])).view(self.dtype)
 
-        alpha = 1.0 / self.pd.gd.N_c.prod()
+        alpha = 1.0
 
         if c_axiv is None:
             c_axiv = self.dict(a_xG.shape[:-1], derivative=True)
 
-        K_v = self.pd.K_qv[q]
-
         x = 0.0
-        for G1, G2 in self.block(q):
-            f_GI = self.expand(q, G1, G2, cc=True)
-            G_Gv = self.pd.G_Qv[self.pd.myQ_qG[q][G1:G2]]
-            if self.pd.dtype == float:
-                d_GI = np.empty_like(f_GI)
+        for G1, G2 in self.block():
+            f_GI = self.expand(G1, G2, cc=True)
+            G_Gv = xp.asarray(self.pw.G_plus_k_Gv[G1:G2])
+            if self.dtype == float:
+                d_GI = xp.empty(f_GI.shape)
                 for v in range(3):
                     d_GI[::2] = f_GI[1::2] * G_Gv[:, v, np.newaxis]
                     d_GI[1::2] = f_GI[::2] * G_Gv[:, v, np.newaxis]
-                    mmm(2 * alpha,
-                        a_xG[:, 2 * G1:2 * G2], 'N',
-                        d_GI, 'N',
-                        x, b_vxI[v])
+                    if xp is np:
+                        mmm(2 * alpha,
+                            a_xG[:, 2 * G1:2 * G2], 'N',
+                            d_GI, 'N',
+                            x, b_vxI[v])
+                    else:
+                        xp.cublas.gemm('N', 'N',
+                                       a_xG[:, 2 * G1:2 * G2],
+                                       d_GI,
+                                       b_vxI[v],
+                                       2 * alpha, x)
             else:
                 for v in range(3):
-                    mmm(-alpha,
-                        a_xG[:, G1:G2], 'N',
-                        f_GI * (G_Gv[:, v] + K_v[v])[:, np.newaxis], 'N',
-                        x, b_vxI[v])
+                    if xp is np:
+                        mmm(-alpha,
+                            a_xG[:, G1:G2], 'N',
+                            f_GI * G_Gv[:, v, np.newaxis], 'N',
+                            x, b_vxI[v])
+                    else:
+                        xp.cublas.gemm('N', 'N',
+                                       a_xG[:, G1:G2],
+                                       f_GI * G_Gv[:, v, np.newaxis],
+                                       b_vxI[v],
+                                       -alpha, x)
             x = 1.0
 
         self.comm.sum(c_vxI)
 
         for v in range(3):
-            if self.pd.dtype == float:
+            if self.dtype == float:
                 for a, I1, I2 in self.my_indices:
                     c_axiv[a][..., v] = c_vxI[v, ..., I1:I2]
             else:
                 for a, I1, I2 in self.my_indices:
-                    c_axiv[a][..., v] = (1.0j * self.eikR_qa[q][a] *
+                    c_axiv[a][..., v] = (1.0j * self.eikR_a[a] *
                                          c_vxI[v, ..., I1:I2])
 
         return c_axiv
 
-    def stress_tensor_contribution(self, a_xG, c_axi=1.0, q=-1):
+    def stress_tensor_contribution(self, a_xG, c_axi=1.0):
+        xp = self.xp
         cache = {}
         things = []
         I1 = 0
         lmax = 0
         for a, spline_j in enumerate(self.spline_aj):
             for spline in spline_j:
                 if spline not in cache:
                     s = ft(spline)
-                    G_G = self.pd.G2_qG[q]**0.5
+                    G_G = (2 * self.pw.ekin_G)**0.5
                     f_G = []
                     dfdGoG_G = []
                     for G in G_G:
                         f, dfdG = s.get_value_and_derivative(G)
                         if G < 1e-10:
                             G = 1.0
                         f_G.append(f)
                         dfdGoG_G.append(dfdG / G)
-                    f_G = np.array(f_G)
-                    dfdGoG_G = np.array(dfdGoG_G)
+                    f_G = xp.array(f_G)
+                    dfdGoG_G = xp.array(dfdGoG_G)
                     cache[spline] = (f_G, dfdGoG_G)
                 else:
                     f_G, dfdGoG_G = cache[spline]
                 l = spline.l
                 lmax = max(l, lmax)
                 I2 = I1 + 2 * l + 1
                 things.append((a, l, I1, I2, f_G, dfdGoG_G))
                 I1 = I2
 
         if isinstance(c_axi, float):
             c_axi = dict((a, c_axi) for a in range(len(self.pos_av)))
 
-        G0_Gv = self.pd.get_reciprocal_vectors(q=q)
+        G0_Gv = self.pw.G_plus_k_Gv
 
-        stress_vv = np.zeros((3, 3))
-        for G1, G2 in self.block(q, ensure_same_number_of_blocks=True):
+        stress_vv = xp.zeros((3, 3))
+        for G1, G2 in self.block(ensure_same_number_of_blocks=True):
             G_Gv = G0_Gv[G1:G2]
-            Z_LvG = np.array([nablarlYL(L, G_Gv.T)
+            Z_LvG = xp.array([nablarlYL(L, G_Gv.T)
                               for L in range((lmax + 1)**2)])
+            G_Gv = xp.asarray(G_Gv)
             aa_xG = a_xG[..., G1:G2]
             for v1 in range(3):
                 for v2 in range(3):
                     stress_vv[v1, v2] += self._stress_tensor_contribution(
-                        v1, v2, things, G1, G2, G_Gv, aa_xG, c_axi, q, Z_LvG)
+                        v1, v2, things, G1, G2, G_Gv, aa_xG, c_axi, Z_LvG)
 
         self.comm.sum(stress_vv)
 
         return stress_vv
 
     def _stress_tensor_contribution(self, v1, v2, things, G1, G2,
-                                    G_Gv, a_xG, c_axi, q, Z_LvG):
-        f_IG = np.empty((self.nI, G2 - G1), complex)
-        emiGR_Ga = self.emiGR_qGa[q][G1:G2]
-        Y_LG = self.Y_qGL[q].T
+                                    G_Gv, a_xG, c_axi, Z_LvG):
+        xp = self.xp
+        f_IG = xp.empty((self.nI, G2 - G1), complex)
+        emiGR_Ga = self.emiGR_Ga[G1:G2]
+        Y_LG = self.Y_GL.T
         for a, l, I1, I2, f_G, dfdGoG_G in things:
             L1 = l**2
             L2 = (l + 1)**2
             f_IG[I1:I2] = (emiGR_Ga[:, a] * (-1.0j)**l *
                            (dfdGoG_G[G1:G2] * G_Gv[:, v1] * G_Gv[:, v2] *
                             Y_LG[L1:L2, G1:G2] +
                             f_G[G1:G2] * G_Gv[:, v1] * Z_LvG[L1:L2, v2]))
 
-        c_xI = np.zeros(a_xG.shape[:-1] + (self.nI,), self.pd.dtype)
+        c_xI = xp.zeros(a_xG.shape[:-1] + (self.nI,), self.pw.dtype)
 
-        x = np.prod(c_xI.shape[:-1], dtype=int)
+        x = prod(c_xI.shape[:-1])
         b_xI = c_xI.reshape((x, self.nI))
         a_xG = a_xG.reshape((x, a_xG.shape[-1]))
 
-        alpha = 1.0 / self.pd.gd.N_c.prod()
-        if self.pd.dtype == float:
-            alpha *= 2
-            if G1 == 0 and self.pd.gd.comm.rank == 0:
+        alpha = 1.0
+        if self.pw.dtype == float:
+            alpha = 2.0
+            if G1 == 0 and self.pw.comm.rank == 0:
                 f_IG[:, 0] *= 0.5
             f_IG = f_IG.view(float)
             a_xG = a_xG.copy().view(float)
 
-        mmm(alpha, a_xG, 'N', f_IG, 'C', 0.0, b_xI)
+        if xp is np:
+            mmm(alpha, a_xG, 'N', f_IG, 'C', 0.0, b_xI)
+        else:
+            xp.cublas.gemm('N', 'H', a_xG, f_IG, b_xI, alpha, 0.0)
         self.comm.sum(b_xI)
 
         stress = 0.0
         for a, I1, I2 in self.my_indices:
-            stress -= self.eikR_qa[q][a] * (c_axi[a] * c_xI[..., I1:I2]).sum()
+            stress -= self.eikR_a[a] * (c_axi[a] * c_xI[..., I1:I2]).sum()
         return stress.real
```

### Comparing `gpaw-22.8.0/gpaw/raman/dipoletransition.py` & `gpaw-23.6.0/gpaw/lcao/dipoletransition.py`

 * *Files 4% similar despite different names*

```diff
@@ -61,14 +61,15 @@
                                                        ksl.Mstop, False,
                                                        derivative=True)
 
     mome_skvnm = np.zeros((nspins, nk, 3, nbands, nbands), dtype=dtype)
     momd_skvnm = np.zeros((nspins, nk, 3, nbands, nbands), dtype=dtype)
     moma_skvnm = np.zeros((nspins, nk, 3, nbands, nbands), dtype=dtype)
 
+    B_cv = 2.0 * np.pi * gd.icell_cv
     for kpt in wfs.kpt_u:
         C_nM = kpt.C_nM
         for v in range(3):
             dThetadRv_MM = dThetadR_qvMM[kpt.q, v]
             nabla_nn = -(C_nM.conj() @ dThetadRv_MM.conj() @ C_nM.T)
             gd.comm.sum(nabla_nn)
             mome_skvnm[kpt.s, kpt.k, v] = nabla_nn
@@ -79,17 +80,17 @@
             nabla_iiv = wfs.setups[a].nabla_iiv
             moma_vnm += np.einsum('ni,ijv,mj->vnm',
                                   P_ni.conj(), nabla_iiv, P_ni)
         gd.comm.sum(moma_vnm)
         moma_skvnm[kpt.s, kpt.k] = moma_vnm
 
         # diagonal term
+        k_v = np.dot(wfs.kd.ibzk_kc[kpt.k], B_cv)
         momd_skvnm[kpt.s, kpt.k] = np.einsum("k,nm->knm",
-                                             wfs.kd.ibzk_kc[kpt.k],
-                                             np.identity(nbands))
+                                             k_v, np.identity(nbands))
 
     mom_skvnm = momd_skvnm - 1j * (mome_skvnm + moma_skvnm)
     wfs.kd.comm.sum(mom_skvnm)
 
     if world.rank == 0 and savetofile:
         np.save('mom_skvnm.npy', mom_skvnm)
     return mom_skvnm
```

### Comparing `gpaw-22.8.0/gpaw/raman/raman.py` & `gpaw-23.6.0/gpaw/raman/raman.py`

 * *Files 9% similar despite different names*

```diff
@@ -3,15 +3,15 @@
 
 i -> j -> m -> n
 i, n are valence; j, m are conduction, also i=n in the end
 see https://doi.org/10.1038/s41467-020-16529-6
 """
 
 import numpy as np
-from ase.units import invcm
+from ase.units import invcm, Hartree
 
 
 def lorentzian(w, gamma):
     l = 0.5 * gamma / (np.pi * (w**2 + 0.25 * gamma**2))
     return l
 
 
@@ -63,15 +63,15 @@
     if isinstance(w_ph, str):
         w_ph = np.load(w_ph)
     assert max(w_ph) < 1.  # else not eV units
     nmodes = len(w_ph)
 
     # Set grid
     w_max = np.round(np.max(w_ph) / invcm + 50, -1)  # max of grid in rcm
-    ngrid = int(w_max / gridspacing)
+    ngrid = int(w_max / gridspacing) + 1
     w = np.linspace(0., w_max, num=ngrid) * invcm  # in eV
 
     # Load files
     mom_skvnm = np.load(momname, mmap_mode='c')
     g_sqklnn = np.load(elphname, mmap_mode='c')  # [s,q=0,k,l,n,m]
 
     # Define a few more variables
@@ -86,28 +86,30 @@
     # valence is ket in ij and bra in mn
     # ab is in and out polarization
     # l is the phonon mode and w is the raman shift
 
     # XXX: The below can probably be made better by lambdas a lot
     def _term1(f_vc, E_vc, mom_dnn, elph_lnn, nc, nv):
         term1_l = np.zeros((elph_lnn.shape[0]), dtype=complex)
-        t1_ij = f_vc * mom_dnn[0, nc:, :nv].T / (w_in - E_vc)
+        t1_ij = f_vc * mom_dnn[0, :nv, nc:] / (w_in - E_vc)
+        # t1_ij = f_vc * mom_dnn[0, nc:, :nv].T / (w_in - E_vc)
         for l in range(nmodes):
             t1_xx = elph_lnn[l]
-            t1_mn = (f_vc * mom_dnn[1, :nv, nc:] / (w_in - w_ph[l] - E_vc)).T
+            # t1_mn = (f_vc * mom_dnn[1, :nv, nc:] / (w_in - w_ph[l] - E_vc)).T
+            t1_mn = f_vc.T * mom_dnn[1, nc:, :nv] / (w_in - w_ph[l] - E_vc.T)
             term1_l[l] += np.einsum('sj,jm,ms', t1_ij, t1_xx[nc:, nc:], t1_mn,
                                     optimize=opt)
             term1_l[l] -= np.einsum('is,ni,sn', t1_ij, t1_xx[:nv, :nv], t1_mn,
                                     optimize=opt)
         return term1_l
 
     def _term2(f_vc, E_vc, mom_dnn, elph_lnn, nc, nv):
         term2_lw = np.zeros((nmodes, ngrid), dtype=complex)
-        t2_ij = f_vc * mom_dnn[0, nc:, :nv].T / (w_in - E_vc)
-        t2_xx = mom_dnn[1]  # XXX might need to T or conj
+        t2_ij = f_vc * mom_dnn[0, :nv, nc:] / (w_in - E_vc)
+        t2_xx = mom_dnn[1]
         for l in range(nmodes):
             for wi in range(ngrid):
                 t2_mn = f_vc.T * elph_lnn[l][nc:, :nv] / (w[wi] - E_vc.T)
                 term2_lw[l, wi] += np.einsum('sj,jm,ms', t2_ij,
                                              t2_xx[nc:, nc:], t2_mn,
                                              optimize=opt)
                 term2_lw[l, wi] -= np.einsum('is,ni,sn', t2_ij,
@@ -116,60 +118,60 @@
         return term2_lw
 
     def _term3(f_vc, E_vc, mom_dnn, elph_lnn, nc, nv):
         term3_lw = np.zeros((nmodes, ngrid), dtype=complex)
         for l in range(nmodes):
             t3_xx = elph_lnn[l]
             for wi in range(ngrid):
-                t3_ij = f_vc * mom_dnn[1, nc:, :nv].T / (-w_in + w[wi] - E_vc)
-                t3_mn = (f_vc * mom_dnn[0, :nv, nc:] / (-w_in - w_ph[l] + w[wi]
-                                                        - E_vc)).T
+                t3_ij = f_vc * mom_dnn[1, :nv, nc:] / (-w_in + w[wi] - E_vc)
+                t3_mn = (f_vc.T * mom_dnn[0, :nv, nc:] / (-w_in - w_ph[l] +
+                                                          w[wi] - E_vc.T))
                 term3_lw[l, wi] += np.einsum('sj,jm,ms', t3_ij,
                                              t3_xx[nc:, nc:], t3_mn,
                                              optimize=opt)
                 term3_lw[l, wi] -= np.einsum('is,ni,sn', t3_ij,
                                              t3_xx[:nv, :nv], t3_mn,
                                              optimize=opt)
         return term3_lw
 
     def _term4(f_vc, E_vc, mom_dnn, elph_lnn, nc, nv):
         term4_lw = np.zeros((nmodes, ngrid), dtype=complex)
-        t4_xx = mom_dnn[0]  # XXX might need to T or conj
+        t4_xx = mom_dnn[0]
         for l in range(nmodes):
             for wi in range(ngrid):
-                t4_ij = f_vc * mom_dnn[1, nc:, :nv].T / (-w_in + w[wi] - E_vc)
-                t4_mn = (f_vc * elph_lnn[l, nc:, :nv].T / (w[wi] - E_vc)).T
+                t4_ij = f_vc * mom_dnn[1, :nv, nc:] / (-w_in + w[wi] - E_vc)
+                t4_mn = (f_vc.T * elph_lnn[l, nc:, :nv] / (w[wi] - E_vc.T))
                 term4_lw[l, wi] += np.einsum('sj,jm,ms', t4_ij,
                                              t4_xx[nc:, nc:], t4_mn,
                                              optimize=opt)
                 term4_lw[l, wi] -= np.einsum('is,ni,sn', t4_ij,
                                              t4_xx[:nv, :nv], t4_mn,
                                              optimize=opt)
         return term4_lw
 
     def _term5(f_vc, E_vc, mom_dnn, elph_lnn, nc, nv):
         term5_l = np.zeros((nmodes), dtype=complex)
-        t5_xx = mom_dnn[0]  # XXX might need to T or conj
+        t5_xx = mom_dnn[0]
         for l in range(nmodes):
             t5_ij = f_vc * elph_lnn[l, :nv, nc:] / (-w_ph[l] - E_vc)
-            t5_mn = (f_vc * mom_dnn[1, :nv, nc:] / (w_in - w_ph[l] - E_vc)).T
+            t5_mn = (f_vc.T * mom_dnn[1, nc:, :nv] / (w_in - w_ph[l] - E_vc.T))
             term5_l[l] += np.einsum('sj,jm,ms', t5_ij, t5_xx[nc:, nc:], t5_mn,
                                     optimize=opt)
             term5_l[l] -= np.einsum('is,ni,sn', t5_ij, t5_xx[:nv, :nv], t5_mn,
                                     optimize=opt)
         return term5_l
 
     def _term6(f_vc, E_vc, mom_dnn, elph_lnn, nc, nv):
         term6_lw = np.zeros((nmodes, ngrid), dtype=complex)
-        t6_xx = mom_dnn[1]  # XXX might need to T or conj
+        t6_xx = mom_dnn[1]
         for l in range(nmodes):
             t6_ij = f_vc * elph_lnn[l, :nv, nc:] / (-w_ph[l] - E_vc)
             for wi in range(ngrid):
-                t6_mn = (f_vc * mom_dnn[0, :nv, nc:] / (-w_in - w_ph[l] + w[wi]
-                                                        - E_vc)).T
+                t6_mn = (f_vc.T * mom_dnn[0, nc:, :nv] / (-w_in - w_ph[l]
+                                                          + w[wi] - E_vc.T))
                 term6_lw[l, wi] += np.einsum('sj,jm,ms', t6_ij,
                                              t6_xx[nc:, nc:], t6_mn,
                                              optimize=opt)
                 term6_lw[l, wi] -= np.einsum('is,ni,sn', t6_ij,
                                              t6_xx[:nv, :nv], t6_mn,
                                              optimize=opt)
         return term6_lw
@@ -183,37 +185,49 @@
     for kpt in calc.wfs.kpt_u:
         print("Rank {}: s={}, k={}".format(kd.comm.rank, kpt.s, kpt.k))
 
         # Check if we need to add timer-add time reversed kpoint
         if (calc.symmetry.time_reversal and not
             np.allclose(kd.ibzk_kc[kpt.k], [0., 0., 0.])):
             add_time_reversed = True
+            # Currently broken
+            raise NotImplementedError
         else:
             add_time_reversed = False
 
         # Limit sums to relevant bands, partially occupied bands are a pain.
         # So, in principal, partially occupied bands can be initial and
         # final states, but we need to restrict to a positive deltaE if we
         # allow this.
         f_n = kpt.f_n / kpt.weight
         assert np.isclose(max(f_n), 1.0, atol=0.1)
-        vs = np.where(f_n >= 0.1)[0]
-        cs = np.where(f_n < 0.9)[0]
-        nv = max(vs) + 1  # VBM+1 index
-        nc = min(cs)  # CBM index
+
+        if 1:
+            vs = np.arange(0, len(f_n))
+            cs = np.arange(0, len(f_n))
+            nc = 0
+            nv = len(f_n)
+        else:
+            vs = np.where(f_n >= 0.1)[0]
+            cs = np.where(f_n < 0.9)[0]
+            nv = max(vs) + 1  # VBM+1 index
+            nc = min(cs)  # CBM index
 
         # Precalculate f * (1-f) term
-        f_vc = np.outer(kpt.f_n[vs], 1. - kpt.f_n[cs])
+        f_vc = np.outer(f_n[vs], 1. - f_n[cs])
+
         # Precalculate E-E term
         E_vc = np.empty((len(vs), len(cs)), dtype=complex)
-        for n in vs:
-            E_vc[n] = kpt.eps_n[cs] - kpt.eps_n[n] + 1j * gamma_l
+        for n in range(len(vs)):
+            E_vc[n] = (kpt.eps_n[cs] - kpt.eps_n[n]) * Hartree + 1j * gamma_l
+
             # set weights for negative energy transitions zero
-            neg = np.where(E_vc[n].real <= 0.)[0]
-            f_vc[n, neg] = 0.
+            if 0:
+                neg = np.where(E_vc[n].real <= 0.)[0]
+                f_vc[n, neg] = 0.
 
         # Obtain appropriate part of mom and g arrays
         mom_dnn = np.ascontiguousarray(mom_skvnm[kpt.s, kpt.k, [d_i, d_o]])
         assert mom_dnn.shape[0] == 2
         g_lnn = np.ascontiguousarray(g_sqklnn[kpt.s, 0, kpt.k])
 
         # Raman contribution of this k-point
@@ -315,15 +329,15 @@
         int_bare += R.real * delta
         int_occ += occ / w_ph[l] * R.real * delta
 
     raman = np.vstack((w, int_bare, int_occ))
     np.save("RI_{}{}_{}.npy".format('xyz'[d_i], 'xyz'[d_o], suffix), raman)
 
 
-def plot_raman(figname, RIsuffix, relative=True, w_min=None, w_max=None):
+def plot_raman(figname, RIsuffix, relative=False, w_min=None, w_max=None):
     """Plots a given Raman spectrum.
 
     Parameters
     ----------
     figname: str
         Filename for figure.
     RIsuffix: str, list
```

### Comparing `gpaw-22.8.0/gpaw/response/bse.py` & `gpaw-23.6.0/gpaw/response/bse.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,157 +1,100 @@
 import functools
 from time import time, ctime
 from datetime import timedelta
-import sys
 
 import numpy as np
 from ase.units import Hartree, Bohr
-from ase.utils import IOContext
 from ase.dft import monkhorst_pack
 from scipy.linalg import eigh
 
-from gpaw import GPAW
 from gpaw.kpt_descriptor import KPointDescriptor
-from gpaw.pw.descriptor import PWDescriptor
 from gpaw.blacs import BlacsGrid, Redistributor
-from gpaw.mpi import world, serial_comm, broadcast
-from gpaw.response.chi0 import Chi0
-from gpaw.response.kernels import get_coulomb_kernel
-from gpaw.response.kernels import get_integrated_kernel
-from gpaw.response.wstc import WignerSeitzTruncatedCoulomb
-from gpaw.response.pair import PairDensity
-from gpaw.response.gamma_int import GammaIntegrator
-from gpaw.response.groundstate import ResponseGroundStateAdapter
+from gpaw.mpi import world, serial_comm
+from gpaw.response import ResponseContext
+from gpaw.response.df import write_response_function
+from gpaw.response.coulomb_kernels import CoulombKernel
+from gpaw.response.screened_interaction import initialize_w_calculator
+from gpaw.response.paw import PWPAWCorrectionData
+from gpaw.response.frequencies import FrequencyDescriptor
+from gpaw.response.pair import PairDensityCalculator, get_gs_and_context
+from gpaw.response.pair_functions import SingleQPWDescriptor
+from gpaw.response.chi0 import Chi0Calculator
 
 
-class BSE:
-    def __init__(self,
-                 calc=None,
+class BSEBackend:
+    def __init__(self, *, gs, context,
                  spinors=False,
                  ecut=10.,
                  scale=1.0,
                  nbands=None,
                  valence_bands=None,
                  conduction_bands=None,
                  eshift=None,
                  gw_skn=None,
                  truncation=None,
                  integrate_gamma=1,
-                 txt=sys.stdout,
                  mode='BSE',
                  wfile=None,
                  write_h=False,
                  write_v=False):
+        self.gs = gs
+        self.context = context
 
-        """Creates the BSE object
-
-        calc: str or calculator object
-            The string should refer to the .gpw file contaning KS orbitals
-        ecut: float
-            Plane wave cutoff energy (eV)
-        nbands: int
-            Number of bands used for the screened interaction
-        valence_bands: list
-            Valence bands used in the BSE Hamiltonian
-        conduction_bands: list
-            Conduction bands used in the BSE Hamiltonian
-        eshift: float
-            Scissors operator opening the gap (eV)
-        gw_skn: list / array
-            List or array defining the gw quasiparticle energies used in
-            the BSE Hamiltonian. Should match spin, k-points and
-            valence/conduction bands
-        truncation: str
-            Coulomb truncation scheme. Can be either wigner-seitz,
-            2D, 1D, or 0D
-        integrate_gamma: int
-            Method to integrate the Coulomb interaction. 1 is a numerical
-            integration at all q-points with G=[0,0,0] - this breaks the
-            symmetry slightly. 0 is analytical integration at q=[0,0,0] only -
-            this conserves the symmetry. integrate_gamma=2 is the same as 1,
-            but the average is only carried out in the non-periodic directions.
-        txt: str
-            txt output
-        mode: str
-            Theory level used. can be RPA TDHF or BSE. Only BSE is screened.
-        wfile: str
-            File for saving screened interaction and some other stuff
-            needed later
-        write_h: bool
-            If True, write the BSE Hamiltonian to H_SS.ulm.
-        write_v: bool
-            If True, write eigenvalues and eigenstates to v_TS.ulm
-        """
-
-        # Calculator
-        if isinstance(calc, str):
-            calc = GPAW(calc, communicator=serial_comm)
-        self.calc = calc
-        self.gs = ResponseGroundStateAdapter(calc)
         self.spinors = spinors
         self.scale = scale
 
         assert mode in ['RPA', 'TDHF', 'BSE']
 
-        self.iocontext = IOContext()
-        self.fd = self.iocontext.openfile(txt)
-
         self.ecut = ecut / Hartree
         self.nbands = nbands
         self.mode = mode
-        self.truncation = truncation
+
         if integrate_gamma == 0 and truncation is not None:
-            print('***WARNING*** Analytical Coulomb integration is ' +
-                  'not expected to work with Coulomb truncation. ' +
-                  'Use integrate_gamma=1', file=self.fd)
+            self.context.print('***WARNING*** Analytical Coulomb integration' +
+                               ' is not expected to work with Coulomb ' +
+                               'truncation. Use integrate_gamma=1')
         self.integrate_gamma = integrate_gamma
         self.wfile = wfile
         self.write_h = write_h
         self.write_v = write_v
 
         # Find q-vectors and weights in the IBZ:
         self.kd = self.gs.kd
         if -1 in self.kd.bz2bz_ks:
-            print('***WARNING*** Symmetries may not be right ' +
-                  'Use gamma-centered grid to be sure', file=self.fd)
+            self.context.print('***WARNING*** Symmetries may not be right. '
+                               'Use gamma-centered grid to be sure')
         offset_c = 0.5 * ((self.kd.N_c + 1) % 2) / self.kd.N_c
         bzq_qc = monkhorst_pack(self.kd.N_c) + offset_c
         self.qd = KPointDescriptor(bzq_qc)
         self.qd.set_symmetry(self.gs.atoms, self.kd.symmetry)
-        self.vol = self.gs.volume
 
         # bands
         self.spins = self.gs.nspins
         if self.spins == 2:
             if self.spinors:
                 self.spinors = False
-                print('***WARNING*** Presently the spinor version' +
-                      'does not work for spin-polarized calculations.' +
-                      'Performing scalar calculation', file=self.fd)
+                self.context.print('***WARNING*** Presently the spinor ' +
+                                   'version does not work for spin-polarized' +
+                                   ' calculations. Performing scalar ' +
+                                   'calculation')
             assert len(valence_bands[0]) == len(valence_bands[1])
             assert len(conduction_bands[0]) == len(conduction_bands[1])
         if valence_bands is None:
-            # XXX nvalence are the valence electrons on the setups,
-            # but that's not the actual number of valence electrons
-            # if the calculation is charged.  Is this a bug?
-            nv = self.gs.setups.nvalence
+            nv = self.gs.nvalence
             valence_bands = [[nv // 2 - 1]]
             if self.spins == 2:
                 valence_bands *= 2
         if conduction_bands is None:
             conduction_bands = [[valence_bands[-1] + 1]]
             if self.spins == 2:
                 conduction_bands *= 2
 
-        self.val_sn = np.array(valence_bands)
-        if len(np.shape(self.val_sn)) == 1:
-            self.val_sn = np.array([self.val_sn])
-        self.con_sn = np.array(conduction_bands)
-        if len(np.shape(self.con_sn)) == 1:
-            self.con_sn = np.array([self.con_sn])
+        self.val_sn = np.atleast_2d(valence_bands)
+        self.con_sn = np.atleast_2d(conduction_bands)
 
         self.td = True
         for n in self.val_sn[0]:
             if n in self.con_sn[0]:
                 self.td = False
         if len(self.val_sn) == 2:
             for n in self.val_sn[1]:
@@ -171,90 +114,81 @@
         self.gw_skn = gw_skn
         self.eshift = eshift
 
         # Number of pair orbitals
         self.nS = self.kd.nbzkpts * self.nv * self.nc * self.spins
         self.nS *= (self.spinors + 1)**2
 
-        # Wigner-Seitz stuff
-        if self.truncation == 'wigner-seitz':
-            self.wstc = WignerSeitzTruncatedCoulomb(self.gs.gd.cell_cv,
-                                                    self.kd.N_c, self.fd)
-        else:
-            self.wstc = None
+        self.coulomb = CoulombKernel(truncation=truncation, gs=self.gs)
+        self.context.print(self.coulomb.description())
 
         self.print_initialization(self.td, self.eshift, self.gw_skn)
 
         # Chi0 object
         self._chi0calc = None  # Initialized later
+        self._wcalc = None  # Initialized later
 
-    def __del__(self):
-        self.iocontext.close()
-
-    def calculate(self, optical=True, ac=1.0):
+    def calculate(self, optical=True):
 
         if self.spinors:
             # Calculate spinors. Here m is index of eigenvalues with SOC
             # and n is the basis of eigenstates without SOC. Below m is used
             # for unoccupied states and n is used for occupied states so be
             # careful!
 
-            print('Diagonalizing spin-orbit Hamiltonian', file=self.fd)
-            if world.rank == 0:
-                # XXX Probably not a good idea for this to be serial!
-                soc = self.gs.soc_eigenstates(scale=self.scale)
-                e_mk = soc.eigenvalues().T
-                v_kmsn = soc.eigenvectors()
-                e_mk /= Hartree
-                data = (e_mk, v_kmsn)
-            else:
-                data = None
-            e_mk, v_kmsn = broadcast(data, 0, world)
+            self.context.print('Diagonalizing spin-orbit Hamiltonian')
+            soc = self.gs.soc_eigenstates(scale=self.scale)
+            e_mk = soc.eigenvalues().T
+            v_kmn = soc.eigenvectors()
+            e_mk /= Hartree
 
         # Parallelization stuff
         nK = self.kd.nbzkpts
         myKrange, myKsize, mySsize = self.parallelisation_sizes()
 
         # Calculate exchange interaction
-        qd0 = KPointDescriptor([self.q_c])
-        pd0 = PWDescriptor(self.ecut, self.gs.gd, complex, qd0)
+        qpd0 = SingleQPWDescriptor.from_q(self.q_c, self.ecut, self.gs.gd)
         ikq_k = self.kd.find_k_plus_q(self.q_c)
-        v_G = get_coulomb_kernel(pd0, self.kd.N_c, truncation=self.truncation,
-                                 wstc=self.wstc)
+        v_G = self.coulomb.V(qpd=qpd0, q_v=None)
+
         if optical:
             v_G[0] = 0.0
 
-        self.pair = PairDensity(self.calc, world=serial_comm,
-                                txt='pair.txt')
+        self.pair = PairDensityCalculator(
+            gs=self.gs,
+            context=ResponseContext(txt='pair.txt', timer=None,
+                                    comm=serial_comm))
 
         # Calculate direct (screened) interaction and PAW corrections
         if self.mode == 'RPA':
-            Q_aGii = self.pair.initialize_paw_corrections(pd0)
+            pairden_paw_corr = self.gs.pair_density_paw_corrections
+            pawcorr = pairden_paw_corr(qpd0)
         else:
-            self.get_screened_potential(ac=ac)
+            self.get_screened_potential()
             if (self.qd.ibzk_kc - self.q_c < 1.0e-6).all():
                 iq0 = self.qd.bz2ibz_k[self.kd.where_is_q(self.q_c,
                                                           self.qd.bzk_kc)]
-                Q_aGii = self.Q_qaGii[iq0]
+                pawcorr = self.pawcorr_q[iq0]  # Q_qaGii[iq0]
             else:
-                Q_aGii = self.pair.initialize_paw_corrections(pd0)
+                pairden_paw_corr = self.gs.pair_density_paw_corrections
+                pawcorr = pairden_paw_corr(qpd0)
 
         # Calculate pair densities, eigenvalues and occupations
         so = self.spinors + 1
         Nv, Nc = so * self.nv, so * self.nc
         Ns = self.spins
         rhoex_KsmnG = np.zeros((nK, Ns, Nv, Nc, len(v_G)), complex)
         # rhoG0_Ksmn = np.zeros((nK, Ns, Nv, Nc), complex)
         df_Ksmn = np.zeros((nK, Ns, Nv, Nc), float)  # -(ev - ec)
         deps_ksmn = np.zeros((myKsize, Ns, Nv, Nc), float)  # -(fv - fc)
 
         optical_limit = np.allclose(self.q_c, 0.0)
 
         get_pair = self.pair.get_kpoint_pair
-        get_rho = self.pair.get_pair_density
+        get_pair_density = self.pair.get_pair_density
         if self.spinors:
             # Get all pair densities to allow for SOC mixing
             # Use twice as many no-SOC states as BSE bands to allow mixing
             vi_s = [2 * self.val_sn[0, 0] - self.val_sn[0, -1] - 1]
             vf_s = [2 * self.con_sn[0, -1] - self.con_sn[0, 0] + 2]
             if vi_s[0] < 0:
                 vi_s[0] = 0
@@ -265,15 +199,15 @@
             mci = 2 * self.con_sn[0, 0]
             mcf = 2 * (self.con_sn[0, -1] + 1)
         else:
             vi_s, vf_s = self.val_sn[:, 0], self.val_sn[:, -1] + 1
             ci_s, cf_s = self.con_sn[:, 0], self.con_sn[:, -1] + 1
         for ik, iK in enumerate(myKrange):
             for s in range(Ns):
-                pair = get_pair(pd0, s, iK,
+                pair = get_pair(qpd0, s, iK,
                                 vi_s[s], vf_s[s], ci_s[s], cf_s[s])
                 m_m = np.arange(vi_s[s], vf_s[s])
                 n_n = np.arange(ci_s[s], cf_s[s])
                 if self.gw_skn is not None:
                     iKq = self.gs.kd.find_k_plus_q(self.q_c, [iK])[0]
                     epsv_m = self.gw_skn[s, iK, :self.nv]
                     epsc_n = self.gw_skn[s, iKq, self.nv:]
@@ -284,34 +218,36 @@
                     epsc_n = e_mk[mci:mcf, iKq]
                     deps_ksmn[ik, s] = -(epsv_m[:, np.newaxis] - epsc_n)
                 else:
                     deps_ksmn[ik, s] = -pair.get_transition_energies(m_m, n_n)
 
                 df_mn = pair.get_occupation_differences(self.val_sn[s],
                                                         self.con_sn[s])
-                rho_mnG = get_rho(pd0, pair,
-                                  m_m, n_n,
-                                  optical_limit=optical_limit,
-                                  direction=self.direction,
-                                  Q_aGii=Q_aGii,
-                                  extend_head=False)
+                rho_mnG = get_pair_density(qpd0, pair, m_m, n_n,
+                                           pawcorr=pawcorr)
+                if optical_limit:
+                    n_mnv = self.pair.get_optical_pair_density_head(qpd0, pair,
+                                                                    m_m, n_n)
+                    rho_mnG[:, :, 0] = n_mnv[:, :, self.direction]
                 if self.spinors:
+                    v0_kmn = v_kmn[:, :, ::2]
+                    v1_kmn = v_kmn[:, :, 1::2]
                     if optical_limit:
                         deps0_mn = -pair.get_transition_energies(m_m, n_n)
                         rho_mnG[:, :, 0] *= deps0_mn
                     df_Ksmn[iK, s, ::2, ::2] = df_mn
                     df_Ksmn[iK, s, ::2, 1::2] = df_mn
                     df_Ksmn[iK, s, 1::2, ::2] = df_mn
                     df_Ksmn[iK, s, 1::2, 1::2] = df_mn
-                    vecv0_mn = v_kmsn[iK, mvi:mvf, 0, ni:nf]
-                    vecc0_mn = v_kmsn[iKq, mci:mcf, 0, ni:nf]
+                    vecv0_mn = v0_kmn[iK, mvi:mvf, ni:nf]
+                    vecc0_mn = v0_kmn[iKq, mci:mcf, ni:nf]
                     rho_0mnG = np.dot(vecv0_mn.conj(),
                                       np.dot(vecc0_mn, rho_mnG))
-                    vecv1_mn = v_kmsn[iK, mvi:mvf, 1, ni:nf]
-                    vecc1_mn = v_kmsn[iKq, mci:mcf, 1, ni:nf]
+                    vecv1_mn = v1_kmn[iK, mvi:mvf, ni:nf]
+                    vecc1_mn = v1_kmn[iKq, mci:mcf, ni:nf]
                     rho_1mnG = np.dot(vecv1_mn.conj(),
                                       np.dot(vecc1_mn, rho_mnG))
                     rhoex_KsmnG[iK, s] = rho_0mnG + rho_1mnG
                     if optical_limit:
                         rhoex_KsmnG[iK, s, :, :, 0] /= deps_ksmn[ik, s]
                 else:
                     df_Ksmn[iK, s] = pair.get_occupation_differences(m_m, n_n)
@@ -327,16 +263,16 @@
         self.rhoG0_S = np.reshape(rhoex_KsmnG[:, :, :, :, 0], -1)
 
         if hasattr(self, 'H_sS'):
             return
 
         # Calculate Hamiltonian
         t0 = time()
-        print('Calculating %s matrix elements at q_c = %s'
-              % (self.mode, self.q_c), file=self.fd)
+        self.context.print('Calculating %s matrix elements at q_c = %s' % (
+            self.mode, self.q_c))
         H_ksmnKsmn = np.zeros((myKsize, Ns, Nv, Nc, nK, Ns, Nv, Nc), complex)
         for ik1, iK1 in enumerate(myKrange):
             for s1 in range(Ns):
                 kptv1 = self.pair.get_k_point(s1, iK1, vi_s[s1], vf_s[s1])
                 kptc1 = self.pair.get_k_point(s1, ikq_k[iK1], ci_s[s1],
                                               cf_s[s1])
                 rho1_mnG = rhoex_KsmnG[iK1, s1]
@@ -359,27 +295,27 @@
                             kptc2 = self.pair.get_k_point(s1, ikq, ci_s[s1],
                                                           cf_s[s1])
                             rho3_mmG, iq = self.get_density_matrix(kptv1,
                                                                    kptv2)
                             rho4_nnG, iq = self.get_density_matrix(kptc1,
                                                                    kptc2)
                             if self.spinors:
-                                vec0_mn = v_kmsn[iK1, mvi:mvf, 0, ni:nf]
-                                vec1_mn = v_kmsn[iK1, mvi:mvf, 1, ni:nf]
-                                vec2_mn = v_kmsn[iK2, mvi:mvf, 0, ni:nf]
-                                vec3_mn = v_kmsn[iK2, mvi:mvf, 1, ni:nf]
+                                vec0_mn = v0_kmn[iK1, mvi:mvf, ni:nf]
+                                vec1_mn = v1_kmn[iK1, mvi:mvf, ni:nf]
+                                vec2_mn = v0_kmn[iK2, mvi:mvf, ni:nf]
+                                vec3_mn = v1_kmn[iK2, mvi:mvf, ni:nf]
                                 rho_0mnG = np.dot(vec0_mn.conj(),
                                                   np.dot(vec2_mn, rho3_mmG))
                                 rho_1mnG = np.dot(vec1_mn.conj(),
                                                   np.dot(vec3_mn, rho3_mmG))
                                 rho3_mmG = rho_0mnG + rho_1mnG
-                                vec0_mn = v_kmsn[ikq_k[iK1], mci:mcf, 0, ni:nf]
-                                vec1_mn = v_kmsn[ikq_k[iK1], mci:mcf, 1, ni:nf]
-                                vec2_mn = v_kmsn[ikq, mci:mcf, 0, ni:nf]
-                                vec3_mn = v_kmsn[ikq, mci:mcf, 1, ni:nf]
+                                vec0_mn = v0_kmn[ikq_k[iK1], mci:mcf, ni:nf]
+                                vec1_mn = v1_kmn[ikq_k[iK1], mci:mcf, ni:nf]
+                                vec2_mn = v0_kmn[ikq, mci:mcf, ni:nf]
+                                vec3_mn = v1_kmn[ikq, mci:mcf, ni:nf]
                                 rho_0mnG = np.dot(vec0_mn.conj(),
                                                   np.dot(vec2_mn, rho4_nnG))
                                 rho_1mnG = np.dot(vec1_mn.conj(),
                                                   np.dot(vec3_mn, rho4_nnG))
                                 rho4_nnG = rho_0mnG + rho_1mnG
 
                             W_mnmn = np.einsum('ijk,km,pqm->ipjq',
@@ -388,23 +324,23 @@
                                                rho4_nnG,
                                                optimize='optimal')
                             W_mnmn *= Ns * so
                             H_ksmnKsmn[ik1, s1, :, :, iK2, s1] -= 0.5 * W_mnmn
             if iK1 % (myKsize // 5 + 1) == 0:
                 dt = time() - t0
                 tleft = dt * myKsize / (iK1 + 1) - dt
-                print('  Finished %s pair orbitals in %s - Estimated %s left' %
-                      ((iK1 + 1) * Nv * Nc * Ns * world.size,
-                       timedelta(seconds=round(dt)),
-                       timedelta(seconds=round(tleft))), file=self.fd)
+                self.context.print(
+                    '  Finished %s pair orbitals in %s - Estimated %s left'
+                    % ((iK1 + 1) * Nv * Nc * Ns * world.size, timedelta(
+                        seconds=round(dt)), timedelta(seconds=round(tleft))))
 
         # if self.mode == 'BSE':
-        #     del self.Q_qaGii, self.W_qGG, self.pd_q
+        #     del self.Q_qaGii, self.W_qGG, self.qpd_q
 
-        H_ksmnKsmn /= self.vol
+        H_ksmnKsmn /= self.gs.volume
 
         mySsize = myKsize * Nv * Nc * Ns
         if myKsize > 0:
             iS0 = myKrange[0] * Nv * Nc * Ns
 
         # world.sum(rhoG0_Ksmn)
         # self.rhoG0_S = np.reshape(rhoG0_Ksmn, -1)
@@ -413,260 +349,151 @@
             self.excludef_S = np.where(np.abs(self.df_S) < 0.001)[0]
         # multiply by 2 when spin-paired and no SOC
         self.df_S *= 2.0 / nK / Ns / so
         self.deps_s = np.reshape(deps_ksmn, -1)
         H_sS = np.reshape(H_ksmnKsmn, (mySsize, self.nS))
         for iS in range(mySsize):
             # Multiply by occupations and adiabatic coupling
-            H_sS[iS] *= self.df_S[iS0 + iS] * ac
+            H_sS[iS] *= self.df_S[iS0 + iS]
             # add bare transition energies
             H_sS[iS, iS0 + iS] += self.deps_s[iS]
 
         self.H_sS = H_sS
 
         if self.write_h:
             self.par_save('H_SS.ulm', 'H_SS', self.H_sS)
-
+    
     def get_density_matrix(self, kpt1, kpt2):
+        from gpaw.response.g0w0 import QSymmetryOp, get_nmG
+        symop, iq = QSymmetryOp.get_symop_from_kpair(self.kd, self.qd,
+                                                     kpt1, kpt2)
+        qpd = self.qpd_q[iq]
+        nG = qpd.ngmax
+        pawcorr, I_G = symop.apply_symop_q(qpd, self.pawcorr_q[iq], kpt1, kpt2)
 
-        Q_c = self.kd.bzk_kc[kpt2.K] - self.kd.bzk_kc[kpt1.K]
-        iQ = self.qd.where_is_q(Q_c, self.qd.bzk_kc)
-        iq = self.qd.bz2ibz_k[iQ]
-        q_c = self.qd.ibzk_kc[iq]
-
-        # Find symmetry that transforms Q_c into q_c
-        sym = self.qd.sym_k[iQ]
-        U_cc = self.qd.symmetry.op_scc[sym]
-        time_reversal = self.qd.time_reversal_k[iQ]
-        sign = 1 - 2 * time_reversal
-        d_c = sign * np.dot(U_cc, q_c) - Q_c
-        assert np.allclose(d_c.round(), d_c)
-
-        pd = self.pd_q[iq]
-        N_c = pd.gd.N_c
-        i_cG = sign * np.dot(U_cc, np.unravel_index(pd.Q_qG[0], N_c))
-
-        shift0_c = Q_c - sign * np.dot(U_cc, q_c)
-        assert np.allclose(shift0_c.round(), shift0_c)
-        shift0_c = shift0_c.round().astype(int)
-
-        shift_c = kpt1.shift_c - kpt2.shift_c - shift0_c
-        I_G = np.ravel_multi_index(i_cG + shift_c[:, None], N_c, 'wrap')
-        G_Gv = pd.get_reciprocal_vectors()
-        spos_ac = self.gs.spos_ac
-        spos_av = np.dot(spos_ac, pd.gd.cell_cv)
-        M_vv = np.dot(pd.gd.cell_cv.T, np.dot(U_cc.T,
-                                              np.linalg.inv(pd.gd.cell_cv).T))
-
-        Q_aGii = []
-        for a, Q_Gii in enumerate(self.Q_qaGii[iq]):
-            x_G = np.exp(1j * np.dot(G_Gv, (spos_av[a] -
-                                            np.dot(M_vv, spos_av[a]))))
-            U_ii = self.gs.setups[a].R_sii[sym]
-
-            Q_Gii = np.einsum('ij,kjl,ml->kim',
-                              U_ii,
-                              Q_Gii * x_G[:, None, None],
-                              U_ii,
-                              optimize='optimal')
-            if sign == -1:
-                Q_Gii = Q_Gii.conj()
-            Q_aGii.append(Q_Gii)
-
-        rho_mnG = np.zeros((len(kpt1.eps_n), len(kpt2.eps_n), len(G_Gv)),
+        rho_mnG = np.zeros((len(kpt1.eps_n), len(kpt2.eps_n), nG),
                            complex)
         for m in range(len(rho_mnG)):
-            C1_aGi = [np.dot(Qa_Gii, P1_ni[m].conj())
-                      for Qa_Gii, P1_ni in zip(Q_aGii, kpt1.P_ani)]
-            ut1cc_R = kpt1.ut_nR[m].conj()
-            rho_mnG[m] = self.pair.calculate_pair_densities(ut1cc_R, C1_aGi,
-                                                            kpt2, pd, I_G)
+            rho_mnG[m] = get_nmG(kpt1, kpt2, pawcorr, m, qpd, I_G, self.pair)
         return rho_mnG, iq
 
-    def get_screened_potential(self, ac=1.0):
+    def get_screened_potential(self):
 
         if hasattr(self, 'W_qGG'):
             return
 
         if self.wfile is not None:
             # Read screened potential from file
             try:
                 data = np.load(self.wfile + '.npz')
-                self.Q_qaGii = data['Q']
+                self.qpd_q = data['pd']
+                assert len(data['pd']) == len(data['Q'])
+                self.pawcorr_q = [
+                    PWPAWCorrectionData(
+                        Q_aGii, qpd=qpd,
+                        pawdatasets=self.gs.pawdatasets,
+                        pos_av=self.gs.get_pos_av())
+                    for Q_aGii, qpd in zip(data['Q'], self.qpd_q)]
                 self.W_qGG = data['W']
-                self.pd_q = data['pd']
-                print('Reading screened potential from % s' % self.wfile,
-                      file=self.fd)
+                self.context.print('Reading screened potential from % s' %
+                                   self.wfile)
             except FileNotFoundError:
-                self.calculate_screened_potential(ac)
-                print('Saving screened potential to % s' % self.wfile,
-                      file=self.fd)
+                self.calculate_screened_potential()
+                self.context.print('Saving screened potential to % s' %
+                                   self.wfile)
                 if world.rank == 0:
                     np.savez(self.wfile,
-                             Q=self.Q_qaGii, pd=self.pd_q, W=self.W_qGG)
+                             Q=[pawcorr.Q_aGii for pawcorr in self.pawcorr_q],
+                             pd=self.qpd_q, W=self.W_qGG)
         else:
-            self.calculate_screened_potential(ac)
-
-    def _calculate_chi0(self, q_c):
-        """Use the Chi0 object to calculate the static susceptibility."""
-        if self._chi0calc is None:
-            self.initialize_chi0_calculator()
-
-        chi0 = self._chi0calc.create_chi0(q_c, extend_head=False)
-        # Do all bands and all spins
-        m1, m2, spins = 0, self.nbands, 'all'
-        chi0 = self._chi0calc.update_chi0(chi0, m1, m2, spins)
-
-        return chi0.pd, chi0.chi0_wGG, chi0.chi0_wxvG, chi0.chi0_wvv
+            self.calculate_screened_potential()
 
     def initialize_chi0_calculator(self):
         """Initialize the Chi0 object to compute the static
         susceptibility."""
-        self._chi0calc = Chi0(self.calc,
-                              frequencies=[0.0],
-                              eta=0.001,
-                              ecut=self.ecut * Hartree,
-                              intraband=False,
-                              hilbert=False,
-                              nbands=self.nbands,
-                              txt='chi0.txt',
-                              world=world,
-                              )
+
+        wd = FrequencyDescriptor([0.0])
+        pair = PairDensityCalculator(
+            gs=self.gs,
+            context=self.context.with_txt('chi0.txt'))
+
+        self._chi0calc = Chi0Calculator(
+            wd=wd,
+            pair=pair,
+            eta=0.001,
+            ecut=self.ecut * Hartree,
+            intraband=False,
+            hilbert=False,
+            nbands=self.nbands)
+
         self.blockcomm = self._chi0calc.blockcomm
 
-    def calculate_screened_potential(self, ac):
+    def calculate_screened_potential(self):
         """Calculate W_GG(q)"""
 
-        self.Q_qaGii = []
+        self.pawcorr_q = []
         self.W_qGG = []
-        self.pd_q = []
+        self.qpd_q = []
 
+        # F.N: Moved this here. chi0 will be calculated by WCalculator
+        if self._chi0calc is None:
+            self.initialize_chi0_calculator()
+        if self._wcalc is None:
+            wcontext = ResponseContext(txt='w.txt', comm=world)
+            self._wcalc = initialize_w_calculator(
+                self._chi0calc, wcontext,
+                coulomb=self.coulomb,
+                integrate_gamma=self.integrate_gamma)
         t0 = time()
-        print('Calculating screened potential', file=self.fd)
+        self.context.print('Calculating screened potential')
         for iq, q_c in enumerate(self.qd.ibzk_kc):
-
-            pd, chi0_wGG, chi0_wxvG, chi0_wvv = self._calculate_chi0(q_c)
-            nG = pd.ngmax
-            chi0_GG = chi0_wGG[0]
-
-            # Calculate eps^{-1}_GG
-            if pd.kd.gamma:
-                # Generate fine grid in vicinity of gamma
-                kd = self.gs.kd
-                gamma_int = GammaIntegrator(kd=kd, pd=pd,
-                                            truncation=self.truncation,
-                                            chi0_wvv=chi0_wvv[:1],
-                                            chi0_wxvG=chi0_wxvG[:1])
-
-                einv_GG = np.zeros((nG, nG), complex)
-                # W_GG = np.zeros((nG, nG), complex)
-                for iqf in range(len(gamma_int.qf_qv)):
-                    chi0_GG[0] = gamma_int.a0_qwG[iqf, 0]
-                    chi0_GG[:, 0] = gamma_int.a1_qwG[iqf, 0]
-                    chi0_GG[0, 0] = gamma_int.a_wq[0, iqf]
-                    sqrV_G = get_coulomb_kernel(pd,
-                                                kd.N_c,
-                                                truncation=self.truncation,
-                                                wstc=self.wstc,
-                                                q_v=gamma_int.qf_qv[iqf])**0.5
-                    sqrV_G *= ac**0.5  # Multiply by adiabatic coupling
-                    e_GG = np.eye(nG) - chi0_GG * sqrV_G * sqrV_G[:,
-                                                                  np.newaxis]
-                    einv_GG += np.linalg.inv(e_GG) * gamma_int.weight_q[iqf]
-                    # einv_GG = np.linalg.inv(e_GG) * weight_q[iqf]
-                    # W_GG += (einv_GG * sqrV_G * sqrV_G[:, np.newaxis]
-                    #          * weight_q[iqf])
-            else:
-                sqrV_G = get_coulomb_kernel(pd,
-                                            self.kd.N_c,
-                                            truncation=self.truncation,
-                                            wstc=self.wstc)**0.5
-                sqrV_G *= ac**0.5  # Multiply by adiabatic coupling
-                e_GG = np.eye(nG) - chi0_GG * sqrV_G * sqrV_G[:, np.newaxis]
-                einv_GG = np.linalg.inv(e_GG)
-                # W_GG = einv_GG * sqrV_G * sqrV_G[:, np.newaxis]
-
-            # Now calculate W_GG
-            if pd.kd.gamma:
-                # Reset bare Coulomb interaction
-                sqrV_G = get_coulomb_kernel(pd,
-                                            self.kd.N_c,
-                                            truncation=self.truncation,
-                                            wstc=self.wstc)**0.5
-            W_GG = einv_GG * sqrV_G * sqrV_G[:, np.newaxis]
-            if self.integrate_gamma != 0:
-                # Numerical integration of Coulomb interaction at all q-points
-                if self.integrate_gamma == 2:
-                    reduced = True
-                else:
-                    reduced = False
-                V0, sqrV0 = get_integrated_kernel(pd,
-                                                  self.kd.N_c,
-                                                  truncation=self.truncation,
-                                                  reduced=reduced,
-                                                  N=100)
-                W_GG[0, 0] = einv_GG[0, 0] * V0
-                W_GG[0, 1:] = einv_GG[0, 1:] * sqrV0 * sqrV_G[1:]
-                W_GG[1:, 0] = einv_GG[1:, 0] * sqrV_G[1:] * sqrV0
-            elif self.integrate_gamma == 0 and pd.kd.gamma:
-                # Analytical integration at gamma
-                bzvol = (2 * np.pi)**3 / self.vol / self.qd.nbzkpts
-                Rq0 = (3 * bzvol / (4 * np.pi))**(1. / 3.)
-                V0 = 16 * np.pi**2 * Rq0 / bzvol
-                sqrV0 = (4 * np.pi)**(1.5) * Rq0**2 / bzvol / 2
-                W_GG[0, 0] = einv_GG[0, 0] * V0
-                W_GG[0, 1:] = einv_GG[0, 1:] * sqrV0 * sqrV_G[1:]
-                W_GG[1:, 0] = einv_GG[1:, 0] * sqrV_G[1:] * sqrV0
-            else:
-                pass
-
-            if pd.kd.gamma:
-                e = 1 / einv_GG[0, 0].real
-                print('    RPA dielectric constant is: %3.3f' % e,
-                      file=self.fd)
-            self.Q_qaGii.append(self._chi0calc.Q_aGii)
-            self.pd_q.append(pd)
+            chi0 = self._chi0calc.calculate(q_c)
+            W_wGG = self._wcalc.calculate_W_wGG(chi0)
+            W_GG = W_wGG[0]
+            self.pawcorr_q.append(self._chi0calc.pawcorr)
+            self.qpd_q.append(chi0.qpd)
             self.W_qGG.append(W_GG)
 
             if iq % (self.qd.nibzkpts // 5 + 1) == 2:
                 dt = time() - t0
                 tleft = dt * self.qd.nibzkpts / (iq + 1) - dt
-                print('  Finished %s q-points in %s - Estimated %s left' %
-                      (iq + 1, timedelta(seconds=round(dt)),
-                       timedelta(seconds=round(tleft))), file=self.fd)
+                self.context.print(
+                    '  Finished %s q-points in %s - Estimated %s left' % (
+                        iq + 1, timedelta(seconds=round(dt)), timedelta(
+                            seconds=round(tleft))))
 
     def diagonalize(self):
 
-        print('Diagonalizing Hamiltonian', file=self.fd)
+        self.context.print('Diagonalizing Hamiltonian')
         """The t and T represent local and global
            eigenstates indices respectively
         """
 
         # Non-Hermitian matrix can only use linalg.eig
         if not self.td:
-            print('  Using numpy.linalg.eig...', file=self.fd)
-            print('  Eliminated %s pair orbitals' % len(self.excludef_S),
-                  file=self.fd)
+            self.context.print('  Using numpy.linalg.eig...')
+            self.context.print('  Eliminated %s pair orbitals' % len(
+                self.excludef_S))
 
             self.H_SS = self.collect_A_SS(self.H_sS)
             self.w_T = np.zeros(self.nS - len(self.excludef_S), complex)
             if world.rank == 0:
                 self.H_SS = np.delete(self.H_SS, self.excludef_S, axis=0)
                 self.H_SS = np.delete(self.H_SS, self.excludef_S, axis=1)
                 self.w_T, self.v_ST = np.linalg.eig(self.H_SS)
             world.broadcast(self.w_T, 0)
             self.df_S = np.delete(self.df_S, self.excludef_S)
             self.rhoG0_S = np.delete(self.rhoG0_S, self.excludef_S)
         # Here the eigenvectors are returned as complex conjugated rows
         else:
             if world.size == 1:
-                print('  Using lapack...', file=self.fd)
+                self.context.print('  Using lapack...')
                 self.w_T, self.v_St = eigh(self.H_sS)
             else:
-                print('  Using scalapack...', file=self.fd)
+                self.context.print('  Using scalapack...')
                 nS = self.nS
                 ns = -(-self.kd.nbzkpts // world.size) * (
                     self.nv * self.nc *
                     self.spins *
                     (self.spinors + 1)**2)
                 grid = BlacsGrid(world, world.size, 1)
                 desc = grid.new_descriptor(nS, nS, ns, nS)
@@ -687,55 +514,52 @@
 
         if self.write_v and self.td:
             # Cannot use par_save without td
             self.par_save('v_TS.ulm', 'v_TS', self.v_St.T)
 
         return
 
-    def get_bse_matrix(self, q_c=[0.0, 0.0, 0.0], direction=0, ac=1.0,
-                       readfile=None, optical=True, write_eig=None):
+    def get_bse_matrix(self, q_c=[0.0, 0.0, 0.0], direction=0,
+                       readfile=None, optical=True):
         """Calculate and diagonalize BSE matrix"""
 
         self.q_c = q_c
         self.direction = direction
 
         if readfile is None:
-            self.calculate(optical=optical, ac=ac)
+            self.calculate(optical=optical)
             if hasattr(self, 'w_T'):
                 return
             self.diagonalize()
         elif readfile == 'H_SS':
-            print('Reading Hamiltonian from file', file=self.fd)
+            self.context.print('Reading Hamiltonian from file')
             self.par_load('H_SS.ulm', 'H_SS')
             self.diagonalize()
         elif readfile == 'v_TS':
-            print('Reading eigenstates from file', file=self.fd)
+            self.context.print('Reading eigenstates from file')
             self.par_load('v_TS.ulm', 'v_TS')
         else:
             raise ValueError('%s array not recognized' % readfile)
 
-        # TODO: Move write_eig here
-
         return
 
     def get_vchi(self, w_w=None, eta=0.1, q_c=[0.0, 0.0, 0.0],
-                 direction=0, ac=1.0, readfile=None, optical=True,
+                 direction=0, readfile=None, optical=True,
                  write_eig=None):
         """Returns v * chi where v is the bare Coulomb interaction"""
 
-        self.get_bse_matrix(q_c=q_c, direction=direction, ac=ac,
-                            readfile=readfile, optical=optical,
-                            write_eig=write_eig)
+        self.get_bse_matrix(q_c=q_c, direction=direction,
+                            readfile=readfile, optical=optical)
 
         w_T = self.w_T
         rhoG0_S = self.rhoG0_S
         df_S = self.df_S
 
-        print('Calculating response function at %s frequency points' %
-              len(w_w), file=self.fd)
+        self.context.print('Calculating response function at %s frequency '
+                           'points' % len(w_w))
         vchi_w = np.zeros(len(w_w), dtype=complex)
 
         if not self.td:
             C_T = np.zeros(self.nS - len(self.excludef_S), complex)
             if world.rank == 0:
                 A_T = np.dot(rhoG0_S, self.v_ST)
                 B_T = np.dot(rhoG0_S * df_S, self.v_ST)
@@ -763,44 +587,40 @@
                     C_T = np.empty(nS, dtype=complex)
                 world.broadcast(C_T, 0)
 
         eta /= Hartree
         for iw, w in enumerate(w_w / Hartree):
             tmp_T = 1. / (w - w_T + 1j * eta)
             vchi_w[iw] += np.dot(tmp_T, C_T)
-        vchi_w *= 4 * np.pi / self.vol
+        vchi_w *= 4 * np.pi / self.gs.volume
 
         if not np.allclose(self.q_c, 0.0):
             cell_cv = self.gs.gd.cell_cv
             B_cv = 2 * np.pi * np.linalg.inv(cell_cv).T
             q_v = np.dot(q_c, B_cv)
             vchi_w /= np.dot(q_v, q_v)
 
         """Check f-sum rule."""
-        # XXX again we are accessing nvalence from setups rather than wfs,
-        # which may not be the right value if system is charged
-        nv = self.gs.setups.nvalence
+        nv = self.gs.nvalence
         dw_w = (w_w[1:] - w_w[:-1]) / Hartree
         wchi_w = (w_w[1:] * vchi_w[1:] + w_w[:-1] * vchi_w[:-1]) / Hartree / 2
-        N = -np.dot(dw_w, wchi_w.imag) * self.vol / (2 * np.pi**2)
-        print(file=self.fd)
-        print('Checking f-sum rule:', file=self.fd)
-        print('  Valence = %s, N = %f' % (nv, N), file=self.fd)
-        print(file=self.fd)
+        N = -np.dot(dw_w, wchi_w.imag) * self.gs.volume / (2 * np.pi**2)
+        self.context.print('', flush=False)
+        self.context.print('Checking f-sum rule:', flush=False)
+        self.context.print('  Valence = %s, N = %f' % (nv, N), flush=False)
+        self.context.print('')
 
         if write_eig is not None:
+            assert isinstance(write_eig, str)
+            filename = write_eig
             if world.rank == 0:
-                f = open(write_eig, 'w')
-                print('# %s eigenvalues in eV' % self.mode, file=f)
-                for iw, w in enumerate(self.w_T * Hartree):
-                    print('%8d %12.6f %12.16f' % (iw, w.real, C_T[iw].real),
-                          file=f)
-                f.close()
+                write_bse_eigenvalues(filename, self.mode,
+                                      self.w_T * Hartree, C_T)
 
-        return vchi_w * ac
+        return vchi_w
 
     def get_dielectric_function(self, w_w=None, eta=0.1,
                                 q_c=[0.0, 0.0, 0.0], direction=0,
                                 filename='df_bse.csv', readfile=None,
                                 write_eig='eig.dat'):
         """Returns and writes real and imaginary part of the dielectric
         function.
@@ -828,23 +648,20 @@
         epsilon_w = -self.get_vchi(w_w=w_w, eta=eta, q_c=q_c,
                                    direction=direction,
                                    readfile=readfile, optical=True,
                                    write_eig=write_eig)
         epsilon_w += 1.0
 
         if world.rank == 0 and filename is not None:
-            f = open(filename, 'w')
-            for iw, w in enumerate(w_w):
-                print('%.9f, %.9f, %.9f' %
-                      (w, epsilon_w[iw].real, epsilon_w[iw].imag), file=f)
-            f.close()
+            write_response_function(filename, w_w,
+                                    epsilon_w.real, epsilon_w.imag)
         world.barrier()
 
-        print('Calculation completed at:', ctime(), file=self.fd)
-        print(file=self.fd)
+        self.context.print('Calculation completed at:', ctime(), flush=False)
+        self.context.print('')
 
         return w_w, epsilon_w
 
     def get_eels_spectrum(self, w_w=None, eta=0.1,
                           q_c=[0.0, 0.0, 0.0], direction=0,
                           filename='df_bse.csv', readfile=None,
                           write_eig='eig.dat'):
@@ -872,22 +689,19 @@
         """
 
         eels_w = -self.get_vchi(w_w=w_w, eta=eta, q_c=q_c, direction=direction,
                                 readfile=readfile, optical=False,
                                 write_eig=write_eig).imag
 
         if world.rank == 0 and filename is not None:
-            f = open(filename, 'w')
-            for iw, w in enumerate(w_w):
-                print('%.9f, %.9f' % (w, eels_w[iw]), file=f)
-            f.close()
+            write_spectrum(filename, w_w, eels_w)
         world.barrier()
 
-        print('Calculation completed at:', ctime(), file=self.fd)
-        print(file=self.fd)
+        self.context.print('Calculation completed at:', ctime(), flush=False)
+        self.context.print('')
 
         return w_w, eels_w
 
     def get_polarizability(self, w_w=None, eta=0.1,
                            q_c=[0.0, 0.0, 0.0], direction=0,
                            filename='pol_bse.csv', readfile=None,
                            write_eig='eig.dat'):
@@ -905,67 +719,30 @@
         is \AA to the power of non-periodic directions.
         """
 
         pbc_c = self.gs.pbc
 
         V = self.gs.nonpbc_cell_product()
 
-        optical = (self.truncation is None)
+        optical = (self.coulomb.truncation is None)
 
         vchi_w = self.get_vchi(w_w=w_w, eta=eta, q_c=q_c, direction=direction,
                                readfile=readfile, optical=optical,
                                write_eig=write_eig)
         alpha_w = -V * vchi_w / (4 * np.pi)
         alpha_w *= Bohr**(sum(~pbc_c))
 
         if world.rank == 0 and filename is not None:
-            fd = open(filename, 'w')
-            for iw, w in enumerate(w_w):
-                print('%.9f, %.9f, %.9f' %
-                      (w, alpha_w[iw].real, alpha_w[iw].imag), file=fd)
-            fd.close()
+            write_response_function(filename, w_w, alpha_w.real, alpha_w.imag)
 
-        print('Calculation completed at:', ctime(), file=self.fd)
-        print(file=self.fd)
+        self.context.print('Calculation completed at:', ctime(), flush=False)
+        self.context.print('')
 
         return w_w, alpha_w
 
-    def get_2d_absorption(self, w_w=None, eta=0.1,
-                          q_c=[0.0, 0.0, 0.0], direction=0,
-                          filename='abs_bse.csv', readfile=None,
-                          write_eig='eig.dat'):
-        r"""Calculate the dimensionless absorption for 2d materials.
-        It is essentially related to the 2D polarizability \alpha_2d as
-
-              ABS = 4 * np.pi * \omega * \alpha_2d / c
-
-        where c is the velocity of light
-        """
-
-        from ase.units import alpha
-        c = 1.0 / alpha
-
-        assert np.sum(self.gs.pbc) == 2
-        V = self.gs.nonpbc_cell_product()
-        vchi_w = self.get_vchi(w_w=w_w, eta=eta, q_c=q_c, direction=direction,
-                               readfile=readfile, optical=True,
-                               write_eig=write_eig)
-        abs_w = -V * vchi_w.imag * w_w / Hartree / c
-
-        if world.rank == 0 and filename is not None:
-            fd = open(filename, 'w')
-            for iw, w in enumerate(w_w):
-                print('%.9f, %.9f' % (w, abs_w[iw]), file=fd)
-            fd.close()
-
-        print('Calculation completed at:', ctime(), file=self.fd)
-        print(file=self.fd)
-
-        return w_w, abs_w
-
     def par_save(self, filename, name, A_sS):
         import ase.io.ulm as ulm
 
         if world.size == 1:
             A_XS = A_sS
         else:
             A_XS = self.collect_A_SS(A_sS)
@@ -1054,25 +831,24 @@
                          min((rank + 1) * myKsize, nK))
         myKsize = len(myKrange)
         mySsize = myKsize * self.nv * self.nc * self.spins
         mySsize *= (1 + self.spinors)**2
         return myKrange, myKsize, mySsize
 
     def print_initialization(self, td, eshift, gw_skn):
-        p = functools.partial(print, file=self.fd)
+        p = functools.partial(self.context.print, flush=False)
         p('----------------------------------------------------------')
         p('%s Hamiltonian' % self.mode)
         p('----------------------------------------------------------')
         p('Started at:  ', ctime())
         p()
         p('Atoms                          :',
           self.gs.atoms.get_chemical_formula(mode='hill'))
         p('Ground state XC functional     :', self.gs.xcname)
-        # XXX Maybe gs.nvalence instread ???
-        p('Valence electrons              :', self.gs.setups.nvalence)
+        p('Valence electrons              :', self.gs.nvalence)
         p('Spinor calculations            :', self.spinors)
         p('Number of bands                :', self.gs.bd.nbands)
         p('Number of spins                :', self.gs.nspins)
         p('Number of k-points             :', self.kd.nbzkpts)
         p('Number of irreducible k-points :', self.kd.nibzkpts)
         p('Number of q-points             :', self.qd.nbzkpts)
         p('Number of irreducible q-points :', self.qd.nibzkpts)
@@ -1093,15 +869,15 @@
             p('Conduction bands               :', self.con_sn[0],
               self.con_sn[1])
         if eshift is not None:
             p('Scissors operator              :', eshift * Hartree, 'eV')
         p('Tamm-Dancoff approximation     :', td)
         p('Number of pair orbitals        :', self.nS)
         p()
-        p('Truncation of Coulomb kernel   :', self.truncation)
+        p('Truncation of Coulomb kernel   :', self.coulomb.truncation)
         if self.integrate_gamma == 0:
             p('Coulomb integration scheme     :', 'Analytical - gamma only')
         elif self.integrate_gamma == 1:
             p('Coulomb integration scheme     :', 'Numerical - all q-points')
         else:
             pass
         p()
@@ -1109,8 +885,80 @@
         p('----------------------------------------------------------')
         p()
         p('Parallelization - Total number of CPUs   : % s' % world.size)
         p('  Screened potential')
         p('    K-point/band decomposition           : % s' % world.size)
         p('  Hamiltonian')
         p('    Pair orbital decomposition           : % s' % world.size)
-        p()
+        self.context.print('')
+
+
+class BSE(BSEBackend):
+    def __init__(self, calc=None, txt='-', **kwargs):
+        """Creates the BSE object
+
+        calc: str or calculator object
+            The string should refer to the .gpw file contaning KS orbitals
+        ecut: float
+            Plane wave cutoff energy (eV)
+        nbands: int
+            Number of bands used for the screened interaction
+        valence_bands: list
+            Valence bands used in the BSE Hamiltonian
+        conduction_bands: list
+            Conduction bands used in the BSE Hamiltonian
+        eshift: float
+            Scissors operator opening the gap (eV)
+        gw_skn: list / array
+            List or array defining the gw quasiparticle energies used in
+            the BSE Hamiltonian. Should match spin, k-points and
+            valence/conduction bands
+        truncation: str or None
+            Coulomb truncation scheme. Can be None or 2D.
+        integrate_gamma: int
+            Method to integrate the Coulomb interaction. 1 is a numerical
+            integration at all q-points with G=[0,0,0] - this breaks the
+            symmetry slightly. 0 is analytical integration at q=[0,0,0] only -
+            this conserves the symmetry. integrate_gamma=2 is the same as 1,
+            but the average is only carried out in the non-periodic directions.
+        txt: str
+            txt output
+        mode: str
+            Theory level used. can be RPA TDHF or BSE. Only BSE is screened.
+        wfile: str
+            File for saving screened interaction and some other stuff
+            needed later
+        write_h: bool
+            If True, write the BSE Hamiltonian to H_SS.ulm.
+        write_v: bool
+            If True, write eigenvalues and eigenstates to v_TS.ulm
+        """
+        gs, context = get_gs_and_context(
+            calc, txt, world=world, timer=None)
+
+        super().__init__(gs=gs, context=context, **kwargs)
+
+
+def write_bse_eigenvalues(filename, mode, w_w, C_w):
+    with open(filename, 'w') as fd:
+        print('# %s eigenvalues (in eV) and weights' % mode, file=fd)
+        print('# Number   eig   weight', file=fd)
+        for iw, (w, C) in enumerate(zip(w_w, C_w)):
+            print('%8d %12.6f %12.16f' % (iw, w.real, C.real),
+                  file=fd)
+
+
+def read_bse_eigenvalues(filename):
+    _, w_w, C_w = np.loadtxt(filename, unpack=True)
+    return w_w, C_w
+
+
+def write_spectrum(filename, w_w, A_w):
+    with open(filename, 'w') as fd:
+        for w, A in zip(w_w, A_w):
+            print('%.9f, %.9f' % (w, A), file=fd)
+
+
+def read_spectrum(filename):
+    w_w, A_w = np.loadtxt(filename, delimiter=',',
+                          unpack=True)
+    return w_w, A_w
```

### Comparing `gpaw-22.8.0/gpaw/response/chi0.py` & `gpaw-23.6.0/gpaw/response/chi0.py`

 * *Files 18% similar despite different names*

```diff
@@ -3,48 +3,167 @@
 import warnings
 from functools import partial
 from time import ctime
 from typing import Union
 
 import numpy as np
 from ase.units import Ha
-from ase.utils.timing import timer
 
 import gpaw
 import gpaw.mpi as mpi
 from gpaw.bztools import convex_hull_volume
 from gpaw.response.chi0_data import Chi0Data
 from gpaw.response.frequencies import (FrequencyDescriptor,
-                                       FrequencyGridDescriptor,
                                        NonLinearFrequencyDescriptor)
 from gpaw.response.hilbert import HilbertTransform
-from gpaw.response.integrators import (Integrator, PointIntegrator,
-                                       TetrahedronIntegrator)
-from gpaw.response.pair import NoCalculatorPairDensity
+from gpaw.response.integrators import (
+    Integrand, Integrator, PointIntegrator, TetrahedronIntegrator)
+from gpaw.response import timer
+from gpaw.response.pair import PairDensityCalculator
 from gpaw.response.pw_parallelization import block_partition
 from gpaw.response.symmetry import PWSymmetryAnalyzer
 from gpaw.typing import Array1D
 from gpaw.utilities.memory import maxrss
 
 
-def find_maximum_frequency(kpt_u, nbands=0, fd=None):
+def find_maximum_frequency(kpt_u, context, nbands=0):
     """Determine the maximum electron-hole pair transition energy."""
     epsmin = 10000.0
     epsmax = -10000.0
     for kpt in kpt_u:
         epsmin = min(epsmin, kpt.eps_n[0])
         epsmax = max(epsmax, kpt.eps_n[nbands - 1])
 
-    if fd is not None:
-        print('Minimum eigenvalue: %10.3f eV' % (epsmin * Ha), file=fd)
-        print('Maximum eigenvalue: %10.3f eV' % (epsmax * Ha), file=fd)
+    context.print('Minimum eigenvalue: %10.3f eV' % (epsmin * Ha),
+                  flush=False)
+    context.print('Maximum eigenvalue: %10.3f eV' % (epsmax * Ha))
 
     return epsmax - epsmin
 
 
+class Chi0Integrand(Integrand):
+    def __init__(self, chi0calc, optical, qpd, analyzer, m1, m2):
+        self._chi0calc = chi0calc
+
+        # In a normal response calculation, we include transitions from all
+        # completely and partially unoccupied bands to range(m1, m2)
+        self.n1 = 0
+        self.n2 = chi0calc.nocc2
+        self.m1 = m1
+        self.m2 = m2
+
+        self.context = chi0calc.context
+        self.pair = chi0calc.pair
+        self.gs = chi0calc.gs
+
+        self.qpd = qpd
+        self.analyzer = analyzer
+        self.integrationmode = chi0calc.integrationmode
+        self.optical = optical
+
+    @timer('Get matrix element')
+    def matrix_element(self, k_v, s):
+        """Return pair density matrix element for integration.
+
+        A pair density is defined as::
+
+         <snk| e^(-i (q + G) r) |s'mk+q>,
+
+        where s and s' are spins, n and m are band indices, k is
+        the kpoint and q is the momentum transfer. For dielectric
+        response s'=s, for the transverse magnetic response
+        s' is flipped with respect to s.
+
+        Parameters
+        ----------
+        k_v : ndarray
+            Kpoint coordinate in cartesian coordinates.
+        s : int
+            Spin index.
+
+        If self.optical, then return optical pair densities, that is, the
+        head and wings matrix elements indexed by:
+        # P = (x, y, v, G1, G2, ...).
+
+        Return
+        ------
+        n_nmG : ndarray
+            Pair densities.
+        """
+
+        if self.optical:
+            target_method = self.pair.get_optical_pair_density
+            out_ngmax = self.qpd.ngmax + 2
+        else:
+            target_method = self.pair.get_pair_density
+            out_ngmax = self.qpd.ngmax
+
+        return self._get_any_matrix_element(
+            k_v, s, block=not self.optical,
+            target_method=target_method,
+        ).reshape(-1, out_ngmax)
+
+    def _get_any_matrix_element(self, k_v, s, block, target_method):
+        assert self.m1 <= self.m2
+        qpd = self.qpd
+
+        k_c = np.dot(qpd.gd.cell_cv, k_v) / (2 * np.pi)
+
+        weight = np.sqrt(self.analyzer.get_kpoint_weight(k_c) /
+                         self.analyzer.how_many_symmetries())
+
+        # Here we're again setting pawcorr willy-nilly
+        if self._chi0calc.pawcorr is None:
+            pairden_paw_corr = self.gs.pair_density_paw_corrections
+            self._chi0calc.pawcorr = pairden_paw_corr(qpd)
+
+        kptpair = self.pair.get_kpoint_pair(qpd, s, k_c, self.n1, self.n2,
+                                            self.m1, self.m2, block=block)
+        m_m = np.arange(self.m1, self.m2)
+        n_n = np.arange(self.n1, self.n2)
+        n_nmG = target_method(qpd, kptpair, n_n, m_m,
+                              pawcorr=self._chi0calc.pawcorr,
+                              block=block)
+
+        if self.integrationmode is None:
+            n_nmG *= weight
+
+        df_nm = kptpair.get_occupation_differences(n_n, m_m)
+        df_nm[df_nm <= 1e-20] = 0.0
+        n_nmG *= df_nm[..., np.newaxis]**0.5
+
+        return n_nmG
+
+    @timer('Get eigenvalues')
+    def eigenvalues(self, k_v, s):
+        """A function that can return the eigenvalues.
+
+        A simple function describing the integrand of
+        the response function which gives an output that
+        is compatible with the gpaw k-point integration
+        routines."""
+
+        qpd = self.qpd
+        gs = self.gs
+        kd = gs.kd
+
+        k_c = np.dot(qpd.gd.cell_cv, k_v) / (2 * np.pi)
+        K1 = self.pair.find_kpoint(k_c)
+        K2 = self.pair.find_kpoint(k_c + qpd.q_c)
+
+        ik1 = kd.bz2ibz_k[K1]
+        ik2 = kd.bz2ibz_k[K2]
+        kpt1 = gs.kpt_qs[ik1][s]
+        assert kd.comm.size == 1
+        kpt2 = gs.kpt_qs[ik2][s]
+        deps_nm = np.subtract(kpt1.eps_n[self.n1:self.n2][:, np.newaxis],
+                              kpt2.eps_n[self.m1:self.m2])
+        return deps_nm.reshape(-1)
+
+
 class Chi0Calculator:
     def __init__(self, wd, pair,
                  hilbert=True,
                  intraband=True,
                  nbands=None,
                  timeordered=False,
                  context=None,
@@ -55,145 +174,161 @@
                  integrationmode=None,
                  rate=0.0, eshift=0.0):
 
         if context is None:
             context = pair.context
 
         # TODO: More refactoring to avoid non-orthogonal inputs.
-        assert pair.context.world is context.world
+        assert pair.context.comm is context.comm
         self.context = context
 
-        self.timer = self.context.timer
-        self.fd = self.context.fd
-
         self.pair = pair
         self.gs = pair.gs
 
         self.disable_point_group = disable_point_group
         self.disable_time_reversal = disable_time_reversal
         self.disable_non_symmorphic = disable_non_symmorphic
         self.integrationmode = integrationmode
         self.eshift = eshift / Ha
 
-        self.vol = self.gs.volume
-        self.world = self.context.world
         self.nblocks = pair.nblocks
-        self.calc = self.gs._calc  # XXX remove me
 
         # XXX this is redundant as pair also does it.
-        self.blockcomm, self.kncomm = block_partition(self.world, self.nblocks)
+        self.blockcomm, self.kncomm = block_partition(self.context.comm,
+                                                      self.nblocks)
 
         if ecut is None:
             ecut = 50.0
         ecut /= Ha
         self.ecut = ecut
 
         self.eta = eta / Ha
-        if rate == 'eta':
-            self.rate = self.eta
-        else:
-            self.rate = rate / Ha
 
         self.nbands = nbands or self.gs.bd.nbands
-        self.include_intraband = intraband
 
         self.wd = wd
-        print(self.wd, file=self.fd)
+        self.context.print(self.wd, flush=False)
 
         if not isinstance(self.wd, NonLinearFrequencyDescriptor):
             assert not hilbert
 
         self.hilbert = hilbert
         self.timeordered = bool(timeordered)
+        if self.timeordered:
+            assert self.hilbert  # Timeordered is only needed for G0W0
 
         if self.eta == 0.0:
             assert not hilbert
             assert not timeordered
             assert not self.wd.omega_w.real.any()
 
-        self.nocc1 = self.pair.nocc1  # number of completely filled bands
-        self.nocc2 = self.pair.nocc2  # number of non-empty bands
-
-        self.Q_aGii = None
+        self.pawcorr = None
 
         if sum(self.pbc) == 1:
             raise ValueError('1-D not supported atm.')
 
-        print('Nonperiodic BCs: ', (~self.pbc),
-              file=self.fd)
+        self.context.print('Nonperiodic BCs: ', (~self.pbc), flush=False)
 
         if integrationmode is not None:
-            print('Using integration method: ' + self.integrationmode,
-                  file=self.fd)
+            self.context.print('Using integration method: ' +
+                               self.integrationmode)
+        else:
+            self.context.print('Using integration method: PointIntegrator')
+
+        # Number of completely filled bands and number of non-empty bands.
+        self.nocc1, self.nocc2 = self.gs.count_occupied_bands()
+        metallic = self.nocc1 != self.nocc2
+
+        if metallic:
+            assert abs(eshift) < 1e-8,\
+                'A rigid energy shift cannot be applied to the conduction '\
+                'bands if there is no band gap'
+
+        # In the optical limit of metals, one must add the Drude dielectric
+        # response from the free-space plasma frequency of the intraband
+        # transitions to the head of the chi0 wings. This is handled by a
+        # separate calculator, provided that intraband is set to True.
+        if metallic and intraband:
+            from gpaw.response.drude import Chi0DrudeCalculator
+            if rate == 'eta':
+                rate = eta
+            self.rate = rate
+            self.drude_calc = Chi0DrudeCalculator(
+                pair,
+                disable_point_group=disable_point_group,
+                disable_time_reversal=disable_time_reversal,
+                disable_non_symmorphic=disable_non_symmorphic,
+                integrationmode=integrationmode)
         else:
-            print('Using integration method: PointIntegrator', file=self.fd)
+            self.drude_calc = None
+            self.rate = None
 
     @property
     def pbc(self):
         return self.gs.pbc
 
-    def create_chi0(self, q_c, extend_head=True):
+    def create_chi0(self, q_c):
         # Extract descriptor arguments
         plane_waves = (q_c, self.ecut, self.gs.gd)
-        parallelization = (self.world, self.blockcomm, self.kncomm)
+        parallelization = (self.context.comm, self.blockcomm, self.kncomm)
 
         # Construct the Chi0Data object
         # In the future, the frequencies should be specified at run-time
         # by Chi0.calculate(), in which case Chi0Data could also initialize
         # the frequency descriptor XXX
         chi0 = Chi0Data.from_descriptor_arguments(self.wd,
                                                   plane_waves,
-                                                  parallelization,
-                                                  extend_head)
+                                                  parallelization)
 
         return chi0
 
     def calculate(self, q_c, spin='all'):
         """Calculate response function.
 
         Parameters
         ----------
         q_c : list or ndarray
             Momentum vector.
         spin : str or int
             If 'all' then include all spins.
             If 0 or 1, only include this specific spin.
-            (not used in transverse response functions)
 
         Returns
         -------
         chi0 : Chi0Data
             Data object containing the chi0 data arrays along with basis
             representation descriptors and blocks distribution
         """
-        gs = self.gs
-
-        if spin == 'all':
-            spins = range(gs.nspins)
-        else:
-            assert spin in range(gs.nspins)
-            spins = [spin]
-
         chi0 = self.create_chi0(q_c)
-
-        self.print_chi(chi0.pd)
-
-        if chi0.optical_limit:
-            self.plasmafreq_vv = np.zeros((3, 3), complex)
-        else:
-            self.plasmafreq_vv = None
+        self.print_info(chi0.qpd)
 
         # Do all transitions into partially filled and empty bands
         m1 = self.nocc1
         m2 = self.nbands
+        spins = self.get_spins(spin)
 
         chi0 = self.update_chi0(chi0, m1, m2, spins)
 
+        if self.drude_calc is not None and chi0.optical_limit:
+            # Add intraband contribution
+            chi0_drude = self.drude_calc.calculate(self.wd, self.rate, spin)
+            chi0.chi0_Wvv[:] += chi0_drude.chi_Zvv
+
         return chi0
 
+    def get_spins(self, spin):
+        nspins = self.gs.nspins
+        if spin == 'all':
+            spins = range(nspins)
+        else:
+            assert spin in range(nspins)
+            spins = [spin]
+
+        return spins
+
     @timer('Calculate CHI_0')
     def update_chi0(self,
                     chi0: Chi0Data,
                     m1, m2, spins):
         """In-place calculation of the response function.
 
         Parameters
@@ -209,109 +344,223 @@
             If [0] or [1], only include this specific spin.
 
         Returns
         -------
         chi0 : Chi0Data
         """
         assert m1 <= m2
-        # Parse spins
-        gs = self.gs
 
+        # Parse spins
+        nspins = self.gs.nspins
         if spins == 'all':
-            spins = range(gs.nspins)
+            spins = range(nspins)
         else:
             for spin in spins:
-                assert spin in range(gs.nspins)
+                assert spin in range(nspins)
 
-        pd = chi0.pd
-        # Are we calculating the optical limit.
-        optical_limit = chi0.optical_limit
-
-        # Use wings in optical limit, if head cannot be extended
-        if optical_limit and not chi0.extend_head:
-            wings = True
-        else:
-            wings = False
+        qpd = chi0.qpd
+        optical_limit = chi0.optical_limit  # Calculating the optical limit?
 
         # Reset PAW correction in case momentum has change
-        self.Q_aGii = self.pair.initialize_paw_corrections(pd)
-        A_wxx = chi0.chi0_wGG  # Change notation
+        pairden_paw_corr = self.gs.pair_density_paw_corrections
+        self.pawcorr = pairden_paw_corr(qpd)
+
+        # Integrate chi0 body
+        self.context.print('Integrating response function.')
+        self._update_chi0_body(chi0, m1, m2, spins)
+
+        if optical_limit:
+            # Update the head and wings
+            self._update_chi0_wings(chi0, m1, m2, spins)
+
+        return chi0
 
-        # Initialize integrator. The integrator class is a general class
-        # for brillouin zone integration that can integrate user defined
-        # functions over user defined domains and sum over bands.
+    def _update_chi0_body(self,
+                          chi0: Chi0Data,
+                          m1, m2, spins):
+        """In-place calculation of the body."""
+        qpd = chi0.qpd
+
+        integrator = self.initialize_integrator()
+        domain, analyzer, prefactor = self.get_integration_domain(qpd, spins)
+        kind, extraargs = self.get_integral_kind()
+
+        integrand = Chi0Integrand(self, qpd=qpd, analyzer=analyzer,
+                                  optical=False, m1=m1, m2=m2)
+
+        chi0.chi0_WgG[:] /= prefactor
+        if self.hilbert:
+            # Allocate a temporary array for the spectral function
+            out_WgG = chi0.zeros()
+        else:
+            # Use the preallocated array for direct updates
+            out_WgG = chi0.chi0_WgG
+        integrator.integrate(kind=kind,  # Kind of integral
+                             domain=domain,  # Integration domain
+                             integrand=integrand,
+                             x=self.wd,  # Frequency Descriptor
+                             out_wxx=out_WgG,  # Output array
+                             **extraargs)
+        if self.hilbert:
+            # The integrator only returns the spectral function and a Hilbert
+            # transform is performed to return the real part of the density
+            # response function.
+            with self.context.timer('Hilbert transform'):
+                # Make Hilbert transform
+                ht = HilbertTransform(np.array(self.wd.omega_w), self.eta,
+                                      timeordered=self.timeordered)
+                ht(out_WgG)
+            # Update the actual chi0 array
+            chi0.chi0_WgG[:] += out_WgG
+        chi0.chi0_WgG[:] *= prefactor
+
+        tmp_chi0_wGG = chi0.copy_array_with_distribution('wGG')
+        analyzer.symmetrize_wGG(tmp_chi0_wGG)
+        # The line below is borderline illegal and should be changed! XXX
+        chi0.chi0_WgG[:] = chi0.blockdist.distribute_as(tmp_chi0_wGG,
+                                                        chi0.nw, 'WgG')
+
+    def _update_chi0_wings(self,
+                           chi0: Chi0Data,
+                           m1, m2, spins):
+        """In-place calculation of the optical limit wings."""
+        qpd = chi0.qpd
+
+        integrator = self.initialize_integrator(block_distributed=False)
+        domain, analyzer, prefactor = self.get_integration_domain(qpd, spins)
+        kind, extraargs = self.get_integral_kind()
+
+        integrand = Chi0Integrand(self, qpd=qpd, analyzer=analyzer,
+                                  optical=True, m1=m1, m2=m2)
+
+        # We integrate the head and wings together, using the combined index P
+        # index v = (x, y, z)
+        # index G = (G0, G1, G2, ...)
+        # index P = (x, y, z, G1, G2, ...)
+        WxvP_shape = list(chi0.WxvG_shape)
+        WxvP_shape[-1] += 2
+        tmp_chi0_WxvP = np.zeros(WxvP_shape, complex)
+        integrator.integrate(kind=kind + ' wings',  # Kind of integral
+                             domain=domain,  # Integration domain
+                             integrand=integrand,
+                             x=self.wd,  # Frequency Descriptor
+                             out_wxx=tmp_chi0_WxvP,  # Output array
+                             **extraargs)
+        if self.hilbert:
+            with self.context.timer('Hilbert transform'):
+                ht = HilbertTransform(np.array(self.wd.omega_w), self.eta,
+                                      timeordered=self.timeordered)
+                ht(tmp_chi0_WxvP)
+        tmp_chi0_WxvP *= prefactor
+
+        # Fill in wings part of the data, but leave out the head part (G0)
+        chi0.chi0_WxvG[..., 1:] += tmp_chi0_WxvP[..., 3:]
+        # Fill in the head
+        chi0.chi0_Wvv[:] += tmp_chi0_WxvP[:, 0, :3, :3]
+        analyzer.symmetrize_wxvG(chi0.chi0_WxvG)
+        analyzer.symmetrize_wvv(chi0.chi0_Wvv)
+
+    def initialize_integrator(self, block_distributed=True) -> Integrator:
+        """The integrator class is a general class for brillouin zone
+        integration that can integrate user defined functions over user
+        defined domains and sum over bands."""
         integrator: Integrator
-        intnoblock: Integrator
 
-        if self.integrationmode is None or \
-           self.integrationmode == 'point integration':
+        cls = self.get_integrator_cls()
+
+        kwargs = dict(
+            cell_cv=self.gs.gd.cell_cv,
+            context=self.context)
+        self.update_integrator_kwargs(kwargs,
+                                      block_distributed=block_distributed)
+
+        integrator = cls(**kwargs)
+
+        return integrator
+
+    def get_integrator_cls(self):
+        """Get the appointed k-point integrator class."""
+        if self.integrationmode is None:
             cls = PointIntegrator
         elif self.integrationmode == 'tetrahedron integration':
             cls = TetrahedronIntegrator  # type: ignore
+            if not all([self.disable_point_group,
+                        self.disable_time_reversal,
+                        self.disable_non_symmorphic]):
+                self.check_high_symmetry_ibz_kpts()
         else:
             raise ValueError(f'Integration mode "{self.integrationmode}"'
                              ' not implemented.')
 
-        kwargs = dict(
-            cell_cv=self.gs.gd.cell_cv,
-            comm=self.world,
-            timer=self.timer,
-            eshift=self.eshift,
-            txt=self.fd)
+        return cls
 
-        integrator = cls(**kwargs, nblocks=self.nblocks)
-        intnoblock = cls(**kwargs)
+    def check_high_symmetry_ibz_kpts(self):
+        """Check that the ground state includes all corners of the IBZ."""
+        ibz_vertices_kc = self.gs.get_ibz_vertices()
+        # Here we mimic the k-point grid compatibility check of
+        # gpaw.bztools.find_high_symmetry_monkhorst_pack()
+        bzk_kc = self.gs.kd.bzk_kc
+        for ibz_vertex_c in ibz_vertices_kc:
+            # Relative coordinate difference to the k-point grid
+            diff_kc = np.abs(bzk_kc - ibz_vertex_c)[:, self.gs.pbc].round(6)
+            # The ibz vertex should exits in the BZ grid up to a reciprocal
+            # lattice vector, meaning that the relative coordinate difference
+            # is allowed to be an integer. Thus, at least one relative k-point
+            # difference should vanish, modulo 1
+            mod_diff_kc = np.mod(diff_kc, 1)
+            nodiff_k = np.all(mod_diff_kc < 1e-5, axis=1)
+            if not np.any(nodiff_k):
+                raise ValueError(
+                    'The ground state k-point grid does not include all '
+                    'vertices of the IBZ. '
+                    'Please use find_high_symmetry_monkhorst_pack() from '
+                    'gpaw.bztools to generate your k-point grid.')
+
+    def update_integrator_kwargs(self, kwargs, block_distributed=True):
+        # Update the energy shift
+        kwargs['eshift'] = self.eshift
+
+        # Update nblocks
+        if block_distributed:
+            kwargs['nblocks'] = self.nblocks
 
+    def get_integration_domain(self, qpd, spins):
+        """Get integrator domain and prefactor for the integral."""
         # The integration domain is determined by the following function
         # that reduces the integration domain to the irreducible zone
         # of the little group of q.
         bzk_kv, analyzer = self.get_kpoints(
-            pd, integrationmode=self.integrationmode)
+            qpd, integrationmode=self.integrationmode)
         domain = (bzk_kv, spins)
 
         if self.integrationmode == 'tetrahedron integration':
             # If there are non-periodic directions it is possible that the
             # integration domain is not compatible with the symmetry operations
             # which essentially means that too large domains will be
             # integrated. We normalize by vol(BZ) / vol(domain) to make
             # sure that to fix this.
             domainvol = convex_hull_volume(
                 bzk_kv) * analyzer.how_many_symmetries()
-            bzvol = (2 * np.pi)**3 / self.vol
+            bzvol = (2 * np.pi)**3 / self.gs.volume
             factor = bzvol / domainvol
         else:
             factor = 1
 
         prefactor = (2 * factor * analyzer.how_many_symmetries() /
-                     (gs.nspins * (2 * np.pi)**3))  # Remember prefactor
+                     (self.gs.nspins * (2 * np.pi)**3))  # Remember prefactor
 
         if self.integrationmode is None:
-            nbzkpts = gs.kd.nbzkpts
+            nbzkpts = self.gs.kd.nbzkpts
             prefactor *= len(bzk_kv) / nbzkpts
 
-        A_wxx /= prefactor
-        if wings:
-            chi0.chi0_wxvG /= prefactor
-            chi0.chi0_wvv /= prefactor
-
-        # The functions that are integrated are defined in the bottom
-        # of this file and take a number of constant keyword arguments
-        # which the integrator class accepts through the use of the
-        # kwargs keyword.
-        kd = gs.kd
-        mat_kwargs = {'kd': kd, 'pd': pd,
-                      'symmetry': analyzer,
-                      'integrationmode': self.integrationmode}
-        eig_kwargs = {'kd': kd, 'pd': pd}
-
-        if not chi0.extend_head:
-            mat_kwargs['extend_head'] = False
+        return domain, analyzer, prefactor
 
-        # Determine what "kind" of integral to make.
-        extraargs = {}  # Initialize extra arguments to integration method.
+    def get_integral_kind(self):
+        """Determine what "kind" of integral to make."""
+        extraargs = {}
         if self.eta == 0:
             # If eta is 0 then we must be working with imaginary frequencies.
             # In this case chi is hermitian and it is therefore possible to
             # reduce the computational costs by a only computing half of the
             # response function.
             kind = 'hermitian response function'
         elif self.hilbert:
@@ -323,239 +572,22 @@
             kind = 'spectral function'
         else:
             # Otherwise, we can make no simplifying assumptions of the
             # form of the response function and we simply perform a brute
             # force calculation of the response function.
             kind = 'response function'
             extraargs['eta'] = self.eta
-            extraargs['timeordered'] = self.timeordered
 
-        # Integrate response function
-        print('Integrating response function.', file=self.fd)
-        # Define band summation. Includes transitions from all
-        # completely and partially filled bands to range(m1, m2)
-        bandsum = {'n1': 0, 'n2': self.nocc2, 'm1': m1, 'm2': m2}
-        mat_kwargs.update(bandsum)
-        eig_kwargs.update(bandsum)
-
-        integrator.integrate(kind=kind,  # Kind of integral
-                             domain=domain,  # Integration domain
-                             integrand=(self.get_matrix_element,  # Integrand
-                                        self.get_eigenvalues),  # Integrand
-                             x=self.wd,  # Frequency Descriptor
-                             kwargs=(mat_kwargs, eig_kwargs),
-                             # Arguments for integrand functions
-                             out_wxx=A_wxx,  # Output array
-                             **extraargs)
-        # extraargs: Extra arguments to integration method
-        if wings:
-            mat_kwargs['extend_head'] = True
-            mat_kwargs['block'] = False
-            # This is horrible but we need to update the wings manually
-            # in order to make them work with ralda, RPA and GW. This entire
-            # section can be deleted in the future if the ralda and RPA code is
-            # made compatible with the head and wing extension that other parts
-            # of the code is using.
-            chi0_wxvx = np.zeros(np.array(chi0.chi0_wxvG.shape) +
-                                 [0, 0, 0, 2],
-                                 complex)  # Notice the wxv"x" for head extend
-            intnoblock.integrate(kind=kind + ' wings',  # kind'o int.
-                                 domain=domain,  # Integration domain
-                                 integrand=(self.get_matrix_element,  # Intgrnd
-                                            self.get_eigenvalues),  # Integrand
-                                 x=self.wd,  # Frequency Descriptor
-                                 kwargs=(mat_kwargs, eig_kwargs),
-                                 # Arguments for integrand functions
-                                 out_wxx=chi0_wxvx,  # Output array
-                                 **extraargs)
-
-        if self.hilbert:
-            # The integrator only returns the spectral function and a Hilbert
-            # transform is performed to return the real part of the density
-            # response function.
-            with self.timer('Hilbert transform'):
-                # Make Hilbert transform
-                ht = HilbertTransform(np.array(self.wd.omega_w), self.eta,
-                                      timeordered=self.timeordered)
-                ht(A_wxx)
-                if wings:
-                    ht(chi0_wxvx)
-
-        # In the optical limit additional work must be performed
-        # for the intraband response.
-        # Only compute the intraband response if there are partially
-        # unoccupied bands and only if the user has not disabled its
-        # calculation using the include_intraband keyword.
-        if optical_limit and self.nocc1 != self.nocc2:
-            # The intraband response is essentially just the calculation
-            # of the free space Drude plasma frequency. The calculation is
-            # similarly to the interband transitions documented above.
-            mat_kwargs = {'kd': kd, 'symmetry': analyzer,
-                          'n1': self.nocc1, 'n2': self.nocc2,
-                          'pd': pd}  # Integrand arguments
-            eig_kwargs = {'kd': kd,
-                          'n1': self.nocc1, 'n2': self.nocc2,
-                          'pd': pd}  # Integrand arguments
-            domain = (bzk_kv, spins)  # Integration domain
-            fermi_level = self.pair.fermi_level  # Fermi level
-
-            # Not so elegant solution but it works
-            plasmafreq_wvv = np.zeros((1, 3, 3), complex)  # Output array
-            print('Integrating intraband density response.', file=self.fd)
-
-            # Depending on which integration method is used we
-            # have to pass different arguments
-            extraargs = {}
-            if self.integrationmode is None:
-                # Calculate intraband transitions at finite fermi smearing
-                extraargs['intraband'] = True  # Calculate intraband
-            elif self.integrationmode == 'tetrahedron integration':
-                # Calculate intraband transitions at T=0
-                extraargs['x'] = FrequencyGridDescriptor([-fermi_level])
-
-            intnoblock.integrate(kind='spectral function',  # Kind of integral
-                                 domain=domain,  # Integration domain
-                                 # Integrands
-                                 integrand=(self.get_intraband_response,
-                                            self.get_intraband_eigenvalue),
-                                 # Integrand arguments
-                                 kwargs=(mat_kwargs, eig_kwargs),
-                                 out_wxx=plasmafreq_wvv,  # Output array
-                                 **extraargs)  # Extra args for int. method
-
-            # Again, not so pretty but that's how it is
-            plasmafreq_vv = plasmafreq_wvv[0].copy()
-            if self.include_intraband:
-                drude_chi_wvv = plasmafreq_vv[np.newaxis]\
-                    / (self.wd.omega_w[:, np.newaxis, np.newaxis]
-                       + 1.j * self.rate)**2
-                if chi0.extend_head:
-                    va = min(chi0.blocks1d.a, 3)
-                    vb = min(chi0.blocks1d.b, 3)
-                    A_wxx[:, :vb - va, :3] += drude_chi_wvv[:, va:vb]
-                else:
-                    # Fill into head part of tmp head AND wings array
-                    chi0_wxvx[:, 0, :3, :3] += drude_chi_wvv
-
-            # Save the plasmafrequency
-            try:
-                self.plasmafreq_vv += 4 * np.pi * plasmafreq_vv * prefactor
-            except AttributeError:
-                self.plasmafreq_vv = 4 * np.pi * plasmafreq_vv * prefactor
-
-            analyzer.symmetrize_wvv(self.plasmafreq_vv[np.newaxis])
-            print('Plasma frequency:', file=self.fd)
-            print((self.plasmafreq_vv**0.5 * Ha).round(2),
-                  file=self.fd)
-
-        # The response function is integrated only over the IBZ. The
-        # chi calculated above must therefore be extended to include the
-        # response from the full BZ. This extension can be performed as a
-        # simple post processing of the response function that makes
-        # sure that the response function fulfills the symmetries of the little
-        # group of q. Due to the specific details of the implementation the chi
-        # calculated above is normalized by the number of symmetries (as seen
-        # below) and then symmetrized.
-        A_wxx *= prefactor
-
-        tmpA_wxx = chi0.blockdist.redistribute(A_wxx, chi0.nw)
-        if chi0.extend_head:
-            analyzer.symmetrize_wxx(tmpA_wxx,
-                                    optical_limit=optical_limit)
-        else:
-            analyzer.symmetrize_wGG(tmpA_wxx)
-            if wings:
-                # Fill in wings part of the data, but leave out the head
-                chi0.chi0_wxvG[..., 1:] += chi0_wxvx[..., 3:]
-                # Fill in the head
-                chi0.chi0_wvv += chi0_wxvx[:, 0, :3, :3]
-                analyzer.symmetrize_wxvG(chi0.chi0_wxvG)
-                analyzer.symmetrize_wvv(chi0.chi0_wvv)
-        A_wxx[:] = chi0.blockdist.redistribute(tmpA_wxx, chi0.nw)
-
-        # If point summation was used then the normalization of the
-        # response function is not right and we have to make up for this
-        # fact.
-
-        if wings:
-            chi0.chi0_wxvG *= prefactor
-            chi0.chi0_wvv *= prefactor
-
-        # In the optical limit, we have extended the wings and the head to
-        # account for their nonanalytic behaviour which means that the size of
-        # the chi0_wGG matrix is nw * (nG + 2)**2. Below we extract these
-        # parameters.
-        if optical_limit and chi0.extend_head:
-            # We always return chi0 in the extend_head=False format. This
-            # makes the update terminology inaccurate as we have to make a
-            # new Chi0Data instance. In the future, extend_head=True should
-            # be confined inside Chi0.update_chi0, so that the update
-            # terminology is self-consistent
-            chi0_new = self.create_chi0(pd.kd.bzk_kc[0], extend_head=False)
-
-            # Make an extended wings object to temporarily hold the head AND
-            # wings data
-            chi0_wxvG = np.zeros(chi0.wxvG_shape, complex)
-
-            # Extract the head and wings data. The x = 0 wing represents the
-            # upper horizontal block, while the x = 1 wing represents the left
-            # vertical block.
-            # The data in A_wxx is distributed over "x"-rows, so we need to be
-            # careful
-            va = min(chi0.blocks1d.a, 3)  # Cartesian part of myslice
-            vb = min(chi0.blocks1d.b, 3)
-            # Fill in the x = 0 wing
-            chi0_wxvG[:, 0, va:vb] = A_wxx[:, :vb - va]
-            # Fill in the x = 1 wing
-            chi0_wxvG[:, 1, :,
-                      chi0.blocks1d.myslice] = np.transpose(
-                A_wxx[..., :3], (0, 2, 1))
-
-            # The head and wings are not distributed in the Chi0Data object,
-            # so we collect the contributions from all blocks
-            self.blockcomm.sum(chi0_wxvG)
-
-            # Fill in the head
-            # The x = 0 wing of the extended wings object has the "normal"
-            # view of the head of chi0
-            chi0_new.chi0_wvv[:] = chi0_wxvG[:, 0, :3, :3]
-            # Fill in wings part of the data, but leave out the head
-            chi0_new.chi0_wxvG[..., 1:] = chi0_wxvG[..., 3:]
-            # Jesus, this is complicated
-
-            # It is easiest to redistribute over freqs to pick body
-            tmpA_wxx = chi0.blockdist.redistribute(A_wxx, chi0.nw)
-            chi0_wGG = tmpA_wxx[:, 2:, 2:]
-            chi0_new.chi0_wGG = chi0_new.blockdist.redistribute(chi0_wGG,
-                                                                chi0.nw)
-
-            # Rename
-            chi0 = chi0_new
-
-        elif optical_limit:
-            # By default, we fill in the G=0 entries of chi0_wGG with the
-            # wings evaluated along the z-direction.
-            # The x = 1 wing represents the left vertical block, which is
-            # distributed in chi0_wGG
-            chi0.chi0_wGG[:, :, 0] = chi0.chi0_wxvG[:, 1, 2,
-                                                    chi0.blocks1d.myslice]
-
-            if self.blockcomm.rank == 0:  # rank with G=0 row
-                # The x = 0 wing represents the upper horizontal block
-                chi0.chi0_wGG[:, 0, :] = chi0.chi0_wxvG[:, 0, 2, :]
-                chi0.chi0_wGG[:, 0, 0] = chi0.chi0_wvv[:, 2, 2]
-
-        return chi0
+        return kind, extraargs
 
     @timer('Get kpoints')
-    def get_kpoints(self, pd, integrationmode=None):
+    def get_kpoints(self, qpd, integrationmode):
         """Get the integration domain."""
         analyzer = PWSymmetryAnalyzer(
-            self.gs.kd, pd,
-            timer=self.timer, txt=self.fd,
+            self.gs.kd, qpd, self.context,
             disable_point_group=self.disable_point_group,
             disable_time_reversal=self.disable_time_reversal,
             disable_non_symmorphic=self.disable_non_symmorphic)
 
         if integrationmode is None:
             K_gK = analyzer.group_kpoints()
             bzk_kc = np.array([self.gs.kd.bzk_kc[K_K[0]] for
@@ -563,252 +595,101 @@
         elif integrationmode == 'tetrahedron integration':
             bzk_kc = analyzer.get_reduced_kd(pbc_c=self.pbc).bzk_kc
             if (~self.pbc).any():
                 bzk_kc = np.append(bzk_kc,
                                    bzk_kc + (~self.pbc).astype(int),
                                    axis=0)
 
-        bzk_kv = np.dot(bzk_kc, pd.gd.icell_cv) * 2 * np.pi
-
+        bzk_kv = np.dot(bzk_kc, qpd.gd.icell_cv) * 2 * np.pi
         return bzk_kv, analyzer
 
-    @timer('Get matrix element')
-    def get_matrix_element(self, k_v, s, n1=None, n2=None,
-                           m1=None, m2=None,
-                           pd=None, kd=None,
-                           symmetry=None, integrationmode=None,
-                           extend_head=True, block=True):
-        """A function that returns pair-densities.
-
-        A pair density is defined as::
-
-         <snk| e^(-i (q + G) r) |s'mk+q>,
-
-        where s and s' are spins, n and m are band indices, k is
-        the kpoint and q is the momentum transfer. For dielectric
-        response s'=s, for the transverse magnetic response
-        s' is flipped with respect to s.
-
-        Parameters
-        ----------
-        k_v : ndarray
-            Kpoint coordinate in cartesian coordinates.
-        s : int
-            Spin index.
-        n1 : int
-            Lower occupied band index.
-        n2 : int
-            Upper occupied band index.
-        m1 : int
-            Lower unoccupied band index.
-        m2 : int
-            Upper unoccupied band index.
-        pd : PlanewaveDescriptor instance
-        kd : KpointDescriptor instance
-            Calculator kpoint descriptor.
-        symmetry: gpaw.response.pair.PWSymmetryAnalyzer instance
-            Symmetry analyzer object for handling symmetries of the kpoints.
-        integrationmode : str
-            The integration mode employed.
-        extend_head: Bool
-            Extend the head to include non-analytic behaviour
-
-        Return
-        ------
-        n_nmG : ndarray
-            Pair densities.
-        """
-        assert m1 <= m2
-
-        k_c = np.dot(pd.gd.cell_cv, k_v) / (2 * np.pi)
-
-        q_c = pd.kd.bzk_kc[0]
-
-        optical_limit = np.allclose(q_c, 0.0)
-
-        nG = pd.ngmax
-        weight = np.sqrt(symmetry.get_kpoint_weight(k_c) /
-                         symmetry.how_many_symmetries())
-        if self.Q_aGii is None:
-            self.Q_aGii = self.pair.initialize_paw_corrections(pd)
-
-        kptpair = self.pair.get_kpoint_pair(pd, s, k_c, n1, n2,
-                                            m1, m2, block=block)
-
-        m_m = np.arange(m1, m2)
-        n_n = np.arange(n1, n2)
-
-        n_nmG = self.pair.get_pair_density(pd, kptpair, n_n, m_m,
-                                           Q_aGii=self.Q_aGii, block=block)
-
-        if integrationmode is None:
-            n_nmG *= weight
-
-        df_nm = kptpair.get_occupation_differences(n_n, m_m)
-        df_nm[df_nm <= 1e-20] = 0.0
-        n_nmG *= df_nm[..., np.newaxis]**0.5
-
-        if not extend_head and optical_limit:
-            n_nmG = np.copy(n_nmG[:, :, 2:])
-            optical_limit = False
-
-        if extend_head and optical_limit:
-            return n_nmG.reshape(-1, nG + 2 * optical_limit)
-        else:
-            return n_nmG.reshape(-1, nG)
-
-    @timer('Get eigenvalues')
-    def get_eigenvalues(self, k_v, s, n1=None, n2=None,
-                        m1=None, m2=None,
-                        kd=None, pd=None, gs=None,
-                        filter=False):
-        """A function that can return the eigenvalues.
-
-        A simple function describing the integrand of
-        the response function which gives an output that
-        is compatible with the gpaw k-point integration
-        routines."""
-        if gs is None:
-            gs = self.gs
-
-        kd = gs.kd
-        k_c = np.dot(pd.gd.cell_cv, k_v) / (2 * np.pi)
-        q_c = pd.kd.bzk_kc[0]
-        K1 = self.pair.find_kpoint(k_c)
-        K2 = self.pair.find_kpoint(k_c + q_c)
-
-        ik1 = kd.bz2ibz_k[K1]
-        ik2 = kd.bz2ibz_k[K2]
-        kpt1 = gs.kpt_qs[ik1][s]
-        assert gs.kd.comm.size == 1
-        kpt2 = gs.kpt_qs[ik2][s]
-        deps_nm = np.subtract(kpt1.eps_n[n1:n2][:, np.newaxis],
-                              kpt2.eps_n[m1:m2])
-
-        if filter:
-            fermi_level = self.pair.fermi_level
-            deps_nm[kpt1.eps_n[n1:n2] > fermi_level, :] = np.nan
-            deps_nm[:, kpt2.eps_n[m1:m2] < fermi_level] = np.nan
-
-        return deps_nm.reshape(-1)
-
-    def get_intraband_response(self, k_v, s, n1=None, n2=None,
-                               kd=None, symmetry=None, pd=None,
-                               integrationmode=None):
-        k_c = np.dot(pd.gd.cell_cv, k_v) / (2 * np.pi)
-        kpt1 = self.pair.get_k_point(s, k_c, n1, n2)
-        n_n = range(n1, n2)
-
-        vel_nv = self.pair.intraband_pair_density(kpt1, n_n)
-
-        if self.integrationmode is None:
-            f_n = kpt1.f_n
-            width = self.gs.get_occupations_width()
-            if width > 1e-15:
-                dfde_n = - 1. / width * (f_n - f_n**2.0)
-            else:
-                dfde_n = np.zeros_like(f_n)
-            vel_nv *= np.sqrt(-dfde_n[:, np.newaxis])
-            weight = np.sqrt(symmetry.get_kpoint_weight(k_c) /
-                             symmetry.how_many_symmetries())
-            vel_nv *= weight
-
-        return vel_nv
-
-    @timer('Intraband eigenvalue')
-    def get_intraband_eigenvalue(self, k_v, s,
-                                 n1=None, n2=None, kd=None, pd=None):
-        """A function that can return the eigenvalues.
-
-        A simple function describing the integrand of
-        the response function which gives an output that
-        is compatible with the gpaw k-point integration
-        routines."""
-        gs = self.gs
-        kd = gs.kd
-        k_c = np.dot(pd.gd.cell_cv, k_v) / (2 * np.pi)
-        K1 = self.pair.find_kpoint(k_c)
-        ik = kd.bz2ibz_k[K1]
-        kpt1 = gs.kpt_qs[ik][s]
-        assert gs.kd.comm.size == 1
-
-        return kpt1.eps_n[n1:n2]
-
-    def print_chi(self, pd):
-        gs = self.gs
-        gd = gs.gd
+    def print_info(self, qpd):
 
         if gpaw.dry_run:
             from gpaw.mpi import SerialCommunicator
             size = gpaw.dry_run
-            world = SerialCommunicator()
-            world.size = size
+            comm = SerialCommunicator()
+            comm.size = size
         else:
-            world = self.world
+            comm = self.context.comm
 
-        q_c = pd.kd.bzk_kc[0]
+        q_c = qpd.q_c
         nw = len(self.wd)
         ecut = self.ecut * Ha
-        ns = gs.nspins
         nbands = self.nbands
-        nk = gs.kd.nbzkpts
-        nik = gs.kd.nibzkpts
-        ngmax = pd.ngmax
+        ngmax = qpd.ngmax
         eta = self.eta * Ha
-        wsize = world.size
+        csize = comm.size
         knsize = self.kncomm.size
-        nocc = self.nocc1
-        npocc = self.nocc2
-        ngridpoints = gd.N_c[0] * gd.N_c[1] * gd.N_c[2]
-        nstat = (ns * npocc + world.size - 1) // world.size
-        occsize = nstat * ngridpoints * 16. / 1024**2
         bsize = self.blockcomm.size
-        chisize = nw * pd.ngmax**2 * 16. / 1024**2 / bsize
+        chisize = nw * qpd.ngmax**2 * 16. / 1024**2 / bsize
 
-        p = partial(print, file=self.fd)
+        p = partial(self.context.print, flush=False)
 
         p('%s' % ctime())
-        p('Called response.chi0.calculate with')
+        p('Called response.chi0.calculate with:')
+        p(self.get_gs_info_string(tab='    '))
+        p()
+        p('    Linear response parametrization:')
         p('    q_c: [%f, %f, %f]' % (q_c[0], q_c[1], q_c[2]))
         p('    Number of frequency points: %d' % nw)
         if bsize > nw:
             p('WARNING! Your nblocks is larger than number of frequency'
               ' points. Errors might occur, if your submodule does'
               ' not know how to handle this.')
         p('    Planewave cutoff: %f' % ecut)
-        p('    Number of spins: %d' % ns)
         p('    Number of bands: %d' % nbands)
-        p('    Number of kpoints: %d' % nk)
-        p('    Number of irredicible kpoints: %d' % nik)
         p('    Number of planewaves: %d' % ngmax)
         p('    Broadening (eta): %f' % eta)
-        p('    world.size: %d' % wsize)
+        p('    comm.size: %d' % csize)
         p('    kncomm.size: %d' % knsize)
         p('    blockcomm.size: %d' % bsize)
-        p('    Number of completely occupied states: %d' % nocc)
-        p('    Number of partially occupied states: %d' % npocc)
         p()
         p('    Memory estimate of potentially large arrays:')
         p('        chi0_wGG: %f M / cpu' % chisize)
-        p('        Occupied states: %f M / cpu' % occsize)
         p('        Memory usage before allocation: %f M / cpu' % (maxrss() /
                                                                   1024**2))
-        p()
+        self.context.print('')
+
+    def get_gs_info_string(self, tab=''):
+        gs = self.gs
+        gd = gs.gd
+
+        ns = gs.nspins
+        nk = gs.kd.nbzkpts
+        nik = gs.kd.nibzkpts
+
+        nocc = self.nocc1
+        npocc = self.nocc2
+        ngridpoints = gd.N_c[0] * gd.N_c[1] * gd.N_c[2]
+        nstat = ns * npocc
+        occsize = nstat * ngridpoints * 16. / 1024**2
+
+        nls = '\n' + tab  # newline string
+        gs_str = tab + 'Ground state adapter containing:'
+        gs_str += nls + 'Number of spins: %d' % ns
+        gs_str += nls + 'Number of kpoints: %d' % nk
+        gs_str += nls + 'Number of irredicible kpoints: %d' % nik
+        gs_str += nls + 'Number of completely occupied states: %d' % nocc
+        gs_str += nls + 'Number of partially occupied states: %d' % npocc
+        gs_str += nls + 'Occupied states memory: %f M / cpu' % occsize
+
+        return gs_str
 
 
 class Chi0(Chi0Calculator):
-    """Class for calculating non-interacting response functions."""
+    """Class for calculating non-interacting response functions.
+    Tries to be backwards compatible, for now. """
 
     def __init__(self,
                  calc,
                  *,
                  frequencies: Union[dict, Array1D] = None,
                  ecut=50,
-                 ftol=1e-6, threshold=1,
-                 real_space_derivatives=False,
+                 threshold=1,
                  world=mpi.world, txt='-', timer=None,
                  nblocks=1,
                  nbands=None,
                  domega0=None,  # deprecated
                  omega2=None,  # deprecated
                  omegamax=None,  # deprecated
                  **kwargs):
@@ -834,23 +715,17 @@
         nbands : int
             Maximum band index to include.
         timeordered : bool
             Switch for calculating the time ordered density response function.
             In this case the hilbert transform cannot be used.
         eta : float
             Artificial broadening of spectra.
-        ftol : float
-            Threshold determining whether a band is completely filled
-            (f > 1 - ftol) or completely empty (f < ftol).
         threshold : float
             Numerical threshold for the optical limit k dot p perturbation
             theory expansion (used in gpaw/response/pair.py).
-        real_space_derivatives : bool
-            Switch for calculating nabla matrix elements (in the optical limit)
-            using a real space finite difference approximation.
         intraband : bool
             Switch for including the intraband contribution to the density
             response function.
         world : MPI comm instance
             MPI communicator.
         txt : str
             Output file.
@@ -880,47 +755,45 @@
 
         Attributes
         ----------
         pair : gpaw.response.pair.PairDensity instance
             Class for calculating matrix elements of pairs of wavefunctions.
 
         """
-        from gpaw.response.context import calc_and_context
-        calc, context = calc_and_context(calc, txt, world, timer)
-        gs = calc.gs_adapter()
+        from gpaw.response.pair import get_gs_and_context
+        gs, context = get_gs_and_context(calc, txt, world, timer)
         nbands = nbands or gs.bd.nbands
 
-        wd = new_frequency_descriptor(gs, nbands, frequencies, fd=context.fd,
-                                      domega0=domega0,
-                                      omega2=omega2, omegamax=omegamax)
-
-        pair = NoCalculatorPairDensity(
-            gs=gs, ftol=ftol, threshold=threshold,
-            real_space_derivatives=real_space_derivatives,
-            context=context,
+        wd = new_frequency_descriptor(
+            gs, context, nbands, frequencies,
+            domega0=domega0,
+            omega2=omega2, omegamax=omegamax)
+
+        pair = PairDensityCalculator(
+            gs, context,
+            threshold=threshold,
             nblocks=nblocks)
 
         super().__init__(wd=wd, pair=pair, nbands=nbands, ecut=ecut, **kwargs)
 
 
-def new_frequency_descriptor(gs, nbands, frequencies=None, *, fd,
+def new_frequency_descriptor(gs, context, nbands, frequencies=None, *,
                              domega0=None, omega2=None, omegamax=None):
     if domega0 is not None or omega2 is not None or omegamax is not None:
         assert frequencies is None
         frequencies = {'type': 'nonlinear',
                        'domega0': domega0,
                        'omega2': omega2,
                        'omegamax': omegamax}
         warnings.warn(f'Please use frequencies={frequencies}')
 
     elif frequencies is None:
         frequencies = {'type': 'nonlinear'}
 
     if (isinstance(frequencies, dict) and
         frequencies.get('omegamax') is None):
-        omegamax = find_maximum_frequency(gs.kpt_u,
-                                          nbands=nbands,
-                                          fd=fd)
+        omegamax = find_maximum_frequency(gs.kpt_u, context,
+                                          nbands=nbands)
         frequencies['omegamax'] = omegamax * Ha
 
     wd = FrequencyDescriptor.from_array_or_dict(frequencies)
     return wd
```

### Comparing `gpaw-22.8.0/gpaw/response/df.py` & `gpaw-23.6.0/gpaw/response/df.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,225 +1,101 @@
-
-import os
 import sys
-import pickle
 from math import pi
 
 import numpy as np
 from ase.units import Hartree, Bohr
 
 import gpaw.mpi as mpi
 
-from gpaw.response.chi0 import Chi0
-
-from gpaw.response.kernels import get_coulomb_kernel
-from gpaw.response.wstc import WignerSeitzTruncatedCoulomb
-from gpaw.response.fxc import get_xc_kernel
-
-
-class DielectricFunction:
-    """This class defines dielectric function related physical quantities."""
-
-    def __init__(self, calc, *,
-                 name=None,
-                 frequencies=None,
-                 domega0=None,  # deprecated
-                 omega2=None,  # deprecated
-                 omegamax=None,  # deprecated
-                 ecut=50,
-                 hilbert=True,
-                 nbands=None, eta=0.2, ftol=1e-6, threshold=1,
-                 intraband=True, nblocks=1, world=mpi.world, txt=sys.stdout,
-                 truncation=None, disable_point_group=False,
-                 disable_time_reversal=False,
-                 integrationmode=None, rate=0.0,
-                 eshift=0.0):
-        """Creates a DielectricFunction object.
-
-        calc: str
-            The groundstate calculation file that the linear response
-            calculation is based on.
-        name: str
-            If defined, save the response function to::
-
-                name + '%+d%+d%+d.pckl' % tuple((q_c * kd.N_c).round())
-
-            where q_c is the reduced momentum and N_c is the number of
-            kpoints along each direction.
-        frequencies:
-            Input parameters for frequency_grid.
-            Can be array of frequencies to evaluate the response function at
-            or dictionary of paramaters for build-in nonlinear grid
-            (see :ref:`frequency grid`).
-        ecut: float
-            Plane-wave cut-off.
-        hilbert: bool
-            Use hilbert transform.
-        nbands: int
-            Number of bands from calc.
-        eta: float
-            Broadening parameter.
-        ftol: float
-            Threshold for including close to equally occupied orbitals,
-            f_ik - f_jk > ftol.
-        threshold: float
-            Threshold for matrix elements in optical response perturbation
-            theory.
-        intraband: bool
-            Include intraband transitions.
-        world: comm
-            mpi communicator.
-        nblocks: int
-            Split matrices in nblocks blocks and distribute them G-vectors or
-            frequencies over processes.
-        txt: str
-            Output file.
-        truncation: str
-            'wigner-seitz' for Wigner Seitz truncated Coulomb.
-            '2D, 1D or 0d for standard analytical truncation schemes.
-            Non-periodic directions are determined from k-point grid
-        eshift: float
-            Shift unoccupied bands
-        """
-
-        self.chi0 = Chi0(calc, frequencies=frequencies,
-                         domega0=domega0, omega2=omega2, omegamax=omegamax,
-                         ecut=ecut, nbands=nbands, eta=eta,
-                         hilbert=hilbert,
-                         ftol=ftol, threshold=threshold,
-                         intraband=intraband, world=world, nblocks=nblocks,
-                         txt=txt,
-                         disable_point_group=disable_point_group,
-                         disable_time_reversal=disable_time_reversal,
-                         integrationmode=integrationmode,
-                         rate=rate, eshift=eshift)
-
-        self.name = name
+from gpaw.response.coulomb_kernels import CoulombKernel
+from gpaw.response.density_kernels import get_density_xc_kernel
+from gpaw.response.chi0 import Chi0Calculator, new_frequency_descriptor
+from gpaw.response.pair import get_gs_and_context, PairDensityCalculator
 
-        self.wd = self.chi0.wd
 
-        nw = len(self.wd)
-
-        world = self.chi0.world
+class DielectricFunctionCalculator:
+    def __init__(self, chi0calc, truncation):
         from gpaw.response.pw_parallelization import Blocks1D
+        self.chi0calc = chi0calc
 
-        self.blocks1d = Blocks1D(world, nw)
-        self.truncation = truncation
+        self.coulomb = CoulombKernel(truncation=truncation, gs=self.gs)
+        self.context = chi0calc.context
+        self.wd = chi0calc.wd
+        self.blocks1d = Blocks1D(self.context.comm, len(self.wd))
+
+        self._chi0cache = {}
+
+    @property
+    def gs(self):
+        return self.chi0calc.gs
 
     def calculate_chi0(self, q_c, spin='all'):
         """Calculates the response function.
 
         Calculate the response function for a specific momentum.
 
         q_c: [float, float, float]
             The momentum wavevector.
         spin : str or int
             If 'all' then include all spins.
             If 0 or 1, only include this specific spin.
             (not used in transverse reponse functions)
         """
 
-        if self.name:
-            kd = self.chi0.gs.kd
-            name = self.name + '%+d%+d%+d.pckl' % tuple((q_c * kd.N_c).round())
-            if os.path.isfile(name):
-                return self.read(name)
-
-        chi0 = self.chi0.calculate(q_c, spin)
-        chi0_wGG = chi0.distribute_frequencies()
-
-        self.chi0.timer.write(self.chi0.fd)
-        if self.name:
-            self.write(name, chi0.pd, chi0_wGG, chi0.chi0_wxvG, chi0.chi0_wvv)
-
-        return chi0.pd, chi0_wGG, chi0.chi0_wxvG, chi0.chi0_wvv
-
-    def write(self, name, pd, chi0_wGG, chi0_wxvG, chi0_wvv):
-        nw = len(self.wd)
-        nG = pd.ngmax
-        world = self.chi0.world
-        mynw = self.blocks1d.blocksize
-
-        if world.rank == 0:
-            fd = open(name, 'wb')
-            pickle.dump((self.wd.omega_w, pd, None, chi0_wxvG, chi0_wvv),
-                        fd, pickle.HIGHEST_PROTOCOL)
-            for chi0_GG in chi0_wGG:
-                pickle.dump(chi0_GG, fd, pickle.HIGHEST_PROTOCOL)
-
-            tmp_wGG = np.empty((mynw, nG, nG), complex)
-            w1 = mynw
-            for rank in range(1, world.size):
-                w2 = min(w1 + mynw, nw)
-                world.receive(tmp_wGG[:w2 - w1], rank)
-                for w in range(w2 - w1):
-                    pickle.dump(tmp_wGG[w], fd, pickle.HIGHEST_PROTOCOL)
-                w1 = w2
-            fd.close()
-        else:
-            world.send(chi0_wGG, 0)
-
-    def read(self, name):
-        print('Reading from', name, file=self.chi0.fd)
-        fd = open(name, 'rb')
-        omega_w, pd, chi0_wGG, chi0_wxvG, chi0_wvv = pickle.load(fd)
-        for omega in self.wd.omega_w:
-            assert np.any(np.abs(omega - omega_w) < 1e-8)
-
-        wmin = np.argmin(np.abs(np.min(self.wd.omega_w) - omega_w))
-        world = self.chi0.world
-
-        nw = len(omega_w)
-        nG = pd.ngmax
-
-        blocks1d = self.blocks1d
-
-        mynw = blocks1d.blocksize
-
-        if chi0_wGG is not None:
-            # Old file format:
-            chi0_wGG = chi0_wGG[wmin + blocks1d.a:blocks1d.b].copy()
-        else:
-            if world.rank == 0:
-                chi0_wGG = np.empty((mynw, nG, nG), complex)
-                for _ in range(wmin):
-                    pickle.load(fd)
-                for chi0_GG in chi0_wGG:
-                    chi0_GG[:] = pickle.load(fd)
-                tmp_wGG = np.empty((mynw, nG, nG), complex)
-                w1 = mynw
-                for rank in range(1, world.size):
-                    w2 = min(w1 + mynw, nw)
-                    for w in range(w2 - w1):
-                        tmp_wGG[w] = pickle.load(fd)
-                    world.send(tmp_wGG[:w2 - w1], rank)
-                    w1 = w2
-            else:
-                chi0_wGG = np.empty((self.blocks1d.nlocal, nG, nG), complex)
-                world.receive(chi0_wGG, 0)
-
-        if chi0_wvv is not None:
-            chi0_wxvG = chi0_wxvG[wmin:wmin + nw]
-            chi0_wvv = chi0_wvv[wmin:wmin + nw]
-
-        fd.close()
+        # We cache the computed data since chi0 may otherwise be redundantly
+        # calculated e.g. if the user calculates multiple directions.
+        #
+        # May be called multiple times with same q_c, and we want to
+        # be able to recognize previous seen values of q_c.
+        # We do this by rounding and converting to string with fixed
+        # precision (so not very elegant).
+        q_key = [f'{q:.10f}' for q in q_c]
+        key = (spin, *q_key)
+
+        # Spin='all' is a terrible cache key since it's inconsistent
+        # with specifying spins one integer at the time.
+        # We might as well change it to do the caching by spin index,
+        # or maybe we can work around the caching entirely with a more
+        # explicit API design.
+
+        if key not in self._chi0cache:
+            # We assume that the caller will trigger this multiple
+            # times with the same qpoint, then several times with
+            # another qpoint, etc.  If that's true, then we
+            # need to cache no more than one qpoint at a time.
+            # Thus to save memory, we clear the cache here.
+            #
+            # This should be replaced with something more reliable,
+            # such as having the caller manage things more explicitly.
+            #
+            # See https://gitlab.com/gpaw/gpaw/-/issues/662
+            #
+            # In conclusion, delete the cache now:
+            self._chi0cache.clear()
 
-        return pd, chi0_wGG, chi0_wxvG, chi0_wvv
+            chi0 = self.chi0calc.calculate(q_c, spin)
+            chi0_wGG = chi0.get_distributed_frequencies_array()
+            self.context.write_timer()
+            things = chi0.qpd, chi0_wGG, chi0.chi0_WxvG, chi0.chi0_Wvv
+            self._chi0cache[key] = things
+
+        qpd, *more_things = self._chi0cache[key]
+        return (qpd, *[thing.copy() if thing is not None else thing
+                       for thing in more_things])
 
     def collect(self, a_w):
-        return self.blocks1d.collect(a_w)
+        return self.blocks1d.all_gather(a_w)
 
     def get_frequencies(self):
         """ Return frequencies that Chi is evaluated on"""
         return self.wd.omega_w * Hartree
 
     def get_chi(self, xc='RPA', q_c=[0, 0, 0], spin='all',
                 direction='x', return_VchiV=True, q_v=None,
-                rshelmax=-1, rshewmin=None,
-                spinpol_cut=None, density_cut=None, fxc_scaling=None):
+                rshelmax=-1, rshewmin=None):
         """ Returns v^1/2 chi v^1/2 for the density response and chi for the
         spin response. The truncated Coulomb interaction is included as
         v^-1/2 v_t v^-1/2. This is in order to conform with
         the head and wings of chi0, which is treated specially for q=0.
 
         spin : str or int
             If 'all' then include all spins.
@@ -232,131 +108,98 @@
             to perform the expansion in (l < 6).
         rshewmin : float or None
             If None, the kernel correction will be fully expanded up to the
             chosen lmax. Given as a float, (0 < rshewmin < 1) indicates what
             coefficients to use in the expansion. If any coefficient
             contributes with less than a fraction of rshewmin on average,
             it will not be included.
-        spinpol_cut : float
-            cutoff spin polarization below which f_xc is evaluated in
-            unpolarized limit (make sure divergent terms cancel out correctly)
-        density_cut : float
-            cutoff density below which f_xc is set to zero
-        fxc_scaling : list
-            Possible scaling of kernel to hit Goldstone mode.
-            If w=0 is included in the present calculation and
-            fxc_scaling=[True, None], the fxc_scaling to match
-            kappaM_w[0] = 0. will be calculated. If
-            fxc_scaling = [True, float], Kxc will be scaled by float.
-            Default is None, i.e. no scaling
         """
-        pd, chi0_wGG, chi0_wxvG, chi0_wvv = self.calculate_chi0(q_c, spin)
+        qpd, chi0_wGG, chi0_WxvG, chi0_Wvv = self.calculate_chi0(q_c, spin)
 
-        N_c = self.chi0.gs.kd.N_c
+        coulomb_bare = CoulombKernel(truncation=None, gs=self.gs)
+        Kbare_G = coulomb_bare.V(qpd=qpd, q_v=q_v)
+        sqrtV_G = Kbare_G**0.5
 
-        Kbare_G = get_coulomb_kernel(pd,
-                                     N_c,
-                                     truncation=None,
-                                     q_v=q_v)
-        vsqr_G = Kbare_G**0.5
-        nG = len(vsqr_G)
-
-        if self.truncation is not None:
-            if self.truncation == 'wigner-seitz':
-                self.wstc = WignerSeitzTruncatedCoulomb(pd.gd.cell_cv, N_c)
-            else:
-                self.wstc = None
-            Ktrunc_G = get_coulomb_kernel(pd,
-                                          N_c,
-                                          truncation=self.truncation,
-                                          wstc=self.wstc,
-                                          q_v=q_v)
-            K_GG = np.diag(Ktrunc_G / Kbare_G)
-        else:
+        nG = len(sqrtV_G)
+
+        Ktrunc_G = self.coulomb.V(qpd=qpd, q_v=q_v)
+
+        if self.coulomb.truncation is None:
             K_GG = np.eye(nG, dtype=complex)
+        else:
+            K_GG = np.diag(Ktrunc_G / Kbare_G)
 
-        if pd.kd.gamma:
+        if qpd.kd.gamma:
             if isinstance(direction, str):
                 d_v = {'x': [1, 0, 0],
                        'y': [0, 1, 0],
                        'z': [0, 0, 1]}[direction]
             else:
                 d_v = direction
             d_v = np.asarray(d_v) / np.linalg.norm(d_v)
             W = self.blocks1d.myslice
-            chi0_wGG[:, 0] = np.dot(d_v, chi0_wxvG[W, 0])
-            chi0_wGG[:, :, 0] = np.dot(d_v, chi0_wxvG[W, 1])
-            chi0_wGG[:, 0, 0] = np.dot(d_v, np.dot(chi0_wvv[W], d_v).T)
+            chi0_wGG[:, 0] = np.dot(d_v, chi0_WxvG[W, 0])
+            chi0_wGG[:, :, 0] = np.dot(d_v, chi0_WxvG[W, 1])
+            chi0_wGG[:, 0, 0] = np.dot(d_v, np.dot(chi0_Wvv[W], d_v).T)
 
         if xc != 'RPA':
-            Kxc_GG = get_xc_kernel(pd,
-                                   self.chi0,
-                                   functional=xc,
-                                   chi0_wGG=chi0_wGG,
-                                   density_cut=density_cut)
-            K_GG += Kxc_GG / vsqr_G / vsqr_G[:, np.newaxis]
+            Kxc_GG = get_density_xc_kernel(qpd,
+                                           self.gs, self.context,
+                                           functional=xc,
+                                           chi0_wGG=chi0_wGG)
+            K_GG += Kxc_GG / sqrtV_G / sqrtV_G[:, np.newaxis]
 
         # Invert Dyson eq.
         chi_wGG = []
         for chi0_GG in chi0_wGG:
             """v^1/2 chi0 V^1/2"""
-            chi0_GG[:] = chi0_GG * vsqr_G * vsqr_G[:, np.newaxis]
+            chi0_GG[:] = chi0_GG * sqrtV_G * sqrtV_G[:, np.newaxis]
             chi_GG = np.dot(np.linalg.inv(np.eye(nG) -
                                           np.dot(chi0_GG, K_GG)),
                             chi0_GG)
             if not return_VchiV:
-                chi0_GG /= vsqr_G * vsqr_G[:, np.newaxis]
-                chi_GG /= vsqr_G * vsqr_G[:, np.newaxis]
+                chi0_GG /= sqrtV_G * sqrtV_G[:, np.newaxis]
+                chi_GG /= sqrtV_G * sqrtV_G[:, np.newaxis]
             chi_wGG.append(chi_GG)
 
         if len(chi_wGG):
             chi_wGG = np.array(chi_wGG)
         else:
             chi_wGG = np.zeros((0, nG, nG), complex)
 
-        return pd, chi0_wGG, np.array(chi_wGG)
+        return qpd, chi0_wGG, np.array(chi_wGG)
 
     def get_dynamic_susceptibility(self, xc='ALDA', q_c=[0, 0, 0],
                                    q_v=None,
                                    rshelmax=-1, rshewmin=None,
-                                   spinpol_cut=None, density_cut=None,
-                                   fxc_scaling=None,
                                    filename='chiM_w.csv'):
         """Calculate the dynamic susceptibility.
 
         Returns macroscopic(could be generalized?) dynamic susceptibility:
         chiM0_w, chiM_w = DielectricFunction.get_dynamic_susceptibility()
         """
 
-        pd, chi0_wGG, chi_wGG = self.get_chi(xc=xc, q_c=q_c,
-                                             rshelmax=rshelmax,
-                                             rshewmin=rshewmin,
-                                             spinpol_cut=spinpol_cut,
-                                             density_cut=density_cut,
-                                             fxc_scaling=fxc_scaling,
-                                             return_VchiV=False)
+        qpd, chi0_wGG, chi_wGG = self.get_chi(xc=xc, q_c=q_c,
+                                              rshelmax=rshelmax,
+                                              rshewmin=rshewmin,
+                                              return_VchiV=False)
 
         rf0_w = np.zeros(len(chi_wGG), dtype=complex)
         rf_w = np.zeros(len(chi_wGG), dtype=complex)
 
         for w, (chi0_GG, chi_GG) in enumerate(zip(chi0_wGG, chi_wGG)):
             rf0_w[w] = chi0_GG[0, 0]
             rf_w[w] = chi_GG[0, 0]
 
         rf0_w = self.collect(rf0_w)
         rf_w = self.collect(rf_w)
 
         if filename is not None and mpi.rank == 0:
-            with open(filename, 'w') as fd:
-                for omega, rf0, rf in zip(self.wd.omega_w * Hartree,
-                                          rf0_w,
-                                          rf_w):
-                    print('%.6f, %.6f, %.6f, %.6f, %.6f' %
-                          (omega, rf0.real, rf0.imag, rf.real, rf.imag),
-                          file=fd)
+            write_response_function(filename, self.wd.omega_w * Hartree,
+                                    rf0_w, rf_w)
 
         return rf0_w, rf_w
 
     def get_dielectric_matrix(self, xc='RPA', q_c=[0, 0, 0],
                               direction='x', symmetric=True,
                               calculate_chi=False, q_v=None,
                               add_intraband=False):
@@ -381,56 +224,47 @@
         LRalpha (long-range kerne), where alpha is a user specified parameter
         (for example xc='LR0.25')
 
         The head of the inverse symmetrized dielectric matrix is equal
         to the head of the inverse dielectric matrix (inverse dielectric
         function)"""
 
-        pd, chi0_wGG, chi0_wxvG, chi0_wvv = self.calculate_chi0(q_c)
+        qpd, chi0_wGG, chi0_WxvG, chi0_Wvv = self.calculate_chi0(q_c)
 
         if add_intraband:
             print('add_intraband=True is not supported at this time')
             raise NotImplementedError
 
-        N_c = self.chi0.gs.kd.N_c
-        if self.truncation == 'wigner-seitz':
-            self.wstc = WignerSeitzTruncatedCoulomb(pd.gd.cell_cv, N_c)
-        else:
-            self.wstc = None
-        K_G = get_coulomb_kernel(pd,
-                                 N_c,
-                                 truncation=self.truncation,
-                                 wstc=self.wstc,
-                                 q_v=q_v)**0.5
+        K_G = self.coulomb.sqrtV(qpd=qpd, q_v=q_v)
         nG = len(K_G)
 
-        if pd.kd.gamma:
+        if qpd.kd.gamma:
             if isinstance(direction, str):
                 d_v = {'x': [1, 0, 0],
                        'y': [0, 1, 0],
                        'z': [0, 0, 1]}[direction]
             else:
                 d_v = direction
 
             d_v = np.asarray(d_v) / np.linalg.norm(d_v)
             W = self.blocks1d.myslice
-            chi0_wGG[:, 0] = np.dot(d_v, chi0_wxvG[W, 0])
-            chi0_wGG[:, :, 0] = np.dot(d_v, chi0_wxvG[W, 1])
-            chi0_wGG[:, 0, 0] = np.dot(d_v, np.dot(chi0_wvv[W], d_v).T)
+            chi0_wGG[:, 0] = np.dot(d_v, chi0_WxvG[W, 0])
+            chi0_wGG[:, :, 0] = np.dot(d_v, chi0_WxvG[W, 1])
+            chi0_wGG[:, 0, 0] = np.dot(d_v, np.dot(chi0_Wvv[W], d_v).T)
             if q_v is not None:
                 print('Restoring q dependence of head and wings of chi0')
                 chi0_wGG[:, 1:, 0] *= np.dot(q_v, d_v)
                 chi0_wGG[:, 0, 1:] *= np.dot(q_v, d_v)
                 chi0_wGG[:, 0, 0] *= np.dot(q_v, d_v)**2
 
         if xc != 'RPA':
-            Kxc_GG = get_xc_kernel(pd,
-                                   self.chi0,
-                                   functional=xc,
-                                   chi0_wGG=chi0_wGG)
+            Kxc_GG = get_density_xc_kernel(qpd,
+                                           self.gs, self.context,
+                                           functional=xc,
+                                           chi0_wGG=chi0_wGG)
 
         if calculate_chi:
             chi_wGG = []
 
         for chi0_GG in chi0_wGG:
             if xc == 'RPA':
                 P_GG = chi0_GG
@@ -459,15 +293,15 @@
             else:
                 chi_wGG = np.zeros((0, nG, nG), complex)
 
         if not calculate_chi:
             return chi0_wGG
         else:
             # chi_wGG is the full density response function..
-            return pd, chi0_wGG, chi_wGG
+            return qpd, chi0_wGG, chi_wGG
 
     def get_dielectric_function(self, xc='RPA', q_c=[0, 0, 0], q_v=None,
                                 direction='x', filename='df.csv'):
         """Calculate the dielectric function.
 
         Returns dielectric function without and with local field correction:
         df_NLFC_w, df_LFC_w = DielectricFunction.get_dielectric_function()
@@ -480,21 +314,16 @@
             df_NLFC_w[w] = e_GG[0, 0]
             df_LFC_w[w] = 1 / np.linalg.inv(e_GG)[0, 0]
 
         df_NLFC_w = self.collect(df_NLFC_w)
         df_LFC_w = self.collect(df_LFC_w)
 
         if filename is not None and mpi.rank == 0:
-            with open(filename, 'w') as fd:
-                for omega, nlfc, lfc in zip(self.wd.omega_w * Hartree,
-                                            df_NLFC_w,
-                                            df_LFC_w):
-                    print('%.6f, %.6f, %.6f, %.6f, %.6f' %
-                          (omega, nlfc.real, nlfc.imag, lfc.real, lfc.imag),
-                          file=fd)
+            write_response_function(filename, self.wd.omega_w * Hartree,
+                                    df_NLFC_w, df_LFC_w)
 
         return df_NLFC_w, df_LFC_w
 
     def get_macroscopic_dielectric_constant(self, xc='RPA',
                                             direction='x', q_v=None):
         """Calculate macroscopic dielectric constant.
 
@@ -507,28 +336,27 @@
 
         eM_LFC: float
             Dielectric constant without local field correction. (RPA, ALDA)
         eM2_NLFC: float
             Dielectric constant with local field correction.
         """
 
-        fd = self.chi0.fd
-        print('', file=fd)
-        print('%s Macroscopic Dielectric Constant:' % xc, file=fd)
+        self.context.print('', flush=False)
+        self.context.print('%s Macroscopic Dielectric Constant:' % xc)
 
         df_NLFC_w, df_LFC_w = self.get_dielectric_function(
             xc=xc,
             filename=None,
             direction=direction,
             q_v=q_v)
         eps0 = np.real(df_NLFC_w[0])
         eps = np.real(df_LFC_w[0])
-        print('  %s direction' % direction, file=fd)
-        print('    Without local field: %f' % eps0, file=fd)
-        print('    Include local field: %f' % eps, file=fd)
+        self.context.print('  %s direction' % direction, flush=False)
+        self.context.print('    Without local field: %f' % eps0, flush=False)
+        self.context.print('    Include local field: %f' % eps)
 
         return eps0, eps
 
     def get_eels_spectrum(self, xc='RPA', q_c=[0, 0, 0],
                           direction='x', filename='eels.csv'):
         r"""Calculate EELS spectrum. By default, generate a file 'eels.csv'.
 
@@ -536,63 +364,58 @@
         density response function as, EELS(\omega) = - 4 * \pi / q^2 Im \chi.
         Returns EELS spectrum without and with local field corrections:
 
         df_NLFC_w, df_LFC_w = DielectricFunction.get_eels_spectrum()
         """
 
         # Calculate V^1/2 \chi V^1/2
-        pd, Vchi0_wGG, Vchi_wGG = self.get_chi(xc=xc, q_c=q_c,
-                                               direction=direction)
-        Nw = self.wd.omega_w.shape[0]
+        qpd, Vchi0_wGG, Vchi_wGG = self.get_chi(xc=xc, q_c=q_c,
+                                                direction=direction)
 
         # Calculate eels = -Im 4 \pi / q^2  \chi
         eels_NLFC_w = -(1. / (1. - Vchi0_wGG[:, 0, 0])).imag
         eels_LFC_w = - (Vchi_wGG[:, 0, 0]).imag
 
         # Collect frequencies
         eels_NLFC_w = self.collect(eels_NLFC_w)
         eels_LFC_w = self.collect(eels_LFC_w)
 
         # Write to file
-        if filename is not None and mpi.rank == 0:
-            fd = open(filename, 'w')
-            print('# energy, eels_NLFC_w, eels_LFC_w', file=fd)
-            for iw in range(Nw):
-                print('%.6f, %.6f, %.6f' %
-                      (self.chi0.wd.omega_w[iw] * Hartree,
-                       eels_NLFC_w[iw], eels_LFC_w[iw]), file=fd)
-            fd.close()
+        if filename is not None and self.context.comm.rank == 0:
+            omega_w = self.wd.omega_w
+            write_response_function(filename, omega_w * Hartree,
+                                    eels_NLFC_w, eels_LFC_w)
 
         return eels_NLFC_w, eels_LFC_w
 
     def get_polarizability(self, xc='RPA', direction='x', q_c=[0, 0, 0],
                            filename='polarizability.csv'):
         r"""Calculate the polarizability alpha.
         In 3D the imaginary part of the polarizability is related to the
         dielectric function by Im(eps_M) = 4 pi * Im(alpha). In systems
         with reduced dimensionality the converged value of alpha is
         independent of the cell volume. This is not the case for eps_M,
-        which is ill defined. A truncated Coulomb kernel will always give
+        which is ill-defined. A truncated Coulomb kernel will always give
         eps_M = 1.0, whereas the polarizability maintains its structure.
 
-        By default, generate a file 'polarizability.csv'. The five colomns are:
+        By default, generate a file 'polarizability.csv'. The five columns are:
         frequency (eV), Real(alpha0), Imag(alpha0), Real(alpha), Imag(alpha)
         alpha0 is the result without local field effects and the
         dimension of alpha is \AA to the power of non-periodic directions
         """
 
-        cell_cv = self.chi0.gs.gd.cell_cv
-        pbc_c = self.chi0.gs.pbc
+        cell_cv = self.gs.gd.cell_cv
+        pbc_c = self.gs.pbc
 
         if pbc_c.all():
             V = 1.0
         else:
             V = np.abs(np.linalg.det(cell_cv[~pbc_c][:, ~pbc_c]))
 
-        if not self.truncation:
+        if not self.coulomb.truncation:
             """Standard expression for the polarizability"""
             df0_w, df_w = self.get_dielectric_function(xc=xc,
                                                        q_c=q_c,
                                                        filename=None,
                                                        direction=direction)
             alpha_w = V * (df_w - 1.0) / (4 * pi)
             alpha0_w = V * (df0_w - 1.0) / (4 * pi)
@@ -605,267 +428,168 @@
             #
             # where <v_ind> = 4 * pi * \chi / q^2 is the averaged induced
             # potential (relative to the strength of the  external potential).
             # With the bare Coulomb potential, this expression is equivalent to
             # the standard one. In a 2D system \chi should be calculated with a
             # truncated Coulomb potential and eps_M = 1.0
 
-            print('Using truncated Coulomb interaction', file=self.chi0.fd)
+            self.context.print('Using truncated Coulomb interaction')
 
-            pd, chi0_wGG, chi_wGG = self.get_chi(xc=xc,
-                                                 q_c=q_c,
-                                                 direction=direction)
+            qpd, chi0_wGG, chi_wGG = self.get_chi(xc=xc,
+                                                  q_c=q_c,
+                                                  direction=direction)
             alpha_w = -V * (chi_wGG[:, 0, 0]) / (4 * pi)
             alpha0_w = -V * (chi0_wGG[:, 0, 0]) / (4 * pi)
 
             alpha_w = self.collect(alpha_w)
             alpha0_w = self.collect(alpha0_w)
 
-        Nw = len(alpha_w)
-        if filename is not None and mpi.rank == 0:
-            fd = open(filename, 'w')
-            for iw in range(Nw):
-                print('%.6f, %.6f, %.6f, %.6f, %.6f' %
-                      (self.chi0.wd.omega_w[iw] * Hartree,
-                       alpha0_w[iw].real * Bohr**(sum(~pbc_c)),
-                       alpha0_w[iw].imag * Bohr**(sum(~pbc_c)),
-                       alpha_w[iw].real * Bohr**(sum(~pbc_c)),
-                       alpha_w[iw].imag * Bohr**(sum(~pbc_c))), file=fd)
-            fd.close()
+        # Convert to external units
+        hypervol = Bohr**(sum(~pbc_c))
+        alpha0_w *= hypervol
+        alpha_w *= hypervol
+
+        # Write results file
+        if filename is not None and self.context.comm.rank == 0:
+            omega_w = self.wd.omega_w
+            write_response_function(filename, omega_w * Hartree,
+                                    alpha0_w, alpha_w)
 
-        return alpha0_w * Bohr**(sum(~pbc_c)), alpha_w * Bohr**(sum(~pbc_c))
+        return alpha0_w, alpha_w
 
     def check_sum_rule(self, spectrum=None):
         """Check f-sum rule.
 
-        It takes the y of a spectrum as an entry and it check its integral.
+        It takes the y of a spectrum as an entry and it checks its integral.
 
         spectrum: np.ndarray
             Input spectrum
 
         Note: not tested for spin response
         """
 
         assert (self.wd.omega_w[1:] - self.wd.omega_w[:-1]).ptp() < 1e-10
 
-        fd = self.chi0.fd
-
         if spectrum is None:
             raise ValueError('No spectrum input ')
-        dw = self.chi0.wd.omega_w[1] - self.chi0.wd.omega_w[0]
+        dw = self.wd.omega_w[1] - self.wd.omega_w[0]
         N1 = 0
         for iw in range(len(spectrum)):
             w = iw * dw
             N1 += spectrum[iw] * w
-        N1 *= dw * self.chi0.vol / (2 * pi**2)
+        N1 *= dw * self.gs.volume / (2 * pi**2)
 
-        print('', file=fd)
-        print('Sum rule:', file=fd)
-        nv = self.chi0.gs.nvalence
-        print('N1 = %f, %f  %% error' % (N1, (N1 - nv) / nv * 100), file=fd)
-
-    def get_eigenmodes(self, q_c=[0, 0, 0], w_max=None, name=None,
-                       eigenvalue_only=False, direction='x',
-                       checkphase=True):
-        """Plasmon eigenmodes as eigenvectors of the dielectric matrix."""
-
-        assert self.chi0.world.size == 1
-
-        pd, chi0_wGG, chi0_wxvG, chi0_wvv = self.calculate_chi0(q_c)
-        e_wGG = self.get_dielectric_matrix(xc='RPA', q_c=q_c,
-                                           direction=direction,
-                                           symmetric=False)
-
-        kd = pd.kd
-
-        # Get real space grid for plasmon modes:
-        r = pd.gd.get_grid_point_coordinates()
-        w_w = self.wd.omega_w * Hartree
-        if w_max:
-            w_w = w_w[np.where(w_w < w_max)]
-        Nw = len(w_w)
-        nG = e_wGG.shape[1]
-
-        eig = np.zeros([Nw, nG], dtype=complex)
-        eig_all = np.zeros([Nw, nG], dtype=complex)
-
-        # Find eigenvalues and eigenvectors:
-        e_GG = e_wGG[0]
-        eig_all[0], vec = np.linalg.eig(e_GG)
-        eig[0] = eig_all[0]
-        vec_dual = np.linalg.inv(vec)
-        omega0 = np.array([])
-        eigen0 = np.array([], dtype=complex)
-        v_ind = np.zeros([0, r.shape[1], r.shape[2], r.shape[3]],
-                         dtype=complex)
-        n_ind = np.zeros([0, r.shape[1], r.shape[2], r.shape[3]],
-                         dtype=complex)
-
-        # Loop to find the eigenvalues that crosses zero
-        # from negative to positive values:
-        for i in np.array(range(1, Nw)):
-            e_GG = e_wGG[i]  # epsilon_GG'(omega + d-omega)
-            eig_all[i], vec_p = np.linalg.eig(e_GG)
-            vec_dual_p = np.linalg.inv(vec_p)
-            overlap = np.abs(np.dot(vec_dual, vec_p))
-            index = list(np.argsort(overlap)[:, -1])
-            if len(np.unique(index)) < nG:  # add missing indices
-                addlist = []
-                removelist = []
-                for j in range(nG):
-                    if index.count(j) < 1:
-                        addlist.append(j)
-                    if index.count(j) > 1:
-                        for l in range(1, index.count(j)):
-                            removelist += \
-                                list(np.argwhere(np.array(index) == j)[l])
-                for j in range(len(addlist)):
-                    index[removelist[j]] = addlist[j]
-
-            vec = vec_p[:, index]
-            vec_dual = vec_dual_p[index, :]
-            eig[i] = eig_all[i, index]
-            for k in [k for k in range(nG)
-                      # Eigenvalue crossing:
-                      if (eig[i - 1, k] < 0 and eig[i, k] > 0)]:
-                a = np.real((eig[i, k] - eig[i - 1, k]) /
-                            (w_w[i] - w_w[i - 1]))
-                # linear interp for crossing point
-                w0 = np.real(-eig[i - 1, k]) / a + w_w[i - 1]
-                eig0 = a * (w0 - w_w[i - 1]) + eig[i - 1, k]
-                print('crossing found at w = %1.2f eV' % w0)
-                omega0 = np.append(omega0, w0)
-                eigen0 = np.append(eigen0, eig0)
-
-                # Fourier Transform:
-                qG = pd.get_reciprocal_vectors(add_q=True)
-                coef_G = np.diagonal(np.inner(qG, qG)) / (4 * pi)
-                qGr_R = np.inner(qG, r.T).T
-                factor = np.exp(1j * qGr_R)
-                v_temp = np.dot(factor, vec[:, k])
-                n_temp = np.dot(factor, vec[:, k] * coef_G)
-                if checkphase:  # rotate eigenvectors in complex plane
-                    integral = np.zeros([81])
-                    phases = np.linspace(0, 2, 81)
-                    for ip in range(81):
-                        v_int = v_temp * np.exp(1j * pi * phases[ip])
-                        integral[ip] = abs(np.imag(v_int)).sum()
-                    phase = phases[np.argsort(integral)][0]
-                    v_temp *= np.exp(1j * pi * phase)
-                    n_temp *= np.exp(1j * pi * phase)
-                v_ind = np.append(v_ind, v_temp[np.newaxis, :], axis=0)
-                n_ind = np.append(n_ind, n_temp[np.newaxis, :], axis=0)
-
-        kd = self.chi0.gs.kd
-        if name is None and self.name:
-            name = (self.name + '%+d%+d%+d-eigenmodes.pckl' %
-                    tuple((q_c * kd.N_c).round()))
-        elif name:
-            name = (name + '%+d%+d%+d-eigenmodes.pckl' %
-                    tuple((q_c * kd.N_c).round()))
-        else:
-            name = '%+d%+d%+d-eigenmodes.pckl' % tuple((q_c * kd.N_c).round())
+        self.context.print('', flush=False)
+        self.context.print('Sum rule:', flush=False)
+        nv = self.gs.nvalence
+        self.context.print('N1 = %f, %f  %% error' %
+                           (N1, (N1 - nv) / nv * 100))
 
-        # Returns: real space grid, frequency grid,
-        # sorted eigenvalues, zero-crossing frequencies + eigenvalues,
-        # induced potential + density in real space.
-        if eigenvalue_only:
-            with open(name, 'wb') as fd:
-                pickle.dump((r * Bohr, w_w, eig),
-                            fd, pickle.HIGHEST_PROTOCOL)
-            return r * Bohr, w_w, eig
-        else:
-            with open(name, 'wb') as fd:
-                pickle.dump((r * Bohr, w_w, eig, omega0, eigen0,
-                             v_ind, n_ind), fd,
-                            pickle.HIGHEST_PROTOCOL)
-            return r * Bohr, w_w, eig, omega0, eigen0, v_ind, n_ind
-
-    def get_spatial_eels(self, q_c=[0, 0, 0], direction='x',
-                         w_max=None, filename='eels', r=None, perpdir=None):
-        r"""Spatially resolved loss spectrum.
-
-        The spatially resolved loss spectrum is calculated as the inverse
-        fourier transform of ``VChiV = (eps^{-1}-I)V``::
-
-            EELS(w,r) = - Im [sum_{G,G'} e^{iGr} Vchi_{GG'}(w) V_G'e^{-iG'r}]
-                          \delta(w-G\dot v_e )
-
-        Input parameters:
-
-        direction: 'x', 'y', or 'z'
-            The direction for scanning acroos the structure
-            (perpendicular to the electron beam) .
-        w_max: float
-            maximum frequency
-        filename: str
-            name of output
 
-        Returns: real space grid, frequency points, EELS(w,r)
+class DielectricFunction(DielectricFunctionCalculator):
+    """This class defines dielectric function related physical quantities."""
+
+    def __init__(self, calc, *,
+                 frequencies=None,
+                 domega0=None,  # deprecated
+                 omega2=None,  # deprecated
+                 omegamax=None,  # deprecated
+                 ecut=50,
+                 hilbert=True,
+                 nbands=None, eta=0.2, threshold=1,
+                 intraband=True, nblocks=1, world=mpi.world, txt=sys.stdout,
+                 truncation=None, disable_point_group=False,
+                 disable_time_reversal=False,
+                 integrationmode=None, rate=0.0,
+                 eshift=0.0):
+        """Creates a DielectricFunction object.
+
+        calc: str
+            The ground-state calculation file that the linear response
+            calculation is based on.
+        frequencies:
+            Input parameters for frequency_grid.
+            Can be an array of frequencies to evaluate the response function at
+            or dictionary of parameters for build-in nonlinear grid
+            (see :ref:`frequency grid`).
+        ecut: float
+            Plane-wave cut-off.
+        hilbert: bool
+            Use hilbert transform.
+        nbands: int
+            Number of bands from calculation.
+        eta: float
+            Broadening parameter.
+        threshold: float
+            Threshold for matrix elements in optical response perturbation
+            theory.
+        intraband: bool
+            Include intraband transitions.
+        world: comm
+            mpi communicator.
+        nblocks: int
+            Split matrices in nblocks blocks and distribute them G-vectors or
+            frequencies over processes.
+        txt: str
+            Output file.
+        truncation: str or None
+            None for no truncation.
+            '2D' for standard analytical truncation scheme.
+            Non-periodic directions are determined from k-point grid
+        eshift: float
+            Shift unoccupied bands
         """
 
-        assert self.chi0.world.size == 1
+        gs, context = get_gs_and_context(calc, txt, world, timer=None)
+        nbands = nbands or gs.bd.nbands
+
+        wd = new_frequency_descriptor(gs, context, nbands, frequencies,
+                                      domega0=domega0,
+                                      omega2=omega2, omegamax=omegamax)
+
+        pair = PairDensityCalculator(
+            gs=gs, context=context, threshold=threshold, nblocks=nblocks)
+
+        chi0calc = Chi0Calculator(
+            wd=wd,
+            pair=pair,
+            ecut=ecut, nbands=nbands, eta=eta,
+            hilbert=hilbert,
+            intraband=intraband,
+            disable_point_group=disable_point_group,
+            disable_time_reversal=disable_time_reversal,
+            integrationmode=integrationmode,
+            rate=rate, eshift=eshift
+        )
+
+        super().__init__(chi0calc=chi0calc, truncation=truncation)
+
+
+def write_response_function(filename, omega_w, rf0_w, rf_w):
+    with open(filename, 'w') as fd:
+        for omega, rf0, rf in zip(omega_w, rf0_w, rf_w):
+            if rf0_w.dtype == complex:
+                print('%.6f, %.6f, %.6f, %.6f, %.6f' %
+                      (omega, rf0.real, rf0.imag, rf.real, rf.imag),
+                      file=fd)
+            else:
+                print('%.6f, %.6f, %.6f' % (omega, rf0, rf), file=fd)
+
 
-        pd, chi0_wGG, chi0_wxvG, chi0_wvv = self.calculate_chi0(q_c)
-        e_wGG = self.get_dielectric_matrix(xc='RPA', q_c=q_c,
-                                           symmetric=False)
-
-        if r is None:
-            r = pd.gd.get_grid_point_coordinates()
-            ix = r.shape[1] // 2 * 0
-            iy = r.shape[2] // 2 * 0
-            iz = r.shape[3] // 2
-            if direction == 'x':
-                r = r[:, :, iy, iz]
-                perpdir = [1, 2]
-            if direction == 'y':
-                r = r[:, ix, :, iz]
-                perpdir = [0, 2]
-            if direction == 'z':
-                r = r[:, ix, iy, :]
-                perpdir = [0, 1]
-
-        nG = e_wGG.shape[1]
-        Gvec = pd.G_Qv[pd.Q_qG[0]]
-        Glist = []
-
-        # Only use G-vectors that are zero along electron beam
-        # due to \delta(w-G\dot v_e )
-        q_v = pd.K_qv[0]
-        for iG in range(nG):
-            if perpdir is not None:
-                if Gvec[iG, perpdir[0]] == 0 and Gvec[iG, perpdir[1]] == 0:
-                    Glist.append(iG)
-            elif not np.abs(np.dot(q_v, Gvec[iG])) < \
-                    np.linalg.norm(q_v) * np.linalg.norm(Gvec[iG]):
-                Glist.append(iG)
-        qG = Gvec[Glist] + pd.K_qv
-
-        w_w = self.wd.omega_w * Hartree
-        if w_max:
-            w_w = w_w[np.where(w_w < w_max)]
-        Nw = len(w_w)
-        qGr = np.inner(qG, r.T).T
-        phase = np.exp(1j * qGr)
-        V_G = (4 * pi) / np.diagonal(np.inner(qG, qG))
-        phase2 = np.exp(-1j * qGr) * V_G
-        E_wrr = np.zeros([Nw, r.shape[1], r.shape[1]])
-        E_wr = np.zeros([Nw, r.shape[1]])
-        Eavg_w = np.zeros([Nw], complex)
-        Ec_wr = np.zeros([Nw, r.shape[1]], complex)
-        for i in range(Nw):
-            Vchi_GG = (np.linalg.inv(e_wGG[i]) -
-                       np.eye(nG))[Glist, :][:, Glist]
-
-            qG_G = np.sum(qG**2, axis=1)**0.5
-            Eavg_w[i] = np.trace(Vchi_GG * np.diag(V_G * qG_G))
-
-            # Fourier transform:
-            E_wrr[i] = -np.imag(np.dot(np.dot(phase, Vchi_GG), phase2.T))
-            E_wr[i] = np.diagonal(E_wrr[i])
-            Ec_wr[i] = np.diagonal(np.dot(np.dot(phase, Vchi_GG *
-                                                 np.diag(qG_G)), phase2.T))
-        with open('%s.pickle' % filename, 'wb') as fd:
-            pickle.dump((r * Bohr, w_w, E_wr), fd,
-                        pickle.HIGHEST_PROTOCOL)
+def read_response_function(filename):
+    """Read a stored response function file"""
+    d = np.loadtxt(filename, delimiter=',')
+    omega_w = np.array(d[:, 0], float)
+
+    if d.shape[1] == 3:
+        # Real response function
+        rf0_w = np.array(d[:, 1], float)
+        rf_w = np.array(d[:, 2], float)
+    elif d.shape[1] == 5:
+        rf0_w = np.array(d[:, 1], complex)
+        rf0_w.imag = d[:, 2]
+        rf_w = np.array(d[:, 3], complex)
+        rf_w.imag = d[:, 4]
+    else:
+        raise ValueError(f'Unexpected array dimension {d.shape}')
 
-        return r * Bohr, w_w, E_wr, Ec_wr, Eavg_w
+    return omega_w, rf0_w, rf_w
```

### Comparing `gpaw-22.8.0/gpaw/response/frequencies.py` & `gpaw-23.6.0/gpaw/response/frequencies.py`

 * *Files 24% similar despite different names*

```diff
@@ -55,14 +55,62 @@
             return NonLinearFrequencyDescriptor(
                 (0.1 if domega0 is None else domega0) / Ha,
                 (10.0 if omega2 is None else omega2) / Ha,
                 omegamax / Ha)
         return FrequencyGridDescriptor(np.asarray(input) / Ha)
 
 
+class ComplexFrequencyDescriptor:
+
+    def __init__(self, hz_z: ArrayLike1D):
+        """Construct the complex frequency descriptor.
+
+        Parameters
+        ----------
+        hz_z:
+            Array of complex frequencies (in units of Hartree)
+        """
+        # Use a copy of the input array
+        hz_z = np.array(hz_z)
+        assert hz_z.dtype == complex
+
+        self.hz_z = hz_z
+
+    def __len__(self):
+        return len(self.hz_z)
+
+    def almost_eq(self, zd):
+        if len(zd) != len(self):
+            return False
+        return np.allclose(self.hz_z, zd.hz_z)
+
+    @staticmethod
+    def from_array(frequencies: ArrayLike1D):
+        """Create a ComplexFrequencyDescriptor from frequencies in eV."""
+        return ComplexFrequencyDescriptor(np.asarray(frequencies) / Ha)
+
+    @property
+    def upper_half_plane(self):
+        """All frequencies reside in the upper half complex frequency plane?"""
+        return np.all(self.hz_z.imag > 0.)
+
+    @property
+    def horizontal_contour(self):
+        """Do all frequency point lie on a horizontal contour?"""
+        return np.ptp(self.hz_z.imag) < 1.e-6
+
+    @property
+    def omega_w(self):
+        """Real part of the frequencies."""
+        assert self.horizontal_contour,\
+            'It only makes sense to index the frequencies by their real part '\
+            'if they reside on a horizontal contour.'
+        return self.hz_z.real
+
+
 class FrequencyGridDescriptor(FrequencyDescriptor):
 
     def get_index_range(self, lim1_m, lim2_m):
         """Get index range. """
 
         i0_m = np.zeros(len(lim1_m), int)
         i1_m = np.zeros(len(lim2_m), int)
```

### Comparing `gpaw-22.8.0/gpaw/response/g0w0.py` & `gpaw-23.6.0/gpaw/response/g0w0.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,56 +1,128 @@
 import functools
-import os
 import pickle
 import warnings
 from math import pi
 from pathlib import Path
 
-import gpaw.mpi as mpi
 import numpy as np
-from ase.dft.kpoints import monkhorst_pack
+
 from ase.parallel import paropen
 from ase.units import Ha
-from ase.utils import opencew, pickleload
-from ase.utils.timing import timer
+
 from gpaw import GPAW, debug
-from gpaw.kpt_descriptor import KPointDescriptor
+import gpaw.mpi as mpi
+from gpaw.hybrids.eigenvalues import non_self_consistent_eigenvalues
+from gpaw.pw.descriptor import (count_reciprocal_vectors, PWMapping)
+from gpaw.utilities.progressbar import ProgressBar
+
+from gpaw.response import ResponseGroundStateAdapter, ResponseContext
 from gpaw.response.chi0 import Chi0Calculator
-from gpaw.pw.descriptor import (PWDescriptor, PWMapping,
-                                count_reciprocal_vectors)
-from gpaw.response.fxckernel_calc import calculate_kernel
-from gpaw.response.gamma_int import GammaIntegrator
-from gpaw.response.hilbert import GWHilbertTransforms
-from gpaw.response.kernels import get_coulomb_kernel, get_integrated_kernel
-from gpaw.response.pair import NoCalculatorPairDensity
+from gpaw.response.pair import PairDensityCalculator, phase_shifted_fft_indices
+from gpaw.response.pair_functions import SingleQPWDescriptor
 from gpaw.response.pw_parallelization import Blocks1D
-from gpaw.response.q0_correction import Q0Correction
-from gpaw.response.temp import DielectricFunctionCalculator
-from gpaw.response.wstc import WignerSeitzTruncatedCoulomb
-from gpaw.utilities.progressbar import ProgressBar
-from gpaw.xc.exx import EXX, select_kpts
-from gpaw.xc.fxc import XCFlags
-from gpaw.xc.tools import vxc
-from gpaw.response.context import calc_and_context
+from gpaw.response.screened_interaction import initialize_w_calculator
+from gpaw.response.coulomb_kernels import CoulombKernel
+from gpaw.response import timer
+
+
+from ase.utils.filecache import MultiFileJSONCache as FileCache
+from contextlib import ExitStack
+from ase.parallel import broadcast
+
+
+def compare_dicts(dict1, dict2, rel_tol=1e-14, abs_tol=1e-14):
+    """
+    Compare each key-value pair within dictionaries that contain nested data
+    structures of arbitrary depth. If a kvp contains floats, you may specify
+    the tolerance (abs or rel) to which the floats are compared. Individual
+    elements within lists are not compared to floating point precision.
+
+    :params dict1: Dictionary containing kvp to compare with other dictionary.
+    :params dict2: Second dictionary.
+    :params rel_tol: Maximum difference for being considered "close",
+    relative to the magnitude of the input values as defined by math.isclose().
+    :params abs_tol: Maximum difference for being considered "close",
+    regardless of the magnitude of the input values as defined by
+    math.isclose().
+
+    :returns: bool indicating kvp's don't match (False) or do match (True)
+    """
+    from math import isclose
+    if dict1.keys() != dict2.keys():
+        return False
+
+    for key in dict1.keys():
+        val1 = dict1[key]
+        val2 = dict2[key]
+
+        if isinstance(val1, dict) and isinstance(val2, dict):
+            # recursive func call to ensure nested structures are also compared
+            if not compare_dicts(val1, val2, rel_tol, abs_tol):
+                return False
+        elif isinstance(val1, float) and isinstance(val2, float):
+            if not isclose(val1, val2, rel_tol=rel_tol, abs_tol=abs_tol):
+                return False
+        else:
+            if val1 != val2:
+                return False
+
+    return True
 
 
 class Sigma:
-    def __init__(self, esknshape):
-        self._buf = np.zeros((2, * esknshape))
+    def __init__(self, iq, q_c, fxc, esknshape, **inputs):
+        """Inputs are used for cache invalidation, and are stored for each
+           file.
+        """
+        self.iq = iq
+        self.q_c = q_c
+        self.fxc = fxc
+        self._buf = np.zeros((2, *esknshape))
         # self-energies and derivatives:
         self.sigma_eskn, self.dsigma_eskn = self._buf
 
+        self.inputs = inputs
+
     def sum(self, comm):
         comm.sum(self._buf)
 
+    def __iadd__(self, other):
+        self.validate_inputs(other.inputs)
+        self._buf += other._buf
+        return self
+
+    def validate_inputs(self, inputs):
+        equals = compare_dicts(inputs, self.inputs, rel_tol=1e-14,
+                               abs_tol=1e-14)
+        if not equals:
+            raise RuntimeError('There exists a cache with mismatching input '
+                               f'parameters: {inputs} != {self.inputs}.')
+
+    @classmethod
+    def fromdict(cls, dct):
+        instance = cls(dct['iq'], dct['q_c'], dct['fxc'],
+                       dct['sigma_eskn'].shape, **dct['inputs'])
+        instance.sigma_eskn[:] = dct['sigma_eskn']
+        instance.dsigma_eskn[:] = dct['dsigma_eskn']
+        return instance
+
+    def todict(self):
+        return {'iq': self.iq,
+                'q_c': self.q_c,
+                'fxc': self.fxc,
+                'sigma_eskn': self.sigma_eskn,
+                'dsigma_eskn': self.dsigma_eskn,
+                'inputs': self.inputs}
+
 
 class G0W0Outputs:
-    def __init__(self, fd, shape, ecut_e, sigma_eskn, dsigma_eskn,
+    def __init__(self, context, shape, ecut_e, sigma_eskn, dsigma_eskn,
                  eps_skn, vxc_skn, exx_skn, f_skn):
-        self.extrapolate(fd, shape, ecut_e, sigma_eskn, dsigma_eskn)
+        self.extrapolate(context, shape, ecut_e, sigma_eskn, dsigma_eskn)
         self.Z_skn = 1 / (1 - self.dsigma_skn)
 
         # G0W0 single-step.
         # If we want GW0 again, we need to grab the expressions
         # from e.g. e73917fca5b9dc06c899f00b26a7c46e7d6fa749
         # or earlier and use qp correctly.
         self.qp_skn = eps_skn + self.Z_skn * (
@@ -60,32 +132,31 @@
         self.dsigma_eskn = dsigma_eskn
 
         self.eps_skn = eps_skn
         self.vxc_skn = vxc_skn
         self.exx_skn = exx_skn
         self.f_skn = f_skn
 
-    def extrapolate(self, fd, shape, ecut_e, sigma_eskn, dsigma_eskn):
+    def extrapolate(self, context, shape, ecut_e, sigma_eskn, dsigma_eskn):
         if len(ecut_e) == 1:
             self.sigma_skn = sigma_eskn[0]
             self.dsigma_skn = dsigma_eskn[0]
             self.sigr2_skn = None
             self.dsigr2_skn = None
             return
 
         from scipy.stats import linregress
 
         # Do linear fit of selfenergy vs. inverse of number of plane waves
         # to extrapolate to infinite number of plane waves
 
-        print('', file=fd)
-        print('Extrapolating selfenergy to infinite energy cutoff:',
-              file=fd)
-        print('  Performing linear fit to %d points' % len(ecut_e),
-              file=fd)
+        context.print('', flush=False)
+        context.print('Extrapolating selfenergy to infinite energy cutoff:',
+                      flush=False)
+        context.print('  Performing linear fit to %d points' % len(ecut_e))
         self.sigr2_skn = np.zeros(shape)
         self.dsigr2_skn = np.zeros(shape)
         self.sigma_skn = np.zeros(shape)
         self.dsigma_skn = np.zeros(shape)
         invN_i = ecut_e**(-3. / 2)
         for m in range(np.product(shape)):
             s, k, n = np.unravel_index(m, shape)
@@ -99,21 +170,21 @@
             slope, intercept, r_value, p_value, std_err = \
                 linregress(invN_i, dsigma_eskn[:, s, k, n])
 
             self.dsigr2_skn[s, k, n] = r_value**2
             self.dsigma_skn[s, k, n] = intercept
 
         if np.any(self.sigr2_skn < 0.9) or np.any(self.dsigr2_skn < 0.9):
-            print('  Warning: Bad quality of linear fit for some (n,k). ',
-                  file=fd)
-            print('           Higher cutoff might be necesarry.', file=fd)
-
-        print('  Minimum R^2 = %1.4f. (R^2 Should be close to 1)' %
-              min(np.min(self.sigr2_skn), np.min(self.dsigr2_skn)),
-              file=fd)
+            context.print('  Warning: Bad quality of linear fit for some ('
+                          'n,k). ', flush=False)
+            context.print('           Higher cutoff might be necessary.',
+                          flush=False)
+
+        context.print('  Minimum R^2 = %1.4f. (R^2 Should be close to 1)' %
+                      min(np.min(self.sigr2_skn), np.min(self.dsigr2_skn)))
 
     def get_results_eV(self):
         results = {
             'f': self.f_skn,
             'eps': self.eps_skn * Ha,
             'vxc': self.vxc_skn * Ha,
             'exx': self.exx_skn * Ha,
@@ -143,19 +214,14 @@
     def apply(self, q_c):
         return self.sign * (self.U_cc @ q_c)
 
     def check_q_Q_symmetry(self, Q_c, q_c):
         d_c = self.apply(q_c) - Q_c
         assert np.allclose(d_c.round(), d_c)
 
-    def get_shift0(self, q_c, Q_c):
-        shift0_c = q_c - self.apply(Q_c)
-        assert np.allclose(shift0_c.round(), shift0_c)
-        return shift0_c.round().astype(int)
-
     def get_M_vv(self, cell_cv):
         # We'll be inverting these cells a lot.
         # Should have an object with the cell and its inverse which does this.
         return cell_cv.T @ self.U_cc.T @ np.linalg.inv(cell_cv).T
 
     @classmethod
     def get_symops(cls, qd, iq, q_c):
@@ -175,14 +241,54 @@
                     sign=1 - 2 * time_reversal)
 
                 symop.check_q_Q_symmetry(Q_c, q_c)
                 # Q_c, symop = QSymmetryOp.from_qd(qd, Q2, q_c)
                 yield Q_c, symop
                 done.add(Q2)
 
+    @classmethod
+    def get_symop_from_kpair(cls, kd, qd, kpt1, kpt2):
+        # from k-point pair kpt1, kpt2 get Q_c = kpt2-kpt1, corrsponding IBZ
+        # k-point q_c, indexes iQ, iq and symmetry transformation relating
+        # Q_c to q_c
+        Q_c = kd.bzk_kc[kpt2.K] - kd.bzk_kc[kpt1.K]
+        iQ = qd.where_is_q(Q_c, qd.bzk_kc)
+        iq = qd.bz2ibz_k[iQ]
+        q_c = qd.ibzk_kc[iq]
+
+        # Find symmetry that transforms Q_c into q_c
+        sym = qd.sym_k[iQ]
+        U_cc = qd.symmetry.op_scc[sym]
+        time_reversal = qd.time_reversal_k[iQ]
+        sign = 1 - 2 * time_reversal
+        symop = cls(sym, U_cc, sign)
+        symop.check_q_Q_symmetry(Q_c, q_c)
+
+        return symop, iq
+
+    def apply_symop_q(self, qpd, pawcorr, kpt1, kpt2):
+        # returns necessary quantities to get symmetry transformed
+        # density matrix
+        Q_G = phase_shifted_fft_indices(kpt1.k_c, kpt2.k_c, qpd,
+                                        coordinate_transformation=self.apply)
+
+        qG_Gv = qpd.get_reciprocal_vectors(add_q=True)
+        M_vv = self.get_M_vv(qpd.gd.cell_cv)
+        mypawcorr = pawcorr.remap_by_symop(self, qG_Gv, M_vv)
+
+        return mypawcorr, Q_G
+
+
+def get_nmG(kpt1, kpt2, mypawcorr, n, qpd, I_G, pair):
+    ut1cc_R = kpt1.ut_nR[n].conj()
+    C1_aGi = mypawcorr.multiply(kpt1.P_ani, band=n)
+    n_mG = pair.calculate_pair_density(
+        ut1cc_R, C1_aGi, kpt2, qpd, I_G)
+    return n_mG
+
 
 gw_logo = """\
   ___  _ _ _
  |   || | | |
  | | || | | |
  |__ ||_____|
  |___|
@@ -195,18 +301,17 @@
         raise Exception('Using a calulator is not implemented at '
                         'the moment, load from file!')
         # nblocks_calc = calc
     else:
         nblocks_calc = GPAW(calc)
     ngmax = []
     for q_c in nblocks_calc.wfs.kd.bzk_kc:
-        qd = KPointDescriptor([q_c])
-        pd = PWDescriptor(np.min(ecut) / Ha,
-                          nblocks_calc.wfs.gd, complex, qd)
-        ngmax.append(pd.ngmax)
+        qpd = SingleQPWDescriptor.from_q(q_c, np.min(ecut) / Ha,
+                                         nblocks_calc.wfs.gd)
+        ngmax.append(qpd.ngmax)
     nG = np.min(ngmax)
 
     while nblocks > nG**0.5 + 1 or world.size % nblocks != 0:
         nblocks -= 1
 
     mynG = (nG + nblocks - 1) // nblocks
     assert mynG * (nblocks - 1) < nG
@@ -225,224 +330,183 @@
                        'domega0': 0.025,
                        'omega2': 10.0}
     else:
         assert frequencies['type'] == 'nonlinear'
     return frequencies
 
 
-def get_qdescriptor(kd, atoms):
-    # Find q-vectors and weights in the IBZ:
-    assert -1 not in kd.bz2bz_ks
-    offset_c = 0.5 * ((kd.N_c + 1) % 2) / kd.N_c
-    bzq_qc = monkhorst_pack(kd.N_c) + offset_c
-    qd = KPointDescriptor(bzq_qc)
-    qd.set_symmetry(atoms, kd.symmetry)
-    return qd
-
-
 def choose_ecut_things(ecut, ecut_extrapolation):
     if ecut_extrapolation is True:
         pct = 0.8
         necuts = 3
         ecut_e = ecut * (1 + (1. / pct - 1) * np.arange(necuts)[::-1] /
                          (necuts - 1))**(-2 / 3)
     elif isinstance(ecut_extrapolation, (list, np.ndarray)):
         ecut_e = np.array(np.sort(ecut_extrapolation))
         ecut = ecut_e[-1]
     else:
         ecut_e = np.array([ecut])
     return ecut, ecut_e
 
 
+def select_kpts(kpts, kd):
+    """Function to process input parameters that take a list of k-points given
+    in different format and returns a list of indices of the corresponding
+    k-points in the IBZ."""
+
+    if kpts is None:
+        # Do all k-points in the IBZ:
+        return np.arange(kd.nibzkpts)
+
+    if np.asarray(kpts).ndim == 1:
+        return kpts
+
+    # Find k-points:
+    bzk_Kc = kd.bzk_kc
+    indices = []
+    for k_c in kpts:
+        d_Kc = bzk_Kc - k_c
+        d_Kc -= d_Kc.round()
+        K = abs(d_Kc).sum(1).argmin()
+        if not np.allclose(d_Kc[K], 0):
+            raise ValueError('Could not find k-point: {k_c}'
+                             .format(k_c=k_c))
+        k = kd.bz2ibz_k[K]
+        indices.append(k)
+    return indices
+
+
 class G0W0Calculator:
     def __init__(self, filename='gw', *,
                  chi0calc,
-                 restartfile=None,
-                 kpts, bands, nbands=None, ppa,
-                 xckernel,
-                 fxc_mode='GW', do_GW_too=False,
-                 truncation=None, integrate_gamma=0,
-                 eta, E0,
+                 wcalc,
+                 kpts, bands, nbands=None,
+                 fxc_modes,
+                 eta,
                  ecut_e,
                  frequencies=None,
-                 q0_correction=False,
-                 savepckl=True,
-                 context):
+                 exx_vxc_calculator,
+                 ppa=False):
+        """G0W0 calculator, initialized through G0W0 object.
 
-        """G0W0 calculator.
-
-        The G0W0 calculator is used is used to calculate the quasi
+        The G0W0 calculator is used to calculate the quasi
         particle energies through the G0W0 approximation for a number
         of states.
 
         Parameters
         ----------
-        calc:
-            GPAW calculator object or filename of saved calculator object.
         filename: str
             Base filename of output files.
-        restartfile: str
-            File that stores data necessary to restart a calculation.
+        wcalc: WCalculator object
+            Defines the calculator for computing the screened interaction
         kpts: list
             List of indices of the IBZ k-points to calculate the quasi particle
             energies for.
         bands:
             Range of band indices, like (n1, n2), to calculate the quasi
             particle energies for. Bands n where n1<=n<n2 will be
             calculated.  Note that the second band index is not included.
-        relbands:
-            Same as *bands* except that the numbers are relative to the
-            number of occupied bands.
-            E.g. (-1, 1) will use HOMO+LUMO.
         frequencies:
             Input parameters for frequency_grid.
             Can be array of frequencies to evaluate the response function at
             or dictionary of parameters for build-in nonlinear grid
             (see :ref:`frequency grid`).
-        ecut: float
-            Plane wave cut-off energy in eV.
-        ecut_extrapolation: bool or list
-            If set to True an automatic extrapolation of the selfenergy to
-            infinite cutoff will be performed based on three points
-            for the cutoff energy.
-            If an array is given, the extrapolation will be performed based on
-            the cutoff energies given in the array.
+        ecut_e: array(float)
+            Plane wave cut-off energies in eV. Defined with choose_ecut_things
         nbands: int
             Number of bands to use in the calculation. If None, the number will
             be determined from :ecut: to yield a number close to the number of
             plane waves used.
-        ppa: bool
-            Sets whether the Godby-Needs plasmon-pole approximation for the
-            dielectric function should be used.
-        xc: str
-            Kernel to use when including vertex corrections.
-        fxc_mode: str
-            Where to include the vertex corrections; polarizability and/or
-            self-energy. 'GWP': Polarizability only, 'GWS': Self-energy only,
-            'GWG': Both.
         do_GW_too: bool
             When carrying out a calculation including vertex corrections, it
             is possible to get the standard GW results at the same time
             (almost for free).
-        Eg: float
-            Gap to apply in the 'JGMs' (simplified jellium-with-gap) kernel.
-            If None the DFT gap is used.
-        truncation: str
-            Coulomb truncation scheme. Can be either wigner-seitz,
-            2D, 1D, or 0D
-        integrate_gamma: int
-            Method to integrate the Coulomb interaction. 1 is a numerical
-            integration at all q-points with G=[0,0,0] - this breaks the
-            symmetry slightly. 0 is analytical integration at q=[0,0,0] only -
-            this conserves the symmetry. integrate_gamma=2 is the same as 1,
-            but the average is only carried out in the non-periodic directions.
-        E0: float
-            Energy (in eV) used for fitting in the plasmon-pole approximation.
-        q0_correction: bool
-            Analytic correction to the q=0 contribution applicable to 2D
-            systems.
-        nblocks: int
-            Number of blocks chi0 should be distributed in so each core
-            does not have to store the entire matrix. This is to reduce
-            memory requirement. nblocks must be less than or equal to the
-            number of processors.
-        nblocksmax: bool
-            Cuts chi0 into as many blocks as possible to reduce memory
-            requirements as much as possible.
-        savepckl: bool
-            Save output to a pckl file.
+        ppa: bool
+            Use Godby-Needs plasmon-pole approximation for screened interaction
+            and self-energy
         """
-
-        # Note: self.wd should be our only representation of the frequencies.
+        self.chi0calc = chi0calc
+        self.wcalc = wcalc
+        self.context = self.wcalc.context
+        self.ppa = ppa
+        
+        # Note: self.chi0calc.wd should be our only representation
+        # of the frequencies.
         # We should therefore get rid of self.frequencies.
         # It is currently only used by the restart code,
         # so should be easy to remove after some further adaptation.
         self.frequencies = frequencies
 
         self.ecut_e = ecut_e / Ha
 
-        self.context = context
-        self.chi0calc = chi0calc
-        self.pair = chi0calc.pair
-        self.wd = chi0calc.wd
-        self.gs = chi0calc.gs
-
-        if ppa and self.pair.nblocks > 1:
-            raise ValueError(
-                'PPA is currently not compatible with block parallelisation.')
-
-        self.timer = self.context.timer
-        self.fd = self.context.fd
-        self.blockcomm = self.pair.blockcomm
-        self.world = self.context.world
-
-        print(gw_logo, file=self.fd)
-
-        self.xckernel = xckernel
-        self.fxc_mode = fxc_mode
-        self.do_GW_too = do_GW_too
-
-        if not self.fxc_mode == 'GW':
-            assert self.xckernel.xc != 'RPA'
-
-        if self.do_GW_too:
-            assert self.xckernel.xc != 'RPA'
-            assert self.fxc_mode != 'GW'
-            if restartfile is not None:
-                raise RuntimeError('Restart function does not currently work '
-                                   'with do_GW_too=True.')
+        self.context.print(gw_logo)
+
+        self.fxc_modes = fxc_modes
+
+        if self.fxc_modes[0] != 'GW':
+            assert self.wcalc.xckernel.xc != 'RPA'
+
+        if len(self.fxc_modes) == 2:
+            # With multiple fxc_modes, we previously could do only
+            # GW plus one other fxc_mode.  Now we can have any set
+            # of modes, but whether things are consistent or not may
+            # depend on how wcalc is configured.
+            assert 'GW' in self.fxc_modes
+            assert self.wcalc.xckernel.xc != 'RPA'
 
         self.filename = filename
-        self.restartfile = restartfile
-        self.savepckl = savepckl
-        self.ppa = ppa
-        self.truncation = truncation
-        self.integrate_gamma = integrate_gamma
         self.eta = eta / Ha
-        self.E0 = E0 / Ha
+
+        if self.context.comm.rank == 0:
+            # We pass a serial communicator because the parallel handling
+            # is somewhat wonky, we'd rather do that ourselves:
+            try:
+                self.qcache = FileCache(f'qcache_{self.filename}',
+                                        comm=mpi.SerialCommunicator())
+            except TypeError as err:
+                raise RuntimeError(
+                    'File cache requires ASE master '
+                    'from September 20 2022 or newer.  '
+                    'You may need to pull newest ASE.') from err
+
+            self.qcache.strip_empties()
 
         self.kpts = kpts
         self.bands = bands
 
         b1, b2 = self.bands
-        self.shape = (self.gs.nspins, len(self.kpts), b2 - b1)
+        self.shape = (self.wcalc.gs.nspins, len(self.kpts), b2 - b1)
 
         self.nbands = nbands
 
-        if self.gs.nspins != 1 and self.fxc_mode != 'GW':
-            raise RuntimeError('Including a xc kernel does currently not '
-                               'work for spinpolarized systems.')
-
-        self.pair_distribution = self.pair.distribute_k_points_and_bands(
-            b1, b2, self.gs.kd.ibz2bz_k[self.kpts])
-
-        self.qd = get_qdescriptor(self.gs.kd, self.gs.atoms)
-
-        if q0_correction:
-            assert self.truncation == '2D'
-            self.q0_corrector = Q0Correction(
-                cell_cv=self.gs.gd.cell_cv, bzk_kc=self.gs.kd.bzk_kc,
-                N_c=self.qd.N_c)
-        else:
-            self.q0_corrector = None
+        if self.wcalc.gs.nspins != 1:
+            for fxc_mode in self.fxc_modes:
+                if fxc_mode != 'GW':
+                    raise RuntimeError('Including a xc kernel does not '
+                                       'currently work for spin-polarized '
+                                       f'systems. Invalid fxc_mode {fxc_mode}.'
+                                       )
+
+        self.pair_distribution = \
+            self.chi0calc.pair.distribute_k_points_and_bands(
+                b1, b2, self.chi0calc.gs.kd.ibz2bz_k[self.kpts])
 
         self.print_parameters(kpts, b1, b2)
-        self.fd.flush()
-        self.hilbert_transform = None  # initialized when we create Chi0
+
+        self.exx_vxc_calculator = exx_vxc_calculator
 
         if self.ppa:
-            print('Using Godby-Needs plasmon-pole approximation:',
-                  file=self.fd)
-            print('  Fitting energy: i*E0, E0 = %.3f Hartee' % self.E0,
-                  file=self.fd)
+            self.context.print('Using Godby-Needs plasmon-pole approximation:')
+            self.context.print('  Fitting energy: i*E0, E0 = %.3f Hartee'
+                               % self.chi0calc.wd.omega_w[1].imag)
         else:
-            print('Using full frequency integration', file=self.fd)
+            self.context.print('Using full frequency integration')
 
     def print_parameters(self, kpts, b1, b2):
-        p = functools.partial(print, file=self.fd)
+        p = functools.partial(self.context.print, flush=False)
         p()
         p('Quasi particle states:')
         if kpts is None:
             p('All k-points in IBZ')
         else:
             kptstxt = ', '.join(['{0:d}'.format(k) for k in self.kpts])
             p('k-points (IBZ indices): [' + kptstxt + ']')
@@ -450,34 +514,34 @@
         p()
         p('Computational parameters:')
         if len(self.ecut_e) == 1:
             p('Plane wave cut-off: {0:g} eV'.format(self.chi0calc.ecut * Ha))
         else:
             assert len(self.ecut_e) > 1
             p('Extrapolating to infinite plane wave cut-off using points at:')
-            p('  [%.3f, %.3f, %.3f] eV' % tuple(self.ecut_e * Ha))
+            for ec in self.ecut_e:
+                p('  %.3f eV' % (ec * Ha))
         p('Number of bands: {0:d}'.format(self.nbands))
-        p('Coulomb cutoff:', self.truncation)
+        p('Coulomb cutoff:', self.wcalc.coulomb.truncation)
         p('Broadening: {0:g} eV'.format(self.eta * Ha))
         p()
-        p('fxc mode:', self.fxc_mode)
-        p('Kernel:', self.xckernel.xc)
-        p('Do GW too:', self.do_GW_too)
-        p()
+        p('fxc modes:', ', '.join(sorted(self.fxc_modes)))
+        p('Kernel:', self.wcalc.xckernel.xc)
+        self.context.print('')
 
     def get_eps_and_occs(self):
         eps_skn = np.empty(self.shape)  # KS-eigenvalues
         f_skn = np.empty(self.shape)  # occupation numbers
 
-        nspins = self.gs.nspins
+        nspins = self.wcalc.gs.nspins
         b1, b2 = self.bands
         for i, k in enumerate(self.kpts):
             for s in range(nspins):
                 u = s + k * nspins
-                kpt = self.gs.kpt_u[u]
+                kpt = self.wcalc.gs.kpt_u[u]
                 eps_skn[s, i] = kpt.eps_n[b1:b2]
                 f_skn[s, i] = kpt.f_n[b1:b2] / kpt.weight
 
         return eps_skn, f_skn
 
     @timer('G0W0')
     def calculate(self):
@@ -501,794 +565,513 @@
         ``qp``       Quasi particle (QP) energies in eV
         ``iqp``      GW0/GW: QP energies for each iteration in eV
         ===========  =============================================
 
         All the values are ``ndarray``'s of shape
         (spins, IBZ k-points, bands)."""
 
-        loaded = False
-        if self.restartfile is not None:
-            loaded = self.load_restart_file()
-            if not loaded:
-                self.last_q = -1
-                self.previous_sigma = 0.
-                self.previous_dsigma = 0.
-
-            else:
-                print('Reading ' + str(self.last_q + 1) +
-                      ' q-point(s) from the previous calculation: ' +
-                      self.restartfile + '.sigma.pckl', file=self.fd)
-        else:
-            self.last_q = -1
-            self.previous_sigma = 0.
-            self.previous_dsigma = 0.
-
-        self.fd.flush()
-
-        # Reset calculation
-        sigmashape = (len(self.ecut_e), *self.shape)
-
-        self.sigmas = {fxc_mode: Sigma(sigmashape)
-                       for fxc_mode in self.fxc_modes}
         # Loop over q in the IBZ:
-        print('Summing all q:', file=self.fd)
-        pb = ProgressBar(self.fd)
-        for nQ, (ie, pd0, Wdict, q_c, m2, symop, blocks1d, Q_aGii) in \
-                enumerate(self.calculate_screened_potential()):
-
-            for progress, kpt1, kpt2 in self.pair_distribution.kpt_pairs_by_q(
-                    q_c, 0, m2):
-                pb.update((nQ + progress) / self.qd.mynk)
-
-                k1 = self.gs.kd.bz2ibz_k[kpt1.K]
-                i = self.kpts.index(k1)
-
-                self.calculate_q(ie, i, kpt1, kpt2, pd0, Wdict,
-                                 symop=symop,
-                                 sigmas=self.sigmas,
-                                 blocks1d=blocks1d,
-                                 Q_aGii=Q_aGii)
-        pb.finish()
+        self.context.print('Summing all q:')
+        self.calculate_all_q_points()
+        sigmas = self.read_sigmas()
+        self.all_results = self.postprocess(sigmas)
+        # Note: self.results is a pointer pointing to one of the results,
+        # for historical reasons.
 
-        return self.postprocess(self.sigmas, loaded)
+        self.savepckl()
+        return self.results
 
-    def postprocess(self, sigmas, loaded):
+    def postprocess(self, sigmas):
         all_results = {}
         for fxc_mode, sigma in sigmas.items():
-            all_results[fxc_mode] = self.postprocess_single(fxc_mode, sigma,
-                                                            loaded)
-        self.all_results = all_results
-        self.print_results(self.all_results)
-
-        # After we have written the results restartfile is obsolete
-        if self.restartfile is not None:
-            if self.world.rank == 0:
-                if os.path.isfile(self.restartfile + '.sigma.pckl'):
-                    os.remove(self.restartfile + '.sigma.pckl')
-
-        return self.results  # XXX ugly discrepancy
-
-    def postprocess_single(self, fxc_name, sigma, loaded):
-        sigma.sum(self.world)  # (Not so pretty that we finalize the sum here)
-
-        if self.restartfile is not None and loaded:
-            assert not self.do_GW_too
-            sigma.sigma_eskn += self.previous_sigma
-            sigma.dsigma_eskn += self.previous_dsigma
+            all_results[fxc_mode] = self.postprocess_single(fxc_mode, sigma)
 
-        output = self.calculate_g0w0_outputs(sigma)
-        result = output.get_results_eV()
+        self.print_results(all_results)
+        return all_results
 
-        if self.savepckl:
-            with paropen(f'{self.filename}_results_{fxc_name}.pckl',
-                         'wb') as fd:
-                pickle.dump(result, fd, 2)
+    def read_sigmas(self):
+        if self.context.comm.rank == 0:
+            sigmas = self._read_sigmas()
+        else:
+            sigmas = None
 
-        return result
+        return broadcast(sigmas, comm=self.context.comm)
 
-    @property
-    def results_GW(self):
-        if self.do_GW_too:
-            return self.all_results['GW']
+    def _read_sigmas(self):
+        assert self.context.comm.rank == 0
 
-    @property
-    def results(self):
-        return self.all_results[self.fxc_mode]
+        # Integrate over all q-points, and accumulate the quasiparticle shifts
+        for iq, q_c in enumerate(self.wcalc.qd.ibzk_kc):
+            key = str(iq)
 
-    def calculate_q(self, ie, k, kpt1, kpt2, pd0, Wdict,
-                    *, symop, sigmas, blocks1d, Q_aGii):
-        """Calculates the contribution to the self-energy and its derivative
-        for a given set of k-points, kpt1 and kpt2."""
+            sigmas_contrib = self.get_sigmas_dict(key)
 
-        N_c = pd0.gd.N_c
-        i_cG = symop.apply(np.unravel_index(pd0.Q_qG[0], N_c))
+            if iq == 0:
+                sigmas = sigmas_contrib
+            else:
+                for fxc_mode in self.fxc_modes:
+                    sigmas[fxc_mode] += sigmas_contrib[fxc_mode]
 
-        q_c = self.gs.kd.bzk_kc[kpt2.K] - self.gs.kd.bzk_kc[kpt1.K]
+        return sigmas
 
-        shift0_c = symop.get_shift0(q_c, pd0.kd.bzk_kc[0])
-        shift_c = kpt1.shift_c - kpt2.shift_c - shift0_c
+    def get_sigmas_dict(self, key):
+        assert self.context.comm.rank == 0
+        return {fxc_mode: Sigma.fromdict(sigma)
+                for fxc_mode, sigma in self.qcache[key].items()}
 
-        I_G = np.ravel_multi_index(i_cG + shift_c[:, None], N_c, 'wrap')
-
-        G_Gv = pd0.get_reciprocal_vectors()
-
-        pos_av = np.dot(self.pair.spos_ac, pd0.gd.cell_cv)
-        M_vv = symop.get_M_vv(pd0.gd.cell_cv)
-
-        myQ_aGii = []
-        for a, Q_Gii in enumerate(Q_aGii):
-            x_G = np.exp(1j * np.dot(G_Gv, (pos_av[a] -
-                                            np.dot(M_vv, pos_av[a]))))
-            U_ii = self.gs.setups[a].R_sii[symop.symno]
-            Q_Gii = np.dot(np.dot(U_ii, Q_Gii * x_G[:, None, None]),
-                           U_ii.T).transpose(1, 0, 2)
-            if symop.sign == -1:
-                Q_Gii = Q_Gii.conj()
-            myQ_aGii.append(Q_Gii)
+    def postprocess_single(self, fxc_name, sigma):
+        output = self.calculate_g0w0_outputs(sigma)
+        return output.get_results_eV()
 
-        if debug:
-            self.check(ie, i_cG, shift0_c, N_c, q_c, myQ_aGii)
+    def savepckl(self):
+        """Save outputs to pckl files and return paths to those files."""
+        # Note: this is always called, but the paths aren't returned
+        # to the caller.  Calling it again then overwrites the files.
+        #
+        # TODO:
+        #  * Replace with JSON
+        #  * Save to different files or same file?
+        #  * Move this functionality to g0w0 result object
+        paths = {}
+        for fxc_mode in self.fxc_modes:
+            path = Path(f'{self.filename}_results_{fxc_mode}.pckl')
+            with paropen(path, 'wb', comm=self.context.comm) as fd:
+                pickle.dump(self.all_results[fxc_mode], fd, 2)
+            paths[fxc_mode] = path
+
+        # Do not return paths to caller before we know they all exist:
+        self.context.comm.barrier()
+        return paths
 
-        if self.ppa:
-            calculate_sigma = self.calculate_sigma_ppa
-        else:
-            calculate_sigma = self.calculate_sigma
+    def calculate_q(self, ie, k, kpt1, kpt2, qpd, Wdict,
+                    *, symop, sigmas, blocks1d, pawcorr):
+        """Calculates the contribution to the self-energy and its derivative
+        for a given set of k-points, kpt1 and kpt2."""
+        mypawcorr, I_G = symop.apply_symop_q(qpd, pawcorr, kpt1, kpt2)
+        if debug:
+            N_c = qpd.gd.N_c
+            i_cG = symop.apply(np.unravel_index(qpd.Q_qG[0], N_c))
+            bzk_kc = self.wcalc.gs.kd.bzk_kc
+            Q_c = bzk_kc[kpt2.K] - bzk_kc[kpt1.K]
+            shift0_c = Q_c - symop.apply(qpd.q_c)
+            self.check(ie, i_cG, shift0_c, N_c, Q_c, mypawcorr)
 
         for n in range(kpt1.n2 - kpt1.n1):
-            ut1cc_R = kpt1.ut_nR[n].conj()
             eps1 = kpt1.eps_n[n]
-            C1_aGi = [np.dot(Qa_Gii, P1_ni[n].conj())
-                      for Qa_Gii, P1_ni in zip(myQ_aGii, kpt1.P_ani)]
-            n_mG = self.pair.calculate_pair_densities(
-                ut1cc_R, C1_aGi, kpt2, pd0, I_G)
+            n_mG = get_nmG(kpt1, kpt2,
+                           mypawcorr,
+                           n, qpd, I_G,
+                           self.chi0calc.pair)
+
             if symop.sign == 1:
                 n_mG = n_mG.conj()
 
             f_m = kpt2.f_n
             deps_m = eps1 - kpt2.eps_n
 
             nn = kpt1.n1 + n - self.bands[0]
 
             assert set(Wdict) == set(sigmas)
             for fxc_mode in self.fxc_modes:
                 sigma = sigmas[fxc_mode]
-                W = Wdict[fxc_mode]
-                sigma_contrib, dsigma_contrib = calculate_sigma(
-                    n_mG, deps_m, f_m, W, blocks1d)
-                sigma.sigma_eskn[ie, kpt1.s, k, nn] += sigma_contrib
-                sigma.dsigma_eskn[ie, kpt1.s, k, nn] += dsigma_contrib
+                Wmodel = Wdict[fxc_mode]
+                # m is band index of all (both unoccupied and occupied) wave
+                # functions in G
+                for m, (deps, f, n_G) in enumerate(zip(deps_m, f_m, n_mG)):
+                    # 2 * f - 1 will be used to select the branch of Hilbert
+                    # transform, see get_HW of screened_interaction.py
+                    # at FullFrequencyHWModel class.
+                    S_GG, dSdw_GG = Wmodel.get_HW(deps, 2 * f - 1)
+                    if S_GG is None:
+                        continue
+
+                    nc_G = n_G.conj()
+                    
+                    # ie: ecut index for extrapolation
+                    # kpt1.s: spin index of *
+                    # k: k-point index of *
+                    # nn: band index of *
+                    # * wave function, where the sigma expectation value is
+                    # evaluated
+                    slot = ie, kpt1.s, k, nn
+                    myn_G = n_G[blocks1d.myslice]
+                    sigma.sigma_eskn[slot] += (myn_G @ S_GG @ nc_G).real
+                    sigma.dsigma_eskn[slot] += (myn_G @ dSdw_GG @ nc_G).real
 
-    def check(self, ie, i_cG, shift0_c, N_c, q_c, Q_aGii):
+    def check(self, ie, i_cG, shift0_c, N_c, Q_c, pawcorr):
+        # Can we delete this check? XXX
+        assert np.allclose(shift0_c.round(), shift0_c)
+        shift0_c = shift0_c.round().astype(int)
         I0_G = np.ravel_multi_index(i_cG - shift0_c[:, None], N_c, 'wrap')
-        qd1 = KPointDescriptor([q_c])
-        pd1 = PWDescriptor(self.ecut_e[ie], self.gs.gd, complex, qd1)
+        qpd = SingleQPWDescriptor.from_q(Q_c, self.ecut_e[ie],
+                                         self.wcalc.gs.gd)
         G_I = np.empty(N_c.prod(), int)
         G_I[:] = -1
-        I1_G = pd1.Q_qG[0]
+        I1_G = qpd.Q_qG[0]
         G_I[I1_G] = np.arange(len(I0_G))
         G_G = G_I[I0_G]
+        # This indexing magic should definitely be moved to a method.
+        # What on earth is it really?
+
         assert len(I0_G) == len(I1_G)
         assert (G_G >= 0).all()
-        for a, Q_Gii in enumerate(self.pair.initialize_paw_corrections(pd1)):
-            e = abs(Q_aGii[a] - Q_Gii[G_G]).max()
-            assert e < 1e-12
-
-    @timer('Sigma')
-    def calculate_sigma(self, n_mG, deps_m, f_m, C_swGG, blocks1d):
-        """Calculates a contribution to the self-energy and its derivative for
-        a given (k, k-q)-pair from its corresponding pair-density and
-        energy."""
-        o_m = abs(deps_m)
-        # Add small number to avoid zeros for degenerate states:
-        sgn_m = np.sign(deps_m + 1e-15)
-
-        # Pick +i*eta or -i*eta:
-        s_m = (1 + sgn_m * np.sign(0.5 - f_m)).astype(int) // 2
-
-        w_m = self.wd.get_floor_index(o_m, safe=False)
-        m_inb = np.where(w_m < len(self.wd) - 1)[0]
-        o1_m = np.empty(len(o_m))
-        o2_m = np.empty(len(o_m))
-        o1_m[m_inb] = self.wd.omega_w[w_m[m_inb]]
-        o2_m[m_inb] = self.wd.omega_w[w_m[m_inb] + 1]
-
-        x = 1.0 / (self.qd.nbzkpts * 2 * pi * self.gs.volume)
-        sigma = 0.0
-        dsigma = 0.0
-        # Performing frequency integration
-        for o, o1, o2, sgn, s, w, n_G in zip(o_m, o1_m, o2_m,
-                                             sgn_m, s_m, w_m, n_mG):
-
-            if w >= len(self.wd.omega_w) - 1:
-                continue
-
-            C1_GG = C_swGG[s][w]
-            C2_GG = C_swGG[s][w + 1]
-            p = x * sgn
-            myn_G = n_G[blocks1d.myslice]
-
-            sigma1 = p * np.dot(np.dot(myn_G, C1_GG), n_G.conj()).imag
-            sigma2 = p * np.dot(np.dot(myn_G, C2_GG), n_G.conj()).imag
-            sigma += ((o - o1) * sigma2 + (o2 - o) * sigma1) / (o2 - o1)
-            dsigma += sgn * (sigma2 - sigma1) / (o2 - o1)
-
-        return sigma, dsigma
-
-    def calculate_screened_potential(self):
-        """Calculates the screened potential for each q-point in the 1st BZ.
-        Since many q-points are related by symmetry, the actual calculation is
-        only done for q-points in the IBZ and the rest are obtained by symmetry
-        transformations. Results are returned as a generator to that it is not
-        necessary to store a huge matrix for each q-point in the memory."""
-        # The decorator $timer('W') doesn't work for generators, do we will
-        # have to manually start and stop the timer here:
-        self.timer.start('W')
-        print('\nCalculating screened Coulomb potential', file=self.fd)
-        if self.truncation is not None:
-            print('Using %s truncated Coloumb potential' % self.truncation,
-                  file=self.fd)
+        pairden_paw_corr = self.wcalc.gs.pair_density_paw_corrections
+        pawcorr_wcalc1 = pairden_paw_corr(qpd)
+        assert pawcorr.almost_equal(pawcorr_wcalc1, G_G)
+
+    def calculate_all_q_points(self):
+        """Main loop over irreducible Brillouin zone points.
+        Handles restarts of individual qpoints using FileCache from ASE,
+        and subsequently calls calculate_q."""
+
+        pb = ProgressBar(self.context.fd)
+
+        self.context.timer.start('W')
+        self.context.print('\nCalculating screened Coulomb potential')
+        self.context.print(self.wcalc.coulomb.description())
 
         chi0calc = self.chi0calc
-
-        if self.truncation == 'wigner-seitz':
-            wstc = WignerSeitzTruncatedCoulomb(
-                self.gs.gd.cell_cv,
-                self.gs.kd.N_c,
-                chi0calc.fd)
-        else:
-            wstc = None
-
-        self.hilbert_transform = GWHilbertTransforms(
-            self.wd.omega_w, self.eta)
-        print(self.wd, file=self.fd)
+        self.context.print(self.chi0calc.wd)
 
         # Find maximum size of chi-0 matrices:
-        nGmax = max(count_reciprocal_vectors(chi0calc.ecut, self.gs.gd, q_c)
-                    for q_c in self.qd.ibzk_kc)
-        nw = len(self.wd)
+        nGmax = max(count_reciprocal_vectors(chi0calc.ecut,
+                                             self.wcalc.gs.gd, q_c)
+                    for q_c in self.wcalc.qd.ibzk_kc)
+        nw = len(self.chi0calc.wd)
 
-        size = self.blockcomm.size
+        size = self.chi0calc.blockcomm.size
 
         mynGmax = (nGmax + size - 1) // size
         mynw = (nw + size - 1) // size
 
         # some memory sizes...
-        if self.world.rank == 0:
+        if self.context.comm.rank == 0:
             siz = (nw * mynGmax * nGmax +
                    max(mynw * nGmax, nw * mynGmax) * nGmax) * 16
             sizA = (nw * nGmax * nGmax + nw * nGmax * nGmax) * 16
-            print('  memory estimate for chi0: local=%.2f MB, global=%.2f MB'
-                  % (siz / 1024**2, sizA / 1024**2), file=self.fd)
-            self.fd.flush()
+            self.context.print(
+                '  memory estimate for chi0: local=%.2f MB, global=%.2f MB'
+                % (siz / 1024**2, sizA / 1024**2))
 
         # Need to pause the timer in between iterations
-        self.timer.stop('W')
-        for iq, q_c in enumerate(self.qd.ibzk_kc):
-            if iq <= self.last_q:
-                continue
-
-            if len(self.ecut_e) > 1:
-                chi0bands = chi0calc.create_chi0(q_c, extend_head=False)
-            else:
-                chi0bands = None
-
-            m1 = chi0calc.nocc1
-            for ie, ecut in enumerate(self.ecut_e):
-                self.timer.start('W')
-
-                # First time calculation
-                if ecut == chi0calc.ecut:
-                    # Nothing to cut away:
-                    m2 = self.nbands
+        self.context.timer.stop('W')
+        if self.context.comm.rank == 0:
+            for key, sigmas in self.qcache.items():
+                sigmas = {fxc_mode: Sigma.fromdict(sigma)
+                          for fxc_mode, sigma in sigmas.items()}
+                for fxc_mode, sigma in sigmas.items():
+                    sigma.validate_inputs(self.get_validation_inputs())
+
+        self.context.comm.barrier()
+        for iq, q_c in enumerate(self.wcalc.qd.ibzk_kc):
+            with ExitStack() as stack:
+                if self.context.comm.rank == 0:
+                    qhandle = stack.enter_context(self.qcache.lock(str(iq)))
+                    skip = qhandle is None
                 else:
-                    m2 = int(self.gs.volume * ecut**1.5 * 2**0.5 / 3 / pi**2)
-                    if m2 > self.nbands:
-                        raise ValueError(f'Trying to extrapolate ecut to'
-                                         f'larger number of bands ({m2})'
-                                         f' than there are bands '
-                                         f'({self.nbands}).')
-                pdi, Wdict, blocks1d, Q_aGii = self.calculate_w(
-                    chi0calc, q_c, chi0bands,
-                    m1, m2, ecut, wstc, iq)
-                m1 = m2
-
-                self.timer.stop('W')
-
-                for Q_c, symop in QSymmetryOp.get_symops(self.qd, iq, q_c):
-                    yield (ie, pdi, Wdict, Q_c, m2, symop,
-                           blocks1d, Q_aGii)
-
-                if self.restartfile is not None:
-                    self.save_restart_file(iq)
-
-    @property
-    def fxc_modes(self):
-        modes = [self.fxc_mode]
-        if self.do_GW_too:
-            modes.append('GW')
-        return modes
-
-    @timer('WW')
-    def calculate_w(self, chi0calc, q_c, chi0bands,
-                    m1, m2, ecut, wstc,
-                    iq):
-        """Calculates the screened potential for a specified q-point."""
-
-        chi0 = chi0calc.create_chi0(q_c, extend_head=False)
-        chi0calc.fd = self.fd
-        chi0calc.print_chi(chi0.pd)
-        chi0calc.update_chi0(chi0, m1, m2, range(self.gs.nspins))
-
-        if len(self.ecut_e) > 1:
-            # Add chi from previous cutoff with remaining bands
-            chi0.chi0_wGG += chi0bands.chi0_wGG
-            chi0bands.chi0_wGG[:] = chi0.chi0_wGG.copy()
-            if chi0.optical_limit:
-                chi0.chi0_wxvG += chi0bands.chi0_wxvG
-                chi0bands.chi0_wxvG[:] = chi0.chi0_wxvG.copy()
-                chi0.chi0_wvv += chi0bands.chi0_wvv
-                chi0bands.chi0_wvv[:] = chi0.chi0_wvv.copy()
-
-        Wdict = {}
-
-        for fxc_mode in self.fxc_modes:
-            pdi, blocks1d, W_wGG = self.dyson_and_W_old(
-                wstc, iq, q_c, chi0calc, chi0, ecut, Q_aGii=chi0calc.Q_aGii,
-                fxc_mode=fxc_mode)
+                    skip = False
 
-            if self.ppa:
-                W_xwGG = W_wGG  # (ppa API is nonsense)
-            else:
-                with self.timer('Hilbert'):
-                    W_xwGG = self.hilbert_transform(W_wGG)
-
-            Wdict[fxc_mode] = W_xwGG
-
-        return pdi, Wdict, blocks1d, chi0calc.Q_aGii
-
-    def dyson_and_W_new(self, wstc, iq, q_c, chi0calc, chi0, ecut):
-        assert not self.ppa
-        assert not self.do_GW_too
-        assert ecut == chi0.pd.ecut
-        assert self.fxc_mode == 'GW'
-
-        assert not np.allclose(q_c, 0)
-
-        nW = len(self.wd)
-        nG = chi0.pd.ngmax
-
-        from gpaw.response.wgg import Grid
-
-        WGG = (nW, nG, nG)
-        WgG_grid = Grid(
-            comm=self.blockcomm,
-            shape=WGG,
-            cpugrid=(1, self.blockcomm.size, 1))
-        assert chi0.chi0_wGG.shape == WgG_grid.myshape
-
-        my_gslice = WgG_grid.myslice[1]
-
-        dielectric_WgG = chi0.chi0_wGG  # XXX
-        for iw, chi0_GG in enumerate(chi0.chi0_wGG):
-            sqrtV_G = get_coulomb_kernel(chi0.pd,  # XXX was: pdi
-                                         self.gs.kd.N_c,
-                                         truncation=self.truncation,
-                                         wstc=wstc)**0.5
-            e_GG = np.eye(nG) - chi0_GG * sqrtV_G * sqrtV_G[:, np.newaxis]
-            e_gG = e_GG[my_gslice]
-
-            dielectric_WgG[iw, :, :] = e_gG
-
-        wgg_grid = Grid(comm=self.blockcomm, shape=WGG)
-
-        dielectric_wgg = wgg_grid.zeros(dtype=complex)
-        WgG_grid.redistribute(wgg_grid, dielectric_WgG, dielectric_wgg)
-
-        assert np.allclose(dielectric_wgg, dielectric_WgG)
-
-        wgg_grid.invert_inplace(dielectric_wgg)
-
-        wgg_grid.redistribute(WgG_grid, dielectric_wgg, dielectric_WgG)
-        inveps_WgG = dielectric_WgG
-
-        self.timer.start('Dyson eq.')
-
-        for iw, inveps_gG in enumerate(inveps_WgG):
-            inveps_gG -= np.identity(nG)[my_gslice]
-            thing_GG = sqrtV_G * sqrtV_G[:, np.newaxis]
-            inveps_gG *= thing_GG[my_gslice]
-
-        W_WgG = inveps_WgG
-        Wp_wGG = W_WgG.copy()
-        Wm_wGG = W_WgG.copy()
-        return chi0.pd, Wm_wGG, Wp_wGG  # not Hilbert transformed yet
-
-    def dyson_and_W_old(self, wstc, iq, q_c, chi0calc, chi0,
-                        ecut, Q_aGii, fxc_mode):
-        nG = chi0.pd.ngmax
-        blocks1d = chi0.blocks1d
-
-        wblocks1d = Blocks1D(self.blockcomm, len(self.wd))
-
-        # The copy() is only required when doing GW_too, since we need
-        # to run this whole thin twice.
-        chi0_wGG = chi0.blockdist.redistribute(chi0.chi0_wGG.copy(), chi0.nw)
-
-        pd = chi0.pd
-        chi0_wxvG = chi0.chi0_wxvG
-        chi0_wvv = chi0.chi0_wvv
-
-        if ecut == pd.ecut:
-            pdi = pd
-            G2G = None
-
-        elif ecut < pd.ecut:  # construct subset chi0 matrix with lower ecut
-            pdi = PWDescriptor(ecut, pd.gd, dtype=pd.dtype,
-                               kd=pd.kd)
-            nG = pdi.ngmax
-            blocks1d = Blocks1D(self.blockcomm, nG)
-            G2G = PWMapping(pdi, pd).G2_G1
-            chi0_wGG = chi0_wGG.take(G2G, axis=1).take(G2G, axis=2)
-
-            if chi0_wxvG is not None:
-                chi0_wxvG = chi0_wxvG.take(G2G, axis=3)
-
-            if Q_aGii is not None:
-                for a, Q_Gii in enumerate(Q_aGii):
-                    Q_aGii[a] = Q_Gii.take(G2G, axis=0)
-
-        if self.integrate_gamma != 0:
-            reduced = (self.integrate_gamma == 2)
-            V0, sqrtV0 = get_integrated_kernel(pdi,
-                                               self.gs.kd.N_c,
-                                               truncation=self.truncation,
-                                               reduced=reduced,
-                                               N=100)
-        elif self.integrate_gamma == 0 and np.allclose(q_c, 0):
-            bzvol = (2 * np.pi)**3 / self.gs.volume / self.qd.nbzkpts
-            Rq0 = (3 * bzvol / (4 * np.pi))**(1. / 3.)
-            V0 = 16 * np.pi**2 * Rq0 / bzvol
-            sqrtV0 = (4 * np.pi)**(1.5) * Rq0**2 / bzvol / 2
+                skip = broadcast(skip, comm=self.context.comm)
 
-        delta_GG = np.eye(nG)
+                if skip:
+                    continue
 
-        if self.ppa:
-            einv_wGG = []
+                result = self.calculate_q_point(iq, q_c, pb, chi0calc)
 
-        if fxc_mode == 'GW':
-            fv = delta_GG
-        else:
-            fv = self.xckernel.calculate(nG, iq, G2G)
+                if self.context.comm.rank == 0:
+                    qhandle.save(result)
+        pb.finish()
 
-        # Generate fine grid in vicinity of gamma
-        kd = self.gs.kd
-        if np.allclose(q_c, 0) and len(chi0_wGG) > 0:
-            gamma_int = GammaIntegrator(truncation=self.truncation,
-                                        kd=kd, pd=pd,
-                                        chi0_wvv=chi0_wvv[wblocks1d.myslice],
-                                        chi0_wxvG=chi0_wxvG[wblocks1d.myslice])
-
-        self.timer.start('Dyson eq.')
-
-        def get_sqrtV_G(N_c, q_v=None):
-            return get_coulomb_kernel(
-                pdi,
-                N_c,
-                truncation=self.truncation,
-                wstc=wstc,
-                q_v=q_v)**0.5
-
-        for iw, chi0_GG in enumerate(chi0_wGG):
-            if np.allclose(q_c, 0):
-                einv_GG = np.zeros((nG, nG), complex)
-                for iqf in range(len(gamma_int.qf_qv)):
-                    chi0_GG[0, :] = gamma_int.a0_qwG[iqf, iw]
-                    chi0_GG[:, 0] = gamma_int.a1_qwG[iqf, iw]
-                    chi0_GG[0, 0] = gamma_int.a_wq[iw, iqf]
-
-                    sqrtV_G = get_sqrtV_G(kd.N_c, q_v=gamma_int.qf_qv[iqf])
-
-                    dfc = DielectricFunctionCalculator(
-                        sqrtV_G, chi0_GG, mode=fxc_mode, fv_GG=fv)
-                    einv_GG += dfc.get_einv_GG() * gamma_int.weight_q[iqf]
+    def calculate_q_point(self, iq, q_c, pb, chi0calc):
+        # Reset calculation
+        sigmashape = (len(self.ecut_e), *self.shape)
+        sigmas = {fxc_mode: Sigma(iq, q_c, fxc_mode, sigmashape,
+                  **self.get_validation_inputs())
+                  for fxc_mode in self.fxc_modes}
+
+        chi0 = chi0calc.create_chi0(q_c)
+
+        m1 = chi0calc.nocc1
+        for ie, ecut in enumerate(self.ecut_e):
+            self.context.timer.start('W')
+
+            # First time calculation
+            if ecut == chi0calc.ecut:
+                # Nothing to cut away:
+                m2 = self.nbands
             else:
-                sqrtV_G = get_sqrtV_G(kd.N_c)
+                m2 = int(self.wcalc.gs.volume * ecut**1.5
+                         * 2**0.5 / 3 / pi**2)
+                if m2 > self.nbands:
+                    raise ValueError(f'Trying to extrapolate ecut to'
+                                     f'larger number of bands ({m2})'
+                                     f' than there are bands '
+                                     f'({self.nbands}).')
+            qpdi, Wdict, blocks1d, pawcorr = self.calculate_w(
+                chi0calc, q_c, chi0,
+                m1, m2, ecut, iq)
+            m1 = m2
+
+            self.context.timer.stop('W')
+
+            for nQ, (bzq_c, symop) in enumerate(QSymmetryOp.get_symops(
+                    self.wcalc.qd, iq, q_c)):
+
+                for (progress, kpt1, kpt2)\
+                    in self.pair_distribution.kpt_pairs_by_q(bzq_c, 0, m2):
+                    pb.update((nQ + progress) / self.wcalc.qd.mynk)
+
+                    k1 = self.wcalc.gs.kd.bz2ibz_k[kpt1.K]
+                    i = self.kpts.index(k1)
+
+                    self.calculate_q(ie, i, kpt1, kpt2, qpdi, Wdict,
+                                     symop=symop,
+                                     sigmas=sigmas,
+                                     blocks1d=blocks1d,
+                                     pawcorr=pawcorr)
+
+        for sigma in sigmas.values():
+            sigma.sum(self.context.comm)
+
+        return sigmas
+
+    def get_validation_inputs(self):
+        return {'kpts': self.kpts,
+                'bands': list(self.bands),
+                'nbands': self.nbands,
+                'ecut_e': list(self.ecut_e),
+                'frequencies': self.frequencies,
+                'fxc_modes': self.fxc_modes,
+                'integrate_gamma': self.wcalc.integrate_gamma}
 
-                dfc = DielectricFunctionCalculator(
-                    sqrtV_G, chi0_GG, mode=fxc_mode, fv_GG=fv)
-                einv_GG = dfc.get_einv_GG()
+    @timer('calculate_w')
+    def calculate_w(self, chi0calc, q_c, chi0,
+                    m1, m2, ecut,
+                    iq):
+        """Calculates the screened potential for a specified q-point."""
 
-            if self.ppa:
-                einv_wGG.append(einv_GG - delta_GG)
-            else:
-                W_GG = chi0_GG
-                W_GG[:] = (einv_GG - delta_GG) * (sqrtV_G *
-                                                  sqrtV_G[:, np.newaxis])
-
-                if self.q0_corrector is not None and np.allclose(q_c, 0):
-                    if iw == 0:
-                        print_ac = True
-                    else:
-                        print_ac = False
-                    this_w = wblocks1d.a + iw
-                    self.add_q0_correction(pdi, W_GG, einv_GG,
-                                           chi0_wxvG[this_w],
-                                           chi0_wvv[this_w],
-                                           sqrtV_G,
-                                           print_ac=print_ac)
-                elif np.allclose(q_c, 0) or self.integrate_gamma != 0:
-                    W_GG[0, 0] = (einv_GG[0, 0] - 1.0) * V0
-                    W_GG[0, 1:] = einv_GG[0, 1:] * sqrtV_G[1:] * sqrtV0
-                    W_GG[1:, 0] = einv_GG[1:, 0] * sqrtV0 * sqrtV_G[1:]
+        chi0calc.print_info(chi0.qpd)
+        chi0calc.update_chi0(chi0, m1, m2, range(self.wcalc.gs.nspins))
 
-        if self.ppa:
-            omegat_GG = self.E0 * np.sqrt(einv_wGG[1] /
-                                          (einv_wGG[0] - einv_wGG[1]))
-            R_GG = -0.5 * omegat_GG * einv_wGG[0]
-            W_GG = pi * R_GG * sqrtV_G * sqrtV_G[:, np.newaxis]
-            if np.allclose(q_c, 0) or self.integrate_gamma != 0:
-                W_GG[0, 0] = pi * R_GG[0, 0] * V0
-                W_GG[0, 1:] = pi * R_GG[0, 1:] * sqrtV_G[1:] * sqrtV0
-                W_GG[1:, 0] = pi * R_GG[1:, 0] * sqrtV0 * sqrtV_G[1:]
-
-            self.timer.stop('Dyson eq.')
-            return pdi, blocks1d, [W_GG, omegat_GG]
-
-        # XXX This creates a new, large buffer.  We could perhaps
-        # avoid that.  Buffer used to exist but was removed due to #456.
-        W_wGG = chi0.blockdist.redistribute(chi0_wGG, chi0.nw)
-
-        self.timer.stop('Dyson eq.')
-        return pdi, blocks1d, W_wGG
-
-    @timer('Kohn-Sham XC-contribution')
-    def calculate_ks_xc_contribution(self):
-        name = self.filename + '.vxc.npy'
-        fd, vxc_skn = self.read_contribution(name)
-        if vxc_skn is None:
-            print('Calculating Kohn-Sham XC contribution', file=self.fd)
-            self.fd.flush()
-            vxc_skn = vxc(self.gs, self.gs.hamiltonian.xc) / Ha
-            n1, n2 = self.bands
-            vxc_skn = vxc_skn[:, self.kpts, n1:n2]
-            np.save(fd, vxc_skn)
-            fd.close()
-        return vxc_skn
-
-    @timer('EXX')
-    def calculate_exact_exchange(self):
-        name = self.filename + '.exx.npy'
-        fd, exx_skn = self.read_contribution(name)
-        if exx_skn is None:
-            print('Calculating EXX contribution', file=self.fd)
-            self.fd.flush()
-            exx = EXX(self.gs, kpts=self.kpts, bands=self.bands,
-                      txt=self.filename + '.exx.txt', timer=self.timer)
-            exx.calculate()
-            exx_skn = exx.get_eigenvalue_contributions() / Ha
-            np.save(fd, exx_skn)
-            fd.close()
-        return exx_skn
-
-    def read_contribution(self, filename):
-        fd = opencew(filename)  # create, exclusive, write
-        if fd is not None:
-            # File was not there: nothing to read
-            return fd, None
-
-        try:
-            with open(filename, 'rb') as fd:
-                x_skn = np.load(fd)
-        except IOError:
-            print('Removing broken file:', filename, file=self.fd)
-        else:
-            print('Read:', filename, file=self.fd)
-            if x_skn.shape == self.shape:
-                return None, x_skn
-            print('Removing bad file (wrong shape of array):', filename,
-                  file=self.fd)
-
-        if self.world.rank == 0:
-            os.remove(filename)
+        Wdict = {}
 
-        return opencew(filename), None
+        for fxc_mode in self.fxc_modes:
+            rqpd = chi0.qpd.copy_with(ecut=ecut)  # reduced qpd
+            rchi0 = chi0.copy_with_reduced_pd(rqpd)
+            Wdict[fxc_mode] = self.wcalc.get_HW_model(rchi0,
+                                                      fxc_mode=fxc_mode)
+            if (chi0calc.pawcorr is not None and
+                rqpd.ecut < chi0.qpd.ecut):
+                assert not self.ppa, """In previous master, PPA with ecut
+                extrapolation was not working. Now it would work, but
+                disabling it here still for sake of it is not tested."""
+                
+                pw_map = PWMapping(rqpd, chi0.qpd)
+                # This is extremely bad behaviour! G0W0Calculator
+                # should not change properties on the
+                # Chi0Calculator! Change in the future! XXX
+                chi0calc.pawcorr = \
+                    chi0calc.pawcorr.reduce_ecut(pw_map.G2_G1)
+
+        # Create a blocks1d for the reduced plane-wave description
+        blocks1d = Blocks1D(chi0.blockdist.blockcomm, rqpd.ngmax)
+
+        return rqpd, Wdict, blocks1d, chi0calc.pawcorr
+
+    @timer('calcualte_vxc_and_exx')
+    def calculate_vxc_and_exx(self):
+        return self.exx_vxc_calculator.calculate(
+            n1=self.bands[0], n2=self.bands[1],
+            kpt_indices=self.kpts)
 
     def print_results(self, results):
         description = ['f:      Occupation numbers',
                        'eps:     KS-eigenvalues [eV]',
                        'vxc:     KS vxc [eV]',
                        'exx:     Exact exchange [eV]',
                        'sigma:   Self-energies [eV]',
                        'dsigma:  Self-energy derivatives',
                        'Z:       Renormalization factors',
                        'qp:      QP-energies [eV]']
 
-        print('\nResults:', file=self.fd)
+        self.context.print('\nResults:')
         for line in description:
-            print(line, file=self.fd)
+            self.context.print(line)
 
         b1, b2 = self.bands
         names = [line.split(':', 1)[0] for line in description]
-        ibzk_kc = self.gs.kd.ibzk_kc
-        for s in range(self.gs.nspins):
+        ibzk_kc = self.wcalc.gs.kd.ibzk_kc
+        for s in range(self.wcalc.gs.nspins):
             for i, ik in enumerate(self.kpts):
-                print('\nk-point ' +
-                      '{0} ({1}): ({2:.3f}, {3:.3f}, {4:.3f})'.format(
-                          i, ik, *ibzk_kc[ik]) + '                ' +
-                      self.fxc_mode, file=self.fd)
-                print('band' +
-                      ''.join('{0:>8}'.format(name) for name in names),
-                      file=self.fd)
+                self.context.print(
+                    '\nk-point ' + '{0} ({1}): ({2:.3f}, {3:.3f}, '
+                    '{4:.3f})'.format(i, ik, *ibzk_kc[ik]) +
+                    '                ' + self.fxc_modes[0])
+                self.context.print('band' + ''.join('{0:>8}'.format(name)
+                                                    for name in names))
 
                 def actually_print_results(resultset):
                     for n in range(b2 - b1):
-                        print('{0:4}'.format(n + b1) +
-                              ''.join('{0:8.3f}'
-                                      .format(resultset[name][s, i, n])
-                                      for name in names),
-                              file=self.fd)
+                        self.context.print(
+                            '{0:4}'.format(n + b1) +
+                            ''.join('{0:8.3f}'.format(
+                                resultset[name][s, i, n]) for name in names))
 
                 for fxc_mode in results:
-                    print(fxc_mode.rjust(69), file=self.fd)
+                    self.context.print(fxc_mode.rjust(69))
                     actually_print_results(results[fxc_mode])
 
-        self.timer.write(self.fd)
-
-    @timer('PPA-Sigma')
-    def calculate_sigma_ppa(self, n_mG, deps_m, f_m, W, *unused):
-        W_GG, omegat_GG = W
-
-        sigma = 0.0
-        dsigma = 0.0
-
-        for m in range(len(n_mG)):
-            deps_GG = deps_m[m]
-            sign_GG = 2 * f_m[m] - 1
-            x1_GG = 1 / (deps_GG + omegat_GG - 1j * self.eta)
-            x2_GG = 1 / (deps_GG - omegat_GG + 1j * self.eta)
-            x3_GG = 1 / (deps_GG + omegat_GG - 1j * self.eta * sign_GG)
-            x4_GG = 1 / (deps_GG - omegat_GG - 1j * self.eta * sign_GG)
-            x_GG = W_GG * (sign_GG * (x1_GG - x2_GG) + x3_GG + x4_GG)
-            dx_GG = W_GG * (sign_GG * (x1_GG**2 - x2_GG**2) +
-                            x3_GG**2 + x4_GG**2)
-            nW_G = np.dot(n_mG[m], x_GG)
-            sigma += np.vdot(n_mG[m], nW_G).real
-            nW_G = np.dot(n_mG[m], dx_GG)
-            dsigma -= np.vdot(n_mG[m], nW_G).real
-
-        x = 1 / (self.qd.nbzkpts * 2 * pi * self.gs.volume)
-        return x * sigma, x * dsigma
-
-    def save_restart_file(self, nQ):
-        sigma = self.sigmas[self.fxc_mode]
-        sigma_eskn_write = sigma.sigma_eskn.copy()
-        dsigma_eskn_write = sigma.dsigma_eskn.copy()
-        self.world.sum(sigma_eskn_write)
-        self.world.sum(dsigma_eskn_write)
-        data = {'last_q': nQ,
-                'sigma_eskn': sigma_eskn_write + self.previous_sigma,
-                'dsigma_eskn': dsigma_eskn_write + self.previous_dsigma,
-                'kpts': self.kpts,
-                'bands': self.bands,
-                'nbands': self.nbands,
-                'ecut_e': self.ecut_e,
-                'frequencies': self.frequencies,
-                'integrate_gamma': self.integrate_gamma}
-
-        if self.world.rank == 0:
-            with open(self.restartfile + '.sigma.pckl', 'wb') as fd:
-                pickle.dump(data, fd, 2)
-
-    def load_restart_file(self):
-        try:
-            with open(self.restartfile + '.sigma.pckl', 'rb') as fd:
-                data = pickleload(fd)
-        except IOError:
-            return False
-        else:
-            if (data['kpts'] == self.kpts and
-                data['bands'] == self.bands and
-                data['nbands'] == self.nbands and
-                (data['ecut_e'] == self.ecut_e).all and
-                data['frequencies']['type'] == self.frequencies['type'] and
-                data['frequencies']['domega0'] ==
-                self.frequencies['domega0'] and
-                data['frequencies']['omega2'] == self.frequencies['omega2'] and
-                data['integrate_gamma'] == self.integrate_gamma):
-                self.last_q = data['last_q']
-                self.previous_sigma = data['sigma_eskn']
-                self.previous_dsigma = data['dsigma_eskn']
-                return True
-            else:
-                raise ValueError(
-                    'Restart file not compatible with parameters used in '
-                    'current calculation. Check kpts, bands, nbands, ecut, '
-                    'domega0, omega2, integrate_gamma.')
+        self.context.write_timer()
 
     def calculate_g0w0_outputs(self, sigma):
         eps_skn, f_skn = self.get_eps_and_occs()
+        vxc_skn, exx_skn = self.calculate_vxc_and_exx()
         kwargs = dict(
-            fd=self.fd,
+            context=self.context,
             shape=self.shape,
             ecut_e=self.ecut_e,
             eps_skn=eps_skn,
-            vxc_skn=self.calculate_ks_xc_contribution(),
-            exx_skn=self.calculate_exact_exchange(),
+            vxc_skn=vxc_skn,
+            exx_skn=exx_skn,
             f_skn=f_skn)
 
         return G0W0Outputs(sigma_eskn=sigma.sigma_eskn,
                            dsigma_eskn=sigma.dsigma_eskn,
                            **kwargs)
 
-    def add_q0_correction(self, pd, W_GG, einv_GG, chi0_xvG, chi0_vv,
-                          sqrtV_G, print_ac=False):
-        self.q0_corrector.add_q0_correction(
-            pd, W_GG, einv_GG, chi0_xvG, chi0_vv,
-            sqrtV_G,
-            fd=self.fd if print_ac else None)
-
 
 def choose_bands(bands, relbands, nvalence, nocc):
     if bands is not None and relbands is not None:
         raise ValueError('Use bands or relbands!')
 
     if relbands is not None:
         bands = [nvalence // 2 + b for b in relbands]
 
     if bands is None:
         bands = [0, nocc]
 
     return bands
 
 
-class G0W0Kernel:
-    def __init__(self, xc, **kwargs):
-        self.xc = xc
-        self.xcflags = XCFlags(xc)
-        self._kwargs = kwargs
-
-    def calculate(self, nG, iq, G2G):
-        return calculate_kernel(
-            xcflags=self.xcflags,
-            nG=nG, iq=iq, cut_G=G2G, **self._kwargs)
-
-
 class G0W0(G0W0Calculator):
     def __init__(self, calc, filename='gw',
                  ecut=150.0,
                  ecut_extrapolation=False,
                  xc='RPA',
                  ppa=False,
                  E0=Ha,
-                 Eg=None,
                  eta=0.1,
                  nbands=None,
                  bands=None,
                  relbands=None,
                  frequencies=None,
                  domega0=None,  # deprecated
                  omega2=None,  # deprecated
                  nblocks=1,
                  nblocksmax=False,
                  kpts=None,
                  world=mpi.world,
                  timer=None,
+                 fxc_mode='GW',
+                 truncation=None,
+                 integrate_gamma=0,
+                 q0_correction=False,
+                 do_GW_too=False,
                  **kwargs):
+        """G0W0 calculator wrapper.
+
+        The G0W0 calculator is used to calculate the quasi
+        particle energies through the G0W0 approximation for a number
+        of states.
+
+        Parameters
+        ----------
+        calc:
+            Filename of saved calculator object.
+        filename: str
+            Base filename of output files.
+        kpts: list
+            List of indices of the IBZ k-points to calculate the quasi particle
+            energies for.
+        bands:
+            Range of band indices, like (n1, n2), to calculate the quasi
+            particle energies for. Bands n where n1<=n<n2 will be
+            calculated.  Note that the second band index is not included.
+        relbands:
+            Same as *bands* except that the numbers are relative to the
+            number of occupied bands.
+            E.g. (-1, 1) will use HOMO+LUMO.
+        frequencies:
+            Input parameters for frequency_grid.
+            Can be an array of frequencies to evaluate the response function at
+            or dictionary of parameters for build-in nonlinear grid
+            (see :ref:`frequency grid`).
+        ecut: float
+            Plane wave cut-off energy in eV.
+        ecut_extrapolation: bool or list
+            If set to True an automatic extrapolation of the selfenergy to
+            infinite cutoff will be performed based on three points
+            for the cutoff energy.
+            If an array is given, the extrapolation will be performed based on
+            the cutoff energies given in the array.
+        nbands: int
+            Number of bands to use in the calculation. If None, the number will
+            be determined from :ecut: to yield a number close to the number of
+            plane waves used.
+        ppa: bool
+            Sets whether the Godby-Needs plasmon-pole approximation for the
+            dielectric function should be used.
+        xc: str
+            Kernel to use when including vertex corrections.
+        fxc_mode: str
+            Where to include the vertex corrections; polarizability and/or
+            self-energy. 'GWP': Polarizability only, 'GWS': Self-energy only,
+            'GWG': Both.
+        do_GW_too: bool
+            When carrying out a calculation including vertex corrections, it
+            is possible to get the standard GW results at the same time
+            (almost for free).
+        truncation: str
+            Coulomb truncation scheme. Can be either 2D, 1D, or 0D.
+        integrate_gamma: int
+            Method to integrate the Coulomb interaction. 1 is a numerical
+            integration at all q-points with G=[0,0,0] - this breaks the
+            symmetry slightly. 0 is analytical integration at q=[0,0,0] only -
+            this conserves the symmetry. integrate_gamma=2 is the same as 1,
+            but the average is only carried out in the non-periodic directions.
+        E0: float
+            Energy (in eV) used for fitting in the plasmon-pole approximation.
+        q0_correction: bool
+            Analytic correction to the q=0 contribution applicable to 2D
+            systems.
+        nblocks: int
+            Number of blocks chi0 should be distributed in so each core
+            does not have to store the entire matrix. This is to reduce
+            memory requirement. nblocks must be less than or equal to the
+            number of processors.
+        nblocksmax: bool
+            Cuts chi0 into as many blocks as possible to reduce memory
+            requirements as much as possible.
+        """
         frequencies = get_frequencies(frequencies, domega0, omega2)
 
-        gpwfile = calc
-        calc, context = calc_and_context(gpwfile, filename + '.txt',
-                                         world, timer)
-        gs = calc.gs_adapter()
+        # (calc can not actually be a calculator at all.)
+        gpwfile = Path(calc)
+
+        context = ResponseContext(txt=filename + '.txt',
+                                  comm=world, timer=timer)
+        gs = ResponseGroundStateAdapter.from_gpw_file(gpwfile,
+                                                      context=context)
 
         # Check if nblocks is compatible, adjust if not
         if nblocksmax:
-            nblocks = get_max_nblocks(context.world, gpwfile, ecut)
+            nblocks = get_max_nblocks(context.comm, gpwfile, ecut)
 
-        pair = NoCalculatorPairDensity(gs, nblocks=nblocks, context=context)
+        pair = PairDensityCalculator(gs, context,
+                                     nblocks=nblocks)
 
         kpts = list(select_kpts(kpts, gs.kd))
 
         if nbands is None:
             nbands = int(gs.volume * (ecut / Ha)**1.5 * 2**0.5 / 3 / pi**2)
         else:
             if ecut_extrapolation:
@@ -1307,48 +1090,79 @@
         else:
             # frequencies = self.frequencies
             parameters = {'eta': eta,
                           'hilbert': True,
                           'timeordered': True}
 
         from gpaw.response.chi0 import new_frequency_descriptor
-        chi_context = context.with_txt(filename + '.w.txt')
-        wd = new_frequency_descriptor(
-            gs, nbands, frequencies, fd=chi_context.fd)
+        wcontext = context.with_txt(filename + '.w.txt')
+        wd = new_frequency_descriptor(gs, wcontext, nbands, frequencies)
 
         chi0calc = Chi0Calculator(
             wd=wd, pair=pair,
             nbands=nbands,
             ecut=ecut,
             intraband=False,
-            context=chi_context,
+            context=wcontext,
             **parameters)
 
         bands = choose_bands(bands, relbands, gs.nvalence, chi0calc.nocc2)
 
-        if Eg is None and xc == 'JGMsx':
-            Eg = gs.get_band_gap()
-
-        if Eg is not None:
-            Eg /= Ha
-
-        xckernel = G0W0Kernel(xc=xc, ecut=ecut / Ha,
-                              gs=gs,
-                              ns=gs.nspins,
-                              wd=wd,
-                              Eg=Eg,
-                              timer=context.timer,
-                              fd=context.fd)
+        coulomb = CoulombKernel(truncation, gs)
+        # XXX eta needs to be converted to Hartree here,
+        # XXX and it is also converted to Hartree at superclass constructor
+        # XXX called below. This needs to be cleaned up.
+        wcalc = initialize_w_calculator(chi0calc, wcontext,
+                                        ppa=ppa,
+                                        xc=xc,
+                                        E0=E0, eta=eta / Ha, coulomb=coulomb,
+                                        integrate_gamma=integrate_gamma,
+                                        q0_correction=q0_correction)
+
+        fxc_modes = [fxc_mode]
+        if do_GW_too:
+            fxc_modes.append('GW')
+
+        exx_vxc_calculator = EXXVXCCalculator(
+            gpwfile,
+            snapshotfile_prefix=filename)
 
         super().__init__(filename=filename,
                          chi0calc=chi0calc,
+                         wcalc=wcalc,
                          ecut_e=ecut_e,
-                         xckernel=xckernel,
                          eta=eta,
-                         ppa=ppa,
-                         E0=E0,
+                         fxc_modes=fxc_modes,
                          nbands=nbands,
                          bands=bands,
                          frequencies=frequencies,
-                         context=context,
                          kpts=kpts,
+                         exx_vxc_calculator=exx_vxc_calculator,
+                         ppa=ppa,
                          **kwargs)
+
+    @property
+    def results_GW(self):
+        # Compatibility with old "do_GW_too" behaviour
+        if 'GW' in self.fxc_modes and self.fxc_modes[0] != 'GW':
+            return self.all_results['GW']
+
+    @property
+    def results(self):
+        return self.all_results[self.fxc_modes[0]]
+
+
+class EXXVXCCalculator:
+    """EXX and Kohn-Sham XC contribution."""
+    def __init__(self, gpwfile, snapshotfile_prefix):
+        self._gpwfile = gpwfile
+        self._snapshotfile_prefix = snapshotfile_prefix
+
+    def calculate(self, n1, n2, kpt_indices):
+        _, vxc_skn, exx_skn = non_self_consistent_eigenvalues(
+            self._gpwfile,
+            'EXX',
+            n1, n2,
+            kpt_indices=kpt_indices,
+            snapshot=f'{self._snapshotfile_prefix}-vxc-exx.json',
+        )
+        return vxc_skn / Ha, exx_skn / Ha
```

### Comparing `gpaw-22.8.0/gpaw/response/gw_bands.py` & `gpaw-23.6.0/gpaw/response/gw_bands.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,12 +1,11 @@
 import pickle
 
 import numpy as np
 from ase.utils import gcd
-from ase.units import Ha
 from scipy.interpolate import InterpolatedUnivariateSpline
 
 from gpaw import GPAW
 from gpaw.spinorbit import soc_eigenstates
 from gpaw.kpt_descriptor import to1bz
 
 
@@ -30,16 +29,14 @@
             self.bandrange = bandrange
 
         self.gd = self.calc.wfs.gd.new_descriptor()
         self.kd = self.calc.wfs.kd
 
         self.acell_cv = self.gd.cell_cv
         self.bcell_cv = 2 * np.pi * self.gd.icell_cv
-        self.vol = self.gd.volume
-        self.BZvol = (2 * np.pi)**3 / self.vol
 
     def find_k_along_path(self, plot_BZ=True):
         """Finds the k-points along the bandpath present in the
            original calculation"""
         kd = self.kd
         acell_cv = self.acell_cv
         bcell_cv = self.bcell_cv
@@ -118,15 +115,15 @@
         if plot_pot:
             import matplotlib.pyplot as plt
             plt.plot(vHt_z)
             plt.show()
         return vHt_z[0]
 
     def get_spinorbit_corrections(self, return_spin=True, return_wfs=False,
-                                  bands=None, gwqeh_file=None, dft=False,
+                                  bands=None, dft=False,
                                   eig_file=None):
         """Gets the spinorbit corrections to the eigenvalues"""
         calc = self.calc
         bandrange = self.bandrange
 
         if not dft:
             try:
@@ -147,33 +144,21 @@
             n2=bandrange[-1] + 1,
             eigenvalues=e_kn[np.newaxis])
         eSO_nk = soc.eigenvalues().T
         e_kn = eSO_nk.T
         return e_kn
 
     def get_gw_bands(self, nk_Int=50, interpolate=False, SO=False,
-                     gwqeh_file=None, dft=False, eig_file=None, vac=False):
+                     dft=False, eig_file=None, vac=False):
         """Getting Eigenvalues along the path"""
         kd = self.kd
         if SO:
             e_kn = self.get_spinorbit_corrections(return_wfs=True,
                                                   dft=dft,
                                                   eig_file=eig_file)
-            if gwqeh_file is not None:
-                gwqeh_file = pickle.load(open(gwqeh_file))
-                eqeh_noSO_kn = gwqeh_file['qp_sin'][0] * Ha
-                eqeh_kn = np.zeros_like(e_kn)
-                eqeh_kn[:, ::2] = eqeh_noSO_kn
-                eqeh_kn[:, 1::2] = eqeh_noSO_kn
-
-                e_kn += eqeh_kn
-
-        elif gwqeh_file is not None:
-            gwqeh_file = pickle.load(open(gwqeh_file))
-            e_kn = gwqeh_file['Qp_sin'][0] * Ha
         elif eig_file is not None:
             e_kn = pickle.load(open(eig_file))[0]
         else:
             if not dft:
                 try:
                     e_kn = self.gw_file['qp'][0]
                 except KeyError:
```

### Comparing `gpaw-22.8.0/gpaw/response/gwqeh.py` & `gpaw-23.6.0/gpaw/response/pair.py`

 * *Files 21% similar despite different names*

```diff
@@ -1,537 +1,545 @@
-import sys
-from math import pi
-import pickle
-import warnings
+import numbers
 
 import numpy as np
 
-from ase.utils.timing import timer
-from ase.units import Hartree
-from ase.dft.kpoints import monkhorst_pack
-
-import gpaw.mpi as mpi
-from gpaw.kpt_descriptor import KPointDescriptor
-from gpaw.response.chi0 import find_maximum_frequency
-from gpaw.response.hilbert import HilbertTransform
-from gpaw.response.frequencies import FrequencyDescriptor
-from gpaw.response.pair import PairDensity
-from gpaw.pw.descriptor import PWDescriptor
-from gpaw.xc.exx import select_kpts
-
-
-class GWQEHCorrection(PairDensity):
-    def __init__(self, calc, gwfile, *,
-                 filename=None, kpts=[0], bands=None,
-                 structure=None, d=None, layer=0,
-                 dW_qw=None, qqeh=None, wqeh=None,
-                 txt=sys.stdout, world=mpi.world,
-                 frequencies=None,
-                 domega0=None,  # deprecated
-                 omega2=None,  # deprecated
-                 eta=0.1, include_q0=True, metal=False):
-        """
-        Class for calculating quasiparticle energies of van der Waals
-        heterostructures using the GW approximation for the self-energy.
-        The quasiparticle energy correction due to increased screening from
-        surrounding layers is obtained from the QEH model.
-        Parameters:
-
-        calc: str or PAW object
-            GPAW calculator object or filename of saved calculator object.
-        gwfile: str
-            name of gw results file from the monolayer calculation
-        filename: str
-            filename for gwqeh output
-        kpts: list
-            List of indices of sthe IBZ k-points to calculate the quasi
-            particle energies for. Set to [0] by default since the QP
-            correction is generally the same for all k.
-        bands: tuple
-            Range of band indices, like (n1, n2+1), to calculate the quasi
-            particle energies for. Note that the second band index is not
-            included. Should be the same as used for the GW calculation.
-        structure: list of str
-            Heterostructure set up. Each entry should consist of number of
-            layers + chemical formula.
-            For example: ['3H-MoS2', graphene', '10H-WS2'] gives 3 layers of
-            H-MoS2, 1 layer of graphene and 10 layers of H-WS2.
-            The name of the layers should correspond to building block files:
-            "<name>-chi.npz" in the local repository.
-        d: array of floats
-            Interlayer distances for neighboring layers in Ang.
-            Length of array = number of layers - 1
-        layer: int
-            index of layer to calculate QP correction for.
-        dW_qw: 2D array of floats dimension q X w
-            Change in screened interaction. Should be set to None to calculate
-            dW directly from buildingblocks.
-        qqeh: array of floats
-            q-grid used for dW_qw (only needed if dW is given by hand).
-        wqeh: array of floats
-            w-grid used for dW_qw. So far this have to be the same as for the
-            GWQEH calculation.  (only needed if dW is given by hand).
-        frequencies:
-            Input parameters for frequency_grid.
-            Can be array of frequencies to evaluate the response function at
-            or dictionary of paramaters for build-in nonlinear grid
-            (see :ref:`frequency grid`).
-        eta: float
-            Broadening parameter.
-        include_q0: bool
-            include q=0 in W or not. if True an integral arround q=0 is
-            performed, if False the q=0 contribution is set to zero.
-        metal: bool
-            If True, the point at q=0 is omitted when averaging the screened
-            potential close to q=0.
+from gpaw.response import ResponseGroundStateAdapter, ResponseContext, timer
+from gpaw.response.pw_parallelization import block_partition
+from gpaw.response.symmetry import KPointFinder
+from gpaw.utilities.blas import mmm
+
+
+class KPoint:
+    def __init__(self, s, K, n1, n2, blocksize, na, nb,
+                 ut_nR, eps_n, f_n, P_ani, k_c):
+        self.s = s    # spin index
+        self.K = K    # BZ k-point index
+        self.n1 = n1  # first band
+        self.n2 = n2  # first band not included
+        self.blocksize = blocksize
+        self.na = na  # first band of block
+        self.nb = nb  # first band of block not included
+        self.ut_nR = ut_nR      # periodic part of wave functions in real-space
+        self.eps_n = eps_n      # eigenvalues
+        self.f_n = f_n          # occupation numbers
+        self.P_ani = P_ani      # PAW projections
+        self.k_c = k_c  # k-point coordinates
+
+
+class PairDistribution:
+    def __init__(self, pair, mysKn1n2):
+        self.pair = pair
+        self.mysKn1n2 = mysKn1n2
+        self.mykpts = [self.pair.get_k_point(s, K, n1, n2)
+                       for s, K, n1, n2 in self.mysKn1n2]
+
+    def kpt_pairs_by_q(self, q_c, m1, m2):
+        pair = self.pair
+        mykpts = self.mykpts
+        for u, kpt1 in enumerate(mykpts):
+            progress = u / len(mykpts)
+            K2 = pair.gs.kd.find_k_plus_q(q_c, [kpt1.K])[0]
+            kpt2 = pair.get_k_point(kpt1.s, K2, m1, m2, block=True)
+
+            yield progress, kpt1, kpt2
+
+
+class KPointPair:
+    """This class defines the kpoint-pair container object.
+
+    Used for calculating pair quantities it contains two kpoints,
+    and an associated set of Fourier components."""
+    def __init__(self, kpt1, kpt2, Q_G):
+        self.kpt1 = kpt1
+        self.kpt2 = kpt2
+        self.Q_G = Q_G
+
+    def get_transition_energies(self, n_n, m_m):
+        """Return the energy difference for specified bands."""
+        n_n = np.array(n_n)
+        m_m = np.array(m_m)
+        kpt1 = self.kpt1
+        kpt2 = self.kpt2
+        deps_nm = (kpt1.eps_n[n_n - self.kpt1.n1][:, np.newaxis] -
+                   kpt2.eps_n[m_m - self.kpt2.n1])
+        return deps_nm
+
+    def get_occupation_differences(self, n_n, m_m):
+        """Get difference in occupation factor between specified bands."""
+        n_n = np.array(n_n)
+        m_m = np.array(m_m)
+        kpt1 = self.kpt1
+        kpt2 = self.kpt2
+        df_nm = (kpt1.f_n[n_n - self.kpt1.n1][:, np.newaxis] -
+                 kpt2.f_n[m_m - self.kpt2.n1])
+        return df_nm
+
+
+class PairDensityCalculator:
+    def __init__(self, gs, context, *,
+                 threshold=1, nblocks=1):
+        """Density matrix elements
+
+        Parameters
+        ----------
+        threshold : float
+            Numerical threshold for the optical limit k dot p perturbation
+            theory expansion.
         """
+        self.gs = gs
+        self.context = context
 
-        self.gwfile = gwfile
+        assert self.gs.kd.symmetry.symmorphic
 
-        self.inputcalc = calc
-        # Set low ecut in order to use PairDensity object since only
-        # G=0 is needed.
-        self.ecut = 1.
-        PairDensity.__init__(self, calc, ecut=self.ecut, world=world,
-                             txt=filename + '.txt')
-
-        self.filename = filename
-        self.ecut /= Hartree
-        self.eta = eta / Hartree
-
-        self.kpts = list(select_kpts(kpts, self.calc.wfs.kd))
-
-        if bands is None:
-            bands = [0, self.nocc2]
-
-        self.bands = bands
-
-        b1, b2 = bands
-        self.shape = shape = (self.calc.wfs.nspins, len(self.kpts), b2 - b1)
-        self.eps_sin = np.empty(shape)     # KS-eigenvalues
-        self.f_sin = np.empty(shape)       # occupation numbers
-        self.sigma_sin = np.zeros(shape)   # self-energies
-        self.dsigma_sin = np.zeros(shape)  # derivatives of self-energies
-        self.Z_sin = None                  # renormalization factors
-        self.qp_sin = None
-        self.Qp_sin = None
-
-        self.ecutnb = 150 / Hartree
-        self.vol = self.calc.wfs.gd.volume
-        self.nbands = min(self.calc.get_number_of_bands(),
-                          int(self.vol *
-                              self.ecutnb**1.5 * 2**0.5 / 3 / pi**2))
-
-        self.nspins = self.calc.wfs.nspins
-
-        kd = self.calc.wfs.kd
-
-        self.mysKn1n2 = None  # my (s, K, n1, n2) indices
-        self.distribute_k_points_and_bands(b1, b2, kd.ibz2bz_k[self.kpts])
-
-        # Find q-vectors and weights in the IBZ:
-        assert -1 not in kd.bz2bz_ks
-        offset_c = 0.5 * ((kd.N_c + 1) % 2) / kd.N_c
-        bzq_qc = monkhorst_pack(kd.N_c) + offset_c
-        self.qd = KPointDescriptor(bzq_qc)
-        self.qd.set_symmetry(self.calc.atoms, kd.symmetry)
-
-        # Set up frequencies argument
-        if domega0 is not None or omega2 is not None:
-            assert frequencies is None
-            frequencies = {'type': 'nonlinear',
-                           'domega0': 0.025 if domega0 is None else domega0,
-                           'omega2': 10.0 if omega2 is None else omega2}
-            warnings.warn(f'Please use frequencies={frequencies}')
-        elif frequencies is None:
-            frequencies = {'type': 'nonlinear',
-                           'domega0': 0.025,
-                           'omega2': 10.0}
-        else:
-            assert frequencies['type'] == 'nonlinear'
-        # Set up frequency descriptor
-        omax = find_maximum_frequency(self.calc, nbands=self.nbands,
-                                      fd=self.fd)
-        frequencies['omegamax'] = omax
-        self.wd = FrequencyDescriptor.from_array_or_dict(frequencies)
-        nw = len(self.wd)
-        self.wsize = 2 * nw
-
-        # Calculate screened potential of Heterostructure
-        if dW_qw is None:
-            try:
-                data = np.load(filename + "_dW_qw.npz")
-                self.qqeh = data['qqeh']
-                self.wqeh = data['wqeh']
-                dW_qw = data['dW_qw']
-            except IOError:
-                dW_qw = self.calculate_W_QEH(structure, d, layer)
-        else:
-            self.qqeh = qqeh
-            self.wqeh = None  # wqeh
+        self.threshold = threshold
 
-        self.dW_qw = self.get_W_on_grid(dW_qw, include_q0=include_q0,
-                                        metal=metal)
+        self.blockcomm, self.kncomm = block_partition(self.context.comm,
+                                                      nblocks)
+        self.nblocks = nblocks
+        self.ut_sKnvR = None  # gradient of wave functions for optical limit
 
-        assert nw == self.dW_qw.shape[1], \
-            ('Frequency grids doesnt match!')
+        self.kptfinder = KPointFinder(self.gs.kd.bzk_kc)
+        self.context.print('Number of blocks:', nblocks)
 
-        self.htp = HilbertTransform(self.wd.omega_w, self.eta, gw=True)
-        self.htm = HilbertTransform(self.wd.omega_w, -self.eta, gw=True)
-
-        self.complete = False
-        self.nq = 0
-        if self.load_state_file():
-            if self.complete:
-                print('Self-energy loaded from file', file=self.fd)
-
-    def calculate_QEH(self):
-        print('Calculating QEH self-energy contribution', file=self.fd)
-
-        kd = self.calc.wfs.kd
-
-        # Reset calculation
-        self.sigma_sin = np.zeros(self.shape)   # self-energies
-        self.dsigma_sin = np.zeros(self.shape)  # derivatives of self-energies
-
-        # Get KS eigenvalues and occupation numbers:
-        b1, b2 = self.bands
-        nibzk = self.calc.wfs.kd.nibzkpts
-        for i, k in enumerate(self.kpts):
-            for s in range(self.nspins):
-                u = s * nibzk + k
-                kpt = self.calc.wfs.kpt_u[u]
-                self.eps_sin[s, i] = kpt.eps_n[b1:b2]
-                self.f_sin[s, i] = kpt.f_n[b1:b2] / kpt.weight
-
-        # My part of the states we want to calculate QP-energies for:
-        mykpts = [self.get_k_point(s, K, n1, n2)
-                  for s, K, n1, n2 in self.mysKn1n2]
-
-        Nq = len((self.qd.ibzk_kc))
-        for iq, q_c in enumerate(self.qd.ibzk_kc):
-            self.nq = iq
-            nq = iq
-            self.save_state_file()
-
-            qcstr = '(' + ', '.join(['%.3f' % x for x in q_c]) + ')'
-            print('Calculating contribution from IBZ q-point #%d/%d q_c=%s'
-                  % (nq, Nq, qcstr), file=self.fd)
-
-            # Screened potential
-            dW_w = self.dW_qw[nq]
-            dW_w = dW_w[:, np.newaxis, np.newaxis]
-            L = abs(self.calc.wfs.gd.cell_cv[2, 2])
-            dW_w *= L
-
-            nw = len(self.wd)
-
-            Wpm_w = np.zeros([2 * nw, 1, 1], dtype=complex)
-            Wpm_w[:nw] = dW_w
-            Wpm_w[nw:] = Wpm_w[0:nw]
-
-            with self.timer('Hilbert transform'):
-                self.htp(Wpm_w[:nw])
-                self.htm(Wpm_w[nw:])
-
-            qd = KPointDescriptor([q_c])
-            pd0 = PWDescriptor(self.ecut, self.calc.wfs.gd, complex, qd)
-
-            # modify pd0 by hand - only G=0 component is needed
-            pd0.G_Qv = np.array([1e-17, 1e-17, 1e-17])[np.newaxis, :]
-            pd0.Q_qG = [np.array([0], dtype='int32')]
-            pd0.ngmax = 1
-            G_Gv = pd0.get_reciprocal_vectors()
-
-            self.Q_aGii = self.initialize_paw_corrections(pd0)
-
-            # Loop over all k-points in the BZ and find those that are related
-            # to the current IBZ k-point by symmetry
-            Q1 = self.qd.ibz2bz_k[iq]
-            Q2s = set()
-            for s, Q2 in enumerate(self.qd.bz2bz_ks[Q1]):
-                if Q2 >= 0 and Q2 not in Q2s:
-                    Q2s.add(Q2)
-
-            for Q2 in Q2s:
-                s = self.qd.sym_k[Q2]
-                self.s = s
-                U_cc = self.qd.symmetry.op_scc[s]
-                time_reversal = self.qd.time_reversal_k[Q2]
-                self.sign = 1 - 2 * time_reversal
-                Q_c = self.qd.bzk_kc[Q2]
-                d_c = self.sign * np.dot(U_cc, q_c) - Q_c
-                assert np.allclose(d_c.round(), d_c)
-
-                for u1, kpt1 in enumerate(mykpts):
-                    K2 = kd.find_k_plus_q(Q_c, [kpt1.K])[0]
-                    kpt2 = self.get_k_point(kpt1.s, K2, 0, self.nbands,
-                                            block=True)
-                    k1 = kd.bz2ibz_k[kpt1.K]
-                    i = self.kpts.index(k1)
-
-                    N_c = pd0.gd.N_c
-                    i_cG = self.sign * np.dot(U_cc,
-                                              np.unravel_index(pd0.Q_qG[0],
-                                                               N_c))
-
-                    k1_c = kd.bzk_kc[kpt1.K]
-                    k2_c = kd.bzk_kc[K2]
-                    # This is the q that connects K1 and K2 in the 1st BZ
-                    q1_c = k2_c - k1_c
-
-                    # G-vector that connects the full Q_c with q1_c
-                    shift1_c = q1_c - self.sign * np.dot(U_cc, q_c)
-                    assert np.allclose(shift1_c.round(), shift1_c)
-                    shift1_c = shift1_c.round().astype(int)
-                    shift_c = kpt1.shift_c - kpt2.shift_c - shift1_c
-                    I_G = np.ravel_multi_index(i_cG + shift_c[:, None],
-                                               N_c, 'wrap')
-                    pos_av = np.dot(self.spos_ac, pd0.gd.cell_cv)
-                    M_vv = np.dot(pd0.gd.cell_cv.T,
-                                  np.dot(U_cc.T,
-                                         np.linalg.inv(pd0.gd.cell_cv).T))
-                    Q_aGii = []
-                    for a, Q_Gii in enumerate(self.Q_aGii):
-                        x_G = np.exp(1j * np.dot(G_Gv, (pos_av[a] -
-                                                        np.dot(M_vv,
-                                                               pos_av[a]))))
-                        U_ii = self.calc.wfs.setups[a].R_sii[self.s]
-                        Q_Gii = np.dot(np.dot(U_ii, Q_Gii * x_G[:, None,
-                                                                None]),
-                                       U_ii.T).transpose(1, 0, 2)
-                        if self.sign == -1:
-                            Q_Gii = Q_Gii.conj()
-                        Q_aGii.append(Q_Gii)
-
-                    for n in range(kpt1.n2 - kpt1.n1):
-                        ut1cc_R = kpt1.ut_nR[n].conj()
-                        eps1 = kpt1.eps_n[n]
-                        C1_aGi = [np.dot(Qa_Gii, P1_ni[n].conj())
-                                  for Qa_Gii, P1_ni in zip(Q_aGii, kpt1.P_ani)]
-
-                        n_mG = self.calculate_pair_densities(ut1cc_R, C1_aGi,
-                                                             kpt2, pd0, I_G)
-                        if self.sign == 1:
-                            n_mG = n_mG.conj()
-
-                        f_m = kpt2.f_n
-                        deps_m = eps1 - kpt2.eps_n
-                        sigma, dsigma = self.calculate_sigma(n_mG, deps_m,
-                                                             f_m, Wpm_w)
-                        nn = kpt1.n1 + n - self.bands[0]
-                        self.sigma_sin[kpt1.s, i, nn] += sigma
-                        self.dsigma_sin[kpt1.s, i, nn] += dsigma
-
-        self.world.sum(self.sigma_sin)
-        self.world.sum(self.dsigma_sin)
-
-        self.complete = True
-        self.save_state_file()
+    def find_kpoint(self, k_c):
+        return self.kptfinder.find(k_c)
 
-        return self.sigma_sin, self.dsigma_sin
+    def distribute_k_points_and_bands(self, band1, band2, kpts=None):
+        """Distribute spins, k-points and bands.
+
+        The attribute self.mysKn1n2 will be set to a list of (s, K, n1, n2)
+        tuples that this process handles.
+        """
+
+        gs = self.gs
+
+        if kpts is None:
+            kpts = np.arange(gs.kd.nbzkpts)
+
+        # nbands is the number of bands for each spin/k-point combination.
+        nbands = band2 - band1
+        size = self.kncomm.size
+        rank = self.kncomm.rank
+        ns = gs.nspins
+        nk = len(kpts)
+        n = (ns * nk * nbands + size - 1) // size
+        i1 = min(rank * n, ns * nk * nbands)
+        i2 = min(i1 + n, ns * nk * nbands)
+
+        mysKn1n2 = []
+        i = 0
+        for s in range(ns):
+            for K in kpts:
+                n1 = min(max(0, i1 - i), nbands)
+                n2 = min(max(0, i2 - i), nbands)
+                if n1 != n2:
+                    mysKn1n2.append((s, K, n1 + band1, n2 + band1))
+                i += nbands
+
+        p = self.context.print
+        p('BZ k-points:', gs.kd, flush=False)
+        p('Distributing spins, k-points and bands (%d x %d x %d)' %
+          (ns, nk, nbands), 'over %d process%s' %
+          (self.kncomm.size, ['es', ''][self.kncomm.size == 1]),
+          flush=False)
+        p('Number of blocks:', self.blockcomm.size)
+
+        return PairDistribution(self, mysKn1n2)
+
+    @timer('Get a k-point')
+    def get_k_point(self, s, k_c, n1, n2, block=False):
+        """Return wave functions for a specific k-point and spin.
+
+        s: int
+            Spin index (0 or 1).
+        K: int
+            BZ k-point index.
+        n1, n2: int
+            Range of bands to include.
+        """
 
-    def calculate_qp_correction(self):
+        assert n1 <= n2
 
-        if self.complete:
-            print('Self-energy loaded from file', file=self.fd)
+        gs = self.gs
+        kd = gs.kd
+
+        # Parse kpoint: is k_c an index or a vector
+        if not isinstance(k_c, numbers.Integral):
+            K = self.kptfinder.find(k_c)
         else:
-            self.calculate_QEH()
+            # Fall back to index
+            K = k_c
 
-        # Need GW result for renormalization factor
-        b1, b2 = self.bands
-        gwdata = pickle.load(open(self.gwfile, 'rb'))
-        self.dsigmagw_sin = gwdata['dsigma']
-        self.qpgw_sin = gwdata['qp'] / Hartree
-        nk = self.qpgw_sin.shape[1]
-        if not self.sigma_sin.shape[1] == nk:
-            self.sigma_sin = np.repeat(self.sigma_sin[:, :1, :], nk, axis=1)
-            self.dsigma_sin = np.repeat(self.dsigma_sin[:, :1, :], nk, axis=1)
-        self.Z_sin = 1. / (1 - self.dsigma_sin - self.dsigmagw_sin)
-        self.qp_sin = self.Z_sin * self.sigma_sin
-
-        return self.qp_sin * Hartree
-
-    def calculate_qp_energies(self):
-        # calculate
-        qp_sin = self.calculate_qp_correction() / Hartree
-        self.Qp_sin = self.qpgw_sin + qp_sin
-        self.save_state_file()
-        return self.Qp_sin * Hartree
-
-    @timer('Sigma')
-    def calculate_sigma(self, n_mG, deps_m, f_m, W_wGG):
-        """Calculates a contribution to the self-energy and its derivative for
-        a given (k, k-q)-pair from its corresponding pair-density and
-        energy."""
-        o_m = abs(deps_m)
-        # Add small number to avoid zeros for degenerate states:
-        sgn_m = np.sign(deps_m + 1e-15)
-
-        # Pick +i*eta or -i*eta:
-        s_m = (1 + sgn_m * np.sign(0.5 - f_m)).astype(int) // 2
-        comm = self.blockcomm
-        nw = len(self.wd)
-        nG = n_mG.shape[1]
-        mynG = (nG + comm.size - 1) // comm.size
-        Ga = min(comm.rank * mynG, nG)
-        Gb = min(Ga + mynG, nG)
-        w_m = self.wd.get_floor_index(o_m, safe=False)
-        o1_m = self.wd.omega_w[w_m]
-        o2_m = self.wd.omega_w[w_m + 1]
-
-        x = 1.0 / (self.qd.nbzkpts * 2 * pi * self.vol)
-        sigma = 0.0
-        dsigma = 0.0
-        # Performing frequency integration
-        for o, o1, o2, sgn, s, w, n_G in zip(o_m, o1_m, o2_m,
-                                             sgn_m, s_m, w_m, n_mG):
-
-            C1_GG = W_wGG[s * nw + w]
-            C2_GG = W_wGG[s * nw + w + 1]
-            p = x * sgn
-            myn_G = n_G[Ga:Gb]
-            sigma1 = p * np.dot(np.dot(myn_G, C1_GG), n_G.conj()).imag
-            sigma2 = p * np.dot(np.dot(myn_G, C2_GG), n_G.conj()).imag
-            sigma += ((o - o1) * sigma2 + (o2 - o) * sigma1) / (o2 - o1)
-            dsigma += sgn * (sigma2 - sigma1) / (o2 - o1)
-
-        return sigma, dsigma
-
-    def save_state_file(self, q=0):
-        data = {'kpts': self.kpts,
-                'bands': self.bands,
-                'nbands': self.nbands,
-                'last_q': self.nq,
-                'complete': self.complete,
-                'sigma_sin': self.sigma_sin,
-                'dsigma_sin': self.dsigma_sin,
-                'qp_sin': self.qp_sin,
-                'Qp_sin': self.Qp_sin}
-        if self.world.rank == 0:
-            np.savez(self.filename + '_qeh.npz',
-                     **data)
-
-    def load_state_file(self):
-        try:
-            data = np.load(self.filename + '_qeh.npz')
-        except IOError:
-            return False
+        if block:
+            nblocks = self.blockcomm.size
+            rank = self.blockcomm.rank
         else:
-            if (data['kpts'] == self.kpts and
-                data['bands'] == self.bands and
-                data['nbands'] == self.nbands):
-                self.nq = data['last_q']
-                self.complete = data['complete']
-                self.complete = data['complete']
-                self.sigma_sin = data['sigma_sin']
-                self.dsigma_sin = data['dsigma_sin']
-                return True
+            nblocks = 1
+            rank = 0
+
+        blocksize = (n2 - n1 + nblocks - 1) // nblocks
+        na = min(n1 + rank * blocksize, n2)
+        nb = min(na + blocksize, n2)
+
+        ik = kd.bz2ibz_k[K]
+        assert kd.comm.size == 1
+        kpt = gs.kpt_qs[ik][s]
+
+        assert n2 <= len(kpt.eps_n), \
+            'Increase GS-nbands or decrease chi0-nbands!'
+        eps_n = kpt.eps_n[n1:n2]
+        f_n = kpt.f_n[n1:n2] / kpt.weight
+
+        k_c = self.gs.ibz2bz[K].map_kpoint()
+
+        with self.context.timer('load wfs'):
+            psit_nG = kpt.psit_nG
+            ut_nR = gs.gd.empty(nb - na, gs.dtype)
+            for n in range(na, nb):
+                ut_nR[n - na] = self.gs.ibz2bz[K].map_pseudo_wave(
+                    gs.pd.ifft(psit_nG[n], ik))
+
+        with self.context.timer('Load projections'):
+            if nb - na > 0:
+                proj = kpt.projections.new(nbands=nb - na, bcomm=None)
+                proj.array[:] = kpt.projections.array[na:nb]
+                proj = self.gs.ibz2bz[K].map_projections(proj)
+                P_ani = [P_ni for _, P_ni in proj.items()]
             else:
-                return False
+                P_ani = []
 
-    def get_W_on_grid(self, dW_qw, include_q0=True, metal=False):
-        """This function transforms the screened potential W(q,w) to the
-        (q,w)-grid of the GW calculation. Also, W is integrated over
-        a region around q=0 if include_q0 is set to True."""
-
-        q_cs = self.qd.ibzk_kc
-
-        rcell_cv = 2 * pi * np.linalg.inv(self.calc.wfs.gd.cell_cv).T
-        q_vs = np.dot(q_cs, rcell_cv)
-        q_grid = (q_vs**2).sum(axis=1)**0.5
-        self.q_grid = q_grid
-
-        wqeh = self.wqeh  # self.wd.omega_w.copy() # self.qeh
-        qqeh = self.qqeh
-        sortqeh = np.argsort(qqeh)
-        qqeh = qqeh[sortqeh]
-        dW_qw = dW_qw[sortqeh]
-
-        sort = np.argsort(q_grid)
-        isort = np.argsort(sort)
-        if metal and np.isclose(qqeh[0], 0):
-            """We don't have the right q=0 limit for metals  and semi-metals.
-            -> Point should be omitted from interpolation"""
-            qqeh = qqeh[1:]
-            dW_qw = dW_qw[1:]
-            sort = sort[1:]
-
-        from scipy.interpolate import RectBivariateSpline
-        yr = RectBivariateSpline(qqeh, wqeh, dW_qw.real, s=0)
-        yi = RectBivariateSpline(qqeh, wqeh, dW_qw.imag, s=0)
-
-        dWgw_qw = yr(q_grid[sort], self.wd.omega_w)\
-            + 1j * yi(q_grid[sort], self.wd.omega_w)
-        dW_qw = yr(qqeh, self.wd.omega_w) + 1j * yi(qqeh, self.wd.omega_w)
-
-        if metal:
-            # Interpolation is done -> put back zeros at q=0
-            dWgw_qw = np.insert(dWgw_qw, 0, 0, axis=0)
-            qqeh = np.insert(qqeh, 0, 0)
-            dW_qw = np.insert(dW_qw, 0, 0, axis=0)
-            q_cut = q_grid[sort][0] / 2.
+        return KPoint(s, K, n1, n2, blocksize, na, nb,
+                      ut_nR, eps_n, f_n, P_ani, k_c)
+
+    @timer('Get kpoint pair')
+    def get_kpoint_pair(self, qpd, s, Kork_c, n1, n2, m1, m2, block=False):
+        assert m1 <= m2
+        assert n1 <= n2
+
+        if isinstance(Kork_c, int):
+            # If k_c is an integer then it refers to
+            # the index of the kpoint in the BZ
+            k_c = self.gs.kd.bzk_kc[Kork_c]
         else:
-            q_cut = q_grid[sort][1] / 2.
+            k_c = Kork_c
 
-        q0 = np.array([q for q in qqeh if q <= q_cut])
-        if len(q0) > 1:  # Integrate arround q=0
-            vol = np.pi * (q0[-1] + q0[1] / 2.)**2
-            if np.isclose(q0[0], 0):
-                weight0 = np.pi * (q0[1] / 2.)**2 / vol
-                c = (1 - weight0) / np.sum(q0)
-                weights = c * q0
-                weights[0] = weight0
-            else:
-                c = 1 / np.sum(q0)
-                weights = c * q0
+        q_c = qpd.q_c
+        with self.context.timer('get k-points'):
+            kpt1 = self.get_k_point(s, k_c, n1, n2)
+            # K2 = wfs.kd.find_k_plus_q(q_c, [kpt1.K])[0]
+            kpt2 = self.get_k_point(s, k_c + q_c, m1, m2, block=block)
+
+        with self.context.timer('fft indices'):
+            Q_G = phase_shifted_fft_indices(kpt1.k_c, kpt2.k_c, qpd)
+
+        return KPointPair(kpt1, kpt2, Q_G)
+
+    def get_optical_pair_density(self, qpd, kptpair, n_n, m_m, *,
+                                 pawcorr, block=False):
+        """Get the full optical pair density, including the optical limit head
+        for q=0."""
+        tmp_nmG = self.get_pair_density(qpd, kptpair, n_n, m_m,
+                                        pawcorr=pawcorr, block=block)
+
+        nG = qpd.ngmax
+        # P = (x, y, z, G1, G2, ...)
+        n_nmP = np.empty((len(n_n), len(m_m), nG + 2), dtype=tmp_nmG.dtype)
+        n_nmP[:, :, 3:] = tmp_nmG[:, :, 1:]
+        n_nmv = self.get_optical_pair_density_head(qpd, kptpair, n_n, m_m,
+                                                   block=block)
+        n_nmP[:, :, :3] = n_nmv
+
+        return n_nmP
+
+    @timer('get_pair_density')
+    def get_pair_density(self, qpd, kptpair, n_n, m_m, *,
+                         pawcorr, block=False):
+        """Get pair density for a kpoint pair."""
+        cpd = self.calculate_pair_density
+
+        kpt1 = kptpair.kpt1
+        kpt2 = kptpair.kpt2
+        Q_G = kptpair.Q_G  # Fourier components of kpoint pair
+        nG = len(Q_G)
+
+        n_nmG = np.zeros((len(n_n), len(m_m), nG), qpd.dtype)
+
+        for j, n in enumerate(n_n):
+            Q_G = kptpair.Q_G
+            with self.context.timer('conj'):
+                ut1cc_R = kpt1.ut_nR[n - kpt1.na].conj()
+            with self.context.timer('paw'):
+                C1_aGi = pawcorr.multiply(kpt1.P_ani, band=n - kpt1.na)
+                n_nmG[j] = cpd(ut1cc_R, C1_aGi, kpt2, qpd, Q_G, block=block)
+
+        return n_nmG
+
+    @timer('get_optical_pair_density_head')
+    def get_optical_pair_density_head(self, qpd, kptpair, n_n, m_m,
+                                      block=False):
+        """Get the optical limit of the pair density head (G=0) for a k-pair.
+        """
+        assert np.allclose(qpd.q_c, 0.0), f"{qpd.q_c} is not the optical limit"
+
+        kpt1 = kptpair.kpt1
+        kpt2 = kptpair.kpt2
 
-            dWgw_qw[0] = (np.repeat(weights[:, np.newaxis], len(self.wd),
-                                    axis=1) * dW_qw[:len(q0)]).sum(axis=0)
+        # v = (x, y, z)
+        n_nmv = np.zeros((len(n_n), len(m_m), 3), qpd.dtype)
 
-        if not include_q0:  # Omit q=0 contrinution completely.
-            dWgw_qw[0] = 0.0
+        for j, n in enumerate(n_n):
+            n_nmv[j] = self.calculate_optical_pair_density_head(n, m_m,
+                                                                kpt1, kpt2,
+                                                                block=block)
+
+        return n_nmv
+
+    @timer('Calculate pair-densities')
+    def calculate_pair_density(self, ut1cc_R, C1_aGi, kpt2, qpd, Q_G,
+                               block=True):
+        """Calculate FFT of pair-densities and add PAW corrections.
+
+        ut1cc_R: 3-d complex ndarray
+            Complex conjugate of the periodic part of the left hand side
+            wave function.
+        C1_aGi: list of ndarrays
+            PAW corrections for all atoms.
+        kpt2: KPoint object
+            Right hand side k-point object.
+        qpd: SingleQPWDescriptor
+            Plane-wave descriptor for q=k2-k1.
+        Q_G: 1-d int ndarray
+            Mapping from flattened 3-d FFT grid to 0.5(G+q)^2<ecut sphere.
+        """
+        dv = qpd.gd.dv
+        n_mG = qpd.empty(kpt2.blocksize)
+        myblocksize = kpt2.nb - kpt2.na
+
+        for ut_R, n_G in zip(kpt2.ut_nR, n_mG):
+            n_R = ut1cc_R * ut_R
+            with self.context.timer('fft'):
+                n_G[:] = qpd.fft(n_R, 0, Q_G) * dv
+        # PAW corrections:
+        with self.context.timer('gemm'):
+            for C1_Gi, P2_mi in zip(C1_aGi, kpt2.P_ani):
+                # gemm(1.0, C1_Gi, P2_mi, 1.0, n_mG[:myblocksize], 't')
+                mmm(1.0, P2_mi, 'N', C1_Gi, 'T', 1.0, n_mG[:myblocksize])
 
-        dWgw_qw = dWgw_qw[isort]  # Put dW back on native grid.
-        return dWgw_qw
-
-    def calculate_W_QEH(self, structure, d, layer=0):
-        from gpaw.response.qeh import Heterostructure, expand_layers
-
-        structure = expand_layers(structure)
-        wmax = self.wd.omega_w[-1]
-        # qmax = (self.q_grid).max()
-
-        # Single layer
-        s = (np.insert(d, 0, d[0]) +
-             np.append(d, d[-1])) / 2.
-        d0 = s[layer]
-        HS0 = Heterostructure(structure=[structure[layer]],
-                              d=[],
-                              d0=d0,
-                              wmax=wmax * Hartree,
-                              # qmax=qmax / Bohr
-                              )
-
-        W0_qw = HS0.get_screened_potential()
-
-        # Full heterostructure
-
-        HS = Heterostructure(structure=structure, d=d,
-                             wmax=wmax * Hartree,
-                             # qmax=qmax / Bohr
-                             )
-        W_qw = HS.get_screened_potential(layer=layer)
-
-        # Difference in screened potential:
-        dW_qw = W_qw - W0_qw
-        self.wqeh = HS.frequencies
-        self.qqeh = HS.q_abs
-
-        if self.world.rank == 0:
-            data = {'qqeh': self.qqeh,
-                    'wqeh': self.wqeh,
-                    'dW_qw': dW_qw}
-            np.savez(self.filename + "_dW_qw.npz",
-                     **data)
+        if not block or self.blockcomm.size == 1:
+            return n_mG
+        else:
+            n_MG = qpd.empty(kpt2.blocksize * self.blockcomm.size)
+            with self.context.timer('all_gather'):
+                self.blockcomm.all_gather(n_mG, n_MG)
+            return n_MG[:kpt2.n2 - kpt2.n1]
+
+    @timer('Optical limit')
+    def calculate_optical_pair_velocity(self, n, kpt1, kpt2, block=False):
+        # This has the effect of caching at most one kpoint.
+        # This caching will be efficient only if we are looping over kpoints
+        # in a particular way.
+        #
+        # It would be better to refactor so this caching is handled explicitly
+        # by the caller providing the right thing.
+        #
+        # See https://gitlab.com/gpaw/gpaw/-/issues/625
+        if self.ut_sKnvR is None or kpt1.K not in self.ut_sKnvR[kpt1.s]:
+            self.ut_sKnvR = self.calculate_derivatives(kpt1)
+
+        gd = self.gs.gd
+        k_v = 2 * np.pi * np.dot(kpt1.k_c, np.linalg.inv(gd.cell_cv).T)
+
+        ut_vR = self.ut_sKnvR[kpt1.s][kpt1.K][n - kpt1.n1]
+        atomdata_a = self.gs.pawdatasets
+        C_avi = [np.dot(atomdata.nabla_iiv.T, P_ni[n - kpt1.na])
+                 for atomdata, P_ni in zip(atomdata_a, kpt1.P_ani)]
+
+        blockbands = kpt2.nb - kpt2.na
+        n0_mv = np.empty((kpt2.blocksize, 3), dtype=complex)
+        nt_m = np.empty(kpt2.blocksize, dtype=complex)
+        n0_mv[:blockbands] = -self.gs.gd.integrate(ut_vR,
+                                                   kpt2.ut_nR).T
+        nt_m[:blockbands] = self.gs.gd.integrate(kpt1.ut_nR[n - kpt1.na],
+                                                 kpt2.ut_nR)
+
+        n0_mv[:blockbands] += (1j * nt_m[:blockbands, np.newaxis] *
+                               k_v[np.newaxis, :])
+
+        for C_vi, P_mi in zip(C_avi, kpt2.P_ani):
+            # gemm(1.0, C_vi, P_mi, 1.0, n0_mv[:blockbands], 'c')
+            mmm(1.0, P_mi, 'N', C_vi, 'C', 1.0, n0_mv[:blockbands])
+
+        if block and self.blockcomm.size > 1:
+            n0_Mv = np.empty((kpt2.blocksize * self.blockcomm.size, 3),
+                             dtype=complex)
+            with self.context.timer('all_gather optical'):
+                self.blockcomm.all_gather(n0_mv, n0_Mv)
+            n0_mv = n0_Mv[:kpt2.n2 - kpt2.n1]
+
+        return -1j * n0_mv
+
+    def calculate_optical_pair_density_head(self, n, m_m, kpt1, kpt2,
+                                            block=False):
+        # Relative threshold for perturbation theory
+        threshold = self.threshold
+
+        eps1 = kpt1.eps_n[n - kpt1.n1]
+        deps_m = (eps1 - kpt2.eps_n)[m_m - kpt2.n1]
+        n0_mv = self.calculate_optical_pair_velocity(n, kpt1, kpt2,
+                                                     block=block)
+
+        deps_m = deps_m.copy()
+        deps_m[deps_m == 0.0] = np.inf
+
+        smallness_mv = np.abs(-1e-3 * n0_mv / deps_m[:, np.newaxis])
+        inds_mv = (np.logical_and(np.inf > smallness_mv,
+                                  smallness_mv > threshold))
+        n0_mv *= - 1 / deps_m[:, np.newaxis]
+        n0_mv[inds_mv] = 0
+
+        return n0_mv
+
+    @timer('Intraband')
+    def intraband_pair_density(self, kpt, n_n):
+        """Calculate intraband matrix elements of nabla"""
+        # Bands and check for block parallelization
+        na, nb, n1 = kpt.na, kpt.nb, kpt.n1
+        vel_nv = np.zeros((nb - na, 3), dtype=complex)
+        assert np.max(n_n) < nb, 'This is too many bands'
+        assert np.min(n_n) >= na, 'This is too few bands'
+
+        # Load kpoints
+        gd = self.gs.gd
+        k_v = 2 * np.pi * np.dot(kpt.k_c, np.linalg.inv(gd.cell_cv).T)
+        atomdata_a = self.gs.pawdatasets
+
+        # Break bands into degenerate chunks
+        degchunks_cn = []  # indexing c as chunk number
+        for n in n_n:
+            inds_n = np.nonzero(np.abs(kpt.eps_n[n - n1] -
+                                       kpt.eps_n) < 1e-5)[0] + n1
+
+            # Has this chunk already been computed?
+            oldchunk = any([n in chunk for chunk in degchunks_cn])
+            if not oldchunk:
+                assert all([ind in n_n for ind in inds_n]), \
+                    self.context.print(
+                        '\nYou are cutting over a degenerate band ' +
+                        'using block parallelization.', inds_n, n_n)
+                degchunks_cn.append((inds_n))
+
+        # Calculate matrix elements by diagonalizing each block
+        for ind_n in degchunks_cn:
+            deg = len(ind_n)
+            ut_nvR = self.gs.gd.zeros((deg, 3), complex)
+            vel_nnv = np.zeros((deg, deg, 3), dtype=complex)
+            # States are included starting from kpt.na
+            ut_nR = kpt.ut_nR[ind_n - na]
+
+            # Get derivatives
+            for ind, ut_vR in zip(ind_n, ut_nvR):
+                ut_vR[:] = self.make_derivative(kpt.s, kpt.K,
+                                                ind, ind + 1)[0]
+
+            # Treat the whole degenerate chunk
+            for n in range(deg):
+                ut_vR = ut_nvR[n]
+                C_avi = [np.dot(atomdata.nabla_iiv.T, P_ni[ind_n[n] - na])
+                         for atomdata, P_ni in zip(atomdata_a,
+                                                   kpt.P_ani)]
+
+                nabla0_nv = -self.gs.gd.integrate(ut_vR, ut_nR).T
+                nt_n = self.gs.gd.integrate(ut_nR[n], ut_nR)
+                nabla0_nv += 1j * nt_n[:, np.newaxis] * k_v[np.newaxis, :]
+
+                for C_vi, P_ni in zip(C_avi, kpt.P_ani):
+                    # gemm(1.0, C_vi, P_ni[ind_n - na], 1.0, nabla0_nv, 'c')
+                    mmm(1.0, P_ni[ind_n - na], 'N', C_vi, 'C', 1.0, nabla0_nv)
+
+                vel_nnv[n] = -1j * nabla0_nv
+
+            for iv in range(3):
+                vel, _ = np.linalg.eig(vel_nnv[..., iv])
+                vel_nv[ind_n - na, iv] = vel  # Use eigenvalues
+
+        return vel_nv[n_n - na]
+
+    def calculate_derivatives(self, kpt):
+        ut_sKnvR = [{}, {}]
+        ut_nvR = self.make_derivative(kpt.s, kpt.K, kpt.n1, kpt.n2)
+        ut_sKnvR[kpt.s][kpt.K] = ut_nvR
+
+        return ut_sKnvR
+
+    @timer('Derivatives')
+    def make_derivative(self, s, K, n1, n2):
+        gs = self.gs
+        U_cc = gs.ibz2bz[K].U_cc
+        A_cv = gs.gd.cell_cv
+        M_vv = np.dot(np.dot(A_cv.T, U_cc.T), np.linalg.inv(A_cv).T)
+        ik = gs.kd.bz2ibz_k[K]
+        assert gs.kd.comm.size == 1
+        kpt = gs.kpt_qs[ik][s]
+        psit_nG = kpt.psit_nG
+        iG_Gv = 1j * gs.pd.get_reciprocal_vectors(q=ik, add_q=False)
+        ut_nvR = gs.gd.zeros((n2 - n1, 3), complex)
+        for n in range(n1, n2):
+            for v in range(3):
+                ut_R = gs.ibz2bz[K].map_pseudo_wave(
+                    gs.pd.ifft(iG_Gv[:, v] * psit_nG[n], ik))
+                for v2 in range(3):
+                    ut_nvR[n - n1, v2] += ut_R * M_vv[v, v2]
+
+        return ut_nvR
+
+
+def phase_shifted_fft_indices(k1_c, k2_c, qpd, coordinate_transformation=None):
+    """Get phase shifted FFT indices for G-vectors inside the cutoff sphere.
+
+    The output 1D FFT indices Q_G can be used to extract the plane-wave
+    components G of the phase shifted Fourier transform
+
+    n_kk'(G+q) = FFT_G[e^(-i[k+q-k']r) n_kk'(r)]
+
+    where n_kk'(r) is some lattice periodic function and the wave vector
+    difference k + q - k' is commensurate with the reciprocal lattice.
+    """
+    N_c = qpd.gd.N_c
+    Q_G = qpd.Q_qG[0]
+    q_c = qpd.q_c
+    if coordinate_transformation:
+        q_c = coordinate_transformation(q_c)
+
+    shift_c = k1_c + q_c - k2_c
+    assert np.allclose(shift_c.round(), shift_c)
+    shift_c = shift_c.round().astype(int)
+
+    if shift_c.any() or coordinate_transformation:
+        # Get the 3D FFT grid indices (relative reciprocal space coordinates)
+        # of the G-vectors inside the cutoff sphere
+        i_cG = np.unravel_index(Q_G, N_c)
+        if coordinate_transformation:
+            i_cG = coordinate_transformation(i_cG)
+        # Shift the 3D FFT grid indices to account for the Bloch-phase shift
+        # e^(-i[k+q-k']r)
+        i_cG += shift_c[:, np.newaxis]
+        # Transform back the FFT grid to 1D FFT indices
+        Q_G = np.ravel_multi_index(i_cG, N_c, 'wrap')
+
+    return Q_G
+
+
+def get_gs_and_context(calc, txt, world, timer):
+    """Interface to initialize gs and context from old input arguments.
+    Should be phased out in the future!"""
+    from gpaw.calculator import GPAW as OldGPAW
+    from gpaw.new.ase_interface import ASECalculator as NewGPAW
+
+    context = ResponseContext(txt=txt, timer=timer, comm=world)
+
+    if isinstance(calc, (OldGPAW, NewGPAW)):
+        assert calc.wfs.world.size == 1
+        gs = calc.gs_adapter()
+    else:
+        gs = ResponseGroundStateAdapter.from_gpw_file(calc, context=context)
 
-        return dW_qw
+    return gs, context
```

### Comparing `gpaw-22.8.0/gpaw/response/heisenberg.py` & `gpaw-23.6.0/gpaw/response/heisenberg.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/response/hilbert.py` & `gpaw-23.6.0/gpaw/response/hilbert.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/response/integrators.py` & `gpaw-23.6.0/gpaw/response/integrators.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,55 +1,58 @@
-from functools import partial
-
+from abc import ABC, abstractmethod
 import numpy as np
-from gpaw.utilities import convert_string_to_fd
-from ase.utils.timing import timer, Timer
+from gpaw.response import timer
 from scipy.spatial import Delaunay
 from scipy.linalg.blas import zher
 
 import _gpaw
-import gpaw.mpi as mpi
 from gpaw.utilities.blas import rk, mmm
 from gpaw.utilities.progressbar import ProgressBar
 from gpaw.response.pw_parallelization import Blocks1D, block_partition
 
 
+class Integrand(ABC):
+    @abstractmethod
+    def matrix_element(self, k_v, s):
+        ...
+
+    @abstractmethod
+    def eigenvalues(self, k_v, s):
+        ...
+
+
 def czher(alpha: float, x, A) -> None:
     """Hermetian rank-1 update of upper half of A.
 
     A += alpha * np.outer(x.conj(), x)
 
     """
     AT = A.T
     out = zher(alpha, x, 1, 1, 0, len(x), AT, 1)
     assert out is AT
 
 
 class Integrator:
-    def __init__(self, cell_cv, comm=mpi.world,
-                 txt='-', timer=None, nblocks=1, eshift=0.0):
+    def __init__(self, cell_cv, context, nblocks=1, eshift=0.0):
         """Baseclass for Brillouin zone integration and band summation.
 
         Simple class to calculate integrals over Brilloun zones
         and summation of bands.
 
-        comm: mpi.communicator
+        context: ResponseContext
         nblocks: block parallelization
         """
 
-        self.comm = comm
+        self.context = context
         self.eshift = eshift
         self.nblocks = nblocks
         self.vol = abs(np.linalg.det(cell_cv))
 
-        self.blockcomm, self.kncomm = block_partition(comm, nblocks)
-
-        self.fd = convert_string_to_fd(txt, comm)
-
-        self.timer = timer or Timer()
+        self.blockcomm, self.kncomm = block_partition(self.context.comm,
+                                                      nblocks)
 
     def distribute_domain(self, domain_dl):
         """Distribute integration domain. """
         domainsize = [len(domain_l) for domain_l in domain_dl]
         nterms = np.prod(domainsize)
         size = self.kncomm.size
         rank = self.kncomm.rank
@@ -62,49 +65,45 @@
         for i in range(i1, i2):
             unravelled_d = np.unravel_index(i, domainsize)
             arguments = []
             for domain_l, index in zip(domain_dl, unravelled_d):
                 arguments.append(domain_l[index])
             mydomain.append(tuple(arguments))
 
-        print('Distributing domain %s' % (domainsize, ),
-              'over %d process%s' %
-              (self.kncomm.size, ['es', ''][self.kncomm.size == 1]),
-              file=self.fd)
-        print('Number of blocks:', self.blockcomm.size, file=self.fd)
+        self.context.print('Distributing domain %s' % (domainsize,),
+                           'over %d process%s' %
+                           (self.kncomm.size,
+                            ['es', ''][self.kncomm.size == 1]),
+                           flush=False)
+        self.context.print('Number of blocks:', self.blockcomm.size)
 
         return mydomain
 
     def integrate(self, *args, **kwargs):
         raise NotImplementedError
 
     def _blocks1d(self, nG):
         return Blocks1D(self.blockcomm, nG)
 
 
 class PointIntegrator(Integrator):
+    """Integrate brillouin zone using a broadening technique.
 
-    def __init__(self, *args, **kwargs):
-
-        """Integrate brillouin zone using a broadening technique.
-
-        The broadening technique consists of smearing out the
-        delta functions appearing in many integrals by some factor
-        eta. In this code we use Lorentzians."""
-        Integrator.__init__(self, *args, **kwargs)
+    The broadening technique consists of smearing out the
+    delta functions appearing in many integrals by some factor
+    eta. In this code we use Lorentzians."""
 
     def integrate(self, kind='pointwise', *args, **kwargs):
-        print('Integral kind:', kind, file=self.fd)
+        self.context.print('Integral kind:', kind)
         if kind == 'pointwise':
             return self.pointwise_integration(*args, **kwargs)
         elif kind == 'hermitian response function':
             return self.response_function_integration(hermitian=True,
                                                       hilbert=False,
                                                       wings=False,
-                                                      intraband=False,
                                                       *args, **kwargs)
         elif kind == 'hermitian response function wings':
             return self.response_function_integration(hermitian=True,
                                                       hilbert=False,
                                                       wings=True,
                                                       *args, **kwargs)
         elif kind == 'spectral function':
@@ -118,72 +117,63 @@
             return self.response_function_integration(hilbert=False,
                                                       *args, **kwargs)
         elif kind == 'response function wings':
             return self.response_function_integration(hilbert=False,
                                                       wings=True,
                                                       *args, **kwargs)
         else:
-            raise NotImplementedError
+            raise ValueError(kind)
 
-    def response_function_integration(self, domain=None, integrand=None,
-                                      x=None, kwargs=None, out_wxx=None,
-                                      timeordered=False, hermitian=False,
+    def response_function_integration(self, *, domain, integrand,
+                                      x=None, out_wxx,
+                                      hermitian=False,
                                       intraband=False, hilbert=False,
-                                      wings=False, **extraargs):
+                                      wings=False, eta=None):
         """Integrate a response function over bands and kpoints.
 
         func: method
         omega_w: ndarray
         out: np.ndarray
-        timeordered: Bool
         """
-        if out_wxx is None:
-            raise NotImplementedError
-
         mydomain_t = self.distribute_domain(domain)
         nbz = len(domain[0])
-        get_matrix_element, get_eigenvalues = integrand
 
         prefactor = (2 * np.pi)**3 / self.vol / nbz
         out_wxx /= prefactor
 
-        # The kwargs contain any constant
-        # arguments provided by the user
-        if kwargs is not None:
-            get_matrix_element = partial(get_matrix_element,
-                                         **kwargs[0])
-            get_eigenvalues = partial(get_eigenvalues,
-                                      **kwargs[1])
-
         # Sum kpoints
         # Calculate integrations weight
-        pb = ProgressBar(self.fd)
+        pb = ProgressBar(self.context.fd)
         for _, arguments in pb.enumerate(mydomain_t):
-            n_MG = get_matrix_element(*arguments)
+            n_MG = integrand.matrix_element(*arguments)
             if n_MG is None:
                 continue
-            deps_M = get_eigenvalues(*arguments)
+            deps_M = integrand.eigenvalues(*arguments)
 
             if intraband:
-                self.update_intraband(n_MG, out_wxx, **extraargs)
+                assert eta is None
+                assert x is None
+                self.update_intraband(n_MG, out_wxx)
             elif hermitian and not wings:
-                self.update_hermitian(n_MG, deps_M, x, out_wxx, **extraargs)
+                assert eta is None
+                self.update_hermitian(n_MG, deps_M, x, out_wxx)
             elif hermitian and wings:
-                self.update_hermitian_optical_limit(n_MG, deps_M, x, out_wxx,
-                                                    **extraargs)
+                assert eta is None
+                self.update_hermitian_optical_limit(n_MG, deps_M, x, out_wxx)
             elif hilbert and not wings:
-                self.update_hilbert(n_MG, deps_M, x, out_wxx, **extraargs)
+                assert eta is None
+                self.update_hilbert(n_MG, deps_M, x, out_wxx)
             elif hilbert and wings:
-                self.update_hilbert_optical_limit(n_MG, deps_M, x,
-                                                  out_wxx, **extraargs)
+                assert eta is None
+                self.update_hilbert_optical_limit(n_MG, deps_M, x, out_wxx)
             elif wings:
                 self.update_optical_limit(n_MG, deps_M, x, out_wxx,
-                                          **extraargs)
+                                          eta=eta)
             else:
-                self.update(n_MG, deps_M, x, out_wxx, **extraargs)
+                self.update(n_MG, deps_M, x, out_wxx, eta=eta)
 
         # Sum over
         # Can this really be valid, if the original input out_wxx is nonzero?
         # This smells and should be investigated XXX
         # There could also be similar errors elsewhere... XXX
         self.kncomm.sum(out_wxx)
 
@@ -198,24 +188,20 @@
             else:
                 for out_xx in out_wxx:
                     out_xx[iu] = out_xx[il].conj()
 
         out_wxx *= prefactor
 
     @timer('CHI_0 update')
-    def update(self, n_mG, deps_m, wd, chi0_wGG, timeordered=False, eta=None):
+    def update(self, n_mG, deps_m, wd, chi0_wGG, eta):
         """Update chi."""
 
         deps_m += self.eshift * np.sign(deps_m)
-        if timeordered:
-            deps1_m = deps_m + 1j * eta * np.sign(deps_m)
-            deps2_m = deps1_m
-        else:
-            deps1_m = deps_m + 1j * eta
-            deps2_m = deps_m - 1j * eta
+        deps1_m = deps_m + 1j * eta
+        deps2_m = deps_m - 1j * eta
 
         blocks1d = self._blocks1d(chi0_wGG.shape[2])
 
         for omega, chi0_GG in zip(wd.omega_w, chi0_wGG):
             x_m = (1 / (omega + deps1_m) - 1 / (omega - deps2_m))
             if self.blockcomm.size > 1:
                 nx_mG = n_mG[:, blocks1d.myslice] * x_m[:, np.newaxis]
@@ -238,47 +224,14 @@
                 nx_mG = n_mG.conj() * x_m[:, np.newaxis]
                 rk(-1.0, nx_mG, 1.0, chi0_wGG[w], 'n')
             else:
                 x_m = np.abs(2 * deps_m / (omega.imag**2 + deps_m**2))
                 mynx_mG = n_mG[:, blocks1d.myslice] * x_m[:, np.newaxis]
                 mmm(-1.0, mynx_mG, 'T', n_mG.conj(), 'N', 1.0, chi0_wGG[w])
 
-    @timer('CHI_0 spectral function update (old)')
-    def update_hilbert_old(self, n_mG, deps_m, wd, chi0_wGG):
-        """Update spectral function.
-
-        Updates spectral function A_wGG and saves it to chi0_wGG for
-        later hilbert-transform."""
-
-        deps_m += self.eshift * np.sign(deps_m)
-        o_m = abs(deps_m)
-        w_m = wd.get_floor_index(o_m)
-
-        o1_m = wd.omega_w[w_m]
-        o2_m = wd.omega_w[w_m + 1]
-        p_m = np.abs(1 / (o2_m - o1_m)**2)
-        p1_m = p_m * (o2_m - o_m)
-        p2_m = p_m * (o_m - o1_m)
-
-        blocks1d = self._blocks1d(chi0_wGG.shape[2])
-
-        if self.blockcomm.size > 1:
-            for p1, p2, n_G, w in zip(p1_m, p2_m, n_mG, w_m):
-                if w + 1 < wd.wmax:  # The last frequency is not reliable
-                    myn_G = n_G[blocks1d.myslice].reshape((-1, 1))
-                    mmm(p1, myn_G, 'N', n_G.reshape((-1, 1)), 'C',
-                        1.0, chi0_wGG[w])
-                    mmm(p2, myn_G, 'N', n_G.reshape((-1, 1)), 'C',
-                        1.0, chi0_wGG[w + 1])
-        else:
-            for p1, p2, n_G, w in zip(p1_m, p2_m, n_mG, w_m):
-                if w + 1 < wd.wmax:  # The last frequency is not reliable
-                    czher(p1, n_G.conj(), chi0_wGG[w])
-                    czher(p2, n_G.conj(), chi0_wGG[w + 1])
-
     @timer('CHI_0 spectral function update (new)')
     def update_hilbert(self, n_mG, deps_m, wd, chi0_wGG):
         """Update spectral function.
 
         Updates spectral function A_wGG and saves it to chi0_wGG for
         later hilbert-transform."""
 
@@ -344,25 +297,18 @@
         """Add intraband contributions"""
 
         for vel_v in vel_mv:
             x_vv = np.outer(vel_v, vel_v)
             chi0_wvv[0] += x_vv
 
     @timer('CHI_0 optical limit update')
-    def update_optical_limit(self, n_mG, deps_m, wd, chi0_wxvG,
-                             timeordered=False, eta=None):
+    def update_optical_limit(self, n_mG, deps_m, wd, chi0_wxvG, eta):
         """Optical limit update of chi."""
-
-        if timeordered:
-            # avoid getting a zero from np.sign():
-            deps1_m = deps_m + 1j * eta * np.sign(deps_m + 1e-20)
-            deps2_m = deps1_m
-        else:
-            deps1_m = deps_m + 1j * eta
-            deps2_m = deps_m - 1j * eta
+        deps1_m = deps_m + 1j * eta
+        deps2_m = deps_m - 1j * eta
 
         for w, omega in enumerate(wd.omega_w):
             x_m = (1 / (omega + deps1_m) - 1 / (omega - deps2_m))
             chi0_wxvG[w, 0] += np.dot(x_m * n_mG[:, :3].T, n_mG.conj())
             chi0_wxvG[w, 1] += np.dot(x_m * n_mG[:, :3].T.conj(), n_mG)
 
     @timer('CHI_0 hermitian optical limit update')
@@ -376,16 +322,16 @@
     @timer('CHI_0 optical limit hilbert-update')
     def update_hilbert_optical_limit(self, n_mG, deps_m, wd, chi0_wxvG):
         """Optical limit update of chi-head and -wings."""
 
         for deps, n_G in zip(deps_m, n_mG):
             o = abs(deps)
             w = wd.get_floor_index(o)
-            if w + 2 > len(wd):
-                break
+            if w + 1 >= wd.wmax:
+                continue
             o1, o2 = wd.omega_w[w:w + 2]
             if o > o2:
                 continue
             else:
                 assert o1 <= o <= o2, (o1, o, o2)
 
             p = 1 / (o2 - o1)**2
@@ -401,17 +347,14 @@
 class TetrahedronIntegrator(Integrator):
     """Integrate brillouin zone using tetrahedron integration.
 
     Tetrahedron integration uses linear interpolation of
     the eigenenergies and of the matrix elements
     between the vertices of the tetrahedron."""
 
-    def __init__(self, *args, **kwargs):
-        Integrator.__init__(self, *args, **kwargs)
-
     @timer('Tesselate')
     def tesselate(self, vertices):
         """Get tesselation descriptor."""
         td = Delaunay(vertices)
 
         td.volumes_s = None
         return td
@@ -429,52 +372,50 @@
             volume = np.abs(np.linalg.det(k_kc[1:] - k_kc[0])) / 6.
             td.volumes_s[s] = volume
 
         return self.get_simplex_volume(td, S)
 
     def integrate(self, kind, *args, **kwargs):
         if kind == 'spectral function':
-            return self.spectral_function_integration(*args, **kwargs)
+            wings = False
+        elif kind == 'spectral function wings':
+            wings = True
         else:
-            raise ValueError("Expected kind='spectral function', got: ",
+            raise ValueError("Expected kind='spectral function'",
+                             "or 'spectral function wings', got: ",
                              kind)
 
+        return self.spectral_function_integration(*args,
+                                                  wings=wings,
+                                                  **kwargs)
+
     @timer('Spectral function integration')
-    def spectral_function_integration(self, domain=None, integrand=None,
-                                      x=None, kwargs=None, out_wxx=None):
+    def spectral_function_integration(self, wings=False,
+                                      *, domain, integrand,
+                                      x, out_wxx):
         """Integrate response function.
 
         Assume that the integral has the
         form of a response function. For the linear tetrahedron
         method it is possible calculate frequency dependent weights
         and do a point summation using these weights."""
 
-        if out_wxx is None:
-            raise NotImplementedError
-
+        wd = x  # XXX Rename.  But it clashes with some other methods
+        # that are **kwargs'ed somewhere, so requires attention.
         blocks1d = self._blocks1d(out_wxx.shape[2])
 
         # Input domain
         td = self.tesselate(domain[0])
         args = domain[1:]
-        get_matrix_element, get_eigenvalues = integrand
-
-        # The kwargs contain any constant
-        # arguments provided by the user
-        if kwargs is not None:
-            get_matrix_element = partial(get_matrix_element,
-                                         **kwargs[0])
-            get_eigenvalues = partial(get_eigenvalues,
-                                      **kwargs[1])
 
         # Relevant quantities
         bzk_kc = td.points
         nk = len(bzk_kc)
 
-        with self.timer('pts'):
+        with self.context.timer('pts'):
             # Point to simplex
             pts_k = [[] for n in range(nk)]
             for s, K_k in enumerate(td.simplices):
                 A_kv = np.append(td.points[K_k],
                                  np.ones(4)[:, np.newaxis], axis=1)
 
                 D_kv = np.append((A_kv[:, :-1]**2).sum(1)[:, np.newaxis],
@@ -487,94 +428,124 @@
                 for K in K_k:
                     pts_k[K].append(s)
 
             # Change to numpy arrays:
             for k in range(nk):
                 pts_k[k] = np.array(pts_k[k], int)
 
-        with self.timer('neighbours'):
+        with self.context.timer('neighbours'):
             # Nearest neighbours
             neighbours_k = [None for n in range(nk)]
 
             for k in range(nk):
                 neighbours_k[k] = np.unique(td.simplices[pts_k[k]])
 
         # Distribute everything
         myterms_t = self.distribute_domain(list(args) +
                                            [list(range(nk))])
 
-        with self.timer('eigenvalues'):
+        with self.context.timer('eigenvalues'):
             # Store eigenvalues
             deps_tMk = None  # t for term
             shape = [len(domain_l) for domain_l in args]
             nterms = int(np.prod(shape))
 
             for t in range(nterms):
                 if len(shape) == 0:
                     arguments = ()
                 else:
                     arguments = np.unravel_index(t, shape)
                 for K in range(nk):
                     k_c = bzk_kc[K]
-                    deps_M = -get_eigenvalues(k_c, *arguments)
+                    deps_M = -integrand.eigenvalues(k_c, *arguments)
                     if deps_tMk is None:
                         deps_tMk = np.zeros([nterms] +
                                             list(deps_M.shape) +
                                             [nk], float)
                     deps_tMk[t, :, K] = deps_M
 
         # Calculate integrations weight
-        pb = ProgressBar(self.fd)
+        pb = ProgressBar(self.context.fd)
         for _, arguments in pb.enumerate(myterms_t):
             K = arguments[-1]
             if len(shape) == 0:
                 t = 0
             else:
                 t = np.ravel_multi_index(arguments[:-1], shape)
             deps_Mk = deps_tMk[t]
             teteps_Mk = deps_Mk[:, neighbours_k[K]]
-            i0_M, i1_M = x.get_index_range(teteps_Mk.min(1), teteps_Mk.max(1))
-
-            n_MG = get_matrix_element(bzk_kc[K],
-                                      *arguments[:-1])
-            for n_G, deps_k, i0, i1 in zip(n_MG, deps_Mk,
-                                           i0_M, i1_M):
-                if i0 == i1:
-                    continue
+            n_MG = integrand.matrix_element(bzk_kc[K],
+                                            *arguments[:-1])
 
+            # Generate frequency weights
+            i0_M, i1_M = wd.get_index_range(
+                teteps_Mk.min(1), teteps_Mk.max(1))
+            W_Mw = []
+            for deps_k, i0, i1 in zip(deps_Mk, i0_M, i1_M):
                 W_w = self.get_kpoint_weight(K, deps_k,
-                                             pts_k, x.omega_w[i0:i1],
+                                             pts_k, wd.omega_w[i0:i1],
                                              td)
+                W_Mw.append(W_w)
 
-                for iw, weight in enumerate(W_w):
-                    if self.blockcomm.size > 1:
-                        myn_G = n_G[blocks1d.myslice].reshape((-1, 1))
-                        # gemm(weight, n_G.reshape((-1, 1)), myn_G,
-                        #      1.0, out_wxx[i0 + iw], 'c')
-                        mmm(weight, myn_G, 'N', n_G.reshape((-1, 1)), 'C',
-                            1.0, out_wxx[i0 + iw])
-                    else:
-                        czher(weight, n_G.conj(), out_wxx[i0 + iw])
+            if wings:
+                self.update_hilbert_optical_limit(n_MG, deps_Mk, W_Mw,
+                                                  i0_M, i1_M, out_wxx)
+            else:
+                self.update_hilbert(n_MG, deps_Mk, W_Mw, i0_M, i1_M,
+                                    out_wxx, blocks1d)
 
         self.kncomm.sum(out_wxx)
 
-        if self.blockcomm.size == 1:
+        if self.blockcomm.size == 1 and not wings:
             # Fill in upper/lower triangle also:
             nx = out_wxx.shape[1]
             il = np.tril_indices(nx, -1)
             iu = il[::-1]
             for out_xx in out_wxx:
                 out_xx[il] = out_xx[iu].conj()
 
+    def update_hilbert(self, n_MG, deps_Mk, W_Mw, i0_M, i1_M,
+                       out_wxx, blocks1d):
+        """Update output array with dissipative part."""
+        for n_G, deps_k, W_w, i0, i1 in zip(n_MG, deps_Mk, W_Mw,
+                                            i0_M, i1_M):
+            if i0 == i1:
+                continue
+
+            for iw, weight in enumerate(W_w):
+                if self.blockcomm.size > 1:
+                    myn_G = n_G[blocks1d.myslice].reshape((-1, 1))
+                    # gemm(weight, n_G.reshape((-1, 1)), myn_G,
+                    #      1.0, out_wxx[i0 + iw], 'c')
+                    mmm(weight, myn_G, 'N', n_G.reshape((-1, 1)), 'C',
+                        1.0, out_wxx[i0 + iw])
+                else:
+                    czher(weight, n_G.conj(), out_wxx[i0 + iw])
+
+    def update_hilbert_optical_limit(self, n_MG, deps_Mk, W_Mw,
+                                     i0_M, i1_M, out_wxvG):
+        """Update optical limit output array with dissipative part of the head
+        and wings."""
+        for n_G, deps_k, W_w, i0, i1 in zip(n_MG, deps_Mk, W_Mw,
+                                            i0_M, i1_M):
+            assert self.blockcomm.size == 1
+            if i0 == i1:
+                continue
+
+            for iw, weight in enumerate(W_w):
+                x_vG = np.outer(n_G[:3], n_G.conj())
+                out_wxvG[i0 + iw, 0, :, :] += weight * x_vG
+                out_wxvG[i0 + iw, 1, :, :] += weight * x_vG.conj()
+
     @timer('Get kpoint weight')
     def get_kpoint_weight(self, K, deps_k, pts_k,
                           omega_w, td):
         # Find appropriate index range
         simplices_s = pts_k[K]
         W_w = np.zeros(len(omega_w), float)
         vol_s = self.get_simplex_volume(td, simplices_s)
-        with self.timer('Tetrahedron weight'):
+        with self.context.timer('Tetrahedron weight'):
             _gpaw.tetrahedron_weight(deps_k, td.simplices, K,
                                      simplices_s,
                                      W_w, omega_w, vol_s)
 
         return W_w
```

### Comparing `gpaw-22.8.0/gpaw/response/kernels.py` & `gpaw-23.6.0/gpaw/response/coulomb_kernels.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,175 +1,139 @@
 """This module defines Coulomb and XC kernels for the response model.
 """
 
 import numpy as np
 from ase.dft import monkhorst_pack
+from gpaw.response.pair_functions import SingleQPWDescriptor
 
 
-def get_coulomb_kernel(pd, N_c, truncation=None, q_v=None, wstc=None):
+class CoulombKernel:
+    def __init__(self, truncation, gs):
+        self.truncation = truncation
+        assert self.truncation in {None, '0D', '2D'}
+        self._gs = gs
+
+    def description(self):
+        if self.truncation is None:
+            return 'No Coulomb truncation'
+        else:
+            return f'{self.truncation} Coulomb truncation'
+
+    def sqrtV(self, qpd, q_v):
+        return self.V(qpd, q_v)**0.5
+
+    def V(self, qpd, q_v):
+        assert isinstance(qpd, SingleQPWDescriptor)
+        return get_coulomb_kernel(
+            qpd, self._gs.kd.N_c, q_v=q_v,
+            truncation=self.truncation)
+
+    def integrated_kernel(self, qpd, reduced):
+        return get_integrated_kernel(
+            qpd=qpd, N_c=self._gs.kd.N_c,
+            truncation=self.truncation, reduced=reduced)
+
+
+def get_coulomb_kernel(qpd, N_c, truncation=None, q_v=None):
     """Factory function that calls the specified flavour
     of the Coulomb interaction"""
 
-    qG_Gv = pd.get_reciprocal_vectors(add_q=True)
+    qG_Gv = qpd.get_reciprocal_vectors(add_q=True)
     if q_v is not None:
-        assert pd.kd.gamma
+        assert qpd.kd.gamma
         qG_Gv += q_v
 
     if truncation is None:
-        if pd.kd.gamma and q_v is None:
-            v_G = np.zeros(len(pd.G2_qG[0]))
+        if qpd.kd.gamma and q_v is None:
+            v_G = np.zeros(len(qpd.G2_qG[0]))
             v_G[0] = 4 * np.pi
             v_G[1:] = 4 * np.pi / (qG_Gv[1:]**2).sum(axis=1)
         else:
             v_G = 4 * np.pi / (qG_Gv**2).sum(axis=1)
 
     elif truncation == '2D':
-        v_G = calculate_2D_truncated_coulomb(pd, q_v=q_v, N_c=N_c)
-        if pd.kd.gamma and q_v is None:
-            v_G[0] = 0.0
-
-    elif truncation == '1D':
-        v_G = calculate_1D_truncated_coulomb(pd, q_v=q_v, N_c=N_c)
-        if pd.kd.gamma and q_v is None:
+        v_G = calculate_2D_truncated_coulomb(qpd, q_v=q_v, N_c=N_c)
+        if qpd.kd.gamma and q_v is None:
             v_G[0] = 0.0
 
     elif truncation == '0D':
-        v_G = calculate_0D_truncated_coulomb(pd, q_v=q_v)
-        if pd.kd.gamma and q_v is None:
-            v_G[0] = 0.0
+        from gpaw.hybrids.wstc import WignerSeitzTruncatedCoulomb
+        wstc = WignerSeitzTruncatedCoulomb(qpd.gd.cell_cv, np.ones(3, int))
+        v_G = wstc.get_potential(qpd)
+
+    elif truncation in {'1D'}:
+        raise feature_removed()
 
-    elif truncation == 'wigner-seitz':
-        v_G = wstc.get_potential(pd, q_v=q_v)
-        if pd.kd.gamma and q_v is None:
-            v_G[0] = 0.0
     else:
         raise ValueError('Truncation scheme %s not implemented' % truncation)
 
     return v_G.astype(complex)
 
 
-def calculate_2D_truncated_coulomb(pd, q_v=None, N_c=None):
+def calculate_2D_truncated_coulomb(qpd, q_v=None, N_c=None):
     """ Simple 2D truncation of Coulomb kernel PRB 73, 205119.
     The non-periodic direction is determined from k-point grid.
     """
 
-    qG_Gv = pd.get_reciprocal_vectors(add_q=True)
-    if pd.kd.gamma:
+    qG_Gv = qpd.get_reciprocal_vectors(add_q=True)
+    if qpd.kd.gamma:
         if q_v is not None:
             qG_Gv += q_v
         else:  # only to avoid warning. Later set to zero in factory function
             qG_Gv[0] = [1., 1., 1.]
 
     # The non-periodic direction is determined from k-point grid
     Nn_c = np.where(N_c == 1)[0]
     Np_c = np.where(N_c != 1)[0]
     if len(Nn_c) != 1:
         # The k-point grid does not fit with boundary conditions
         Nn_c = [2]  # choose reduced cell vectors 0, 1
         Np_c = [0, 1]  # choose reduced cell vector 2
     # Truncation length is half of cell vector in non-periodic direction
-    R = pd.gd.cell_cv[Nn_c[0], Nn_c[0]] / 2.
+    R = qpd.gd.cell_cv[Nn_c[0], Nn_c[0]] / 2.
 
     qGp_G = ((qG_Gv[:, Np_c[0]])**2 + (qG_Gv[:, Np_c[1]]**2))**0.5
     qGn_G = qG_Gv[:, Nn_c[0]]
 
     v_G = 4 * np.pi / (qG_Gv**2).sum(axis=1)
-    if np.allclose(qGn_G[0], 0) or pd.kd.gamma:
+    if np.allclose(qGn_G[0], 0) or qpd.kd.gamma:
         """sin(qGn_G * R) = 0 when R = L/2 and q_n = 0.0"""
         v_G *= 1.0 - np.exp(-qGp_G * R) * np.cos(qGn_G * R)
     else:
         """Normal component of q is not zero"""
         a_G = qGn_G / qGp_G * np.sin(qGn_G * R) - np.cos(qGn_G * R)
         v_G *= 1. + np.exp(-qGp_G * R) * a_G
 
     return v_G.astype(complex)
 
 
-def calculate_1D_truncated_coulomb(pd, q_v=None, N_c=None):
-    """ Simple 1D truncation of Coulomb kernel PRB 73, 205119.
-    The periodic direction is determined from k-point grid.
-    """
-
-    from scipy.special import j1, k0, j0, k1
-
-    qG_Gv = pd.get_reciprocal_vectors(add_q=True)
-    if pd.kd.gamma:
-        if q_v is not None:
-            qG_Gv += q_v
-        else:
-            raise ValueError(
-                'Presently, calculations only work with a small q in the '
-                'normal direction')
-
-    # The periodic direction is determined from k-point grid
-    Nn_c = np.where(N_c == 1)[0]
-    Np_c = np.where(N_c != 1)[0]
-    if len(Nn_c) != 2:
-        # The k-point grid does not fit with boundary conditions
-        Nn_c = [0, 1]    # Choose reduced cell vectors 0, 1
-        Np_c = [2]       # Choose reduced cell vector 2
-    # The radius is determined from area of non-periodic part of cell
-    Acell_cv = pd.gd.cell_cv[Nn_c, :][:, Nn_c]
-    R = abs(np.linalg.det(Acell_cv) / np.pi)**0.5
-
-    qGnR_G = (qG_Gv[:, Nn_c[0]]**2 + qG_Gv[:, Nn_c[1]]**2)**0.5 * R
-    qGpR_G = abs(qG_Gv[:, Np_c[0]]) * R
-    v_G = 4 * np.pi / (qG_Gv**2).sum(axis=1)
-    v_G *= (1.0 + qGnR_G * j1(qGnR_G) * k0(qGpR_G)
-            - qGpR_G * j0(qGnR_G) * k1(qGpR_G))
-
-    return v_G.astype(complex)
-
-
-def calculate_0D_truncated_coulomb(pd, q_v=None):
-    """ Simple spherical truncation of the Coulomb interaction
-    PRB 73, 205119
-    """
-
-    qG_Gv = pd.get_reciprocal_vectors(add_q=True)
-    if pd.kd.gamma:
-        if q_v is not None:
-            qG_Gv += q_v
-        else:  # Only to avoid warning. Later set to zero in factory function
-            qG_Gv[0] = [1., 1., 1.]
-    # The radius is determined from volume of cell
-    R = (3 * pd.gd.volume / (4 * np.pi))**(1. / 3.)
-
-    qG2_G = (qG_Gv**2).sum(axis=1)
-
-    v_G = 4 * np.pi / qG2_G
-    v_G *= 1.0 - np.cos(qG2_G**0.5 * R)
-
-    return v_G
-
-
-def get_integrated_kernel(pd, N_c, truncation=None, N=100, reduced=False):
+def get_integrated_kernel(qpd, N_c, truncation=None, N=100, reduced=False):
     from scipy.special import j1, k0, j0, k1
 
-    B_cv = 2 * np.pi * pd.gd.icell_cv
+    B_cv = 2 * np.pi * qpd.gd.icell_cv
     Nf_c = np.array([N, N, N])
     if reduced:
         # Only integrate periodic directions if truncation is used
         Nf_c[np.where(N_c == 1)[0]] = 1
     q_qc = monkhorst_pack(Nf_c) / N_c
-    q_qc += pd.kd.ibzk_kc[0]
+    q_qc += qpd.q_c
     q_qv = np.dot(q_qc, B_cv)
 
     if truncation is None:
         V_q = 4 * np.pi / np.sum(q_qv**2, axis=1)
     elif truncation == '2D':
         # The non-periodic direction is determined from k-point grid
         Nn_c = np.where(N_c == 1)[0]
         Np_c = np.where(N_c != 1)[0]
         if len(Nn_c) != 1:
             # The k-point grid does not fit with boundary conditions
             Nn_c = [2]  # choose reduced cell vectors 0, 1
             Np_c = [0, 1]  # choose reduced cell vector 2
         # Truncation length is half of cell vector in non-periodic direction
-        R = pd.gd.cell_cv[Nn_c[0], Nn_c[0]] / 2.
+        R = qpd.gd.cell_cv[Nn_c[0], Nn_c[0]] / 2.
 
         qp_q = ((q_qv[:, Np_c[0]])**2 + (q_qv[:, Np_c[1]]**2))**0.5
         qn_q = q_qv[:, Nn_c[0]]
 
         V_q = 4 * np.pi / (q_qv**2).sum(axis=1)
         a_q = qn_q / qp_q * np.sin(qn_q * R) - np.cos(qn_q * R)
         V_q *= 1. + np.exp(-qp_q * R) * a_q
@@ -179,22 +143,30 @@
         Np_c = np.where(N_c != 1)[0]
 
         if len(Nn_c) != 2:
             # The k-point grid does not fit with boundary conditions
             Nn_c = [0, 1]    # Choose reduced cell vectors 0, 1
             Np_c = [2]       # Choose reduced cell vector 2
         # The radius is determined from area of non-periodic part of cell
-        Acell_cv = pd.gd.cell_cv[Nn_c, :][:, Nn_c]
+        Acell_cv = qpd.gd.cell_cv[Nn_c, :][:, Nn_c]
         R = abs(np.linalg.det(Acell_cv) / np.pi)**0.5
 
         qnR_q = (q_qv[:, Nn_c[0]]**2 + q_qv[:, Nn_c[1]]**2)**0.5 * R
         qpR_q = abs(q_qv[:, Np_c[0]]) * R
         V_q = 4 * np.pi / (q_qv**2).sum(axis=1)
         V_q *= (1.0 + qnR_q * j1(qnR_q) * k0(qpR_q)
                 - qpR_q * j0(qnR_q) * k1(qpR_q))
-    elif truncation == '0D' or 'wigner-seitz':
-        R = (3 * pd.gd.volume / (4 * np.pi))**(1. / 3.)
+    elif truncation == '0D':
+        R = (3 * qpd.gd.volume / (4 * np.pi))**(1. / 3.)
         q2_q = (q_qv**2).sum(axis=1)
         V_q = 4 * np.pi / q2_q
         V_q *= 1.0 - np.cos(q2_q**0.5 * R)
 
     return np.sum(V_q) / len(V_q), np.sum(V_q**0.5) / len(V_q)
+
+
+def feature_removed():
+    return RuntimeError(
+        '0D and 1D truncation have been removed due to not being tested.  '
+        'If you need them, please find them in '
+        'ec9e49e25613bb99cd69eec9d2613e38b9f6e6e1 '
+        'and make sure to add tests in order to have them re-added.')
```

### Comparing `gpaw-22.8.0/gpaw/response/kspair.py` & `gpaw-23.6.0/gpaw/response/kspair.py`

 * *Files 21% similar despite different names*

```diff
@@ -1,349 +1,240 @@
-from pathlib import Path
+from __future__ import annotations
 
 import numpy as np
 
-from gpaw.utilities import convert_string_to_fd
-from ase.utils.timing import Timer, timer
+from ase.utils import lazyproperty
 
-from gpaw import disable_dry_run
-from gpaw import GPAW
-import gpaw.mpi as mpi
-from gpaw.response.math_func import two_phi_planewave_integrals
+from gpaw.projections import Projections, serial_comm
+from gpaw.response import ResponseGroundStateAdapter, ResponseContext, timer
 from gpaw.response.symmetry import KPointFinder
-from gpaw.response.groundstate import ResponseGroundStateAdapter
+from gpaw.response.pw_parallelization import Blocks1D
 
 
-class KohnShamKPoint:
-    """Kohn-Sham orbital information for a given k-point."""
-    def __init__(self, n_t, s_t, K,
-                 eps_t, f_t, ut_tR, projections, shift_c):
-        """K-point data is indexed by a joint spin and band index h, which is
-        directly related to the transition index t."""
-        self.K = K                      # BZ k-point index
-        self.n_t = n_t                  # Band index
-        self.s_t = s_t                  # Spin index
-        self.eps_t = eps_t              # Eigenvalues
-        self.f_t = f_t                  # Occupation numbers
-        self.ut_tR = ut_tR              # Periodic part of wave functions
-        self.projections = projections  # PAW projections
+class IrreducibleKPoint:
+    """Irreducible k-point data pertaining to a certain set of transitions."""
 
-        self.shift_c = shift_c  # long story - see the
-        # PairDensity.construct_symmetry_operators() method
+    def __init__(self, ik, eps_h, f_h, Ph, psit_hG, h_myt):
+        """Construct the IrreducibleKPoint data object.
 
+        The data is indexed by the composite band and spin index h = (n, s),
+        which can be unfolded to the local transition index myt.
+        """
+        self.ik = ik             # Irreducible k-point index
+        self.eps_h = eps_h       # Eigenvalues
+        self.f_h = f_h           # Occupation numbers
+        self.Ph = Ph             # PAW projections
+        self.psit_hG = psit_hG   # Pseudo wave function plane-wave components
+        self.h_myt = h_myt       # myt -> h index mapping
+
+    @lazyproperty
+    def nh(self):
+        nh = len(self.eps_h)
+        assert len(self.f_h) == nh
+        assert self.Ph.nbands == nh
+        assert len(self.psit_hG) == nh
 
-class KohnShamKPointPair:
-    """Object containing all transitions between Kohn-Sham orbitals from a
-    specified k-point to another."""
-
-    def __init__(self, kpt1, kpt2, mynt, nt, ta, tb, comm=None):
-        self.kpt1 = kpt1
-        self.kpt2 = kpt2
-
-        self.mynt = mynt  # Number of transitions in this block
-        self.nt = nt      # Total number of transitions between all blocks
-        self.ta = ta      # First transition index of this block
-        self.tb = tb      # First transition index of this block not included
-        self.comm = comm  # MPI communicator between blocks of transitions
-
-    def transition_distribution(self):
-        """Get the distribution of transitions."""
-        return self.mynt, self.nt, self.ta, self.tb
+        return nh
 
-    def get_transitions(self):
-        return self.n1_t, self.n2_t, self.s1_t, self.s2_t
+    @property
+    def eps_myt(self):
+        return self.eps_h[self.h_myt]
 
-    def get_all(self, A_mytx):
-        """Get a certain data array with all transitions"""
-        if self.comm is None or A_mytx is None:
-            return A_mytx
+    @property
+    def f_myt(self):
+        return self.f_h[self.h_myt]
 
-        A_tx = np.empty((self.mynt * self.comm.size,) + A_mytx.shape[1:],
-                        dtype=A_mytx.dtype)
+    def projectors_in_transition_index(self, Ph):
+        Pmyt = Ph.new(nbands=len(self.h_myt), bcomm=None)
+        Pmyt.array[:] = Ph.array[self.h_myt]
+        return Pmyt
 
-        self.comm.all_gather(A_mytx, A_tx)
 
-        return A_tx[:self.nt]
+class KohnShamKPointPair:
+    """Data of pairs of Kohn-Sham orbital pertaining to transitions k -> k'."""
 
-    @property
-    def n1_t(self):
-        return self.get_all(self.kpt1.n_t)
+    def __init__(self, K1, K2, ikpt1, ikpt2, transitions, tblocks):
+        """Construct the KohnShamKPointPair from the k-point data of k and k'.
 
-    @property
-    def n2_t(self):
-        return self.get_all(self.kpt2.n_t)
+        K1, K2 : int, int
+            k-point indices of k and k'
+        ikpt1, ikpt2 : IrreducibleKPoint, IrreducibleKPoint
+            k-point data of the two specific k-points in the irreducible part
+            of the BZ which are related to K1 and K2 by symmetry respectively.
+        """
 
-    @property
-    def s1_t(self):
-        return self.get_all(self.kpt1.s_t)
+        self.K1 = K1
+        self.K2 = K2
+        self.ikpt1 = ikpt1
+        self.ikpt2 = ikpt2
+        self.transitions = transitions
+        self.tblocks = tblocks
 
-    @property
-    def s2_t(self):
-        return self.get_all(self.kpt2.s_t)
+    def get_all(self, in_mytx):
+        """Get a certain data array with all transitions"""
+        return self.tblocks.all_gather(in_mytx)
 
     @property
     def deps_t(self):
-        return self.get_all(self.kpt2.eps_t) - self.get_all(self.kpt1.eps_t)
+        return self.get_all(self.ikpt2.eps_myt) \
+            - self.get_all(self.ikpt1.eps_myt)
 
     @property
     def df_t(self):
-        return self.get_all(self.kpt2.f_t) - self.get_all(self.kpt1.f_t)
+        return self.get_all(self.ikpt2.f_myt) \
+            - self.get_all(self.ikpt1.f_myt)
 
-    @classmethod
-    def add_mytransitions_array(cls, _key, key):
-        """Add a A_tx data array class attribute.
-        Handles the fact, that the transitions are distributed in blocks.
 
-        Parameters
-        ----------
-        _key : str
-            attribute name for the A_mytx data array
-        key : str
-            attribute name for the A_tx data array
-        """
-        # In general, the data array has not been specified to instances of
-        # the class. As a result, set the _key to None
-        setattr(cls, _key, None)
-        # self.key should return full data array
-        setattr(cls, key,
-                property(lambda self: self.get_all(self.__dict__[_key])))
-
-    def attach(self, _key, key, A_mytx):
-        """Attach a data array to the k-point pair.
-        Used by PairMatrixElement to attach matrix elements calculated
-        between the k-points for the different transitions."""
-        self.add_mytransitions_array(_key, key)
-        setattr(self, _key, A_mytx)
-
-
-class KohnShamPair:
-    """Class for extracting pairs of Kohn-Sham orbitals from a ground
-    state calculation."""
+class KohnShamKPointPairExtractor:
+    """Functionality to extract KohnShamKPointPairs from a
+    ResponseGroundStateAdapter."""
 
-    def __init__(self, gs, world=mpi.world, transitionblockscomm=None,
-                 kptblockcomm=None, txt='-', timer=None):
+    def __init__(self, gs, context, *,
+                 transitions_blockcomm, kpts_blockcomm):
         """
         Parameters
         ----------
-        transitionblockscomm : gpaw.mpi.Communicator
-            Communicator for distributing the transitions among processes
-        kptblockcomm : gpaw.mpi.Communicator
-            Communicator for distributing k-points among processes
+        gs : ResponseGroundStateAdapter
+        context : ResponseContext
+        transitions_blockcomm : gpaw.mpi.Communicator
+            Communicator to distribute band and spin transitions
+        kpts_blockcomm : gpaw.mpi.Communicator
+            Communicator over which the k-point are distributed
         """
-        self.world = world
-        self.fd = convert_string_to_fd(txt, world)
-        self.timer = timer or Timer()
-        calc = get_calc(gs, fd=self.fd, timer=self.timer)
-        self.gs = ResponseGroundStateAdapter(calc)
+        assert isinstance(gs, ResponseGroundStateAdapter)
+        self.gs = gs
+        assert isinstance(context, ResponseContext)
+        self.context = context
+
         self.calc_parallel = self.check_calc_parallelisation()
 
-        self.transitionblockscomm = transitionblockscomm
-        self.kptblockcomm = kptblockcomm
+        self.transitions_blockcomm = transitions_blockcomm
+        self.kpts_blockcomm = kpts_blockcomm
 
         # Prepare to distribute transitions
-        self.mynt = None
-        self.nt = None
-        self.ta = None
-        self.tb = None
+        self.tblocks = None
 
         # Prepare to find k-point data from vector
         kd = self.gs.kd
         self.kptfinder = KPointFinder(kd.bzk_kc)
 
-        # Prepare to use other processes' k-points
-        self._pd0 = None
-
         # Prepare to redistribute kptdata
         self.rrequests = []
         self.srequests = []
 
         # Count bands so it is possible to remove null transitions
         self.nocc1 = None  # number of completely filled bands
         self.nocc2 = None  # number of non-empty bands
         self.count_occupied_bands()
 
     def check_calc_parallelisation(self):
         """Check how ground state calculation is distributed in memory"""
         if self.gs.world.size == 1:
             return False
         else:
-            assert self.world.rank == self.gs.world.rank
+            assert self.context.comm.rank == self.gs.world.rank
             assert self.gs.gd.comm.size == 1
             return True
 
     def count_occupied_bands(self):
         """Count number of occupied and unoccupied bands in ground state
         calculation. Can be used to omit null-transitions between two occupied
         bands or between two unoccupied bands."""
-        ftol = 1.e-9  # Could be given as input
-        nocc1 = 9999999
-        nocc2 = 0
-        for kpt in self.gs.kpt_u:
-            f_n = kpt.f_n / kpt.weight
-            nocc1 = min((f_n > 1 - ftol).sum(), nocc1)
-            nocc2 = max((f_n > ftol).sum(), nocc2)
+
+        nocc1, nocc2 = self.gs.count_occupied_bands(ftol=1e-9)
         nocc1 = int(nocc1)
         nocc2 = int(nocc2)
 
         # Collect nocc for all k-points
         nocc1 = self.gs.kd.comm.min(nocc1)
         nocc2 = self.gs.kd.comm.max(nocc2)
 
         # Sum over band distribution
         nocc1 = self.gs.bd.comm.sum(nocc1)
         nocc2 = self.gs.bd.comm.sum(nocc2)
 
         self.nocc1 = int(nocc1)
         self.nocc2 = int(nocc2)
-        print('Number of completely filled bands:', self.nocc1, file=self.fd)
-        print('Number of partially filled bands:', self.nocc2, file=self.fd)
-        print('Total number of bands:', self.gs.bd.nbands,
-              file=self.fd)
-
-    @property
-    def pd0(self):
-        """Get a PWDescriptor that includes all k-points"""
-        if self._pd0 is None:
-            from gpaw.pw.descriptor import PWDescriptor
-            gs = self.gs
-            assert gs.gd.comm.size == 1
-
-            kd0 = gs.kd.copy()
-            pd, gd = gs.pd, gs.gd
-
-            # Extract stuff from pd
-            ecut, dtype = pd.ecut, pd.dtype
-            fftwflags, gammacentered = pd.fftwflags, pd.gammacentered
-
-            # Initiate _pd0 with kd0
-            self._pd0 = PWDescriptor(ecut, gd, dtype=dtype,
-                                     kd=kd0, fftwflags=fftwflags,
-                                     gammacentered=gammacentered)
-        return self._pd0
+        self.context.print('Number of completely filled bands:',
+                           self.nocc1, flush=False)
+        self.context.print('Number of partially filled bands:',
+                           self.nocc2, flush=False)
+        self.context.print('Total number of bands:', self.gs.bd.nbands)
 
     @timer('Get Kohn-Sham pairs')
-    def get_kpoint_pairs(self, n1_t, n2_t, k1_pc, k2_pc, s1_t, s2_t):
-        """Get all pairs of Kohn-Sham orbitals for transitions:
+    def get_kpoint_pairs(self, k1_pc, k2_pc,
+                         transitions) -> KohnShamKPointPair | None:
+        """Get all pairs of Kohn-Sham orbitals for transitions k -> k'
+
         (n1_t, k1_p, s1_t) -> (n2_t, k2_p, s2_t)
-        Here, t is a composite band and spin transition index
-        and p is indexing the different k-points to be distributed."""
+
+        Here, t is a composite band and spin transition index accounted for by
+        the input PairTransitions object, whereas p indexes the k-point that
+        each rank of the k-point block communicator needs to extract."""
+        assert k1_pc.shape == k2_pc.shape
 
         # Distribute transitions and extract data for transitions in
         # this process' block
-        nt = len(n1_t)
-        assert nt == len(n2_t)
-        self.distribute_transitions(nt)
-
-        kpt1 = self.get_kpoints(k1_pc, n1_t, s1_t)
-        kpt2 = self.get_kpoints(k2_pc, n2_t, s2_t)
-
-        # The process might not have any k-point pairs to evaluate, as
-        # their are distributed in the kptblockcomm
-        if kpt1 is None:
-            assert kpt2 is None
+        self.tblocks = Blocks1D(self.transitions_blockcomm, len(transitions))
+
+        K1, ikpt1 = self.get_kpoints(k1_pc, transitions.n1_t, transitions.s1_t)
+        K2, ikpt2 = self.get_kpoints(k2_pc, transitions.n2_t, transitions.s2_t)
+
+        # The process might not have a Kohn-Sham k-point pair to return, due to
+        # the distribution over kpts_blockcomm
+        if self.kpts_blockcomm.rank not in range(len(k1_pc)):
             return None
-        assert kpt2 is not None
 
-        return KohnShamKPointPair(kpt1, kpt2,
-                                  self.mynt, nt, self.ta, self.tb,
-                                  comm=self.transitionblockscomm)
-
-    def distribute_transitions(self, nt):
-        """Distribute transitions between processes in block communicator"""
-        if self.transitionblockscomm is None:
-            mynt = nt
-            ta = 0
-            tb = nt
-        else:
-            nblocks = self.transitionblockscomm.size
-            rank = self.transitionblockscomm.rank
+        assert K1 is not None and ikpt1 is not None
+        assert K2 is not None and ikpt2 is not None
 
-            mynt = (nt + nblocks - 1) // nblocks
-            ta = min(rank * mynt, nt)
-            tb = min(ta + mynt, nt)
-
-        self.mynt = mynt
-        self.nt = nt
-        self.ta = ta
-        self.tb = tb
+        return KohnShamKPointPair(K1, K2, ikpt1, ikpt2,
+                                  transitions, self.tblocks)
 
     def get_kpoints(self, k_pc, n_t, s_t):
-        """Get KohnShamKPoint and help other processes extract theirs"""
+        """Get the process' own k-point data and help other processes
+        extracting theirs."""
         assert len(n_t) == len(s_t)
-        assert len(k_pc) <= self.kptblockcomm.size
-        kpt = None
+        assert len(k_pc) <= self.kpts_blockcomm.size
 
         # Use the data extraction factory to extract the kptdata
-        _extract_kptdata = self.create_extract_kptdata()
-        kptdata = _extract_kptdata(k_pc, n_t, s_t)
+        kptdata = self.extract_kptdata(k_pc, n_t, s_t)
+
+        if self.kpts_blockcomm.rank not in range(len(k_pc)):
+            return None, None  # The process has no data of its own
 
-        # Make local n and s arrays for the KohnShamKPoint object
-        n_myt = np.empty(self.mynt, dtype=n_t.dtype)
-        n_myt[:self.tb - self.ta] = n_t[self.ta:self.tb]
-        s_myt = np.empty(self.mynt, dtype=s_t.dtype)
-        s_myt[:self.tb - self.ta] = s_t[self.ta:self.tb]
-
-        # Initiate k-point object.
-        if self.kptblockcomm.rank in range(len(k_pc)):
-            assert kptdata is not None
-            kpt = KohnShamKPoint(n_myt, s_myt, *kptdata)
+        assert kptdata is not None
+        K = kptdata[0]
+        ikpt = IrreducibleKPoint(*kptdata[1:])
 
-        return kpt
+        return K, ikpt
 
-    def create_extract_kptdata(self):
-        """Creator component of the data extraction factory."""
+    @timer('Extracting data from the ground state calculator object')
+    def extract_kptdata(self, k_pc, n_t, s_t):
+        """Extract the input data needed to construct the IrreducibleKPoints.
+        """
         if self.calc_parallel:
-            return self.parallel_extract_kptdata
+            return self.parallel_extract_kptdata(k_pc, n_t, s_t)
         else:
-            return self.serial_extract_kptdata
+            return self.serial_extract_kptdata(k_pc, n_t, s_t)
             # Useful for debugging:
-            # return self.parallel_extract_kptdata
+            # return self.parallel_extract_kptdata(k_pc, n_t, s_t)
 
     def parallel_extract_kptdata(self, k_pc, n_t, s_t):
-        """Returns the input to KohnShamKPoint:
-        K, n_myt, s_myt, eps_myt, f_myt, ut_mytR, projections, shift_c
-        if a k-point in the given list, k_pc, belongs to the process.
-        """
-        # Extract the data from the ground state calculator object
-        data, h_myt, myt_myt = self._parallel_extract_kptdata(k_pc, n_t, s_t)
-
-        # If the process has a k-point to return, symmetrize and unfold
-        if self.kptblockcomm.rank in range(len(k_pc)):
-            assert data is not None
-            # Unpack data, apply FT and symmetrization
-            K, k_c, eps_h, f_h, Ph, psit_hG = data
-            Ph, ut_hR, shift_c = self.transform_and_symmetrize(K, k_c, Ph,
-                                                               psit_hG)
-
-            (eps_myt, f_myt,
-             P, ut_mytR) = self.unfold_arrays(eps_h, f_h, Ph, ut_hR,
-                                              h_myt, myt_myt)
-
-            data = (K, eps_myt, f_myt, ut_mytR, P, shift_c)
-
-        # Wait for communication to finish
-        with self.timer('Waiting to complete mpi.send'):
-            while self.srequests:
-                self.world.wait(self.srequests.pop(0))
-
-        return data
-
-    @timer('Extracting data from the ground state calculator object')
-    def _parallel_extract_kptdata(self, k_pc, n_t, s_t):
-        """In-place kptdata extraction."""
-        (data, myu_eu,
+        """Extract the k-point data from a parallelized calculator."""
+        (myK, myik, myu_eu,
          myn_eueh, ik_r2,
          nrh_r2, eh_eur2reh,
          rh_eur2reh, h_r1rh,
-         h_myt, myt_myt) = self.get_extraction_protocol(k_pc, n_t, s_t)
+         h_myt) = self.get_parallel_extraction_protocol(k_pc, n_t, s_t)
 
         (eps_r1rh, f_r1rh,
          P_r1rhI, psit_r1rhG,
          eps_r2rh, f_r2rh,
-         P_r2rhI, psit_r2rhG) = self.allocate_transfer_arrays(data, nrh_r2,
+         P_r2rhI, psit_r2rhG) = self.allocate_transfer_arrays(myik, nrh_r2,
                                                               ik_r2, h_r1rh)
 
         # Do actual extraction
         for myu, myn_eh, eh_r2reh, rh_r2reh in zip(myu_eu, myn_eueh,
                                                    eh_eur2reh, rh_eur2reh):
 
             eps_eh, f_eh, P_ehI = self.extract_wfs_data(myu, myn_eh)
@@ -358,61 +249,68 @@
             # for one band index at a time, handle them seperately
             self.add_wave_function(myu, myn_eh, eh_r2reh,
                                    rh_r2reh, psit_r2rhG)
 
         self.distribute_extracted_data(eps_r1rh, f_r1rh, P_r1rhI, psit_r1rhG,
                                        eps_r2rh, f_r2rh, P_r2rhI, psit_r2rhG)
 
-        data = self.collect_kptdata(data, h_r1rh, eps_r1rh,
-                                    f_r1rh, P_r1rhI, psit_r1rhG)
+        # Some processes may not have to return a k-point
+        if myik is None:
+            data = None
+        else:
+            eps_h, f_h, Ph, psit_hG = self.collect_kptdata(
+                myik, h_r1rh, eps_r1rh, f_r1rh, P_r1rhI, psit_r1rhG)
+            data = myK, myik, eps_h, f_h, Ph, psit_hG, h_myt
+
+        # Wait for communication to finish
+        with self.context.timer('Waiting to complete mpi.send'):
+            while self.srequests:
+                self.context.comm.wait(self.srequests.pop(0))
 
-        return data, h_myt, myt_myt
+        return data
 
     @timer('Create data extraction protocol')
-    def get_extraction_protocol(self, k_pc, n_t, s_t):
-        """Figure out how to extract data efficiently.
-        For the serial communicator, all processes can access all data,
-        and resultantly, there is no need to send any data.
-        """
+    def get_parallel_extraction_protocol(self, k_pc, n_t, s_t):
+        """Figure out how to extract data efficiently in parallel."""
+        comm = self.context.comm
         get_extraction_info = self.create_get_extraction_info()
 
-        # Kpoint data
-        data = (None, None, None)
+        # (K, ik) for each process
+        mykpt = (None, None)
 
         # Extraction protocol
         myu_eu = []
         myn_eueh = []
 
         # Data distribution protocol
-        nrh_r2 = np.zeros(self.world.size, dtype=int)
-        ik_r2 = [None for _ in range(self.world.size)]
+        nrh_r2 = np.zeros(comm.size, dtype=int)
+        ik_r2 = [None for _ in range(comm.size)]
         eh_eur2reh = []
         rh_eur2reh = []
-        h_r1rh = [list([]) for _ in range(self.world.size)]
+        h_r1rh = [list([]) for _ in range(comm.size)]
 
         # h to t index mapping
-        myt_myt = np.arange(self.tb - self.ta)
-        t_myt = range(self.ta, self.tb)
+        t_myt = self.tblocks.myslice
         n_myt, s_myt = n_t[t_myt], s_t[t_myt]
-        h_myt = np.empty(self.tb - self.ta, dtype=int)
+        h_myt = np.empty(self.tblocks.nlocal, dtype=int)
 
         nt = len(n_t)
         assert nt == len(s_t)
         t_t = np.arange(nt)
         nh = 0
         for p, k_c in enumerate(k_pc):  # p indicates the receiving process
             K = self.kptfinder.find(k_c)
             ik = self.gs.kd.bz2ibz_k[K]
-            for r2 in range(p * self.transitionblockscomm.size,
-                            min((p + 1) * self.transitionblockscomm.size,
-                                self.world.size)):
+            for r2 in range(p * self.tblocks.blockcomm.size,
+                            min((p + 1) * self.tblocks.blockcomm.size,
+                                comm.size)):
                 ik_r2[r2] = ik
 
-            if p == self.kptblockcomm.rank:
-                data = (K, k_c, ik)
+            if p == self.kpts_blockcomm.rank:
+                mykpt = (K, ik)
 
             # Find out who should store the data in KSKPpoint
             r2_t, myt_t = self.map_who_has(p, t_t)
 
             # Find out how to extract data
             # In the ground state, kpts are indexed by u=(s, k)
             for s in set(s_t):
@@ -424,20 +322,20 @@
 
                 # Find out where data is in GS
                 u = ik * self.gs.nspins + s
                 myu, r1_ct, myn_ct = get_extraction_info(u, n_ct, r2_ct)
 
                 # If the process is extracting or receiving data,
                 # figure out how to do so
-                if self.world.rank in np.append(r1_ct, r2_ct):
+                if comm.rank in np.append(r1_ct, r2_ct):
                     # Does this process have anything to send?
-                    thisr1_ct = r1_ct == self.world.rank
+                    thisr1_ct = r1_ct == comm.rank
                     if np.any(thisr1_ct):
-                        eh_r2reh = [list([]) for _ in range(self.world.size)]
-                        rh_r2reh = [list([]) for _ in range(self.world.size)]
+                        eh_r2reh = [list([]) for _ in range(comm.size)]
+                        rh_r2reh = [list([]) for _ in range(comm.size)]
                         # Find composite indeces h = (n, s)
                         n_et = n_ct[thisr1_ct]
                         n_eh = np.unique(n_et)
                         # Find composite local band indeces
                         myn_eh = np.unique(myn_ct[thisr1_ct])
 
                         # Where to send the data
@@ -457,15 +355,15 @@
 
                         myu_eu.append(myu)
                         myn_eueh.append(myn_eh)
                         eh_eur2reh.append(eh_r2reh)
                         rh_eur2reh.append(rh_r2reh)
 
                     # Does this process have anything to receive?
-                    thisr2_ct = r2_ct == self.world.rank
+                    thisr2_ct = r2_ct == comm.rank
                     if np.any(thisr2_ct):
                         # Find unique composite indeces h = (n, s)
                         n_rt = n_ct[thisr2_ct]
                         n_rn = np.unique(n_rt)
                         nrn = len(n_rn)
                         h_rn = np.arange(nrn) + nh
                         nh += nrn
@@ -483,16 +381,16 @@
 
                                 # h to t mapping
                                 thisn_myt = n_myt == n
                                 thish_myt = np.logical_and(thisn_myt,
                                                            thiss_myt)
                                 h_myt[thish_myt] = h
 
-        return (data, myu_eu, myn_eueh, ik_r2, nrh_r2,
-                eh_eur2reh, rh_eur2reh, h_r1rh, h_myt, myt_myt)
+        return (*mykpt, myu_eu, myn_eueh, ik_r2, nrh_r2,
+                eh_eur2reh, rh_eur2reh, h_r1rh, h_myt)
 
     def create_get_extraction_info(self):
         """Creator component of the extraction information factory."""
         if self.calc_parallel:
             return self.get_parallel_extraction_info
         else:
             return self.get_serial_extraction_info
@@ -523,28 +421,27 @@
                   + bandrank * gs.gd.comm.size)
             r1_ct.append(r1)
             myn_ct.append(myn)
 
         return myu, np.array(r1_ct), np.array(myn_ct)
 
     @timer('Allocate transfer arrays')
-    def allocate_transfer_arrays(self, data, nrh_r2, ik_r2, h_r1rh):
+    def allocate_transfer_arrays(self, myik, nrh_r2, ik_r2, h_r1rh):
         """Allocate arrays for intermediate storage of data."""
         kptex = self.gs.kpt_u[0]
         Pshape = kptex.projections.array.shape
         Pdtype = kptex.projections.matrix.dtype
         psitdtype = kptex.psit.array.dtype
 
         # Number of h-indeces to receive
         nrh_r1 = [len(h_rh) for h_rh in h_r1rh]
 
-        # if self.kptblockcomm.rank in range(len(ik_p)):
-        if data[2] is not None:
-            ik = data[2]
-            ng = self.pd0.ng_q[ik]
+        # if self.kpts_blockcomm.rank in range(len(ik_p)):
+        if myik is not None:
+            ng = self.gs.global_pd.ng_q[myik]
             eps_r1rh, f_r1rh, P_r1rhI, psit_r1rhG = [], [], [], []
             for nrh in nrh_r1:
                 if nrh >= 1:
                     eps_r1rh.append(np.empty(nrh))
                     f_r1rh.append(np.empty(nrh))
                     P_r1rhI.append(np.empty((nrh,) + Pshape[1:], dtype=Pdtype))
                     psit_r1rhG.append(np.empty((nrh, ng), dtype=psitdtype))
@@ -558,30 +455,30 @@
 
         eps_r2rh, f_r2rh, P_r2rhI, psit_r2rhG = [], [], [], []
         for nrh, ik in zip(nrh_r2, ik_r2):
             if nrh:
                 eps_r2rh.append(np.empty(nrh))
                 f_r2rh.append(np.empty(nrh))
                 P_r2rhI.append(np.empty((nrh,) + Pshape[1:], dtype=Pdtype))
-                ng = self.pd0.ng_q[ik]
+                ng = self.gs.global_pd.ng_q[ik]
                 psit_r2rhG.append(np.empty((nrh, ng), dtype=psitdtype))
             else:
                 eps_r2rh.append(None)
                 f_r2rh.append(None)
                 P_r2rhI.append(None)
                 psit_r2rhG.append(None)
 
         return (eps_r1rh, f_r1rh, P_r1rhI, psit_r1rhG,
                 eps_r2rh, f_r2rh, P_r2rhI, psit_r2rhG)
 
     def map_who_has(self, p, t_t):
         """Convert k-point and transition index to global world rank
         and local transition index"""
-        trank_t, myt_t = np.divmod(t_t, self.mynt)
-        return p * self.transitionblockscomm.size + trank_t, myt_t
+        trank_t, myt_t = np.divmod(t_t, self.tblocks.blocksize)
+        return p * self.tblocks.blockcomm.size + trank_t, myt_t
 
     @timer('Extracting eps, f and P_I from wfs')
     def extract_wfs_data(self, myu, myn_eh):
         kpt = self.gs.kpt_u[myu]
         # Get eig and occ
         eps_eh, f_eh = kpt.eps_n[myn_eh], kpt.f_n[myn_eh] / kpt.weight
 
@@ -603,191 +500,148 @@
                 for eh, rh in zip(eh_reh, rh_reh):
                     psit_rhG[rh] = kpt.psit_nG[myn_eh[eh]]
 
     @timer('Distributing kptdata')
     def distribute_extracted_data(self, eps_r1rh, f_r1rh, P_r1rhI, psit_r1rhG,
                                   eps_r2rh, f_r2rh, P_r2rhI, psit_r2rhG):
         """Send the extracted data to appropriate destinations"""
+        comm = self.context.comm
         # Store the data extracted by the process itself
-        rank = self.world.rank
+        rank = comm.rank
         # Check if there is actually some data to store
         if eps_r2rh[rank] is not None:
             eps_r1rh[rank] = eps_r2rh[rank]
             f_r1rh[rank] = f_r2rh[rank]
             P_r1rhI[rank] = P_r2rhI[rank]
             psit_r1rhG[rank] = psit_r2rhG[rank]
 
         # Receive data
         if eps_r1rh is not None:  # The process may not be receiving anything
             for r1, (eps_rh, f_rh,
                      P_rhI, psit_rhG) in enumerate(zip(eps_r1rh, f_r1rh,
                                                        P_r1rhI, psit_r1rhG)):
                 # Check if there is any data to receive
                 if r1 != rank and eps_rh is not None:
-                    rreq1 = self.world.receive(eps_rh, r1,
-                                               tag=201, block=False)
-                    rreq2 = self.world.receive(f_rh, r1,
-                                               tag=202, block=False)
-                    rreq3 = self.world.receive(P_rhI, r1,
-                                               tag=203, block=False)
-                    rreq4 = self.world.receive(psit_rhG, r1,
-                                               tag=204, block=False)
+                    rreq1 = comm.receive(eps_rh, r1, tag=201, block=False)
+                    rreq2 = comm.receive(f_rh, r1, tag=202, block=False)
+                    rreq3 = comm.receive(P_rhI, r1, tag=203, block=False)
+                    rreq4 = comm.receive(psit_rhG, r1, tag=204, block=False)
                     self.rrequests += [rreq1, rreq2, rreq3, rreq4]
 
         # Send data
         for r2, (eps_rh, f_rh,
                  P_rhI, psit_rhG) in enumerate(zip(eps_r2rh, f_r2rh,
                                                    P_r2rhI, psit_r2rhG)):
             # Check if there is any data to send
             if r2 != rank and eps_rh is not None:
-                sreq1 = self.world.send(eps_rh, r2, tag=201, block=False)
-                sreq2 = self.world.send(f_rh, r2, tag=202, block=False)
-                sreq3 = self.world.send(P_rhI, r2, tag=203, block=False)
-                sreq4 = self.world.send(psit_rhG, r2, tag=204, block=False)
+                sreq1 = comm.send(eps_rh, r2, tag=201, block=False)
+                sreq2 = comm.send(f_rh, r2, tag=202, block=False)
+                sreq3 = comm.send(P_rhI, r2, tag=203, block=False)
+                sreq4 = comm.send(psit_rhG, r2, tag=204, block=False)
                 self.srequests += [sreq1, sreq2, sreq3, sreq4]
 
-        with self.timer('Waiting to complete mpi.receive'):
+        with self.context.timer('Waiting to complete mpi.receive'):
             while self.rrequests:
-                self.world.wait(self.rrequests.pop(0))
+                comm.wait(self.rrequests.pop(0))
 
     @timer('Collecting kptdata')
-    def collect_kptdata(self, data, h_r1rh,
+    def collect_kptdata(self, myik, h_r1rh,
                         eps_r1rh, f_r1rh, P_r1rhI, psit_r1rhG):
-        """From the extracted data, collect the KohnShamKPoint data arrays"""
-
-        # Some processes may not have to return a k-point
-        if data[0] is None:
-            return None
-        K, k_c, ik = data
-
+        """From the extracted data, collect the IrreducibleKPoint data arrays
+        """
+        kpt0 = self.gs.kpt_u[0]
         # Allocate data arrays
         maxh_r1 = [max(h_rh) for h_rh in h_r1rh if h_rh]
         if maxh_r1:
             nh = max(maxh_r1) + 1
+            Ph = kpt0.projections.new(nbands=nh, bcomm=None)
         else:  # Carry around empty array
-            assert self.ta == self.tb
-            nh = 1
+            assert self.tblocks.a == self.tblocks.b
+            nh = 0
+            # We have to initialize the projections by hand, because
+            # Projections.new() interprets nbands == 0 to imply that it should
+            # inherit the preexisting number of bands...
+            proj = kpt0.projections
+            Ph = Projections(nh, proj.nproj_a, proj.atom_partition,
+                             serial_comm, proj.collinear, proj.spin,
+                             proj.matrix.dtype)
         eps_h = np.empty(nh)
         f_h = np.empty(nh)
-        kpt0 = self.gs.kpt_u[0]
-        Ph = kpt0.projections.new(nbands=nh, bcomm=None)
         assert self.gs.dtype == kpt0.psit.array.dtype
-        psit_hG = np.empty((nh, self.pd0.ng_q[ik]), self.gs.dtype)
+        psit_hG = np.empty((nh, self.gs.global_pd.ng_q[myik]), self.gs.dtype)
 
         # Store extracted data in the arrays
         for (h_rh, eps_rh,
              f_rh, P_rhI, psit_rhG) in zip(h_r1rh, eps_r1rh,
                                            f_r1rh, P_r1rhI, psit_r1rhG):
             if h_rh:
                 eps_h[h_rh] = eps_rh
                 f_h[h_rh] = f_rh
                 Ph.array[h_rh] = P_rhI
                 psit_hG[h_rh] = psit_rhG
 
-        return (K, k_c, eps_h, f_h, Ph, psit_hG)
-
-    @timer('Unfolding arrays')
-    def unfold_arrays(self, eps_h, f_h, Ph, ut_hR, h_myt, myt_myt):
-        """Create transition data arrays from the composite h = (n, s) index"""
+        return eps_h, f_h, Ph, psit_hG
 
-        gs = self.gs
-        # Allocate data arrays for the k-point
-        mynt = self.mynt
-        eps_myt = np.empty(mynt)
-        f_myt = np.empty(mynt)
-        P = gs.kpt_u[0].projections.new(nbands=mynt, bcomm=None)
-        ut_mytR = gs.gd.empty(self.mynt, gs.dtype)
-
-        # Unfold k-point data
-        eps_myt[myt_myt] = eps_h[h_myt]
-        f_myt[myt_myt] = f_h[h_myt]
-        P.array[myt_myt] = Ph.array[h_myt]
-        ut_mytR[myt_myt] = ut_hR[h_myt]
+    def serial_extract_kptdata(self, k_pc, n_t, s_t):
+        """Extract the k-point data from a serial calculator.
 
-        return eps_myt, f_myt, P, ut_mytR
+        Since all the processes can access all of the data, each process
+        extracts the data of its own k-point without any need for
+        communication."""
+        if self.kpts_blockcomm.rank not in range(len(k_pc)):
+            # No data to extract
+            return None
 
-    @timer('Extracting data from the ground state calculator object')
-    def serial_extract_kptdata(self, k_pc, n_t, s_t):
-        # All processes can access all data. Each process extracts it own data.
         gs = self.gs
         kpt_u = gs.kpt_u
 
-        # Do data extraction for the processes, which have data to extract
-        if self.kptblockcomm.rank in range(len(k_pc)):
-            # Find k-point indeces
-            k_c = k_pc[self.kptblockcomm.rank]
-            K = self.kptfinder.find(k_c)
-            ik = gs.kd.bz2ibz_k[K]
-            # Construct symmetry operators
-            (_, T, a_a, U_aii, shift_c,
-             time_reversal) = self.construct_symmetry_operators(K, k_c=k_c)
-
-            (myu_eu, myn_eurn, nh, h_eurn, h_myt,
-             myt_myt) = self.get_serial_extraction_protocol(ik, n_t, s_t)
-
-            # Allocate transfer arrays
-            eps_h = np.empty(nh)
-            f_h = np.empty(nh)
-            Ph = kpt_u[0].projections.new(nbands=nh, bcomm=None)
-            ut_hR = gs.gd.empty(nh, gs.dtype)
-
-            # Extract data from the ground state
-            for myu, myn_rn, h_rn in zip(myu_eu, myn_eurn, h_eurn):
-                kpt = kpt_u[myu]
-                with self.timer('Extracting eps, f and P_I from GS'):
-                    eps_h[h_rn] = kpt.eps_n[myn_rn]
-                    f_h[h_rn] = kpt.f_n[myn_rn] / kpt.weight
-                    Ph.array[h_rn] = kpt.projections.array[myn_rn]
-
-                with self.timer('Extracting, fourier transforming and '
-                                'symmetrizing wave function'):
-                    for myn, h in zip(myn_rn, h_rn):
-                        ut_hR[h] = T(gs.pd.ifft(kpt.psit_nG[myn], kpt.q))
-
-            # Symmetrize projections
-            with self.timer('Apply symmetry operations'):
-                P_ahi = []
-                for a1, U_ii in zip(a_a, U_aii):
-                    P_hi = np.ascontiguousarray(Ph[a1])
-                    # Apply symmetry operations. This will map a1 onto a2
-                    np.dot(P_hi, U_ii, out=P_hi)
-                    if time_reversal:
-                        np.conj(P_hi, out=P_hi)
-                    P_ahi.append(P_hi)
-
-                # Store symmetrized projectors
-                for a2, P_hi in enumerate(P_ahi):
-                    I1, I2 = Ph.map[a2]
-                    Ph.array[..., I1:I2] = P_hi
-
-            (eps_myt, f_myt,
-             P, ut_mytR) = self.unfold_arrays(eps_h, f_h, Ph, ut_hR,
-                                              h_myt, myt_myt)
+        # Find k-point indeces
+        k_c = k_pc[self.kpts_blockcomm.rank]
+        K = self.kptfinder.find(k_c)
+        ik = gs.kd.bz2ibz_k[K]
+
+        (myu_eu, myn_eurn, nh,
+         h_eurn, h_myt) = self.get_serial_extraction_protocol(ik, n_t, s_t)
+
+        # Allocate transfer arrays
+        eps_h = np.empty(nh)
+        f_h = np.empty(nh)
+        Ph = kpt_u[0].projections.new(nbands=nh, bcomm=None)
+        psit_hG = np.empty((nh, gs.pd.ng_q[ik]),
+                           dtype=kpt_u[0].psit.array.dtype)
+
+        # Extract data from the ground state
+        for myu, myn_rn, h_rn in zip(myu_eu, myn_eurn, h_eurn):
+            kpt = kpt_u[myu]
+            with self.context.timer('Extracting eps, f and P_I from wfs'):
+                eps_h[h_rn] = kpt.eps_n[myn_rn]
+                f_h[h_rn] = kpt.f_n[myn_rn] / kpt.weight
+                Ph.array[h_rn] = kpt.projections.array[myn_rn]
+
+            with self.context.timer('Extracting wave function from wfs'):
+                for myn, h in zip(myn_rn, h_rn):
+                    psit_hG[h] = kpt.psit_nG[myn]
 
-            return (K, eps_myt, f_myt, ut_mytR, P, shift_c)
+        return K, ik, eps_h, f_h, Ph, psit_hG, h_myt
 
     @timer('Create data extraction protocol')
     def get_serial_extraction_protocol(self, ik, n_t, s_t):
-        """Figure out how to extract data efficiently.
-        For the serial communicator, all processes can access all data,
-        and resultantly, there is no need to send any data.
-        """
+        """Figure out how to extract data efficiently in serial."""
 
         # Only extract the transitions handled by the process itself
-        myt_myt = np.arange(self.tb - self.ta)
-        t_myt = range(self.ta, self.tb)
+        t_myt = self.tblocks.myslice
         n_myt = n_t[t_myt]
         s_myt = s_t[t_myt]
 
         # In the ground state, kpts are indexed by u=(s, k)
         myu_eu = []
         myn_eurn = []
         nh = 0
         h_eurn = []
-        h_myt = np.empty(self.tb - self.ta, dtype=int)
+        h_myt = np.empty(self.tblocks.nlocal, dtype=int)
         for s in set(s_myt):
             thiss_myt = s_myt == s
             n_ct = n_myt[thiss_myt]
 
             # Find unique composite h = (n, u) indeces
             n_rn = np.unique(n_ct)
             nrn = len(n_rn)
@@ -805,208 +659,8 @@
             # The process has access to all data
             myu = u
             myn_rn = n_rn
 
             myu_eu.append(myu)
             myn_eurn.append(myn_rn)
 
-        return myu_eu, myn_eurn, nh, h_eurn, h_myt, myt_myt
-
-    @timer('Apply symmetry operations')
-    def transform_and_symmetrize(self, K, k_c, Ph, psit_hG):
-        """Get wave function on a real space grid and symmetrize it
-        along with the corresponding PAW projections."""
-        (_, T, a_a, U_aii, shift_c,
-         time_reversal) = self.construct_symmetry_operators(K, k_c=k_c)
-
-        # Symmetrize wave functions
-        gs = self.gs
-        ik = gs.kd.bz2ibz_k[K]
-        ut_hR = gs.gd.empty(len(psit_hG), gs.dtype)
-        with self.timer('Fourier transform and symmetrize wave functions'):
-            for h, psit_G in enumerate(psit_hG):
-                ut_hR[h] = T(self.pd0.ifft(psit_G, ik))
-
-        # Symmetrize projections
-        P_ahi = []
-        for a1, U_ii in zip(a_a, U_aii):
-            P_hi = np.ascontiguousarray(Ph[a1])
-            # Apply symmetry operations. This will map a1 onto a2
-            np.dot(P_hi, U_ii, out=P_hi)
-            if time_reversal:
-                np.conj(P_hi, out=P_hi)
-            P_ahi.append(P_hi)
-
-        # Store symmetrized projectors
-        for a2, P_hi in enumerate(P_ahi):
-            I1, I2 = Ph.map[a2]
-            Ph.array[..., I1:I2] = P_hi
-
-        return Ph, ut_hR, shift_c
-
-    @timer('Construct symmetry operators')
-    def construct_symmetry_operators(self, K, k_c=None):
-        from gpaw.response.symmetry_ops import construct_symmetry_operators
-        return construct_symmetry_operators(
-            self.gs, K, k_c, apply_strange_shift=True)
-
-
-def get_calc(gs, fd=None, timer=None):
-    """Get ground state calculation object."""
-    if not isinstance(gs, (str, Path)):
-        return gs
-    else:
-        if timer is None:
-            def timer(*unused):
-                def __enter__(self):
-                    pass
-
-                def __exit__(self):
-                    pass
-
-        with timer('Read ground state'):
-            assert Path(gs).is_file()
-            if fd is not None:
-                print('Reading ground state calculation:\n  %s' % gs,
-                      file=fd)
-            with disable_dry_run():
-                return GPAW(gs, txt=None, communicator=mpi.serial_comm)
-
-
-class PairMatrixElement:
-    """Class for calculating matrix elements for transitions in Kohn-Sham
-    linear response functions."""
-    def __init__(self, kspair):
-        """
-        Parameters
-        ----------
-        kslrf : KohnShamLinearResponseFunction instance
-        """
-        self.gs = kspair.gs
-        self.fd = kspair.fd
-        self.timer = kspair.timer
-        self.transitionblockscomm = kspair.transitionblockscomm
-
-    def initialize(self, *args, **kwargs):
-        """Initialize e.g. PAW corrections or other operations
-        ahead in time of integration."""
-        pass
-
-    def __call__(self, kskptpair, *args, **kwargs):
-        """Calculate the matrix element for all transitions in kskptpairs."""
-        raise NotImplementedError('Define specific matrix element')
-
-
-class PlaneWavePairDensity(PairMatrixElement):
-    """Class for calculating pair densities
-
-    n_kt(G+q) = n_nks,n'k+qs'(G+q) = <nks| e^-i(G+q)r |n'k+qs'>_V0
-
-    for a single k-point pair (k,k+q) in the plane wave mode"""
-    def __init__(self, kspair):
-        PairMatrixElement.__init__(self, kspair)
-
-        # Save PAW correction for all calls with same q_c
-        self.Q_aGii = None
-        self.currentq_c = None
-
-    def initialize(self, pd):
-        """Initialize PAW corrections ahead in time of integration."""
-        self.initialize_paw_corrections(pd)
-
-    @timer('Initialize PAW corrections')
-    def initialize_paw_corrections(self, pd):
-        """Initialize PAW corrections, if not done already, for the given q"""
-        q_c = pd.kd.bzk_kc[0]
-        if self.Q_aGii is None or not np.allclose(q_c - self.currentq_c, 0.):
-            self.Q_aGii = self._initialize_paw_corrections(pd)
-            self.currentq_c = q_c
-
-    def _initialize_paw_corrections(self, pd):
-        spos_ac = self.gs.spos_ac
-        setups = self.gs.setups
-        G_Gv = pd.get_reciprocal_vectors()
-
-        pos_av = np.dot(spos_ac, pd.gd.cell_cv)
-
-        # Collect integrals for all species:
-        Q_xGii = {}
-        for id, atomdata in setups.setups.items():
-            Q_Gii = two_phi_planewave_integrals(G_Gv, atomdata)
-            ni = atomdata.ni
-            Q_Gii.shape = (-1, ni, ni)
-
-            Q_xGii[id] = Q_Gii
-
-        Q_aGii = []
-        for a, atomdata in enumerate(setups):
-            id = setups.id_a[a]
-            Q_Gii = Q_xGii[id]
-            x_G = np.exp(-1j * np.dot(G_Gv, pos_av[a]))
-            Q_aGii.append(x_G[:, np.newaxis, np.newaxis] * Q_Gii)
-
-        return Q_aGii
-
-    @timer('Calculate pair density')
-    def __call__(self, kskptpair, pd):
-        """Calculate the pair densities for all transitions t of the (k,k+q)
-        k-point pair:
-
-        n_kt(G+q) = <nks| e^-i(G+q)r |n'k+qs'>_V0
-
-                    /
-                  = | dr e^-i(G+q)r psi_nks^*(r) psi_n'k+qs'(r)
-                    /V0
-        """
-        Q_aGii = self.get_paw_projectors(pd)
-        Q_G = self.get_fft_indices(kskptpair, pd)
-        mynt, nt, ta, tb = kskptpair.transition_distribution()
-
-        n_mytG = pd.empty(mynt)
-
-        # Calculate smooth part of the pair densities:
-        with self.timer('Calculate smooth part'):
-            ut1cc_mytR = kskptpair.kpt1.ut_tR.conj()
-            n_mytR = ut1cc_mytR * kskptpair.kpt2.ut_tR
-            # Unvectorized
-            for myt in range(tb - ta):
-                n_mytG[myt] = pd.fft(n_mytR[myt], 0, Q_G) * pd.gd.dv
-
-        # Calculate PAW corrections with numpy
-        with self.timer('PAW corrections'):
-            P1 = kskptpair.kpt1.projections
-            P2 = kskptpair.kpt2.projections
-            for (Q_Gii, (a1, P1_myti),
-                 (a2, P2_myti)) in zip(Q_aGii, P1.items(), P2.items()):
-                P1cc_myti = P1_myti[:tb - ta].conj()
-                C1_Gimyt = np.tensordot(Q_Gii, P1cc_myti, axes=([1, 1]))
-                P2_imyt = P2_myti.T[:, :tb - ta]
-                n_mytG[:tb - ta] += np.sum(C1_Gimyt * P2_imyt[np.newaxis,
-                                                              :, :], axis=1).T
-
-        # Attach the calculated pair density to the KohnShamKPointPair object
-        kskptpair.attach('n_mytG', 'n_tG', n_mytG)
-
-    def get_paw_projectors(self, pd):
-        """Make sure PAW correction has been initialized properly
-        and return projectors"""
-        self.initialize_paw_corrections(pd)
-        return self.Q_aGii
-
-    @timer('Get G-vector indices')
-    def get_fft_indices(self, kskptpair, pd):
-        """Get indices for G-vectors inside cutoff sphere."""
-        kpt1 = kskptpair.kpt1
-        kpt2 = kskptpair.kpt2
-        kd = self.gs.kd
-        q_c = pd.kd.bzk_kc[0]
-
-        N_G = pd.Q_qG[0]
-
-        shift_c = kpt1.shift_c - kpt2.shift_c
-        shift_c += (q_c - kd.bzk_kc[kpt2.K]
-                    + kd.bzk_kc[kpt1.K]).round().astype(int)
-        if shift_c.any():
-            n_cG = np.unravel_index(N_G, pd.gd.N_c)
-            n_cG = [n_G + shift for n_G, shift in zip(n_cG, shift_c)]
-            N_G = np.ravel_multi_index(n_cG, pd.gd.N_c, 'wrap')
-        return N_G
+        return myu_eu, myn_eurn, nh, h_eurn, h_myt
```

### Comparing `gpaw-22.8.0/gpaw/response/pair.py` & `gpaw-23.6.0/gpaw/xas.py`

 * *Files 21% similar despite different names*

```diff
@@ -1,687 +1,662 @@
-import numbers
+import pickle
+from math import log, pi
 
 import numpy as np
+from gpaw.overlap import Overlap
+from ase.units import Hartree
+from gpaw.utilities.cg import CG
+import gpaw.mpi as mpi
 
-from ase.utils.timing import timer
 
-import gpaw.mpi as mpi
-from gpaw.fd_operators import Gradient
-from gpaw.response.pw_parallelization import block_partition
-from gpaw.response.symmetry import KPointFinder
-from gpaw.response.context import calc_and_context
-from gpaw.utilities.blas import mmm
-
-
-class KPoint:
-    def __init__(self, s, K, n1, n2, blocksize, na, nb,
-                 ut_nR, eps_n, f_n, P_ani, shift_c):
-        self.s = s    # spin index
-        self.K = K    # BZ k-point index
-        self.n1 = n1  # first band
-        self.n2 = n2  # first band not included
-        self.blocksize = blocksize
-        self.na = na  # first band of block
-        self.nb = nb  # first band of block not included
-        self.ut_nR = ut_nR      # periodic part of wave functions in real-space
-        self.eps_n = eps_n      # eigenvalues
-        self.f_n = f_n          # occupation numbers
-        self.P_ani = P_ani      # PAW projections
-        self.shift_c = shift_c  # long story - see the
-        # PairDensity.construct_symmetry_operators() method
-
-
-class PairDistribution:
-    def __init__(self, pair, mysKn1n2):
-        self.pair = pair
-        self.mysKn1n2 = mysKn1n2
-        self.mykpts = [self.pair.get_k_point(s, K, n1, n2)
-                       for s, K, n1, n2 in self.mysKn1n2]
-
-    def kpt_pairs_by_q(self, q_c, m1, m2):
-        pair = self.pair
-        mykpts = self.mykpts
-        for u, kpt1 in enumerate(mykpts):
-            progress = u / len(mykpts)
-            K2 = pair.kd.find_k_plus_q(q_c, [kpt1.K])[0]
-            kpt2 = pair.get_k_point(kpt1.s, K2, m1, m2, block=True)
-
-            yield progress, kpt1, kpt2
-
-
-class KPointPair:
-    """This class defines the kpoint-pair container object.
-
-    Used for calculating pair quantities it contains two kpoints,
-    and an associated set of Fourier components."""
-    def __init__(self, kpt1, kpt2, Q_G):
-        self.kpt1 = kpt1
-        self.kpt2 = kpt2
-        self.Q_G = Q_G
-
-    def get_k1(self):
-        """ Return KPoint object 1."""
-        return self.kpt1
-
-    def get_k2(self):
-        """ Return KPoint object 2."""
-        return self.kpt2
-
-    def get_planewave_indices(self):
-        """ Return the planewave indices associated with this pair."""
-        return self.Q_G
-
-    def get_transition_energies(self, n_n, m_m):
-        """Return the energy difference for specified bands."""
-        n_n = np.array(n_n)
-        m_m = np.array(m_m)
-        kpt1 = self.kpt1
-        kpt2 = self.kpt2
-        deps_nm = (kpt1.eps_n[n_n - self.kpt1.n1][:, np.newaxis] -
-                   kpt2.eps_n[m_m - self.kpt2.n1])
-        return deps_nm
-
-    def get_occupation_differences(self, n_n, m_m):
-        """Get difference in occupation factor between specified bands."""
-        n_n = np.array(n_n)
-        m_m = np.array(m_m)
-        kpt1 = self.kpt1
-        kpt2 = self.kpt2
-        df_nm = (kpt1.f_n[n_n - self.kpt1.n1][:, np.newaxis] -
-                 kpt2.f_n[m_m - self.kpt2.n1])
-        return df_nm
-
-
-class NoCalculatorPairDensity:
-    def __init__(self, gs, *, context, ftol=1e-6,
-                 threshold=1, real_space_derivatives=False, nblocks=1):
-        self.gs = gs
-        self.context = context
-
-        self.fd = context.fd
-        self.timer = context.timer
-        self.world = context.world
-
-        assert self.gs.kd.symmetry.symmorphic
-
-        self.ftol = ftol
-        self.threshold = threshold
-        self.real_space_derivatives = real_space_derivatives
-
-        self.blockcomm, self.kncomm = block_partition(context.world, nblocks)
-        self.nblocks = nblocks
-
-        self.fermi_level = self.gs.fermi_level
-        self.spos_ac = self.gs.spos_ac
-
-        self.nocc1 = None  # number of completely filled bands
-        self.nocc2 = None  # number of non-empty bands
-        self.count_occupied_bands()
-
-        self.ut_sKnvR = None  # gradient of wave functions for optical limit
-
-        self.vol = self.gs.gd.volume
-
-        self.kd = self.gs.kd
-        self.kptfinder = KPointFinder(self.kd.bzk_kc)
-        print('Number of blocks:', nblocks, file=self.fd)
-
-    def find_kpoint(self, k_c):
-        return self.kptfinder.find(k_c)
-
-    def count_occupied_bands(self):
-        self.nocc1 = 9999999
-        self.nocc2 = 0
-        for kpt in self.gs.kpt_u:
-            f_n = kpt.f_n / kpt.weight
-            self.nocc1 = min((f_n > 1 - self.ftol).sum(), self.nocc1)
-            self.nocc2 = max((f_n > self.ftol).sum(), self.nocc2)
-        print('Number of completely filled bands:', self.nocc1, file=self.fd)
-        print('Number of non-empty bands:', self.nocc2, file=self.fd)
-        print('Total number of bands:', self.gs.bd.nbands,
-              file=self.fd)
+class XAS:
+    def __init__(self, paw, mode='xas', center=None, spin=0):
+        wfs = paw.wfs
+        self.orthogonal = wfs.gd.orthogonal
+        self.cell_cv = np.array(wfs.gd.cell_cv)
+        assert wfs.world.size == 1  # assert not mpi.parallel
+        # assert wfs.gd.orthogonal
+
+        # to allow spin polarized calclulation
+        nkpts = len(wfs.kd.ibzk_kc)
+
+        # the following lines are to stop the user to make mistakes
+        # if mode is not 'xes' and spin == 1:
+        #     raise RuntimeError(
+        #         'The core hole is always in spin 0: please use spin=0')
+
+        if wfs.nspins == 1:
+            if spin != 0:
+                raise RuntimeError(
+                    'use spin=0 for a spin paired calculation')
+            nocc = wfs.setups.nvalence // 2
+            self.list_kpts = range(nkpts)
+        else:
+            self.list_kpts = []
 
-    def distribute_k_points_and_bands(self, band1, band2, kpts=None):
-        """Distribute spins, k-points and bands.
+            if spin != 0 and spin != 1:
+                print('spin', spin)
+                raise RuntimeError(
+                    'use either spin=0 or spin=1')
+
+            # find kpoints with correct spin
+            for i, kpt in enumerate(wfs.kpt_u):
+                if kpt.s == spin:
+                    self.list_kpts.append(i)
+                print(self.list_kpts)
+            assert len(self.list_kpts) == nkpts
+
+            # find number of occupied orbitals, if no fermi smearing
+            nocc = 0.0
+            for i in self.list_kpts:
+                nocc += sum(wfs.kpt_u[i].f_n)
+            nocc = int(nocc + 0.5)
+            print('nocc', nocc)
+
+        # look for the center with the corehole
+        if center is not None:
+            setup = wfs.setups[center]
+            a = center
+        else:
+            for a, setup in enumerate(wfs.setups):
+                if setup.phicorehole_g is not None:
+                    break
+
+        A_ci = setup.A_ci
+
+        # xas, xes or all modes
+        if mode == 'xas':
+            n_start = nocc
+            n_end = wfs.bd.nbands
+            n = wfs.bd.nbands - nocc
+        elif mode == 'xes':
+            n_start = 0
+            n_end = nocc
+            n = nocc
+        elif mode == 'all':
+            n_start = 0
+            n_end = wfs.bd.nbands
+            n = wfs.bd.nbands
+        else:
+            raise RuntimeError(
+                "wrong keyword for 'mode', use 'xas', 'xes' or 'all'")
 
-        The attribute self.mysKn1n2 will be set to a list of (s, K, n1, n2)
-        tuples that this process handles.
-        """
+        self.n = n
 
-        gs = self.gs
+        self.eps_n = np.empty(nkpts * n)
+        self.sigma_cn = np.empty((3, nkpts * n), complex)
+        n1 = 0
+        for kpt in wfs.kpt_u:
+            if kpt.s != spin:
+                continue
+
+            n2 = n1 + n
+            self.eps_n[n1:n2] = kpt.eps_n[n_start:n_end] * Hartree
+            P_ni = kpt.P_ani[a][n_start:n_end]
+            a_cn = np.inner(A_ci, P_ni)
+            weight = kpt.weight * wfs.nspins / 2
+            print('weight', weight)
+            print(a_cn.shape, self.sigma_cn.shape)
+            self.sigma_cn[:, n1:n2] = weight**0.5 * a_cn  # .real
+            n1 = n2
+
+        self.symmetry = wfs.kd.symmetry
+
+    def get_spectra(self, fwhm=0.5, E_in=None, linbroad=None,
+                    N=1000, kpoint=None,
+                    proj=None, proj_xyz=True, stick=False):
+        """Calculate spectra.
+
+        Parameters:
+
+        fwhm:
+          the full width half maximum in eV for gaussian broadening
+        linbroad:
+          a list of three numbers, the first fwhm2, the second the value
+          where the linear increase starts and the third the value where
+          the broadening has reached fwhm2. example [0.5, 540, 550]
+        E_in:
+          a list of energy values where the spectrum is to be computed
+          if None the orbital energies will be used to compute the energy
+          range
+        N:
+          the number of bins in the broadened spectrum. If E_in is given N
+          has no effect
+        kpoint:
+          select a specific k-point to calculate spectrum for
+        proj:
+          a list of vectors to project the transition dipole on. Default
+          is None then only x,y,z components are calculated.  a_stick and
+          a_c squares of the transition moments in resp. direction
+        proj_xyz:
+          if True keep projections in x, y and z. a_stck and a_c will have
+          length 3 + len(proj). if False only those projections
+          defined by proj keyword, a_stick and a_c will have length len(proj)
+        stick:
+          if False return broadened spectrum, if True return stick spectrum
+
+        Symmtrization has been moved inside get_spectra because we want to
+        symmtrice squares of transition dipoles."""
+
+        # eps_n = self.eps_n[k_in*self.n: (k_in+1)*self.n -1]
+
+        # proj keyword, check normalization of incoming vectors
+        if proj_xyz:
+            proj_3 = np.array([[1, 0, 0], [0, 1, 0], [0, 0, 1]], float)
+        else:
+            proj_3 = np.array([], float)
 
-        if kpts is None:
-            kpts = np.arange(gs.kd.nbzkpts)
+        if proj is not None:
+            assert self.orthogonal
+            proj_2 = np.array(proj, float)
+            if len(proj_2.shape) == 1:
+                proj_2 = np.array([proj], float)
+
+            for i, p in enumerate(proj_2):
+                if sum(p ** 2) ** 0.5 != 1.0:
+                    print('proj_2 %s not normalized' % i)
+                    proj_2[i] /= sum(p ** 2) ** 0.5
+
+            proj_tmp = np.zeros((proj_3.shape[0] + proj_2.shape[0], 3), float)
+
+            for i, p in enumerate(proj_3):
+                proj_tmp[i, :] = proj_3[i, :]
+
+            for i, p in enumerate(proj_2):
+                proj_tmp[proj_3.shape[0] + i, :] = proj_2[i, :]
+
+            proj_3 = proj_tmp.copy()
+
+        # now symmetrize
+        sigma2_cn = np.zeros((proj_3.shape[0], self.sigma_cn.shape[1]), float)
+
+        if self.symmetry is not None:
+            for i, p in enumerate(proj_3):
+                for op_cc in self.symmetry.op_scc:
+                    op_vv = np.dot(np.linalg.inv(self.cell_cv),
+                                   np.dot(op_cc, self.cell_cv))
+                    s_tmp = np.dot(p, np.dot(op_vv, self.sigma_cn))
+                    sigma2_cn[i, :] += (s_tmp * np.conjugate(s_tmp)).real
+            sigma2_cn /= len(self.symmetry.op_scc)
 
-        # nbands is the number of bands for each spin/k-point combination.
-        nbands = band2 - band1
-        size = self.kncomm.size
-        rank = self.kncomm.rank
-        ns = gs.nspins
-        nk = len(kpts)
-        n = (ns * nk * nbands + size - 1) // size
-        i1 = min(rank * n, ns * nk * nbands)
-        i2 = min(i1 + n, ns * nk * nbands)
-
-        mysKn1n2 = []
-        i = 0
-        for s in range(ns):
-            for K in kpts:
-                n1 = min(max(0, i1 - i), nbands)
-                n2 = min(max(0, i2 - i), nbands)
-                if n1 != n2:
-                    mysKn1n2.append((s, K, n1 + band1, n2 + band1))
-                i += nbands
-
-        print('BZ k-points:', gs.kd, file=self.fd)
-        print('Distributing spins, k-points and bands (%d x %d x %d)' %
-              (ns, nk, nbands),
-              'over %d process%s' %
-              (self.kncomm.size, ['es', ''][self.kncomm.size == 1]),
-              file=self.fd)
-        print('Number of blocks:', self.blockcomm.size, file=self.fd)
-
-        return PairDistribution(self, mysKn1n2)
-
-    @timer('Get a k-point')
-    def get_k_point(self, s, k_c, n1, n2, load_wfs=True, block=False):
-        """Return wave functions for a specific k-point and spin.
-
-        s: int
-            Spin index (0 or 1).
-        K: int
-            BZ k-point index.
-        n1, n2: int
-            Range of bands to include.
-        """
+        else:
+            for i, p in enumerate(proj_3):
+                s_tmp = np.dot(p, self.sigma_cn)
+                sigma2_cn[i, :] += (s_tmp * np.conjugate(s_tmp)).real
+
+        eps_n = self.eps_n[:]
+
+        if kpoint is not None:
+            eps_start = kpoint * self.n
+            eps_end = (kpoint + 1) * self.n
+        else:
+            eps_start = 0
+            eps_end = len(self.eps_n)
 
-        assert n1 <= n2
+        # return stick spectrum if stick=True
+        if stick:
+            e_stick = eps_n[eps_start:eps_end]
+            a_stick = sigma2_cn[:, eps_start:eps_end]
 
-        gs = self.gs
-        kd = gs.kd
+            return e_stick, a_stick
 
-        # Parse kpoint: is k_c an index or a vector
-        if not isinstance(k_c, numbers.Integral):
-            K = self.kptfinder.find(k_c)
-            shift0_c = (kd.bzk_kc[K] - k_c).round().astype(int)
-        else:
-            # Fall back to index
-            K = k_c
-            shift0_c = np.array([0, 0, 0])
-            k_c = None
-
-        if block:
-            nblocks = self.blockcomm.size
-            rank = self.blockcomm.rank
-        else:
-            nblocks = 1
-            rank = 0
-
-        blocksize = (n2 - n1 + nblocks - 1) // nblocks
-        na = min(n1 + rank * blocksize, n2)
-        nb = min(na + blocksize, n2)
-
-        U_cc, T, a_a, U_aii, shift_c, time_reversal = \
-            self.construct_symmetry_operators(K, k_c=k_c)
-
-        shift_c += -shift0_c
-        ik = kd.bz2ibz_k[K]
-        assert kd.comm.size == 1
-        kpt = gs.kpt_qs[ik][s]
-
-        assert n2 <= len(kpt.eps_n), \
-            'Increase GS-nbands or decrease chi0-nbands!'
-        eps_n = kpt.eps_n[n1:n2]
-        f_n = kpt.f_n[n1:n2] / kpt.weight
-
-        if not load_wfs:
-            return KPoint(s, K, n1, n2, blocksize, na, nb,
-                          None, eps_n, f_n, None, shift_c)
-
-        with self.timer('load wfs'):
-            psit_nG = kpt.psit_nG
-            ut_nR = gs.gd.empty(nb - na, gs.dtype)
-            for n in range(na, nb):
-                ut_nR[n - na] = T(gs.pd.ifft(psit_nG[n], ik))
-
-        with self.timer('Load projections'):
-            P_ani = []
-            for b, U_ii in zip(a_a, U_aii):
-                P_ni = np.dot(kpt.P_ani[b][na:nb], U_ii)
-                if time_reversal:
-                    P_ni = P_ni.conj()
-                P_ani.append(P_ni)
-
-        return KPoint(s, K, n1, n2, blocksize, na, nb,
-                      ut_nR, eps_n, f_n, P_ani, shift_c)
-
-    @timer('Get kpoint pair')
-    def get_kpoint_pair(self, pd, s, Kork_c, n1, n2, m1, m2,
-                        load_wfs=True, block=False):
-        assert m1 <= m2
-        assert n1 <= n2
-
-        if isinstance(Kork_c, int):
-            # If k_c is an integer then it refers to
-            # the index of the kpoint in the BZ
-            k_c = self.gs.kd.bzk_kc[Kork_c]
-        else:
-            k_c = Kork_c
-
-        q_c = pd.kd.bzk_kc[0]
-        with self.timer('get k-points'):
-            kpt1 = self.get_k_point(s, k_c, n1, n2, load_wfs=load_wfs)
-            # K2 = wfs.kd.find_k_plus_q(q_c, [kpt1.K])[0]
-            kpt2 = self.get_k_point(s, k_c + q_c, m1, m2,
-                                    load_wfs=load_wfs, block=block)
-
-        with self.timer('fft indices'):
-            Q_G = self.get_fft_indices(kpt1.K, kpt2.K, q_c, pd,
-                                       kpt1.shift_c - kpt2.shift_c)
-
-        return KPointPair(kpt1, kpt2, Q_G)
-
-    @timer('get_pair_density')
-    def get_pair_density(self, pd, kptpair, n_n, m_m,
-                         optical_limit=False, intraband=False,
-                         Q_aGii=None, block=False, direction=2,
-                         extend_head=True):
-        """Get pair density for a kpoint pair."""
-        ol = optical_limit = np.allclose(pd.kd.bzk_kc[0], 0.0)
-        eh = extend_head
-        cpd = self.calculate_pair_densities  # General pair densities
-        opd = self.optical_pair_density  # Interband pair densities / q
-
-        if Q_aGii is None:
-            Q_aGii = self.initialize_paw_corrections(pd)
-
-        kpt1 = kptpair.kpt1
-        kpt2 = kptpair.kpt2
-        Q_G = kptpair.Q_G  # Fourier components of kpoint pair
-        nG = len(Q_G)
-
-        if extend_head:
-            n_nmG = np.zeros((len(n_n), len(m_m), nG + 2 * ol), pd.dtype)
-        else:
-            n_nmG = np.zeros((len(n_n), len(m_m), nG), pd.dtype)
-
-        for j, n in enumerate(n_n):
-            Q_G = kptpair.Q_G
-            with self.timer('conj'):
-                ut1cc_R = kpt1.ut_nR[n - kpt1.na].conj()
-            with self.timer('paw'):
-                C1_aGi = [np.dot(Q_Gii, P1_ni[n - kpt1.na].conj())
-                          for Q_Gii, P1_ni in zip(Q_aGii, kpt1.P_ani)]
-                n_nmG[j, :, 2 * ol * eh:] = cpd(ut1cc_R, C1_aGi, kpt2, pd, Q_G,
-                                                block=block)
-            if optical_limit:
-                if extend_head:
-                    n_nmG[j, :, 0:3] = opd(n, m_m, kpt1, kpt2,
-                                           block=block)
+        # else return broadened spectrum
+        else:
+            if E_in is not None:
+                e = np.array(E_in)
+            else:
+                emin = min(eps_n) - 2 * fwhm
+                emax = max(eps_n) + 2 * fwhm
+                e = emin + np.arange(N + 1) * ((emax - emin) / N)
+
+            a_c = np.zeros((len(sigma2_cn), len(e)))
+
+            if linbroad is None:
+                # constant broadening fwhm
+                alpha = 4 * log(2) / fwhm**2
+
+                for n, eps in enumerate(eps_n[eps_start:eps_end]):
+                    x = -alpha * (e - eps)**2
+                    x = np.clip(x, -100.0, 100.0)
+                    a_c += np.outer(sigma2_cn[:, n + eps_start],
+                                    (alpha / pi)**0.5 * np.exp(x))
+            else:
+
+                # constant broadening fwhm until linbroad[1] and a
+                # constant broadening over linbroad[2] with fwhm2=
+                # linbroad[0]
+                fwhm2 = linbroad[0]
+                lin_e1 = linbroad[1]
+                lin_e2 = linbroad[2]
+                print('fwhm', fwhm, fwhm2, lin_e1, lin_e2)
+                for n, eps in enumerate(eps_n):
+                    if eps < lin_e1:
+                        alpha = 4 * log(2) / fwhm**2
+                    elif eps <= lin_e2:
+                        fwhm_lin = (fwhm + (eps - lin_e1) *
+                                    (fwhm2 - fwhm) / (lin_e2 - lin_e1))
+                        alpha = 4 * log(2) / fwhm_lin**2
+                    elif eps >= lin_e2:
+                        alpha = 4 * log(2) / fwhm2**2
+
+                    x = -alpha * (e - eps)**2
+                    x = np.clip(x, -100.0, 100.0)
+                    a_c += np.outer(sigma2_cn[:, n],
+                                    (alpha / pi)**0.5 * np.exp(x))
+
+            return e, a_c
+
+
+class RecursionMethod:
+    """This class implements the Haydock recursion method. """
+
+    def __init__(self, paw=None, filename=None,
+                 tol=1e-10, maxiter=100, proj=None,
+                 proj_xyz=True):
+
+        if paw is not None:
+            wfs = paw.wfs
+            assert wfs.gd.orthogonal
+
+            self.wfs = wfs
+            self.hamiltonian = paw.hamiltonian
+            self.nkpts = len(wfs.kd.ibzk_kc) * wfs.nspins
+            self.nmykpts = len(wfs.kpt_u)
+
+            self.k1 = wfs.kd.comm.rank * self.nmykpts
+            self.k2 = self.k1 + self.nmykpts
+
+            print('k1', self.k1, 'k2', self.k2)
+
+            # put spin and weight index in the columns corresponding
+            # to this processors k-points
+            self.spin_k = np.zeros(self.nkpts, int)
+            self.weight_k = np.zeros(self.nkpts)
+
+            for n, i in enumerate(range(self.k1, self.k2)):
+                self.spin_k[i] = wfs.kpt_u[n].s
+                self.weight_k[i] = wfs.kpt_u[n].weight
+
+            self.op_scc = None
+            if wfs.kd.symmetry is not None:
+                self.op_scc = wfs.kd.symmetry.op_scc
+        else:
+            self.k1 = 0
+            self.k2 = None
+            self.wfs = None
+            wfs = None
+
+        self.tol = tol
+        self.maxiter = maxiter
+
+        if filename is not None:
+            self.read(filename)
+            if wfs is not None:
+                self.allocate_tmp_arrays()
+        else:
+            self.initialize_start_vector(proj=proj, proj_xyz=proj_xyz)
+
+    def read(self, filename):
+        with open(filename, 'rb') as fd:
+            data = pickle.load(fd)
+        self.nkpts = data['nkpts']
+        if 'swaps' in data:
+            # This is an old file:
+            self.op_scc = np.array([np.identity(3, int)[list(swap)]
+                                    for swap in data['swaps']])
+        else:
+            self.op_scc = data['symmetry operations']
+        self.weight_k = data['weight_k']
+        self.spin_k = data['spin_k']
+        self.dim = data['dim']
+        k1, k2 = self.k1, self.k2
+        if k2 is None:
+            k2 = self.nkpts
+        a_kci, b_kci = data['ab']
+        self.a_uci = a_kci[k1:k2].copy()
+        self.b_uci = b_kci[k1:k2].copy()
+
+        if self.wfs is not None and 'arrays' in data:
+            print('reading arrays')
+            w_kcG, wold_kcG, y_kcG = data['arrays']
+            i = [slice(k1, k2), slice(0, self.dim)] + self.wfs.gd.get_slice()
+            self.w_ucG = w_kcG[i].copy()
+            self.wold_ucG = wold_kcG[i].copy()
+            self.y_ucG = y_kcG[i].copy()
+
+    def write(self, filename, mode=''):
+        assert self.wfs is not None
+        kpt_comm = self.wfs.kd.comm
+        gd = self.wfs.gd
+
+        if gd.comm.rank == 0:
+            if kpt_comm.rank == 0:
+                nmyu, dim, ni = self.a_uci.shape
+                a_kci = np.empty((kpt_comm.size, nmyu, dim, ni),
+                                 self.wfs.dtype)
+                b_kci = np.empty((kpt_comm.size, nmyu, dim, ni),
+                                 self.wfs.dtype)
+
+                kpt_comm.gather(self.a_uci, 0, a_kci)
+                kpt_comm.gather(self.b_uci, 0, b_kci)
+                kpt_comm.sum(self.spin_k, 0)
+                kpt_comm.sum(self.weight_k, 0)
+
+                a_kci.shape = (self.nkpts, dim, ni)
+                b_kci.shape = (self.nkpts, dim, ni)
+                data = {'ab': (a_kci, b_kci),
+                        'nkpts': self.nkpts,
+                        'symmetry operations': self.op_scc,
+                        'weight_k': self.weight_k,
+                        'spin_k': self.spin_k,
+                        'dim': dim}
+            else:
+                kpt_comm.gather(self.a_uci, 0)
+                kpt_comm.gather(self.b_uci, 0)
+                kpt_comm.sum(self.spin_k, 0)
+                kpt_comm.sum(self.weight_k, 0)
+
+        if mode == 'all':
+            w0_ucG = gd.collect(self.w_ucG)
+            wold0_ucG = gd.collect(self.wold_ucG)
+            y0_ucG = gd.collect(self.y_ucG)
+            if gd.comm.rank == 0:
+                if kpt_comm.rank == 0:
+                    w_kcG = gd.empty((self.nkpts, dim), self.wfs.dtype,
+                                     global_array=True)
+                    wold_kcG = gd.empty((self.nkpts, dim), self.wfs.dtype,
+                                        global_array=True)
+                    y_kcG = gd.empty((self.nkpts, dim), self.wfs.dtype,
+                                     global_array=True)
+                    kpt_comm.gather(w0_ucG, 0, w_kcG)
+                    kpt_comm.gather(wold0_ucG, 0, wold_kcG)
+                    kpt_comm.gather(y0_ucG, 0, y_kcG)
+                    data['arrays'] = (w_kcG, wold_kcG, y_kcG)
                 else:
-                    n_nmG[j, :, 0] = opd(n, m_m, kpt1, kpt2,
-                                         block=block)[:, direction]
-        return n_nmG
-
-    @timer('get_pair_momentum')
-    def get_pair_momentum(self, pd, kptpair, n_n, m_m, Q_avGii=None):
-        r"""Calculate matrix elements of the momentum operator.
-
-        Calculates::
-
-          n_{nm\mathrm{k}}\int_{\Omega_{\mathrm{cell}}}\mathrm{d}\mathbf{r}
-          \psi_{n\mathrm{k}}^*(\mathbf{r})
-          e^{-i\,(\mathrm{q} + \mathrm{G})\cdot\mathbf{r}}
-          \nabla\psi_{m\mathrm{k} + \mathrm{q}}(\mathbf{r})
-
-        pd: PlaneWaveDescriptor
-            Plane wave descriptor of a single q_c.
-        kptpair: KPointPair
-            KpointPair object containing the two kpoints.
-        n_n: list
-            List of left-band indices (n).
-        m_m:
-            List of right-band indices (m).
-        """
-        gs = self.gs
+                    kpt_comm.gather(w0_ucG, 0)
+                    kpt_comm.gather(wold0_ucG, 0)
+                    kpt_comm.gather(y0_ucG, 0)
+
+        if self.wfs.world.rank == 0:
+            with open(filename, 'wb') as fd:
+                pickle.dump(data, fd)
+
+    def allocate_tmp_arrays(self):
+
+        self.tmp1_cG = self.wfs.gd.zeros(self.dim, self.wfs.dtype)
+        self.tmp2_cG = self.wfs.gd.zeros(self.dim, self.wfs.dtype)
+        self.z_cG = self.wfs.gd.zeros(self.dim, self.wfs.dtype)
+
+    def initialize_start_vector(self, proj=None, proj_xyz=True):
+        # proj is one list of vectors [[e1_x,e1_y,e1_z],[e2_x,e2_y,e2_z]]
+        # ( or [ex,ey,ez] if only one projection )
+        # that the spectrum will be projected on
+        # default is to only calculate the averaged spectrum
+        # if proj_xyz is True, keep projection in x,y,z, if False
+        # only calculate the projections in proj
+
+        # Create initial wave function:
+        nmykpts = self.nmykpts
+
+        for a, setup in enumerate(self.wfs.setups):
+            if setup.phicorehole_g is not None:
+                break
+        A_ci = setup.A_ci
+
+        #
+        # proj keyword
+        #
+
+        # check normalization of incoming vectors
+        if proj is not None:
+            proj_2 = np.array(proj, float)
+            if len(proj_2.shape) == 1:
+                proj_2 = np.array([proj], float)
+
+            for i, p in enumerate(proj_2):
+                if sum(p ** 2) ** 0.5 != 1.0:
+                    print('proj_2 %s not normalized' % i)
+                    proj_2[i] /= sum(p ** 2) ** 0.5
+
+            proj_tmp = []
+            for p in proj_2:
+                proj_tmp.append(np.dot(p, A_ci))
+            proj_tmp = np.array(proj_tmp, float)
+
+            # if proj_xyz is True, append projections to A_ci
+            if proj_xyz:
+                A_ci_tmp = np.zeros((3 + proj_2.shape[0], A_ci.shape[1]))
+                A_ci_tmp[0:3, :] = A_ci
+                A_ci_tmp[3:, :] = proj_tmp
+
+            # otherwise, replace A_ci by projections
+            else:
+                A_ci_tmp = np.zeros((proj_2.shape[0], A_ci.shape[1]))
+                A_ci_tmp = proj_tmp
+            A_ci = A_ci_tmp
+
+        self.dim = len(A_ci)
+
+        self.allocate_tmp_arrays()
+
+        self.w_ucG = self.wfs.gd.zeros((nmykpts, self.dim), self.wfs.dtype)
+        self.wold_ucG = self.wfs.gd.zeros((nmykpts, self.dim), self.wfs.dtype)
+        self.y_ucG = self.wfs.gd.zeros((nmykpts, self.dim), self.wfs.dtype)
+
+        self.a_uci = np.zeros((nmykpts, self.dim, 0), self.wfs.dtype)
+        self.b_uci = np.zeros((nmykpts, self.dim, 0), self.wfs.dtype)
+
+        A_aci = self.wfs.pt.dict(3, zero=True)
+        if a in A_aci:
+            A_aci[a] = A_ci.astype(self.wfs.dtype)
+        for u in range(nmykpts):
+            self.wfs.pt.add(self.w_ucG[u], A_aci, u)
+
+    def run(self, nsteps, inverse_overlap='exact'):
+
+        if inverse_overlap == 'exact':
+            self.solver = self.solve
+        elif inverse_overlap == 'approximate':
+            self.solver = self.solve2
+        elif inverse_overlap == 'noinverse':
+            self.solver = self.solve3
+        else:
+            raise RuntimeError("Error, inverse_solver must be either 'exact' "
+                               "'approximate' or 'noinverse'")
 
-        kpt1 = kptpair.kpt1
-        kpt2 = kptpair.kpt2
-        Q_G = kptpair.Q_G  # Fourier components of kpoint pair
-
-        # For the same band we
-        kd = gs.kd
-        gd = gs.gd
-        k_c = kd.bzk_kc[kpt1.K] + kpt1.shift_c
-        k_v = 2 * np.pi * np.dot(k_c, np.linalg.inv(gd.cell_cv).T)
-
-        # Calculate k + G
-        G_Gv = pd.get_reciprocal_vectors(add_q=True)
-        kqG_Gv = k_v[np.newaxis] + G_Gv
-
-        # Pair velocities
-        n_nmvG = pd.zeros((len(n_n), len(m_m), 3))
-
-        # Calculate derivatives of left-wavefunction
-        # (there will typically be fewer of these)
-        ut_nvR = self.make_derivative(kpt1.s, kpt1.K, kpt1.n1, kpt1.n2)
-
-        # PAW-corrections
-        if Q_avGii is None:
-            Q_avGii = self.initialize_paw_nabla_corrections(pd)
-
-        # Iterate over occupied bands
-        for j, n in enumerate(n_n):
-            ut1cc_R = kpt1.ut_nR[n].conj()
-
-            n_mG = self.calculate_pair_densities(ut1cc_R,
-                                                 [], kpt2,
-                                                 pd, Q_G)
-
-            n_nmvG[j] = 1j * kqG_Gv.T[np.newaxis] * n_mG[:, np.newaxis]
-
-            # Treat each cartesian component at a time
-            for v in range(3):
-                # Minus from integration by parts
-                utvcc_R = -ut_nvR[n, v].conj()
-                Cv1_aGi = [np.dot(P1_ni[n].conj(), Q_vGii[v])
-                           for Q_vGii, P1_ni in zip(Q_avGii, kpt1.P_ani)]
-
-                nv_mG = self.calculate_pair_densities(utvcc_R,
-                                                      Cv1_aGi, kpt2,
-                                                      pd, Q_G)
-
-                n_nmvG[j, :, v] += nv_mG
-
-        # We want the momentum operator
-        n_nmvG *= -1j
-
-        return n_nmvG
-
-    @timer('Calculate pair-densities')
-    def calculate_pair_densities(self, ut1cc_R, C1_aGi, kpt2, pd, Q_G,
-                                 block=True):
-        """Calculate FFT of pair-densities and add PAW corrections.
-
-        ut1cc_R: 3-d complex ndarray
-            Complex conjugate of the periodic part of the left hand side
-            wave function.
-        C1_aGi: list of ndarrays
-            PAW corrections for all atoms.
-        kpt2: KPoint object
-            Right hand side k-point object.
-        pd: PWDescriptor
-            Plane-wave descriptor for for q=k2-k1.
-        Q_G: 1-d int ndarray
-            Mapping from flattened 3-d FFT grid to 0.5(G+q)^2<ecut sphere.
-        """
+        self.overlap = Overlap()
 
-        dv = pd.gd.dv
-        n_mG = pd.empty(kpt2.blocksize)
-        myblocksize = kpt2.nb - kpt2.na
-
-        for ut_R, n_G in zip(kpt2.ut_nR, n_mG):
-            n_R = ut1cc_R * ut_R
-            with self.timer('fft'):
-                n_G[:] = pd.fft(n_R, 0, Q_G) * dv
-        # PAW corrections:
-        with self.timer('gemm'):
-            for C1_Gi, P2_mi in zip(C1_aGi, kpt2.P_ani):
-                # gemm(1.0, C1_Gi, P2_mi, 1.0, n_mG[:myblocksize], 't')
-                mmm(1.0, P2_mi, 'N', C1_Gi, 'T', 1.0, n_mG[:myblocksize])
-
-        if not block or self.blockcomm.size == 1:
-            return n_mG
-        else:
-            n_MG = pd.empty(kpt2.blocksize * self.blockcomm.size)
-            self.blockcomm.all_gather(n_mG, n_MG)
-            return n_MG[:kpt2.n2 - kpt2.n1]
-
-    @timer('Optical limit')
-    def optical_pair_velocity(self, n, m_m, kpt1, kpt2, block=False):
-        if self.ut_sKnvR is None or kpt1.K not in self.ut_sKnvR[kpt1.s]:
-            self.ut_sKnvR = self.calculate_derivatives(kpt1)
-
-        kd = self.gs.kd
-        gd = self.gs.gd
-        k_c = kd.bzk_kc[kpt1.K] + kpt1.shift_c
-        k_v = 2 * np.pi * np.dot(k_c, np.linalg.inv(gd.cell_cv).T)
-
-        ut_vR = self.ut_sKnvR[kpt1.s][kpt1.K][n - kpt1.n1]
-        atomdata_a = self.gs.setups
-        C_avi = [np.dot(atomdata.nabla_iiv.T, P_ni[n - kpt1.na])
-                 for atomdata, P_ni in zip(atomdata_a, kpt1.P_ani)]
-
-        blockbands = kpt2.nb - kpt2.na
-        n0_mv = np.empty((kpt2.blocksize, 3), dtype=complex)
-        nt_m = np.empty(kpt2.blocksize, dtype=complex)
-        n0_mv[:blockbands] = -self.gs.gd.integrate(ut_vR,
-                                                   kpt2.ut_nR).T
-        nt_m[:blockbands] = self.gs.gd.integrate(kpt1.ut_nR[n - kpt1.na],
-                                                 kpt2.ut_nR)
-
-        n0_mv[:blockbands] += (1j * nt_m[:blockbands, np.newaxis] *
-                               k_v[np.newaxis, :])
-
-        for C_vi, P_mi in zip(C_avi, kpt2.P_ani):
-            # gemm(1.0, C_vi, P_mi, 1.0, n0_mv[:blockbands], 'c')
-            mmm(1.0, P_mi, 'N', C_vi, 'C', 1.0, n0_mv[:blockbands])
-
-        if block and self.blockcomm.size > 1:
-            n0_Mv = np.empty((kpt2.blocksize * self.blockcomm.size, 3),
-                             dtype=complex)
-            self.blockcomm.all_gather(n0_mv, n0_Mv)
-            n0_mv = n0_Mv[:kpt2.n2 - kpt2.n1]
-
-        return -1j * n0_mv
-
-    def optical_pair_density(self, n, m_m, kpt1, kpt2,
-                             block=False):
-        # Relative threshold for perturbation theory
-        threshold = self.threshold
-
-        eps1 = kpt1.eps_n[n - kpt1.n1]
-        deps_m = (eps1 - kpt2.eps_n)[m_m - kpt2.n1]
-        n0_mv = self.optical_pair_velocity(n, m_m, kpt1, kpt2,
-                                           block=block)
-
-        deps_m = deps_m.copy()
-        deps_m[deps_m == 0.0] = np.inf
-
-        smallness_mv = np.abs(-1e-3 * n0_mv / deps_m[:, np.newaxis])
-        inds_mv = (np.logical_and(np.inf > smallness_mv,
-                                  smallness_mv > threshold))
-        n0_mv *= - 1 / deps_m[:, np.newaxis]
-        n0_mv[inds_mv] = 0
-
-        return n0_mv
-
-    @timer('Intraband')
-    def intraband_pair_density(self, kpt, n_n=None,
-                               only_partially_occupied=False):
-        """Calculate intraband matrix elements of nabla"""
-        # Bands and check for block parallelization
-        na, nb, n1 = kpt.na, kpt.nb, kpt.n1
-        vel_nv = np.zeros((nb - na, 3), dtype=complex)
-        if n_n is None:
-            n_n = np.arange(na, nb)
-        assert np.max(n_n) < nb, 'This is too many bands'
-        assert np.min(n_n) >= na, 'This is too few bands'
-
-        # Load kpoints
-        kd = self.gs.kd
-        gd = self.gs.gd
-        k_c = kd.bzk_kc[kpt.K] + kpt.shift_c
-        k_v = 2 * np.pi * np.dot(k_c, np.linalg.inv(gd.cell_cv).T)
-        atomdata_a = self.gs.setups
-        f_n = kpt.f_n
-
-        width = self.gs.get_occupations_width()
-
-        if width > 1e-15:
-            dfde_n = -1 / width * (f_n - f_n**2.0)  # Analytical derivative
-            partocc_n = np.abs(dfde_n) > 1e-5  # Is part. occupied?
-        else:
-            # Just include all bands to be sure
-            partocc_n = np.ones(len(f_n), dtype=bool)
-
-        if only_partially_occupied and not partocc_n.any():
-            return None
-
-        if only_partially_occupied:
-            # Check for block par. consistency
-            assert (partocc_n < nb).all(), \
-                print('Include more unoccupied bands ', +
-                      'or less block parr.', file=self.fd)
-
-        # Break bands into degenerate chunks
-        degchunks_cn = []  # indexing c as chunk number
-        for n in n_n:
-            inds_n = np.nonzero(np.abs(kpt.eps_n[n - n1] -
-                                       kpt.eps_n) < 1e-5)[0] + n1
-
-            # Has this chunk already been computed?
-            oldchunk = any([n in chunk for chunk in degchunks_cn])
-            if not oldchunk and \
-               (partocc_n[n - n1] or not only_partially_occupied):
-                assert all([ind in n_n for ind in inds_n]), \
-                    print('\nYou are cutting over a degenerate band ' +
-                          'using block parallelization.',
-                          inds_n, n_n, file=self.fd)
-                degchunks_cn.append((inds_n))
-
-        # Calculate matrix elements by diagonalizing each block
-        for ind_n in degchunks_cn:
-            deg = len(ind_n)
-            ut_nvR = self.gs.gd.zeros((deg, 3), complex)
-            vel_nnv = np.zeros((deg, deg, 3), dtype=complex)
-            # States are included starting from kpt.na
-            ut_nR = kpt.ut_nR[ind_n - na]
-
-            # Get derivatives
-            for ind, ut_vR in zip(ind_n, ut_nvR):
-                ut_vR[:] = self.make_derivative(kpt.s, kpt.K,
-                                                ind, ind + 1)[0]
-
-            # Treat the whole degenerate chunk
-            for n in range(deg):
-                ut_vR = ut_nvR[n]
-                C_avi = [np.dot(atomdata.nabla_iiv.T, P_ni[ind_n[n] - na])
-                         for atomdata, P_ni in zip(atomdata_a, kpt.P_ani)]
-
-                nabla0_nv = -self.gs.gd.integrate(ut_vR, ut_nR).T
-                nt_n = self.gs.gd.integrate(ut_nR[n], ut_nR)
-                nabla0_nv += 1j * nt_n[:, np.newaxis] * k_v[np.newaxis, :]
-
-                for C_vi, P_ni in zip(C_avi, kpt.P_ani):
-                    # gemm(1.0, C_vi, P_ni[ind_n - na], 1.0, nabla0_nv, 'c')
-                    mmm(1.0, P_ni[ind_n - na], 'N', C_vi, 'C', 1.0, nabla0_nv)
-
-                vel_nnv[n] = -1j * nabla0_nv
-
-            for iv in range(3):
-                vel, _ = np.linalg.eig(vel_nnv[..., iv])
-                vel_nv[ind_n - na, iv] = vel  # Use eigenvalues
-
-        return vel_nv[n_n - na]
-
-    def get_fft_indices(self, K1, K2, q_c, pd, shift0_c):
-        """Get indices for G-vectors inside cutoff sphere."""
-        kd = self.gs.kd
-        N_G = pd.Q_qG[0]
-        shift_c = (shift0_c +
-                   (q_c - kd.bzk_kc[K2] + kd.bzk_kc[K1]).round().astype(int))
-        if shift_c.any():
-            n_cG = np.unravel_index(N_G, pd.gd.N_c)
-            n_cG = [n_G + shift for n_G, shift in zip(n_cG, shift_c)]
-            N_G = np.ravel_multi_index(n_cG, pd.gd.N_c, 'wrap')
-        return N_G
-
-    def construct_symmetry_operators(self, K, k_c=None):
-        from gpaw.response.symmetry_ops import construct_symmetry_operators
-        return construct_symmetry_operators(
-            self.gs, K, k_c, apply_strange_shift=False)
-
-    @timer('Initialize PAW corrections')
-    def initialize_paw_corrections(self, pd, soft=False):
-        from gpaw.response.paw import calculate_paw_corrections
-        return calculate_paw_corrections(
-            setups=self.gs.setups, pd=pd, soft=soft,
-            spos_ac=self.spos_ac)
-
-    @timer('Initialize PAW corrections')
-    def initialize_paw_nabla_corrections(self, pd, soft=False):
-        print('Initializing nabla PAW Corrections', file=self.fd)
-        from gpaw.response.paw import calculate_paw_nabla_corrections
-        return calculate_paw_nabla_corrections(
-            setups=self.gs.setups, pd=pd, soft=soft,
-            spos_ac=self.spos_ac)
-
-    def calculate_derivatives(self, kpt):
-        ut_sKnvR = [{}, {}]
-        ut_nvR = self.make_derivative(kpt.s, kpt.K, kpt.n1, kpt.n2)
-        ut_sKnvR[kpt.s][kpt.K] = ut_nvR
-
-        return ut_sKnvR
-
-    @timer('Derivatives')
-    def make_derivative(self, s, K, n1, n2):
-        gs = self.gs
-        if self.real_space_derivatives:
-            grad_v = [Gradient(gs.gd, v, 1.0, 4, complex).apply
-                      for v in range(3)]
-
-        U_cc, T, a_a, U_aii, shift_c, time_reversal = \
-            self.construct_symmetry_operators(K)
-        A_cv = gs.gd.cell_cv
-        M_vv = np.dot(np.dot(A_cv.T, U_cc.T), np.linalg.inv(A_cv).T)
-        ik = gs.kd.bz2ibz_k[K]
-        assert gs.kd.comm.size == 1
-        kpt = gs.kpt_qs[ik][s]
-        psit_nG = kpt.psit_nG
-        iG_Gv = 1j * gs.pd.get_reciprocal_vectors(q=ik, add_q=False)
-        ut_nvR = gs.gd.zeros((n2 - n1, 3), complex)
-        for n in range(n1, n2):
-            for v in range(3):
-                if self.real_space_derivatives:
-                    ut_R = T(gs.pd.ifft(psit_nG[n], ik))
-                    grad_v[v](ut_R, ut_nvR[n - n1, v],
-                              np.ones((3, 2), complex))
-                else:
-                    ut_R = T(gs.pd.ifft(iG_Gv[:, v] * psit_nG[n], ik))
-                    for v2 in range(3):
-                        ut_nvR[n - n1, v2] += ut_R * M_vv[v, v2]
-
-        return ut_nvR
-
-    def __del__(self):
-        self.context.close()
-
-
-class PairDensity(NoCalculatorPairDensity):
-    def __init__(self, gs, *,
-                 world=mpi.world, txt='-', timer=None,
-                 **kwargs):
-        """Density matrix elements
-
-        Parameters
-        ----------
-        ftol : float
-            Threshold determining whether a band is completely filled
-            (f > 1 - ftol) or completely empty (f < ftol).
-        threshold : float
-            Numerical threshold for the optical limit k dot p perturbation
-            theory expansion.
-        real_space_derivatives : bool
-            Calculate nabla matrix elements (in the optical limit)
-            using a real space finite difference approximation.
+        ni = self.a_uci.shape[2]
+        a_uci = np.empty((self.nmykpts, self.dim, ni + nsteps), self.wfs.dtype)
+        b_uci = np.empty((self.nmykpts, self.dim, ni + nsteps), self.wfs.dtype)
+        a_uci[:, :, :ni] = self.a_uci
+        b_uci[:, :, :ni] = self.b_uci
+        self.a_uci = a_uci
+        self.b_uci = b_uci
+
+        for u in range(self.nmykpts):
+            for i in range(nsteps):
+                self.step(u, ni + i)
+
+    def step(self, u, i):
+        print(u, i)
+        integrate = self.wfs.gd.integrate
+        w_cG = self.w_ucG[u]
+        y_cG = self.y_ucG[u]
+        wold_cG = self.wold_ucG[u]
+        z_cG = self.z_cG
+
+        self.solver(w_cG, self.z_cG, u)
+        I_c = np.reshape(integrate(np.conjugate(z_cG) * w_cG)**-0.5,
+                         (self.dim, 1, 1, 1))
+        z_cG *= I_c
+        w_cG *= I_c
+
+        if i != 0:
+            b_c = 1.0 / I_c
+        else:
+            b_c = np.reshape(np.zeros(self.dim), (self.dim, 1, 1, 1))
+
+        self.hamiltonian.apply(z_cG, y_cG, self.wfs, self.wfs.kpt_u[u])
+        a_c = np.reshape(integrate(np.conjugate(z_cG) * y_cG),
+                         (self.dim, 1, 1, 1))
+        wnew_cG = (y_cG - a_c * w_cG - b_c * wold_cG)
+        wold_cG[:] = w_cG
+        w_cG[:] = wnew_cG
+        self.a_uci[u, :, i] = a_c[:, 0, 0, 0]
+        self.b_uci[u, :, i] = b_c[:, 0, 0, 0]
+
+    def continued_fraction(self, e, k, c, i, imax):
+        a_i = self.a_uci[k, c]
+        b_i = self.b_uci[k, c]
+        if i == imax - 2:
+            return self.terminator(a_i[i], b_i[i], e)
+        return 1.0 / (a_i[i] - e -
+                      b_i[i + 1]**2 *
+                      self.continued_fraction(e, k, c, i + 1, imax))
+
+    def get_spectra(self, eps_s, delta=0.1, imax=None, kpoint=None, fwhm=None,
+                    linbroad=None, spin=0):
+        assert not mpi.parallel
+
+        # the following lines are to stop the user to make mistakes
+        # if spin == 1:
+        #     raise RuntimeError(
+        #         'The core hole is always in spin 0: please use spin=0')
+
+        n = len(eps_s)
+
+        sigma_cn = np.zeros((self.dim, n))
+        if imax is None:
+            imax = self.a_uci.shape[2]
+        eps_n = (eps_s + delta * 1.0j) / Hartree
+
+        # if a certain k-point is chosen
+        if kpoint is not None:
+            for c in range(self.dim):
+                sigma_cn[c] += self.continued_fraction(eps_n, kpoint, c,
+                                                       0, imax).imag
+        else:
+            for k in range(self.nkpts):
+                print('kpoint', k, 'spin_k', self.spin_k[k], spin,
+                      'weight', self.weight_k[k])
+                if self.spin_k[k] == spin:
+                    weight = self.weight_k[k]
+                    for c in range(self.dim):
+                        sigma_cn[c] += weight * self.continued_fraction(
+                            eps_n, k, c, 0, imax).imag
+
+        if self.op_scc is not None:
+            sigma0_cn = sigma_cn
+            sigma_cn = np.zeros((self.dim, n))
+            for op_cc in self.op_scc:
+                sigma_cn += np.dot(op_cc**2, sigma0_cn)
+            sigma_cn /= len(self.op_scc)
+
+        # gaussian broadening
+        if fwhm is not None:
+            sigma_tmp = np.zeros(sigma_cn.shape)
+
+            # constant broadening fwhm
+            if linbroad is None:
+                alpha = 4 * log(2) / fwhm**2
+                for n, eps in enumerate(eps_s):
+                    x = -alpha * (eps_s - eps)**2
+                    x = np.clip(x, -100.0, 100.0)
+                    sigma_tmp += np.outer(sigma_cn[:, n],
+                                          (alpha / pi)**0.5 * np.exp(x))
+
+            else:
+                # constant broadening fwhm until linbroad[1] and a
+                # constant broadening over linbroad[2] with fwhm2=
+                # linbroad[0]
+                fwhm2 = linbroad[0]
+                lin_e1 = linbroad[1]
+                lin_e2 = linbroad[2]
+                for n, eps in enumerate(eps_s):
+                    if eps < lin_e1:
+                        alpha = 4 * log(2) / fwhm**2
+                    elif eps <= lin_e2:
+                        fwhm_lin = (fwhm + (eps - lin_e1) *
+                                    (fwhm2 - fwhm) / (lin_e2 - lin_e1))
+                        alpha = 4 * log(2) / fwhm_lin**2
+                    elif eps >= lin_e2:
+                        alpha = 4 * log(2) / fwhm2**2
+
+                    x = -alpha * (eps_s - eps)**2
+                    x = np.clip(x, -100.0, 100.0)
+                    sigma_tmp += np.outer(sigma_cn[:, n],
+                                          (alpha / pi)**0.5 * np.exp(x))
+            sigma_cn = sigma_tmp
+
+        return sigma_cn
+
+    def solve(self, w_cG, z_cG, u):
+        # exact inverse overlap
+        self.overlap.apply_inverse(w_cG, self.tmp1_cG, self.wfs,
+                                   self.wfs.kpt_u[u])
+        self.u = u
+        CG(self, z_cG, self.tmp1_cG,
+           tolerance=self.tol, maxiter=self.maxiter)
+
+    def solve2(self, w_cG, z_cG, u):
+        # approximate inverse overlap
+        self.overlap.apply_inverse(w_cG, z_cG, self.wfs, self.wfs.kpt_u[u])
+
+        self.u = u
+
+    def solve3(self, w_cG, z_cG, u):
+        # no inverse overlap
+        z_cG[:] = w_cG
+        self.u = u
+
+    def sum(self, a):
+        self.wfs.gd.comm.sum(a)
+        return a
+
+    def __call__(self, in_cG, out_cG):
+        """Function that is called by CG. It returns S~-1Sx_in in x_out
         """
 
-        # note: gs is just called gs for historical reasons.
-        # It's actually calc-or-filename union.
+        kpt = self.wfs.kpt_u[self.u]
+        self.overlap.apply(in_cG, self.tmp2_cG, self.wfs, kpt)
+        self.overlap.apply_inverse(self.tmp2_cG, out_cG, self.wfs, kpt)
+
+    def terminator(self, a, b, e):
+        """ Analytic formula to terminate the continued fraction from
+        [R Haydock, V Heine, and M J Kelly,
+        J Phys. C: Solid State Physics, Vol 8, (1975), 2591-2605]
+        """
 
-        self.calc, context = calc_and_context(gs, txt, world, timer)
+        return 0.5 * (e - a - ((e - a)**2 - 4 * b**2)**0.5 / b**2)
 
-        super().__init__(
-            gs=self.calc.gs_adapter(),
-            context=context,
-            **kwargs)
+    def duplicate_coefficients(self, nsteps, ntimes):
+        n1 = self.a_uci.shape[0]
+        n2 = self.a_uci.shape[1]
+        ni = self.a_uci.shape[2]
+        type_code = self.a_uci.dtype.name  # typecode()
+        a_uci = np.empty((n1, n2, ni + nsteps * ntimes), type_code)
+        b_uci = np.empty((n1, n2, ni + nsteps * ntimes), type_code)
+        a_uci[:, :, :ni] = self.a_uci
+        b_uci[:, :, :ni] = self.b_uci
+
+        ni1 = ni
+        ni2 = ni + nsteps
+        for i in range(ntimes):
+            a_uci[:, :, ni1: ni2] = a_uci[:, :, ni - nsteps:ni]
+            b_uci[:, :, ni1: ni2] = b_uci[:, :, ni - nsteps:ni]
+            ni1 += nsteps
+            ni2 += nsteps
+        self.a_uci = a_uci
+        self.b_uci = b_uci
+
+
+def write_spectrum(a, b, filename):
+    f = open(filename, 'w')
+    print(f, a.shape, b.shape)
+
+    for i in range(a.shape[0]):
+        print('%g' % a[i], b[0, i] + b[1, i] + b[2, i], end=' ', file=f)
+        for b2 in b:
+            print('%g' % b2[i], end=' ', file=f)
+        print(file=f)
+    f.close()
```

### Comparing `gpaw-22.8.0/gpaw/response/q0_correction.py` & `gpaw-23.6.0/gpaw/response/q0_correction.py`

 * *Files 9% similar despite different names*

```diff
@@ -3,72 +3,78 @@
 
 class Q0Correction:
     def __init__(self, cell_cv, bzk_kc, N_c):
         self.cell_cv = cell_cv
         self.bzk_kc = bzk_kc
         self.N_c = N_c
 
-        self.x0density = 0.1  # ? 0.01
+        # Check that basic assumptions of cell and k-grid
+        # for Q0Correction are fulfilled
+        assert N_c[2] == 1  # z-axis is non periodic direction
+        assert (all(cell_cv[:2, 2] == 0) and all(cell_cv[2, :2] == 0)
+                and cell_cv[2, 2] > 0)
+        
+        # Hardcoded crap?
+        x0density = 0.1  # ? 0.01
 
-    def add_q0_correction(self, pd, W_GG, einv_GG, chi0_xvG, chi0_vv,
-                          sqrtV_G, fd=None):
+        # Generate numerical q-point grid
+        self.rcell_cv = 2 * np.pi * np.linalg.inv(cell_cv).T
+
+        # Prepare stuff
+        self.q0cell_cv = np.array([1, 1, 1])**0.5 * self.rcell_cv / self.N_c
+        L = cell_cv[2, 2]
+        q0density = 2. / L * x0density
+        npts_c = np.ceil(np.sum(self.q0cell_cv**2, axis=1)**0.5 /
+                         q0density).astype(int)
+        npts_c[2] = 1
+        npts_c += (npts_c + 1) % 2
+        self.npts_c = npts_c
+
+    def add_q0_correction(self, qpd, W_GG, einv_GG,
+                          chi0_xvG, chi0_vv, sqrtV_G):
         from ase.dft import monkhorst_pack
-        pi = np.pi
-        cell_cv = self.cell_cv
         qpts_qc = self.bzk_kc
-        L = cell_cv[2, 2]
+        pi = np.pi
+        L = self.cell_cv[2, 2]
+        
         vc_G0 = sqrtV_G[1:]**2
 
         B_GG = einv_GG[1:, 1:]
         u_v0G = vc_G0[np.newaxis, :]**0.5 * chi0_xvG[0, :, 1:]
         u_vG0 = vc_G0[np.newaxis, :]**0.5 * chi0_xvG[1, :, 1:]
         U_vv = -chi0_vv
         a_v0G = -np.dot(u_v0G, B_GG)
         a_vG0 = -np.dot(u_vG0, B_GG.T)
         A_vv = U_vv - np.dot(a_v0G, u_vG0.T)
         S_v0G = a_v0G
         S_vG0 = a_vG0
         L_vv = A_vv
 
         # Get necessary G vectors.
-        G_Gv = pd.get_reciprocal_vectors()[1:]
+        G_Gv = qpd.get_reciprocal_vectors(add_q=False)[1:]
         G_Gv += np.array([1e-14, 1e-14, 0])
         G2_G = np.sum(G_Gv**2, axis=1)
         Gpar_G = np.sum(G_Gv[:, 0:2]**2, axis=1)**0.5
 
-        # Generate numerical q-point grid
-        rcell_cv = 2 * pi * np.linalg.inv(cell_cv).T
-
+        # There is still a lot of stuff here,
+        # which could go to the constructor! XXX
         iq = np.argmin(np.sum(qpts_qc**2, axis=1))
         assert np.allclose(qpts_qc[iq], 0)
-        q0cell_cv = np.array([1, 1, 1])**0.5 * rcell_cv / self.N_c
-        q0vol = abs(np.linalg.det(q0cell_cv))
-
-        x0density = self.x0density
-        q0density = 2. / L * x0density
-        npts_c = np.ceil(np.sum(q0cell_cv**2, axis=1)**0.5 /
-                         q0density).astype(int)
-        npts_c[2] = 1
-        npts_c += (npts_c + 1) % 2
-        if fd is not None:
-            print('Applying analytical 2D correction to W:',
-                  file=fd)
-            print('    Evaluating Gamma point contribution to W on a ' +
-                  '%dx%dx%d grid' % tuple(npts_c), file=fd)
+        q0vol = abs(np.linalg.det(self.q0cell_cv))
 
-        qpts_qc = monkhorst_pack(npts_c)
+        qpts_qc = monkhorst_pack(self.npts_c)
         qgamma = np.argmin(np.sum(qpts_qc**2, axis=1))
 
-        qpts_qv = np.dot(qpts_qc, q0cell_cv)
+        qpts_qv = np.dot(qpts_qc, self.q0cell_cv)
         qpts_q = np.sum(qpts_qv**2, axis=1)**0.5
         qpts_q[qgamma] = 1e-14
         qdir_qv = qpts_qv / qpts_q[:, np.newaxis]
         qdir_qvv = qdir_qv[:, :, np.newaxis] * qdir_qv[:, np.newaxis, :]
         nq = len(qpts_qc)
-        q0area = q0vol / q0cell_cv[2, 2]
+        q0area = q0vol / self.q0cell_cv[2, 2]
         dq0 = q0area / nq
         dq0rad = (dq0 / pi)**0.5
         R = L / 2.
         x0area = q0area * R**2
         dx0rad = dq0rad * R
 
         exp_q = 4 * pi * (1 - np.exp(-qpts_q * R))
```

### Comparing `gpaw-22.8.0/gpaw/response/qeh.py` & `gpaw-23.6.0/gpaw/response/qeh.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,13 +1,11 @@
 import pickle
 import numpy as np
 from math import pi
 import ase.units
-from ase.parallel import world
-import sys
 import os
 
 Hartree = ase.units.Hartree
 Bohr = ase.units.Bohr
 
 
 def load(fd):
@@ -19,32 +17,32 @@
 
 class BuildingBlock:
 
     """ Module for using Linear response to calculate dielectric
     building block of 2D material with GPAW"""
 
     def __init__(self, filename, df, isotropic_q=True, nq_inf=10,
-                 direction='x', qmax=None, txt=sys.stdout):
+                 direction='x', qmax=None, txt='-'):
         """Creates a BuildingBlock object.
 
         filename: str
             used to save data file: filename-chi.npz
         df: DielectricFunction object
             Determines how linear response calculation is performed
         isotropic_q: bool
             If True, only q-points along one direction (1 0 0) in the
-            2D BZ is included, thus asuming an isotropic material
+            2D BZ is included, thus assuming an isotropic material
         direction: 'x' or 'y'
             Direction used for isotropic q sampling.
         qmax: float
             Cutoff for q-grid. To be used if one wishes to sample outside the
             irreducible BZ. Only works for isotropic q-sampling.
         nq_inf: int
             number of extra q points in the limit q->0 along each direction,
-            extrapolated from q=0, assumung that the head of chi0_wGG goes
+            extrapolated from q=0, assuming that the head of chi0_wGG goes
             as q^2 and the wings as q.
             Note that this does not hold for (semi)metals!
 
         """
         assert isotropic_q, "Non-isotropic calculation" \
             + " temporarily turned-off until properly tested."
         if qmax is not None:
@@ -59,26 +57,20 @@
         if direction == 'x':
             qdir = 0
         elif direction == 'y':
             qdir = 1
         self.direction = direction
 
         self.df = df  # dielectric function object
-        self.df.truncation = '2D'  # in case you forgot!
-        self.wd = self.df.chi0.wd
-        self.world = self.df.chi0.world
-
-        if self.world.rank != 0:
-            from gpaw.utilities import devnull
-            txt = devnull
-        elif isinstance(txt, str):
-            txt = open(txt, 'w', 1)
-        self.fd = txt
+        assert self.df.coulomb.truncation == '2D'
+        self.wd = self.df.wd
 
-        gs = self.df.chi0.gs
+        self.context = self.df.context.with_txt(txt)
+
+        gs = self.df.gs
         kd = gs.kd
         self.kd = kd
         r = gs.gd.get_grid_point_coordinates()
         self.z = r[2, 0, 0, :]
 
         nw = len(self.wd)
         self.chiM_qw = np.zeros([0, nw])
@@ -145,66 +137,67 @@
         self.q_vs += q_infs
         self.q_abs = (self.q_vs**2).sum(axis=1)**0.5
         self.q_infs = q_infs
         self.complete = False
         self.nq = 0
         if self.load_chi_file():
             if self.complete:
-                print('Building block loaded from file', file=self.fd)
-        world.barrier()
+                self.context.print('Building block loaded from file')
+        self.context.comm.barrier()
 
     def calculate_building_block(self, add_intraband=False):
         if self.complete:
             return
         Nq = self.q_cs.shape[0]
         for nq in range(self.nq, Nq):
             self.nq = nq
             self.save_chi_file()
             q_c = self.q_cs[nq]
             q_inf = self.q_infs[nq]
             if np.allclose(q_inf, 0):
                 q_inf = None
 
             qcstr = '(' + ', '.join(['%.3f' % x for x in q_c]) + ')'
-            print('Calculating contribution from q-point #%d/%d, q_c=%s'
-                  % (nq + 1, Nq, qcstr), file=self.fd)
+            self.context.print(
+                'Calculating contribution from q-point #%d/%d, q_c=%s' % (
+                    nq + 1, Nq, qcstr), flush=False)
             if q_inf is not None:
                 qstr = '(' + ', '.join(['%.3f' % x for x in q_inf]) + ')'
-                print('    and q_inf=%s' % qstr, file=self.fd)
-            pd, chi0_wGG, \
+                self.context.print('    and q_inf=%s' % qstr, flush=False)
+            qpd, chi0_wGG, \
                 chi_wGG = self.df.get_dielectric_matrix(
                     symmetric=False,
                     calculate_chi=True,
                     q_c=q_c,
                     q_v=q_inf,
                     direction=self.direction,
                     add_intraband=add_intraband)
-            print('calculated chi!', file=self.fd)
+            self.context.print('calculated chi!')
 
             nw = len(self.wd)
-            world = self.df.chi0.world
-            w1 = min(self.df.blocks1d.blocksize * world.rank, nw)
+            comm = self.context.comm
+            w1 = min(self.df.blocks1d.blocksize * comm.rank, nw)
 
             _, _, chiM_qw, chiD_qw, _, drhoM_qz, drhoD_qz = \
-                get_chi_2D(self.wd.omega_w, pd, chi_wGG)
+                get_chi_2D(self.wd.omega_w, qpd, chi_wGG)
 
             chiM_w = chiM_qw[0]
             chiD_w = chiD_qw[0]
             chiM_w = self.collect(chiM_w)
             chiD_w = self.collect(chiD_w)
 
-            if self.world.rank == 0:
+            if self.context.comm.rank == 0:
                 assert w1 == 0  # drhoM and drhoD in static limit
                 self.update_building_block(chiM_w[np.newaxis, :],
                                            chiD_w[np.newaxis, :],
                                            drhoM_qz, drhoD_qz)
 
         # Induced densities are not probably described in q-> 0 limit-
         # replace with finite q result:
-        if self.world.rank == 0:
+        if self.context.comm.rank == 0:
             for n in range(Nq):
                 if np.allclose(self.q_cs[n], 0):
                     self.drhoM_qz[n] = self.drhoM_qz[self.nq_cut]
                     self.drhoD_qz[n] = self.drhoD_qz[self.nq_cut]
 
         self.complete = True
         self.save_chi_file()
@@ -231,18 +224,18 @@
                 'omega_w': self.wd.omega_w,
                 'chiM_qw': self.chiM_qw,
                 'chiD_qw': self.chiD_qw,
                 'z': self.z,
                 'drhoM_qz': self.drhoM_qz,
                 'drhoD_qz': self.drhoD_qz}
 
-        if self.world.rank == 0:
+        if self.context.comm.rank == 0:
             np.savez_compressed(filename + '-chi.npz',
                                 **data)
-        world.barrier()
+        self.context.comm.barrier()
 
     def load_chi_file(self):
         try:
             data = np.load(self.filename + '-chi.npz')
         except IOError:
             return False
         if (np.all(data['omega_w'] == self.wd.omega_w) and
@@ -338,27 +331,27 @@
         self.drhoD_qz = yr(q_grid, self.z) + 1j * yi(q_grid, self.z)
 
         self.q_abs = q_grid
         self.wd = FrequencyGridDescriptor(w_grid)
         self.save_chi_file(filename=self.filename + '_int')
 
     def collect(self, a_w):
-        world = self.df.chi0.world
+        comm = self.context.comm
         mynw = self.df.blocks1d.blocksize
         b_w = np.zeros(mynw, a_w.dtype)
         b_w[:self.df.blocks1d.nlocal] = a_w
         nw = len(self.wd)
-        A_w = np.empty(world.size * mynw, a_w.dtype)
-        world.all_gather(b_w, A_w)
+        A_w = np.empty(comm.size * mynw, a_w.dtype)
+        comm.all_gather(b_w, A_w)
         return A_w[:nw]
 
     def clear_temp_files(self):
         if not self.savechi0:
-            world = self.df.chi0.world
-            if world.rank == 0:
+            comm = self.context.comm
+            if comm.rank == 0:
                 while len(self.temp_files) > 0:
                     filename = self.temp_files.pop()
                     os.remove(filename)
 
 
 """TOOLS"""
 
@@ -384,15 +377,15 @@
             return False
         elif not ((data['q_abs'] == q).all() and
                   (data['omega_w'] == w).all()):
             return False
     return True
 
 
-def get_chi_2D(omega_w=None, pd=None, chi_wGG=None, q0=None,
+def get_chi_2D(omega_w=None, qpd=None, chi_wGG=None, q0=None,
                filenames=None, name=None):
     r"""Calculate the monopole and dipole contribution to the
     2D susceptibillity chi_2D, defined as
 
     ::
 
       \chi^M_2D(q, \omega) = \int\int dr dr' \chi(q, \omega, r,r') \\
@@ -410,53 +403,53 @@
         the DielectricFunction module in GPAW
     name: str
         name writing output files
     """
 
     q_list_abs = []
     if chi_wGG is None and filenames is not None:
-        omega_w, pd, chi_wGG, q0 = read_chi_wGG(filenames[0])
+        omega_w, qpd, chi_wGG, q0 = read_chi_wGG(filenames[0])
         nq = len(filenames)
     elif chi_wGG is not None:
         nq = 1
     nw = chi_wGG.shape[0]
-    r = pd.gd.get_grid_point_coordinates()
+    r = qpd.gd.get_grid_point_coordinates()
     z = r[2, 0, 0, :]
-    L = pd.gd.cell_cv[2, 2]  # Length of cell in Bohr
+    L = qpd.gd.cell_cv[2, 2]  # Length of cell in Bohr
     z0 = L / 2.  # position of layer
     chiM_qw = np.zeros([nq, nw], dtype=complex)
     chiD_qw = np.zeros([nq, nw], dtype=complex)
     drhoM_qz = np.zeros([nq, len(z)], dtype=complex)  # induced density
     drhoD_qz = np.zeros([nq, len(z)], dtype=complex)  # induced dipole density
     for iq in range(nq):
         if iq != 0:
-            omega_w, pd, chi_wGG, q0 = read_chi_wGG(filenames[iq])
+            omega_w, qpd, chi_wGG, q0 = read_chi_wGG(filenames[iq])
         if q0 is not None:
             q = q0
         else:
-            q = pd.K_qv
+            q = qpd.K_qv
         npw = chi_wGG.shape[1]
-        Gvec = pd.get_reciprocal_vectors(add_q=False)
+        G_Gv = qpd.get_reciprocal_vectors(add_q=False)
 
         Glist = []
         for iG in range(npw):  # List of G with Gx,Gy = 0
-            if Gvec[iG, 0] == 0 and Gvec[iG, 1] == 0:
+            if G_Gv[iG, 0] == 0 and G_Gv[iG, 1] == 0:
                 Glist.append(iG)
 
         chiM_qw[iq] = L * chi_wGG[:, 0, 0]
         drhoM_qz[iq] += chi_wGG[0, 0, 0]
         q_abs = np.linalg.norm(q)
         q_list_abs.append(q_abs)
         for iG in Glist[1:]:
-            G_z = Gvec[iG, 2]
+            G_z = G_Gv[iG, 2]
             qGr_R = np.inner(G_z, z.T).T
             # Fourier transform to get induced density at \omega=0
             drhoM_qz[iq] += np.exp(1j * qGr_R) * chi_wGG[0, iG, 0]
             for iG1 in Glist[1:]:
-                G_z1 = Gvec[iG1, 2]
+                G_z1 = G_Gv[iG1, 2]
                 # integrate with z along both coordinates
                 factor = z_factor(z0, L, G_z)
                 factor1 = z_factor(z0, L, G_z1, sign=-1)
                 chiD_qw[iq, :] += 1. / L * factor * chi_wGG[:, iG, iG1] * \
                     factor1
                 # induced dipole density due to V_ext = z
                 drhoD_qz[iq, :] += 1. / L * np.exp(1j * qGr_R) * \
@@ -514,14 +507,14 @@
 def read_chi_wGG(name):
     """
     Read density response matrix calculated with the DielectricFunction
     module in GPAW.
     Returns frequency grid, gpaw.wavefunctions object, chi_wGG
     """
     fd = open(name, 'rb')
-    omega_w, pd, chi_wGG, q0, chi0_wvv = load(fd)
+    omega_w, qpd, chi_wGG, q0, chi0_wvv = load(fd)
     nw = len(omega_w)
-    nG = pd.ngmax
+    nG = qpd.ngmax
     chi_wGG = np.empty((nw, nG, nG), complex)
     for chi_GG in chi_wGG:
         chi_GG[:] = load(fd)
-    return omega_w, pd, chi_wGG, q0
+    return omega_w, qpd, chi_wGG, q0
```

### Comparing `gpaw-22.8.0/gpaw/response/site_kernels.py` & `gpaw-23.6.0/gpaw/response/site_kernels.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,14 +1,14 @@
 """Compute site-kernels. Used for computing Heisenberg exchange constants.
 Specifically, one maps a DFT calculations onto a Heisenberg lattice model,
 where the site kernels define the lattice sites and magnetic moments."""
 
 import numpy as np
 from scipy.special import jv
-from gpaw.response.susceptibility import get_pw_coordinates
+from gpaw.response.pair_functions import get_pw_coordinates
 from ase.units import Bohr
 
 
 class SiteKernels:
     """Factory for calculating sublattice site kernels
 
                 1  /
@@ -63,26 +63,26 @@
             if all([shape == geometries[0][0] for shape, _ in geometries]):
                 geometry_shapes.append(geometries[0][0])
             else:
                 geometry_shapes.append(None)
 
         return geometry_shapes
 
-    def calculate(self, pd):
+    def calculate(self, qpd):
         """Generate the site kernels of each partition.
 
         Returns
         -------
         K_aGG : np.ndarray (dtype=complex)
             Site kernels of sites a and plane wave components G and G'.
         """
         for geometries in self.partitions:
             # We yield one set of site kernels at a time, because they can be
             # memory intensive
-            yield calculate_site_kernels(pd, self.positions, geometries)
+            yield calculate_site_kernels(qpd, self.positions, geometries)
 
     def __add__(self, sitekernels):
         """Add the sites from two SiteKernels instances to a new joint
         SiteKernels instance with nsites = nsites1 + nsites2."""
         assert isinstance(sitekernels, SiteKernels)
         assert self.npartitions == sitekernels.npartitions
 
@@ -219,15 +219,15 @@
         # Generate partitions as list of lists of geometries
         partitions = [[('parallelepiped', (cell_cv,)) for cell_cv in cell_acv]
                       for cell_acv in cell_pacv]
 
         SiteKernels.__init__(self, positions, partitions)
 
 
-def calculate_site_kernels(pd, positions, geometries):
+def calculate_site_kernels(qpd, positions, geometries):
     """Calculate the sublattice site kernel:
 
                 1  /
     K_aGG'(q) = ‾‾ | dr e^(-i[G-G'+q].r) θ(r∊V_a)
                 V0 /
 
     where V_a denotes the integration volume of site a, centered at the site
@@ -250,15 +250,15 @@
 
                 1
     K_aGG'(q) = ‾‾ τ_a(G-G'+q) Θ(G-G'+q)
                 V0
 
     Parameters
     ----------
-    pd : PWDescriptor
+    qpd : SingleQPWDescriptor
         Plane wave descriptor corresponding to the q wave vector of interest.
     positions : np.ndarray
         Site positions. Array of shape (nsites, 3).
     geometries : list
         List of site geometries. A site geometry is a tuple of the integration
         volume shape (str) and arguments (tuple): (shape, args). Valid shapes
         are 'sphere', 'cylinder' and 'parallelepiped'. The integration volume
@@ -269,18 +269,18 @@
     K_aGG : np.ndarray (dtype=complex)
         Site kernels of sites a and plane wave components G and G'.
     """
     assert positions.shape[0] == len(geometries)
     assert positions.shape[1] == 3
 
     # Extract unit cell volume
-    V0 = pd.gd.volume
+    V0 = qpd.gd.volume
 
     # Construct Q=G-G'+q
-    Q_GGv = construct_wave_vectors(pd)
+    Q_GGv = construct_wave_vectors(qpd)
 
     # Allocate site kernel array
     nsites = len(geometries)
     K_aGG = np.zeros((nsites,) + Q_GGv.shape[:2], dtype=complex)
 
     # Calculate the site kernel for each site individually
     for a, (tau_v, (shape, args)) in enumerate(zip(positions, geometries)):
@@ -294,44 +294,42 @@
 
         # Update data
         K_aGG[a, :, :] = 1 / V0 * tau_GG * Theta_GG
 
     return K_aGG
 
 
-def construct_wave_vectors(pd):
+def construct_wave_vectors(qpd):
     """Construct wave vectors Q=G1-G2+q corresponding to the q-vector of
     interest."""
-    G_Gv, q_v = get_plane_waves_and_reduced_wave_vector(pd)
+    G_Gv, q_v = get_plane_waves_and_reduced_wave_vector(qpd)
 
     # Allocate arrays for G, G' and q respectively
     nG = len(G_Gv)
     G1_GGv = np.tile(G_Gv[:, np.newaxis, :], [1, nG, 1])
     G2_GGv = np.tile(G_Gv[np.newaxis, :, :], [nG, 1, 1])
     q_GGv = np.tile(q_v[np.newaxis, np.newaxis, :], [nG, nG, 1])
 
     # Contruct the wave vector G1 - G2 + q
     Q_GGv = G1_GGv - G2_GGv + q_GGv
 
     return Q_GGv
 
 
-def get_plane_waves_and_reduced_wave_vector(pd):
+def get_plane_waves_and_reduced_wave_vector(qpd):
     """Get the reciprocal lattice vectors and reduced wave vector of the plane
     wave representation corresponding to the q-vector of interest."""
     # Get the reduced wave vector
-    q_qc = pd.kd.bzk_kc
-    assert len(q_qc) == 1
-    q_c = q_qc[0, :]  # Assume single q
+    q_c = qpd.q_c
 
     # Get the reciprocal lattice vectors in relative coordinates
-    G_Gc = get_pw_coordinates(pd)
+    G_Gc = get_pw_coordinates(qpd)
 
     # Convert to cartesian coordinates
-    B_cv = 2.0 * np.pi * pd.gd.icell_cv  # Coordinate transform matrix
+    B_cv = 2.0 * np.pi * qpd.gd.icell_cv  # Coordinate transform matrix
     q_v = np.dot(q_c, B_cv)  # Unit = Bohr^(-1)
     G_Gv = np.dot(G_Gc, B_cv)
 
     return G_Gv, q_v
 
 
 def create_geometry_factor(shape):
```

### Comparing `gpaw-22.8.0/gpaw/response/susceptibility.py` & `gpaw-23.6.0/gpaw/response/susceptibility.py`

 * *Files 21% similar despite different names*

```diff
@@ -1,541 +1,504 @@
-import sys
-from time import ctime
-from pathlib import Path
-import pickle
+from __future__ import annotations
 
 import numpy as np
 
 from ase.units import Hartree
-from gpaw.utilities import convert_string_to_fd
-from ase.utils.timing import Timer, timer
 
-import gpaw.mpi as mpi
-from gpaw.response.kspair import get_calc
-from gpaw.response.frequencies import FrequencyDescriptor
-from gpaw.response.chiks import ChiKS
-from gpaw.response.kxc import get_fxc
-from gpaw.response.kernels import get_coulomb_kernel
+from gpaw.response.frequencies import ComplexFrequencyDescriptor
 from gpaw.response.pw_parallelization import Blocks1D
-from gpaw.response.groundstate import ResponseGroundStateAdapter
-
-
-class FourComponentSusceptibilityTensor:
-    """Class calculating the full four-component susceptibility tensor"""
-
-    def __init__(self, gs, fxc='ALDA', fxckwargs={},
-                 eta=0.2, ecut=50, gammacentered=False,
-                 disable_point_group=False, disable_time_reversal=False,
-                 bandsummation='pairwise', nbands=None, bundle_integrals=True,
-                 world=mpi.world, nblocks=1, txt=sys.stdout):
-        """
-        Currently, everything is in plane wave mode.
-        If additional modes are implemented, maybe look to fxc to see how
-        multiple modes can be supported.
-
-        Parameters
-        ----------
-        gs : see gpaw.response.chiks, gpaw.response.kslrf
-        fxc, fxckwargs : see gpaw.response.fxc
-        eta, ecut, gammacentered
-        disable_point_group,
-        disable_time_reversal,
-        bandsummation, nbands, bundle_integrals,
-        world, nblocks, txt : see gpaw.response.chiks, gpaw.response.kslrf
-        """
-        # Initiate output file and timer
-        self.world = world
-        self.fd = convert_string_to_fd(txt, world)
-        self.cfd = self.fd
-        self.timer = Timer()
-
-        # Load ground state calculation
-        self.calc = get_calc(gs, fd=self.fd, timer=self.timer)
-        self.gs = ResponseGroundStateAdapter(self.calc)
-
-        # The plane wave basis is defined by keywords
-        self.ecut = None if ecut is None else ecut / Hartree
-        self.gammacentered = gammacentered
-
-        # Initiate Kohn-Sham susceptibility and fxc objects
-        self.chiks = ChiKS(self.calc, eta=eta, ecut=ecut,
-                           gammacentered=gammacentered,
-                           disable_point_group=disable_point_group,
-                           disable_time_reversal=disable_time_reversal,
-                           bandsummation=bandsummation, nbands=nbands,
-                           bundle_integrals=bundle_integrals,
-                           world=world, nblocks=nblocks, txt=self.fd,
-                           timer=self.timer)
-        self.fxc = get_fxc(self.calc, fxc,
-                           response='susceptibility', mode='pw',
-                           world=self.chiks.world, txt=self.chiks.fd,
-                           timer=self.timer, **fxckwargs)
-
-        # Parallelization over frequencies depends on the frequency input
-        self.blocks1d = None
-
-    def get_macroscopic_component(self, spincomponent, q_c, frequencies,
-                                  filename=None, txt=None):
-        """Calculates the spatially averaged (macroscopic) component of the
-        susceptibility tensor and writes it to a file.
+from gpaw.response.pair_functions import (SingleQPWDescriptor, Chi,
+                                          get_pw_coordinates)
+from gpaw.response.chiks import ChiKSCalculator
+from gpaw.response.coulomb_kernels import get_coulomb_kernel
+from gpaw.response.fxc_kernels import FXCKernel, AdiabaticFXCCalculator
+from gpaw.response.dyson import DysonSolver, HXCKernel
+
+
+class ChiFactory:
+    r"""User interface to calculate individual elements of the four-component
+    susceptibility tensor χ^μν, see [PRB 103, 245110 (2021)]."""
+
+    def __init__(self,
+                 chiks_calc: ChiKSCalculator,
+                 fxc_calculator: AdiabaticFXCCalculator | None = None):
+        """Contruct a many-body susceptibility factory."""
+        self.chiks_calc = chiks_calc
+        self.gs = chiks_calc.gs
+        self.context = chiks_calc.context
+        self.dyson_solver = DysonSolver(self.context)
+
+        # If no fxc_calculator is supplied, fall back to default
+        if fxc_calculator is None:
+            fxc_calculator = AdiabaticFXCCalculator.from_rshe_parameters(
+                self.gs, self.context)
+        else:
+            assert fxc_calculator.gs is chiks_calc.gs
+            assert fxc_calculator.context is chiks_calc.context
+        self.fxc_calculator = fxc_calculator
+
+        # Prepare a buffer for the fxc kernels
+        self.fxc_kernel_cache: dict[str, FXCKernel] = {}
+
+    def __call__(self, spincomponent, q_c, complex_frequencies,
+                 fxc=None, hxc_scaling=None, txt=None) -> tuple[Chi, Chi]:
+        r"""Calculate a given element (spincomponent) of the four-component
+        Kohn-Sham susceptibility tensor and construct a corresponding many-body
+        susceptibility object within a given approximation to the
+        exchange-correlation kernel.
 
         Parameters
         ----------
-        spincomponent, q_c,
-        frequencies : see gpaw.response.chiks, gpaw.response.kslrf
-        filename : str
-            Save chiks_w and chi_w to file of given name.
-            Defaults to:
-            'chi%s_q«%+d-%+d-%+d».csv' % (spincomponent,
-                                          *tuple((q_c * kd.N_c).round()))
+        spincomponent : str
+            Spin component (μν) of the susceptibility.
+            Currently, '00', 'uu', 'dd', '+-' and '-+' are implemented.
+        q_c : list or ndarray
+            Wave vector
+        complex_frequencies : np.array or ComplexFrequencyDescriptor
+            Array of complex frequencies to evaluate the response function at
+            or a descriptor of those frequencies.
+        fxc : str (None defaults to ALDA)
+            Approximation to the (local) xc kernel.
+            Choices: RPA, ALDA, ALDA_X, ALDA_x
+        hxc_scaling : None or HXCScaling
+            Supply an HXCScaling object to scale the hxc kernel.
         txt : str
             Save output of the calculation of this specific component into
             a file with the filename of the given input.
-
-        Returns
-        -------
-        see calculate_macroscopic_component
         """
+        # Fall back to ALDA per default
+        if fxc is None:
+            fxc = 'ALDA'
 
-        if filename is None:
-            tup = (spincomponent,
-                   *tuple((q_c * self.calc.wfs.kd.N_c).round()))
-            filename = 'chi%s_q«%+d-%+d-%+d».csv' % tup
-
-        (omega_w,
-         chiks_w,
-         chi_w) = self.calculate_macroscopic_component(spincomponent, q_c,
-                                                       frequencies,
-                                                       txt=txt)
-
-        write_macroscopic_component(omega_w, chiks_w, chi_w,
-                                    filename, self.world)
-
-        return omega_w, chiks_w, chi_w
-
-    def calculate_macroscopic_component(self, spincomponent,
-                                        q_c, frequencies, txt=None):
-        """Calculates the spatially averaged (macroscopic) component of the
-        susceptibility tensor.
+        # Initiate new output file, if supplied
+        if txt is not None:
+            self.context.new_txt_and_timer(txt)
 
-        Parameters
-        ----------
-        spincomponent, q_c,
-        frequencies : see gpaw.response.chiks, gpaw.response.kslrf
-        txt : see get_macroscopic_component
-
-        Returns
-        -------
-        omega_w, chiks_w, chi_w : nd.array, nd.array, nd.array
-            omega_w: frequencies in eV
-            chiks_w: macroscopic dynamic susceptibility (Kohn-Sham system)
-            chi_w: macroscopic dynamic susceptibility
-        """
-        (pd, wd,
-         chiks_wGG, chi_wGG) = self.calculate_component(spincomponent, q_c,
-                                                        frequencies, txt=txt)
-
-        # Macroscopic component
-        chiks_w = chiks_wGG[:, 0, 0]
-        chi_w = chi_wGG[:, 0, 0]
-
-        # Collect data for all frequencies
-        omega_w = wd.omega_w * Hartree
-        chiks_w = self.collect(chiks_w)
-        chi_w = self.collect(chi_w)
-
-        return omega_w, chiks_w, chi_w
-
-    def get_component_array(self, spincomponent, q_c, frequencies,
-                            array_ecut=50, filename=None, txt=None):
-        """Calculates a specific spin component of the susceptibility tensor,
-        collects it as a numpy array in a reduced plane wave description
-        and writes it to a file.
+        # Print to output file
+        self.context.print('---------------', flush=False)
+        self.context.print('Calculating susceptibility spincomponent='
+                           f'{spincomponent} with q_c={q_c}', flush=False)
+        self.context.print('---------------')
 
-        Parameters
-        ----------
-        spincomponent, q_c,
-        frequencies : see gpaw.response.chiks, gpaw.response.kslrf
-        array_ecut : see calculate_component_array
-        filename : str
-            Save chiks_w and chi_w to pickle file of given name.
-            Defaults to:
-            'chi%sGG_q«%+d-%+d-%+d».pckl' % (spincomponent,
-                                             *tuple((q_c * kd.N_c).round()))
-        txt : str
-            Save output of the calculation of this specific component into
-            a file with the filename of the given input.
+        # Calculate chiks
+        chiks = self.calculate_chiks(spincomponent, q_c, complex_frequencies)
 
-        Returns
-        -------
-        see calculate_component_array
-        """
+        # Construct the hxc kernel
+        hartree_kernel = self.get_hartree_kernel(spincomponent, chiks.qpd)
+        xc_kernel = self.get_xc_kernel(fxc, spincomponent, chiks.qpd)
+        hxc_kernel = HXCKernel(hartree_kernel, xc_kernel, scaling=hxc_scaling)
 
-        if filename is None:
-            tup = (spincomponent,
-                   *tuple((q_c * self.gs.kd.N_c).round()))
-            filename = 'chi%sGG_q«%+d-%+d-%+d».pckl' % tup
-
-        (omega_w, G_Gc, chiks_wGG,
-         chi_wGG) = self.calculate_component_array(spincomponent,
-                                                   q_c,
-                                                   frequencies,
-                                                   array_ecut=array_ecut,
-                                                   txt=txt)
-
-        # Write susceptibilities to a pickle file
-        write_component(omega_w, G_Gc, chiks_wGG, chi_wGG,
-                        filename, self.world)
-
-        return omega_w, G_Gc, chiks_wGG, chi_wGG
-
-    def calculate_component_array(self, spincomponent, q_c, frequencies,
-                                  array_ecut=50, txt=None):
-        """Calculates a specific spin component of the susceptibility tensor
-        and collects it as a numpy array in a reduced plane wave description.
+        # Solve dyson equation
+        chi = self.dyson_solver(chiks, hxc_kernel)
 
-        Parameters
-        ----------
-        spincomponent, q_c,
-        frequencies : see gpaw.response.chiks, gpaw.response.kslrf
-        array_ecut : float
-            Energy cutoff for the reduced plane wave representation.
-            The susceptibility is returned in the reduced representation.
-
-        Returns
-        -------
-        omega_w, G_Gc, chiks_wGG, chi_wGG : nd.array(s)
-            omega_w: frequencies in eV
-            G_Gc : plane wave repr. as coordinates on the reciprocal lattice
-            chiks_wGG: dynamic susceptibility (Kohn-Sham system)
-            chi_wGG: dynamic susceptibility
-        """
-        (pd, wd,
-         chiks_wGG, chi_wGG) = self.calculate_component(spincomponent, q_c,
-                                                        frequencies, txt=txt)
+        return chiks, chi
 
-        # Get frequencies in eV
-        omega_w = wd.omega_w * Hartree
+    def get_hartree_kernel(self, spincomponent, qpd):
+        if spincomponent in ['+-', '-+']:
+            # No Hartree term in Dyson equation
+            return None
+        else:
+            return get_coulomb_kernel(qpd, self.gs.kd.N_c)
 
-        # Get susceptibility in a reduced plane wave representation
-        mask_G = get_pw_reduction_map(pd, array_ecut)
-        chiks_wGG = np.ascontiguousarray(chiks_wGG[:, mask_G, :][:, :, mask_G])
-        chi_wGG = np.ascontiguousarray(chi_wGG[:, mask_G, :][:, :, mask_G])
+    def get_xc_kernel(self,
+                      fxc: str,
+                      spincomponent: str,
+                      qpd: SingleQPWDescriptor):
+        """Get the requested xc-kernel object."""
+        if fxc == 'RPA':
+            # No xc-kernel
+            return None
+
+        if qpd.gammacentered:
+            # When using a gamma-centered plane-wave basis, we can reuse the
+            # fxc kernel for all q-vectors. Thus, we keep a cache of calculated
+            # kernels
+            key = f'{fxc},{spincomponent}'
+            if key not in self.fxc_kernel_cache:
+                self.fxc_kernel_cache[key] = self.fxc_calculator(
+                    fxc, spincomponent, qpd)
+            fxc_kernel = self.fxc_kernel_cache[key]
+        else:
+            # Always compute the kernel
+            fxc_kernel = self.fxc_calculator(fxc, spincomponent, qpd)
 
-        # Get reduced plane wave repr. as coordinates on the reciprocal lattice
-        G_Gc = get_pw_coordinates(pd)[mask_G]
+        return fxc_kernel
 
-        # Gather susceptibilities for all frequencies
-        chiks_wGG = self.gather(chiks_wGG, wd)
-        chi_wGG = self.gather(chi_wGG, wd)
+    def calculate_chiks(self, spincomponent, q_c, complex_frequencies):
+        """Calculate the Kohn-Sham susceptibility."""
+        q_c = np.asarray(q_c)
+        if isinstance(complex_frequencies, ComplexFrequencyDescriptor):
+            zd = complex_frequencies
+        else:
+            zd = ComplexFrequencyDescriptor.from_array(complex_frequencies)
 
-        return omega_w, G_Gc, chiks_wGG, chi_wGG
+        # Perform actual calculation
+        chiks = self.chiks_calc.calculate(spincomponent, q_c, zd)
+        # Distribute frequencies over world
+        chiks = chiks.copy_with_global_frequency_distribution()
 
-    def calculate_component(self, spincomponent, q_c, frequencies, txt=None):
-        """Calculate a single component of the susceptibility tensor.
+        return chiks
 
-        Parameters
-        ----------
-        spincomponent, q_c,
-        frequencies : see gpaw.response.chiks, gpaw.response.kslrf
 
-        Returns
-        -------
-        pd : PWDescriptor
-            Descriptor object for the plane wave basis
-        wd : FrequencyDescriptor
-            Descriptor object for the calculated frequencies
-        chiks_wGG : ndarray
-            The process' block of the Kohn-Sham susceptibility component
-        chi_wGG : ndarray
-            The process' block of the full susceptibility component
-        """
+def spectral_decomposition(chi, pos_eigs=1, neg_eigs=0):
+    """Decompose the susceptibility in terms of spectral functions.
 
-        # Initiate new call-output file, if supplied
-        if txt is not None:
-            # Store timer and close old call-output file
-            self.write_timer()
-            if str(self.fd) != str(self.cfd):
-                print('\nClosing, %s' % ctime(), file=self.cfd)
-                self.cfd.close()
-            # Initiate new output file
-            self.cfd = convert_string_to_fd(txt, self.world)
-        # Print to output file(s)
-        if str(self.fd) != str(self.cfd):
-            print('---------------', file=self.fd)
-            print(f'Calculating susceptibility spincomponent={spincomponent}'
-                  f'with q_c={q_c}', flush=True, file=self.fd)
-        if txt is not None:
-            print('---------------', file=self.fd)
-            print(f'Calculating susceptibility spincomponent={spincomponent}'
-                  f'with q_c={q_c}', file=self.cfd)
-            print('---------------', flush=True, file=self.cfd)
+    The full spectrum of induced excitations is extracted and separated into
+    contributions corresponding to the pos_eigs and neg_eigs largest positive
+    and negative eigenvalues respectively.
+    """
+    # Initiate an EigendecomposedSpectrum object with the full spectrum
+    full_spectrum = EigendecomposedSpectrum.from_chi(chi)
 
-        wd = FrequencyDescriptor.from_array_or_dict(frequencies)
+    # Separate the positive and negative eigenvalues for each frequency
+    Apos = full_spectrum.get_positive_eigenvalue_spectrum()
+    Aneg = full_spectrum.get_negative_eigenvalue_spectrum()
 
-        # Initialize parallelization over frequencies
-        self.blocks1d = Blocks1D(self.world, len(wd))
+    # Keep only a fixed number of eigenvalues
+    Apos = Apos.reduce_number_of_eigenvalues(pos_eigs)
+    Aneg = Aneg.reduce_number_of_eigenvalues(neg_eigs)
 
-        return self._calculate_component(spincomponent, q_c, wd)
+    return Apos, Aneg
 
-    def _calculate_component(self, spincomponent, q_c, wd):
-        """In-place calculation of the given spin-component."""
-        pd, chiks_wGG = self.calculate_ks_component(spincomponent, q_c,
-                                                    wd, txt=self.cfd)
 
-        Kxc_GG = self.get_xc_kernel(spincomponent, pd, chiks_wGG=chiks_wGG)
-        if spincomponent in ['+-', '-+']:
-            # No Hartree kernel
-            assert Kxc_GG is not None
-            Khxc_GG = Kxc_GG
-        else:
-            Khxc_GG = self.get_hartree_kernel(pd)
-            if Kxc_GG is not None:  # Kxc can be None in the RPA case
-                Khxc_GG += Kxc_GG
-
-        chi_wGG = self.invert_dyson(chiks_wGG, Khxc_GG)
-
-        print('\nFinished calculating component', file=self.cfd)
-        print('---------------', flush=True, file=self.cfd)
-
-        return pd, wd, chiks_wGG, chi_wGG
-
-    def get_xc_kernel(self, spincomponent, pd, **ignored):
-        return self.fxc(spincomponent, pd, txt=self.cfd)
-
-    def get_hartree_kernel(self, pd):
-        """Calculate the Hartree kernel"""
-        Kbare_G = get_coulomb_kernel(pd, self.gs.kd.N_c)
-        vsqrt_G = Kbare_G ** 0.5
-        Kh_GG = np.eye(len(vsqrt_G)) * vsqrt_G * vsqrt_G[:, np.newaxis]
-
-        return Kh_GG
-
-    def write_timer(self):
-        """Write timer to call-output file and initiate a new."""
-        self.timer.write(self.cfd)
-        self.timer = Timer()
-
-        # Update all other class instance timers
-        self.chiks.timer = self.timer
-        self.chiks.integrator.timer = self.timer
-        self.chiks.kspair.timer = self.timer
-        self.chiks.pme.timer = self.timer
-        self.fxc.timer = self.timer
+class EigendecomposedSpectrum:
+    """Data object for eigendecomposed susceptibility spectra."""
 
-    def calculate_ks_component(self, spincomponent, q_c, wd, txt=None):
-        """Calculate a single component of the Kohn-Sham susceptibility tensor.
+    def __init__(self, omega_w, G_Gc, s_we, v_wGe, A_w=None,
+                 wblocks: Blocks1D | None = None):
+        """Construct the EigendecomposedSpectrum.
 
         Parameters
         ----------
-        spincomponent, q_c : see gpaw.response.chiks, gpaw.response.kslrf
-        wd : see calculate_component
-
-        Returns
-        -------
-        pd : PWDescriptor
-            see gpaw.response.chiks, gpaw.response.kslrf
-        chiks_wGG : ndarray
-            The process' block of the Kohn-Sham susceptibility component
+        omega_w : np.array
+            Global array of frequencies in eV.
+        G_Gc : np.array
+            Reciprocal lattice vectors in relative coordinates.
+        s_we : np.array
+            Sorted eigenvalues (in decreasing order) at all frequencies.
+            Here, e is the eigenvalue index.
+        v_wGe : np.array
+            Eigenvectors for corresponding to the (sorted) eigenvalues. With
+            all eigenvalues present in the representation, v_Ge should
+            constitute the unitary transformation matrix between the eigenbasis
+            and the plane-wave representation.
+        A_w : np.array or None
+            Full spectral weight as a function of frequency. If given as None,
+            A_w will be calculated as the sum of all eigenvalues (equal to the
+            trace of the spectrum, if no eigenvalues have been discarded).
+        wblocks : Blocks1D
+            Frequency block parallelization, if any.
         """
-        # ChiKS calculates the susceptibility distributed over plane waves
-        pd, chiks_wGG = self.chiks.calculate(q_c, wd, txt=txt,
-                                             spincomponent=spincomponent)
+        self.omega_w = omega_w
+        self.G_Gc = G_Gc
 
-        # Redistribute memory, so each block has its own frequencies, but all
-        # plane waves (for easy invertion of the Dyson-like equation)
-        chiks_wGG = self.chiks.distribute_frequencies(chiks_wGG)
+        self.s_we = s_we
+        self.v_wGe = v_wGe
 
-        return pd, chiks_wGG
-
-    @timer('Invert dyson-like equation')
-    def invert_dyson(self, chiks_wGG, Khxc_GG):
-        """Invert the Dyson-like equation:
+        self._A_w = A_w
+        if wblocks is None:
+            # Create a serial Blocks1D instance
+            from gpaw.mpi import serial_comm
+            wblocks = Blocks1D(serial_comm, len(omega_w))
+        self.wblocks = wblocks
+
+    @classmethod
+    def from_chi(cls, chi):
+        """Construct the eigendecomposed spectrum of a given susceptibility.
+
+        The spectrum of induced excitations, S_GG'^(μν)(q,ω), which are encoded
+        in a given susceptibility, can be extracted directly from its the
+        dissipative part:
+
+                            1
+        S_GG'^(μν)(q,ω) = - ‾ χ_GG'^(μν")(q,ω)
+                            π
+        """
+        assert chi.distribution == 'zGG'
 
-        chi = chi_ks + chi_ks Khxc chi
+        # Extract the spectrum of induced excitations
+        chid = chi.copy_dissipative_part()
+        S_wGG = - chid.array / np.pi
+
+        # Extract frequencies (in eV) and reciprocal lattice vectors
+        omega_w = chid.zd.omega_w * Hartree
+        G_Gc = get_pw_coordinates(chid.qpd)
+
+        return cls.from_spectrum(omega_w, G_Gc, S_wGG, wblocks=chid.blocks1d)
+
+    @classmethod
+    def from_spectrum(cls, omega_w, G_Gc, S_wGG, wblocks=None):
+        """Perform an eigenvalue decomposition of a given spectrum."""
+        # Find eigenvalues and eigenvectors of the spectrum
+        s_wK, v_wGK = np.linalg.eigh(S_wGG)
+
+        # Sort by spectral intensity (eigenvalues in descending order)
+        sorted_indices_wK = np.argsort(-s_wK)
+        s_we = np.take_along_axis(s_wK, sorted_indices_wK, axis=1)
+        v_wGe = np.take_along_axis(
+            v_wGK, sorted_indices_wK[:, np.newaxis, :], axis=2)
+
+        return cls(omega_w, G_Gc, s_we, v_wGe, wblocks=wblocks)
+
+    @classmethod
+    def from_file(cls, filename):
+        """Construct the eigendecomposed spectrum from a .pckl file."""
+        import pickle
+        assert isinstance(filename, str) and filename[-5:] == '.pckl'
+        with open(filename, 'rb') as fd:
+            omega_w, G_Gc, s_we, v_wGe, A_w = pickle.load(fd)
+        return cls(omega_w, G_Gc, s_we, v_wGe, A_w=A_w)
+
+    def write(self, filename):
+        """Write the eigendecomposed spectrum as a .pckl file."""
+        import pickle
+        assert isinstance(filename, str) and filename[-5:] == '.pckl'
+
+        # Gather data from the different blocks of frequencies to root
+        s_we = self.wblocks.gather(self.s_we)
+        v_wGe = self.wblocks.gather(self.v_wGe)
+        A_w = self.wblocks.gather(self.A_w)
+
+        # Let root write the spectrum to a pickle file
+        if self.wblocks.blockcomm.rank == 0:
+            with open(filename, 'wb') as fd:
+                pickle.dump((self.omega_w, self.G_Gc, s_we, v_wGe, A_w), fd)
+
+    @property
+    def nG(self):
+        return self.G_Gc.shape[0]
+
+    @property
+    def neigs(self):
+        return self.s_we.shape[1]
+
+    @property
+    def A_w(self):
+        if self._A_w is None:
+            self._A_w = np.nansum(self.s_we, axis=1)
+        return self._A_w
+
+    @property
+    def A_wGG(self):
+        """Generate the spectrum from the eigenvalues and eigenvectors."""
+        A_wGG = np.empty((self.wblocks.nlocal, self.nG, self.nG),
+                         dtype=complex)
+        for w, (s_e, v_Ge) in enumerate(zip(self.s_we, self.v_wGe)):
+            emask = ~np.isnan(s_e)
+            svinv_eG = s_e[emask][:, np.newaxis] * np.conj(v_Ge.T[emask])
+            A_wGG[w] = v_Ge[:, emask] @ svinv_eG
+        return A_wGG
+
+    def get_positive_eigenvalue_spectrum(self):
+        """Create a new EigendecomposedSpectrum from the positive eigenvalues.
+
+        This is especially useful in order to separate the full spectrum of
+        induced excitations, see [PRB 103, 245110 (2021)],
+
+        S_GG'^μν(q,ω) = A_GG'^μν(q,ω) - A_(-G'-G)^νμ(-q,-ω)
+
+        into the ν and μ components of the spectrum. Since the spectral
+        function A_GG'^μν(q,ω) is positive definite or zero (in regions without
+        excitations), A_GG'^μν(q,ω) simply corresponds to the positive
+        eigenvalue contribution to the full spectrum S_GG'^μν(q,ω).
         """
-        print('Inverting Dyson-like equation', flush=True, file=self.cfd)
-        chi_wGG = np.empty_like(chiks_wGG)
-        for w, chiks_GG in enumerate(chiks_wGG):
-            chi_GG = invert_dyson_single_frequency(chiks_GG, Khxc_GG)
-
-            chi_wGG[w] = chi_GG
-
-        return chi_wGG
-
-    def collect(self, a_w):
-        """Collect frequencies from all blocks"""
-        return self.blocks1d.collect(a_w)
-
-    def gather(self, A_wGG, wd):
-        """Gather a full susceptibility array to root."""
-        # Allocate arrays to gather (all need to be the same shape)
-        blocks1d = self.blocks1d
-        shape = (blocks1d.blocksize,) + A_wGG.shape[1:]
-        tmp_wGG = np.empty(shape, dtype=A_wGG.dtype)
-        tmp_wGG[:blocks1d.nlocal] = A_wGG
-
-        # Allocate array for the gathered data
-        if self.world.rank == 0:
-            # Make room for all frequencies
-            Npadded = blocks1d.blocksize * blocks1d.blockcomm.size
-            shape = (Npadded,) + A_wGG.shape[1:]
-            allA_wGG = np.empty(shape, dtype=A_wGG.dtype)
+        # Find the maximum number of positive eigenvalues across the entire
+        # frequency range
+        if self.wblocks.nlocal > 0:
+            pos_we = self.s_we > 0.
+            npos_max = int(np.max(np.sum(pos_we, axis=1)))
         else:
-            allA_wGG = None
-
-        self.world.gather(tmp_wGG, 0, allA_wGG)
-
-        # Return array for w indeces on frequency grid
-        if allA_wGG is not None:
-            allA_wGG = allA_wGG[:len(wd), :, :]
-
-        return allA_wGG
-
-    def close(self):
-        self.timer.write(self.cfd)
-        print('\nClosing, %s' % ctime(), file=self.cfd)
-        self.cfd.close()
-        print('\nClosing, %s' % ctime(), file=self.fd)
-        self.fd.close()
-
-
-def invert_dyson_single_frequency(chiks_GG, Khxc_GG):
-    """Invert single frequency Dyson equation in plane wave basis:
-
-    chi_GG' = chiks_GG + chiks_GG1 Khxc_G1G2 chi_G2G'
-    """
-    enhancement_GG = np.linalg.inv(np.eye(len(chiks_GG)) -
-                                   np.dot(chiks_GG, Khxc_GG))
-    chi_GG = np.dot(enhancement_GG, chiks_GG)
-
-    return chi_GG
-
+            npos_max = 0
+        npos_max = self.wblocks.blockcomm.max(npos_max)
 
-def get_pw_reduction_map(pd, ecut):
-    """Get a mask to reduce the plane wave representation.
-
-    Please remark, that the response code currently works with one q-vector
-    at a time, at thus only a single plane wave representation at a time.
-
-    Returns
-    -------
-    mask_G : nd.array (dtype=bool)
-        Mask which reduces the representation
-    """
-    assert ecut is not None
-    ecut /= Hartree
-    assert ecut <= pd.ecut
-
-    # List of all plane waves
-    G_Gv = np.array([pd.G_Qv[Q] for Q in pd.Q_qG[0]])
-
-    if pd.gammacentered:
-        mask_G = ((G_Gv ** 2).sum(axis=1) <= 2 * ecut)
-    else:
-        mask_G = (((G_Gv + pd.K_qv[0]) ** 2).sum(axis=1) <= 2 * ecut)
-
-    return mask_G
-
-
-def get_pw_coordinates(pd):
-    """Get the reciprocal lattice vector coordinates corresponding to a
-    givne plane wave basis.
+        # Allocate new arrays filled with nan to accomodate all the positive
+        # eigenvalues
+        s_we = np.empty((self.wblocks.nlocal, npos_max),
+                        dtype=self.s_we.dtype)
+        v_wGe = np.empty((self.wblocks.nlocal, self.nG, npos_max),
+                         dtype=self.v_wGe.dtype)
+        s_we[:] = np.nan
+        v_wGe[:] = np.nan
+
+        # Fill arrays with the positive eigenvalue data
+        for w, (s_e, v_Ge) in enumerate(zip(self.s_we, self.v_wGe)):
+            pos_e = s_e > 0.
+            npos = np.sum(pos_e)
+            s_we[w, :npos] = s_e[pos_e]
+            v_wGe[w, :, :npos] = v_Ge[:, pos_e]
+
+        return EigendecomposedSpectrum(self.omega_w, self.G_Gc, s_we, v_wGe,
+                                       wblocks=self.wblocks)
+
+    def get_negative_eigenvalue_spectrum(self):
+        """Create a new EigendecomposedSpectrum from the negative eigenvalues.
+
+        The spectrum is created by reversing and negating the spectrum,
+
+        -S_GG'^μν(q,-ω) = -A_GG'^μν(q,-ω) + A_(-G'-G)^νμ(-q,ω),
+
+        from which the spectral function A_GG'^νμ(q,ω) can be extracted as the
+        positive eigenvalue contribution, thanks to the reciprocity relation
+
+                                  ˍˍ
+        χ_GG'^μν(q,ω) = χ_(-G'-G)^νμ(-q,ω),
+                   ˍ
+        in which n^μ(r) denotes the hermitian conjugate [n^μ(r)]^†, and which
+        is valid for μν ∊ {00,0z,zz,+-} in collinear systems without spin-orbit
+        coupling.
+        """
+        # Negate the spectral function, its frequencies and reverse the order
+        # of eigenvalues
+        omega_w = - self.omega_w
+        s_we = - self.s_we[:, ::-1]
+        v_wGe = self.v_wGe[..., ::-1]
+        inverted_spectrum = EigendecomposedSpectrum(omega_w, self.G_Gc,
+                                                    s_we, v_wGe,
+                                                    wblocks=self.wblocks)
+
+        return inverted_spectrum.get_positive_eigenvalue_spectrum()
+
+    def reduce_number_of_eigenvalues(self, neigs):
+        """Create a new spectrum with only the neigs largest eigenvalues.
+
+        The returned EigendecomposedSpectrum is constructed to retain knowledge
+        of the full spectral weight of the unreduced spectrum through the A_w
+        attribute.
+        """
+        assert self.neigs >= neigs
+        # Check that the available eigenvalues are in descending order
+        assert all([np.all(np.logical_not(s_e[1:] - s_e[:-1] > 0.))
+                    for s_e in self.s_we]),\
+            'Eigenvalues needs to be sorted in descending order!'
 
-    Please remark, that the response code currently works with one q-vector
-    at a time, at thus only a single plane wave representation at a time.
+        # Keep only the neigs largest eigenvalues
+        s_we = self.s_we[:, :neigs]
+        v_wGe = self.v_wGe[..., :neigs]
 
-    Returns
-    -------
-    G_Gc : nd.array (dtype=int)
-        Coordinates on the reciprocal lattice
-    """
-    # List of all plane waves
-    G_Gv = np.array([pd.G_Qv[Q] for Q in pd.Q_qG[0]])
+        return EigendecomposedSpectrum(self.omega_w, self.G_Gc, s_we, v_wGe,
+                                       # Keep the full spectral weight
+                                       A_w=self.A_w,
+                                       wblocks=self.wblocks)
 
-    # Use cell to get coordinates
-    B_cv = 2.0 * np.pi * pd.gd.icell_cv
-    return np.round(np.dot(G_Gv, np.linalg.inv(B_cv))).astype(int)
+    def get_eigenmode_lineshapes(self, nmodes=1):
+        """Extract the spectral lineshapes of the eigenmodes.
 
+        The spectral lineshape is calculated as the inner product
 
-def get_inverted_pw_mapping(pd1, pd2):
-    """Get the plane wave coefficients mapping GG' of pd1 into -G-G' of pd2"""
-    G1_Gc = get_pw_coordinates(pd1)
-    G2_Gc = get_pw_coordinates(pd2)
+        
+        a^μν_n(q,ω) = <v^μν_n(q)| A^μν(q,ω) |v^μν_n(q)>
 
-    mG2_G1 = []
-    for G1_c in G1_Gc:
-        found_match = False
-        for G2, G2_c in enumerate(G2_Gc):
-            if np.all(G2_c == -G1_c):
-                mG2_G1.append(G2)
-                found_match = True
-                break
-        if not found_match:
-            raise ValueError('Could not match pd1 and pd2')
+        where the eigenvectors |v^μν_n> diagonalize the full spectral function
+        at an appropriately chosen frequency ω_m:
 
-    # Set up mapping from GG' to -G-G'
-    invmap_GG = tuple(np.meshgrid(mG2_G1, mG2_G1, indexing='ij'))
+        S^μν(q,ω_m) |v^μν_n(q)> = s^μν_n(q,ω_m) |v^μν_n(q)>
+        """
+        wm = self.get_eigenmode_frequency(nmodes=nmodes)
+        v_Gm = self.get_eigenvectors_at_frequency(wm, nmodes=nmodes)
+        return self._get_eigenmode_lineshapes(v_Gm)
 
-    return invmap_GG
+    def get_eigenmode_frequency(self, nmodes=1):
+        """Get the frequency at which to extract the eigenmodes.
 
+        Generally, we chose the frequency ω_m to maximize the minimum
+        eigenvalue difference
 
-def symmetrize_reciprocity(pd, A_wGG):
-    """In collinear systems without spin-orbit coupling, the plane wave
-    susceptibility is reciprocal in the sense that e.g.
+        ω_m(q) = maxmin_ωn[s^μν_n(q,ω) - s^μν_n+1(q,ω)]
 
-    χ_(GG')^(+-)(q, ω) = χ_(-G'-G)^(+-)(-q, ω)
+        where n only runs over the desired number of modes (and the eigenvalues
+        are sorted in descending order).
 
-    This method symmetrizes A_wGG in the case where q=0.
-    """
-    from gpaw.test.response.test_chiks import get_inverted_pw_mapping
+        However, in the case where only a single mode is extracted, we use the
+        frequency at which the eigenvalue is maximal.
+        """
+        assert nmodes <= self.neigs
+        wblocks = self.wblocks
+        if nmodes == 1:
+            # Find frequency where the eigenvalue is maximal
+            s_w = wblocks.all_gather(self.s_we[:, 0])
+            wm = np.argmax(s_w)
+        else:
+            # Find frequency with maximum minimal difference between size of
+            # eigenvalues
+            ds_we = np.array([self.s_we[:, e] - self.s_we[:, e + 1]
+                              for e in range(nmodes - 1)]).T
+            dsmin_w = np.min(ds_we, axis=1)
+            dsmin_w = wblocks.all_gather(dsmin_w)
+            wm = np.argmax(dsmin_w)
+
+        return wm
+
+    def get_eigenvectors_at_frequency(self, wm, nmodes=1):
+        """Extract the eigenvectors a specific frequency index."""
+        wblocks = self.wblocks
+        root, wmlocal = wblocks.find_global_index(wm)
+        if wblocks.blockcomm.rank == root:
+            v_Ge = self.v_wGe[wmlocal]
+            v_Gm = np.ascontiguousarray(v_Ge[:, :nmodes])
+        else:
+            v_Gm = np.empty((self.nG, nmodes), dtype=complex)
+        wblocks.blockcomm.broadcast(v_Gm, root)
 
-    q_c = pd.kd.bzk_kc[0]
-    if np.allclose(q_c, 0.):
-        invmap_GG = get_inverted_pw_mapping(pd, pd)
-        for A_GG in A_wGG:
-            tmp_GG = np.zeros_like(A_GG)
-
-            # Symmetrize [χ_(GG')(q, ω) + χ_(-G'-G)(-q, ω)] / 2
-            tmp_GG += A_GG
-            tmp_GG += A_GG[invmap_GG].T
-            A_GG[:] = tmp_GG / 2.
-
-
-def write_macroscopic_component(omega_w, chiks_w, chi_w, filename, world):
-    """Write the spatially averaged dynamic susceptibility."""
-    assert isinstance(filename, str)
-    if world.rank == 0:
-        with Path(filename).open('w') as fd:
-            for omega, chiks, chi in zip(omega_w, chiks_w, chi_w):
-                print('%.6f, %.6f, %.6f, %.6f, %.6f' %
-                      (omega, chiks.real, chiks.imag, chi.real, chi.imag),
-                      file=fd)
-
-
-def read_macroscopic_component(filename):
-    """Read a stored macroscopic susceptibility file"""
-    d = np.loadtxt(filename, delimiter=',')
-    omega_w = d[:, 0]
-    chiks_w = np.array(d[:, 1], complex)
-    chiks_w.imag = d[:, 2]
-    chi_w = np.array(d[:, 3], complex)
-    chi_w.imag = d[:, 4]
-
-    return omega_w, chiks_w, chi_w
-
-
-def write_component(omega_w, G_Gc, chiks_wGG, chi_wGG, filename, world):
-    """Write the dynamic susceptibility as a pickle file."""
-    assert isinstance(filename, str)
-    if world.rank == 0:
-        with open(filename, 'wb') as fd:
-            pickle.dump((omega_w, G_Gc, chiks_wGG, chi_wGG), fd)
-
-
-def read_component(filename):
-    """Read a stored susceptibility component file"""
-    assert isinstance(filename, str)
-    with open(filename, 'rb') as fd:
-        omega_w, G_Gc, chiks_wGG, chi_wGG = pickle.load(fd)
+        return v_Gm
 
-    return omega_w, G_Gc, chiks_wGG, chi_wGG
+    def _get_eigenmode_lineshapes(self, v_Gm):
+        """Extract the eigenmode lineshape based on the mode eigenvectors."""
+        wblocks = self.wblocks
+        A_wGG = self.A_wGG
+        a_wm = np.empty((wblocks.nlocal, v_Gm.shape[1]), dtype=float)
+        for m, v_G in enumerate(v_Gm.T):
+            a_w = np.conj(v_G) @ A_wGG @ v_G
+            assert np.allclose(a_w.imag, 0.)
+            a_wm[:, m] = a_w.real
+        a_wm = wblocks.all_gather(a_wm)
+
+        return a_wm
+
+    def write_full_spectral_weight(self, filename):
+        A_w = self.wblocks.gather(self.A_w)
+        if self.wblocks.blockcomm.rank == 0:
+            write_full_spectral_weight(filename, self.omega_w, A_w)
+
+    def write_eigenmode_lineshapes(self, filename, nmodes=1):
+        a_wm = self.get_eigenmode_lineshapes(nmodes=nmodes)
+        if self.wblocks.blockcomm.rank == 0:
+            write_eigenmode_lineshapes(filename, self.omega_w, a_wm)
+
+
+def write_full_spectral_weight(filename, omega_w, A_w):
+    """Write the sum of spectral weights A(ω) to a file."""
+    with open(filename, 'w') as fd:
+        print('# {0:>11}, {1:>11}'.format('omega [eV]', 'A(w)'), file=fd)
+        for omega, A in zip(omega_w, A_w):
+            print('  {0:11.6f}, {1:11.6f}'.format(omega, A), file=fd)
+
+
+def read_full_spectral_weight(filename):
+    """Read a stored full spectral weight file."""
+    data = np.loadtxt(filename, delimiter=',')
+    omega_w = np.array(data[:, 0], float)
+    A_w = np.array(data[:, 1], float)
+    return omega_w, A_w
+
+
+def write_eigenmode_lineshapes(filename, omega_w, a_wm):
+    """Write the eigenmode lineshapes a^μν_n(ω) to a file."""
+    with open(filename, 'w') as fd:
+        # Print header
+        header = '# {0:>11}'.format('omega [eV]')
+        for m in range(a_wm.shape[1]):
+            header += ', {0:>11}'.format(f'a_{m}(w)')
+        print(header, file=fd)
+        # Print data
+        for omega, a_m in zip(omega_w, a_wm):
+            data = '  {0:11.6f}'.format(omega)
+            for a in a_m:
+                data += ', {0:11.6f}'.format(a)
+            print(data, file=fd)
+
+
+def read_eigenmode_lineshapes(filename):
+    """Read a stored eigenmode lineshapes file."""
+    data = np.loadtxt(filename, delimiter=',')
+    omega_w = np.array(data[:, 0], float)
+    a_wm = np.array(data[:, 1:], float)
+    return omega_w, a_wm
```

### Comparing `gpaw-22.8.0/gpaw/response/symmetry.py` & `gpaw-23.6.0/gpaw/response/symmetry.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,16 +1,17 @@
-import sys
 import functools
 
 import numpy as np
 from scipy.spatial import Delaunay, cKDTree
-from ase.utils.timing import timer
 
 from gpaw.kpt_descriptor import KPointDescriptor
 from gpaw.bztools import get_reduced_bz, unique_rows
+from _gpaw import GG_shuffle
+
+from gpaw.response import timer
 
 
 class KPointFinder:
     def __init__(self, bzk_kc):
         self.kdtree = cKDTree(self._round(bzk_kc))
 
     @staticmethod
@@ -25,71 +26,69 @@
                              'are commensurate with the k-point grid.')
 
         return k
 
 
 class PWSymmetryAnalyzer:
     """Class for handling planewave symmetries."""
-    def __init__(self, kd, pd, txt=sys.stdout,
+    def __init__(self, kd, qpd, context,
                  disable_point_group=False,
                  disable_non_symmorphic=True,
-                 disable_time_reversal=False,
-                 *, timer):
+                 disable_time_reversal=False):
         """Creates a PWSymmetryAnalyzer object.
 
         Determines which of the symmetries of the atomic structure
         that is compatible with the reciprocal lattice. Contains the
         necessary functions for mapping quantities between kpoints,
         and or symmetrizing arrays.
 
         kd: KPointDescriptor
             The kpoint descriptor containing the
             information about symmetries and kpoints.
-        pd: PWDescriptor
+        qpd: SingleQPWDescriptor
             Plane wave descriptor that contains the reciprocal
             lattice .
-        txt: str
-            Output file.
+        context: ResponseContext
         disable_point_group: bool
             Switch for disabling point group symmetries.
         disable_non_symmorphic:
             Switch for disabling non symmorphic symmetries.
         disable_time_reversal:
             Switch for disabling time reversal.
         """
-        self.pd = pd
+        self.qpd = qpd
         self.kd = kd
-        self.fd = txt
+        self.context = context
 
         assert disable_non_symmorphic, ('You are not allowed to use '
                                         'non-symmorphic syms, sorry.')
 
         # Settings
         self.disable_point_group = disable_point_group
         self.disable_time_reversal = disable_time_reversal
         self.disable_non_symmorphic = disable_non_symmorphic
         if (kd.symmetry.has_inversion or not kd.symmetry.time_reversal) and \
            not self.disable_time_reversal:
-            print('\nThe ground calculation does not support time-reversal ' +
-                  'symmetry possibly because it has an inversion center ' +
-                  'or that it has been manually deactivated. \n', file=self.fd)
+            self.context.print('\nThe ground calculation does not support time'
+                               '-reversal symmetry possibly because it has an '
+                               'inversion center or that it has been manually '
+                               'deactivated.\n')
             self.disable_time_reversal = True
 
         self.disable_symmetries = (self.disable_point_group and
                                    self.disable_time_reversal and
                                    self.disable_non_symmorphic)
 
         # Number of symmetries
         U_scc = kd.symmetry.op_scc
         self.nU = len(U_scc)
 
         self.nsym = 2 * self.nU
         self.use_time_reversal = not self.disable_time_reversal
 
-        self.timer = timer
         self.kptfinder = KPointFinder(kd.bzk_kc)
         self.initialize()
 
     @timer('Initialize')
     def initialize(self):
         """Initialize relevant quantities."""
         self.infostring = ''
@@ -114,21 +113,21 @@
 
         # Do the work
         self.analyze_symmetries()
         self.analyze_kpoints()
         self.initialize_G_maps()
 
         # Print info
-        print(self.infostring, file=self.fd)
+        self.context.print(self.infostring)
         self.print_symmetries()
 
     def print_symmetries(self):
         """Handsome print function for symmetry operations."""
 
-        p = functools.partial(print, file=self.fd)
+        p = functools.partial(self.context.print, flush=False)
 
         p()
         nx = 6 if self.disable_non_symmorphic else 3
         ns = len(self.s_s)
         y = 0
         for y in range((ns + nx - 1) // nx):
             for c in range(3):
@@ -137,15 +136,15 @@
                     if s == ns:
                         break
                     tmp = self.get_symmetry_operator(self.s_s[s])
                     op_cc, sign, TR, shift_c, ft_c = tmp
                     op_c = sign * op_cc[c]
                     p('  (%2d %2d %2d)' % tuple(op_c), end='')
                 p()
-            p()
+            self.context.print()  # flush output
 
     @timer('Analyze')
     def analyze_kpoints(self):
         """Calculate the reduction in the number of kpoints."""
         K_gK = self.group_kpoints()
         ng = len(K_gK)
         self.infostring += '{0} groups of equivalent kpoints. '.format(ng)
@@ -162,18 +161,18 @@
 
         Under time-reversal (indirect) it must fulfill::
 
           -U \mathbf{q} = q + \Delta
 
         where :math:`\Delta` is a reciprocal lattice vector.
         """
-        pd = self.pd
+        qpd = self.qpd
 
         # Shortcuts
-        q_c = pd.kd.bzk_kc[0]
+        q_c = qpd.q_c
         kd = self.kd
 
         U_scc = kd.symmetry.op_scc
         nU = self.nU
         nsym = self.nsym
 
         shift_sc = np.zeros((nsym, 3), int)
@@ -264,30 +263,30 @@
         U_scc = []
         for s in self.s_s:
             U_cc, sign, _, _, _ = self.get_symmetry_operator(s)
             U_scc.append(sign * U_cc)
         U_scc = np.array(U_scc)
 
         # Determine the irreducible BZ
-        bzk_kc, ibzk_kc = get_reduced_bz(self.pd.gd.cell_cv,
+        bzk_kc, ibzk_kc = get_reduced_bz(self.qpd.gd.cell_cv,
                                          U_scc,
                                          False)
 
         return bzk_kc
 
     def get_reduced_kd(self, pbc_c=np.ones(3, bool)):
         # Get the little group of q
         U_scc = []
         for s in self.s_s:
             U_cc, sign, _, _, _ = self.get_symmetry_operator(s)
             U_scc.append(sign * U_cc)
         U_scc = np.array(U_scc)
 
         # Determine the irreducible BZ
-        bzk_kc, ibzk_kc = get_reduced_bz(self.pd.gd.cell_cv,
+        bzk_kc, ibzk_kc = get_reduced_bz(self.qpd.gd.cell_cv,
                                          U_scc,
                                          False,
                                          pbc_c=pbc_c)
 
         n = 3
         N_xc = np.indices((n, n, n)).reshape((3, n**3)).T - n // 2
 
@@ -301,26 +300,26 @@
                 ik_kc = unique_rows(k_kc)
             elif len(k_kc):
                 ik_kc = unique_rows(np.append(k_kc, ik_kc, axis=0))
 
         return KPointDescriptor(ik_kc)
 
     def unfold_kpoints(self, points_pv, tol=1e-8, mod=None):
-        points_pc = np.dot(points_pv, self.pd.gd.cell_cv.T) / (2 * np.pi)
+        points_pc = np.dot(points_pv, self.qpd.gd.cell_cv.T) / (2 * np.pi)
 
         # Get the little group of q
         U_scc = []
         for s in self.s_s:
             U_cc, sign, _, _, _ = self.get_symmetry_operator(s)
             U_scc.append(sign * U_cc)
         U_scc = np.array(U_scc)
 
         points = np.concatenate(np.dot(points_pc, U_scc.transpose(0, 2, 1)))
         points = unique_rows(points, tol=tol, mod=mod)
-        points = np.dot(points, self.pd.gd.icell_cv) * (2 * np.pi)
+        points = np.dot(points, self.qpd.gd.icell_cv) * (2 * np.pi)
         return points
 
     def get_kpoint_weight(self, k_c):
         K = self.kptfinder.find(k_c)
         iK = self.kd.bz2ibz_k[K]
         K_k = self.unfold_ibz_kpoint(iK)
         K_gK = self.group_kpoints(K_k)
@@ -333,16 +332,16 @@
         """Get index of symmetry for mapping between K1 and K2"""
         s_s = self.s_s
         bz2bz_ks = self.kd.bz2bz_ks
         bzk2rbz_s = bz2bz_ks[K1][s_s]
         try:
             s = np.argwhere(bzk2rbz_s == K2)[0][0]
         except IndexError:
-            print('K = {0} cannot be mapped into K = {1}'.format(K1, K2),
-                  file=self.fd)
+            self.context.print(f'K = {K1} cannot be mapped into '
+                               f'K = {K2}')
             raise
         return s_s[s]
 
     def get_shift(self, K1, K2, U_cc, sign):
         """Get shift for mapping between K1 and K2."""
         kd = self.kd
         k1_c = kd.bzk_kc[K1]
@@ -366,35 +365,48 @@
         G_G, sign = self.map_G_vectors(K1, K2)
 
         s = self.get_kpoint_mapping(K1, K2)
         U_cc, _, TR, shift_c, ft_c = self.get_symmetry_operator(s)
 
         return TR(a_MG[..., G_G])
 
+    @timer('symmetrize_wGG')
     def symmetrize_wGG(self, A_wGG):
         """Symmetrize an array in GG'."""
-
+        
         for A_GG in A_wGG:
-            tmp_GG = np.zeros_like(A_GG)
+            tmp_GG = np.zeros_like(A_GG, order='C')
+            # tmp2_GG = np.zeros_like(A_GG)
 
             for s in self.s_s:
                 G_G, sign, _ = self.G_sG[s]
-                if sign == 1:
-                    tmp_GG += A_GG[G_G, :][:, G_G]
-                if sign == -1:
-                    tmp_GG += A_GG[G_G, :][:, G_G].T
+                GG_shuffle(G_G, sign, A_GG, tmp_GG)
 
+                # This is the exact operation that GG_shuffle does.
+                # Uncomment lines involving tmp2_GG to test the
+                # implementation in action:
+                #
+                # if sign == 1:
+                #     tmp2_GG += A_GG[G_G, :][:, G_G]
+                # if sign == -1:
+                #     tmp2_GG += A_GG[G_G, :][:, G_G].T
+            
+            # assert np.allclose(tmp_GG, tmp2_GG)
             A_GG[:] = tmp_GG / self.how_many_symmetries()
 
+    # Set up complex frequency alias
+    symmetrize_zGG = symmetrize_wGG
+
+    @timer('symmetrize_wxx')
     def symmetrize_wxx(self, A_wxx, optical_limit=False):
         """Symmetrize an array in xx'."""
         tmp_wxx = np.zeros_like(A_wxx)
 
-        A_cv = self.pd.gd.cell_cv
-        iA_cv = self.pd.gd.icell_cv
+        A_cv = self.qpd.gd.cell_cv
+        iA_cv = self.qpd.gd.icell_cv
 
         if self.use_time_reversal:
             AT_wxx = np.transpose(A_wxx, (0, 2, 1))
 
         for s in self.s_s:
             G_G, sign, shift_c = self.G_sG[s]
             if optical_limit:
@@ -419,18 +431,19 @@
                                                   (1, 0, 2)) * sign
                     tmp[:, :, 0:3] = np.dot(tmp[:, :, 0:3], M_vv) * sign
                 tmp_wxx += tmp
 
         # Inplace overwriting
         A_wxx[:] = tmp_wxx / self.how_many_symmetries()
 
+    @timer('symmetrize_wxvG')
     def symmetrize_wxvG(self, A_wxvG):
         """Symmetrize chi0_wxvG"""
-        A_cv = self.pd.gd.cell_cv
-        iA_cv = self.pd.gd.icell_cv
+        A_cv = self.qpd.gd.cell_cv
+        iA_cv = self.qpd.gd.icell_cv
 
         if self.use_time_reversal:
             # ::-1 corresponds to transpose in wing indices
             AT_wxvG = A_wxvG[:, ::-1]
 
         tmp_wxvG = np.zeros_like(A_wxvG)
         for s in self.s_s:
@@ -442,18 +455,19 @@
             elif sign == -1:
                 tmp = sign * np.dot(M_vv.T, AT_wxvG[..., G_G])
             tmp_wxvG += np.transpose(tmp, (1, 2, 0, 3))
 
         # Overwrite the input
         A_wxvG[:] = tmp_wxvG / self.how_many_symmetries()
 
+    @timer('symmetrize_wvv')
     def symmetrize_wvv(self, A_wvv):
         """Symmetrize chi_wvv."""
-        A_cv = self.pd.gd.cell_cv
-        iA_cv = self.pd.gd.icell_cv
+        A_cv = self.qpd.gd.cell_cv
+        iA_cv = self.qpd.gd.icell_cv
         tmp_wvv = np.zeros_like(A_wvv)
         if self.use_time_reversal:
             AT_wvv = np.transpose(A_wvv, (0, 2, 1))
 
         for s in self.s_s:
             G_G, sign, shift_c = self.G_sG[s]
             U_cc, _, TR, shift_c, ft_c = self.get_symmetry_operator(s)
@@ -473,16 +487,16 @@
 
         if len(a_Mv) == 0:
             return []
 
         if K1 == K2:
             return a_Mv
 
-        A_cv = self.pd.gd.cell_cv
-        iA_cv = self.pd.gd.icell_cv
+        A_cv = self.qpd.gd.cell_cv
+        iA_cv = self.qpd.gd.icell_cv
 
         # Get symmetry
         s = self.get_kpoint_mapping(K1, K2)
         U_cc, sign, TR, _, ft_c = self.get_symmetry_operator(s)
 
         # Create cartesian operator
         M_vv = np.dot(np.dot(A_cv.T, U_cc.T), iA_cv)
@@ -514,45 +528,46 @@
     def map_G_vectors(self, K1, K2):
         """Return G vector mapping."""
         s = self.get_kpoint_mapping(K1, K2)
         G_G, sign, shift_c = self.G_sG[s]
 
         return G_G, sign
 
+    @timer('Initialize_G_maps')
     def initialize_G_maps(self):
         """Calculate the Gvector mappings."""
-        pd = self.pd
-        B_cv = 2.0 * np.pi * pd.gd.icell_cv
-        G_Gv = pd.get_reciprocal_vectors(add_q=False)
+        qpd = self.qpd
+        B_cv = 2.0 * np.pi * qpd.gd.icell_cv
+        G_Gv = qpd.get_reciprocal_vectors(add_q=False)
         G_Gc = np.dot(G_Gv, np.linalg.inv(B_cv))
-        Q_G = pd.Q_qG[0]
+        Q_G = qpd.Q_qG[0]
 
         G_sG = [None] * self.nsym
         UG_sGc = [None] * self.nsym
         Q_sG = [None] * self.nsym
         for s in self.s_s:
             U_cc, sign, TR, shift_c, ft_c = self.get_symmetry_operator(s)
             iU_cc = np.linalg.inv(U_cc).T
             UG_Gc = np.dot(G_Gc - shift_c, sign * iU_cc)
 
             assert np.allclose(UG_Gc.round(), UG_Gc)
             UQ_G = np.ravel_multi_index(UG_Gc.round().astype(int).T,
-                                        pd.gd.N_c, 'wrap')
+                                        qpd.gd.N_c, 'wrap')
 
             G_G = len(Q_G) * [None]
             for G, UQ in enumerate(UQ_G):
                 try:
                     G_G[G] = np.argwhere(Q_G == UQ)[0][0]
                 except IndexError:
                     print('This should not be possible but' +
                           'a G-vector was mapped outside the sphere')
                     raise IndexError
             UG_sGc[s] = UG_Gc
             Q_sG[s] = UQ_G
-            G_sG[s] = [G_G, sign, shift_c]
+            G_sG[s] = [np.array(G_G, dtype=np.int32), sign, shift_c]
         self.G_Gc = G_Gc
         self.UG_sGc = UG_sGc
         self.Q_sG = Q_sG
         self.G_sG = G_sG
 
     def unfold_ibz_kpoint(self, ik):
         """Return kpoints related to irreducible kpoint."""
```

### Comparing `gpaw-22.8.0/gpaw/response/tool.py` & `gpaw-23.6.0/gpaw/response/tool.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,16 +1,16 @@
 import sys
 
 import numpy as np
 from scipy.optimize import leastsq
 
 from ase.units import Ha
-from gpaw.pw.descriptor import PWDescriptor
-from gpaw.kpt_descriptor import KPointDescriptor
-from gpaw.response.pair import PairDensity
+import gpaw.mpi as mpi
+from gpaw.response.pair_functions import SingleQPWDescriptor
+from gpaw.response.pair import PairDensityCalculator, get_gs_and_context
 
 
 def check_degenerate_bands(filename, etol):
 
     from gpaw import GPAW
     calc = GPAW(filename, txt=None)
     print('Number of Electrons   :', calc.get_number_of_electrons())
@@ -27,89 +27,94 @@
                 print(k, n, e_kn[k, n], e_kn[k, n - 1])
     return
 
 
 def get_orbitals(calc):
     """Get LCAO orbitals on 3D grid by lcao_to_grid method."""
 
-    bfs_a = [setup.phit_j for setup in calc.wfs.setups]
+    bfs_a = [setup.basis_functions_J for setup in calc.wfs.setups]
 
     from gpaw.lfc import BasisFunctions
     bfs = BasisFunctions(calc.wfs.gd, bfs_a, calc.wfs.kd.comm, cut=True)
     bfs.set_positions(calc.spos_ac)
 
     nLCAO = calc.get_number_of_bands()
     orb_MG = calc.wfs.gd.zeros(nLCAO)
     C_M = np.identity(nLCAO)
     bfs.lcao_to_grid(C_M, orb_MG, q=-1)
 
     return orb_MG
 
 
-def get_pw_descriptor(q_c, calc, ecut, gammacentered=False):
-    """Get the planewave descriptor of q_c."""
-    qd = KPointDescriptor([q_c])
-    pd = PWDescriptor(ecut, calc.wfs.gd,
-                      complex, qd, gammacentered=gammacentered)
-    return pd
-
-
 def get_bz_transitions(filename, q_c, bzk_kc,
                        spins='all',
                        ecut=50, txt=sys.stdout):
     """
     Get transitions in the Brillouin zone from kpoints bzk_kv
     contributing to the linear response at wave vector q_c.
     """
 
     ecut /= Ha
 
-    pair = PairDensity(filename, txt=txt)
-    pd = get_pw_descriptor(q_c, pair.calc, ecut)
+    gs, context = get_gs_and_context(filename, txt=txt, world=mpi.world,
+                                     timer=None)
 
-    bzk_kv = np.dot(bzk_kc, pd.gd.icell_cv) * 2 * np.pi
+    pair = PairDensityCalculator(gs=gs, context=context)
+    qpd = SingleQPWDescriptor.from_q(q_c, ecut, gs.gd)
+    bzk_kv = np.dot(bzk_kc, qpd.gd.icell_cv) * 2 * np.pi
 
     if spins == 'all':
-        spins = range(pair.calc.wfs.nspins)
+        spins = range(pair.gs.nspins)
     else:
         for spin in spins:
-            assert spin in range(pair.calc.wfs.nspins)
+            assert spin in range(pair.gs.nspins)
 
     domain_dl = (bzk_kv, spins)
     domainsize_d = [len(domain_l) for domain_l in domain_dl]
     nterms = np.prod(domainsize_d)
     domainarg_td = []
     for t in range(nterms):
         unravelled_d = np.unravel_index(t, domainsize_d)
         arg = []
         for domain_l, index in zip(domain_dl, unravelled_d):
             arg.append(domain_l[index])
         domainarg_td.append(tuple(arg))
 
-    return pair, pd, domainarg_td
+    return pair, qpd, domainarg_td
 
 
-def get_chi0_integrand(pair, pd, n_n, m_m, k_v, s):
+def get_chi0_integrand(pair, qpd, n_n, m_m, k_v, s):
     """
     Calculates the pair densities, occupational differences
     and energy differences of transitions from certain kpoint
     and spin.
     """
+    optical_limit = qpd.optical_limit
+    k_c = np.dot(qpd.gd.cell_cv, k_v) / (2 * np.pi)
 
-    k_c = np.dot(pd.gd.cell_cv, k_v) / (2 * np.pi)
-
-    kptpair = pair.get_kpoint_pair(pd, s, k_c, n_n[0], n_n[-1] + 1,
+    kptpair = pair.get_kpoint_pair(qpd, s, k_c, n_n[0], n_n[-1] + 1,
                                    m_m[0], m_m[-1] + 1)
 
-    n_nmG = pair.get_pair_density(pd, kptpair, n_n, m_m)
+    pairden_paw_corr = pair.gs.pair_density_paw_corrections
+    pawcorr = pairden_paw_corr(qpd)
+
     df_nm = kptpair.get_occupation_differences(n_n, m_m)
     eps_n = kptpair.kpt1.eps_n
     eps_m = kptpair.kpt2.eps_n
 
-    return n_nmG, df_nm, eps_n, eps_m
+    if optical_limit:
+        n_nmP = pair.get_optical_pair_density(qpd, kptpair, n_n, m_m,
+                                              pawcorr=pawcorr)
+
+        return n_nmP, df_nm, eps_n, eps_m
+    else:
+        n_nmG = pair.get_pair_density(qpd, kptpair, n_n, m_m,
+                                      pawcorr=pawcorr)
+
+        return n_nmG, df_nm, eps_n, eps_m
 
 
 def get_degeneracy_matrix(eps_n, tol=1.e-3):
     """
     Generate a matrix that can sum over degenerate values.
     """
     degmat = []
```

### Comparing `gpaw-22.8.0/gpaw/response/wgg.py` & `gpaw-23.6.0/gpaw/response/wgg.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/response/wstc.py` & `gpaw-23.6.0/gpaw/hybrids/wstc.py`

 * *Files 9% similar despite different names*

```diff
@@ -5,46 +5,37 @@
     Ravishankar Sundararaman and T. A. Arias:
     Phys. Rev. B 87, 165122 (2013)
 
     Regularization of the Coulomb singularity in exact exchange by
     Wigner-Seitz truncated interactions: Towards chemical accuracy
     in nontrivial systems
 """
-import sys
 from math import pi
 
 import numpy as np
 from scipy.special import erf
 from ase.units import Bohr
 from ase.utils import seterr
 
 import gpaw.mpi as mpi
 from gpaw.fftw import get_efficient_fft_size
 from gpaw.grid_descriptor import GridDescriptor
 
 
 class WignerSeitzTruncatedCoulomb:
-    def __init__(self, cell_cv, nk_c, txt=None):
-        txt = txt or sys.stdout
+    def __init__(self, cell_cv, nk_c):
         self.nk_c = nk_c
         bigcell_cv = cell_cv * nk_c[:, np.newaxis]
         L_c = (np.linalg.inv(bigcell_cv)**2).sum(0)**-0.5
-
-        rc = 0.5 * L_c.min()
-        print('Inner radius for %dx%dx%d Wigner-Seitz cell: %.3f Ang' %
-              (tuple(nk_c) + (rc * Bohr,)), file=txt)
-
-        self.a = 5 / rc
-        print('Range-separation parameter: %.3f Ang^-1' % (self.a / Bohr),
-              file=txt)
+        
+        self.rc = 0.5 * L_c.min()
+        self.a = 5 / self.rc
 
         nr_c = [get_efficient_fft_size(2 * int(L * self.a * 3.0))
                 for L in L_c]
-        print('FFT size for calculating truncated Coulomb: %dx%dx%d' %
-              tuple(nr_c), file=txt)
 
         self.gd = GridDescriptor(nr_c, bigcell_cv, comm=mpi.serial_comm)
         v_ijk = self.gd.empty()
 
         pos_ijkv = self.gd.get_grid_point_coordinates().transpose((1, 2, 3, 0))
         corner_xv = np.dot(np.indices((2, 2, 2)).reshape((3, 8)).T, bigcell_cv)
 
@@ -57,15 +48,26 @@
                 r_jk = (d_jkxv**2).sum(axis=3).min(2)**0.5
                 v_jk[:] = erf(self.a * r_jk) / r_jk
 
         # Fix 0/0 corner value:
         v_ijk[0, 0, 0] = 2 * self.a / pi**0.5
 
         self.K_Q = np.fft.fftn(v_ijk) * self.gd.dv
-
+    
+    def get_description(self):
+        descriptors = []
+        descriptors.append('Inner radius for %dx%dx%d Wigner-Seitz cell: '
+                           '%.3f Ang' % (tuple(self.nk_c) + (self.rc * Bohr,)))
+        descriptors.append('Range-separation parameter: %.3f Ang^-1' % (
+            self.a / Bohr))
+        descriptors.append('FFT size for calculating truncated Coulomb: '
+                           '%dx%dx%d' % tuple(self.gd.N_c))
+        
+        return '\n'.join(descriptors)
+    
     def get_potential(self, pd, q_v=None):
         q_c = pd.kd.bzk_kc[0]
         shift_c = (q_c * self.nk_c).round().astype(int)
         max_c = self.gd.N_c // 2
         K_G = pd.zeros()
         N_c = pd.gd.N_c
         if pd.dtype == complex:
```

### Comparing `gpaw-22.8.0/gpaw/rotation.py` & `gpaw-23.6.0/gpaw/rotation.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/scf.py` & `gpaw-23.6.0/gpaw/scf.py`

 * *Files 2% similar despite different names*

```diff
@@ -2,14 +2,15 @@
 import warnings
 
 import numpy as np
 from ase.units import Ha
 
 from gpaw import KohnShamConvergenceError
 from gpaw.convergence_criteria import check_convergence
+from gpaw.forces import calculate_forces
 
 
 class SCFLoop:
     """Self-consistent field loop."""
     def __init__(self, criteria, maxiter=100, niter_fixdensity=None):
         self.criteria = criteria
         self.maxiter = maxiter
@@ -45,14 +46,15 @@
         self.eigensolver_used = None
 
     def irun(self, wfs, ham, dens, log, callback):
 
         self.eigensolver_used = getattr(wfs.eigensolver, "name", None)
         self.check_eigensolver_state(wfs, ham, dens)
         self.niter = 1
+        converged = False
 
         while self.niter <= self.maxiter:
             self.iterate_eigensolver(wfs, ham, dens)
 
             self.check_convergence(
                 dens, ham, wfs, log, callback)
             yield
@@ -218,14 +220,19 @@
     def __init__(self, dens, ham, wfs, niter, log):
         self.dens = dens
         self.ham = ham
         self.wfs = wfs
         self.niter = niter
         self.log = log
 
+    def calculate_forces(self):
+        with self.wfs.timer('Forces'):
+            F_av = calculate_forces(self.wfs, self.dens, self.ham)
+        return F_av
+
 
 oops = """
 Did not converge!
 
 Here are some tips:
 
 1) Make sure the geometry and spin-state is physically sound.
```

### Comparing `gpaw-22.8.0/gpaw/setup.py` & `gpaw-23.6.0/gpaw/setup.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,12 +1,11 @@
 from __future__ import annotations
 import functools
 from io import StringIO
 from math import pi, sqrt
-from typing import List, Tuple
 import ase.units as units
 import numpy as np
 from ase.data import chemical_symbols
 
 from gpaw import debug
 from gpaw.basis_data import Basis
 from gpaw.gaunt import gaunt, nabla
@@ -16,49 +15,31 @@
 from gpaw.spline import Spline
 from gpaw.utilities import pack, unpack
 from gpaw.xc import XC
 from gpaw.new import zip
 from gpaw.xc.ri.spherical_hse_kernel import RadialHSE
 
 
-def parse_hubbard_string(type: str) -> Tuple[str,
-                                             List[int],
-                                             List[float],
-                                             List[bool]]:
-    # Parse DFT+U parameters from type-string:
-    # Examples: "type:l,U" or "type:l,U,scale"
-    type, lus = type.split(':')
-    if type == '':
-        type = 'paw'
-
-    l = []
-    U = []
-    scale = []
-
-    for lu in lus.split(';'):  # Multiple U corrections
-        l_, u_, scale_ = (lu + ',,').split(',')[:3]
-        l.append('spdf'.find(l_))
-        U.append(float(u_) / units.Hartree)
-        if scale_:
-            scale.append(bool(int(scale_)))
-        else:
-            scale.append(True)
-    return type, l, U, scale
+class WrongMagmomForHundsRuleError(ValueError):
+    """
+    Custom error for catching bad magnetic moments in Hund's rule calculation
+    """
 
 
 def create_setup(symbol, xc='LDA', lmax=0,
                  type='paw', basis=None, setupdata=None,
                  filter=None, world=None):
     if isinstance(xc, str):
         xc = XC(xc)
 
     if isinstance(type, str) and ':' in type:
-        type, l, U, scale = parse_hubbard_string(type)
+        from gpaw.hubbard import parse_hubbard_string
+        type, hubbard_u = parse_hubbard_string(type)
     else:
-        U = None
+        hubbard_u = None
 
     if setupdata is None:
         if type == 'hgh' or type == 'hgh.sc':
             lmax = 0
             from gpaw.hgh import HGHSetupData, sc_setups, setups
             if type == 'hgh.sc':
                 table = sc_setups
@@ -96,17 +77,19 @@
                                  'functional.  This calculation would use '
                                  'the %s functional.' % xc.get_setup_name())
         else:
             setupdata = SetupData(symbol, xc.get_setup_name(),
                                   type, True,
                                   world=world)
     if hasattr(setupdata, 'build'):
-        setup = LeanSetup(setupdata.build(xc, lmax, basis, filter))
-        if U is not None:
-            setup.set_hubbard_u(U, l, scale)
+        # It is not so nice that we have hubbard_u floating around here.
+        # For example, none of the other setup types are aware
+        # of hubbard u, so they silently ignore it!
+        setup = LeanSetup(setupdata.build(xc, lmax, basis, filter),
+                          hubbard_u=hubbard_u)
         return setup
     else:
         return setupdata
 
 
 def correct_occ_numbers(f_j,
                         degeneracy_j,
@@ -151,14 +134,15 @@
     This makes it possible to inherit the most important methods without
     the cumbersome constructor of the ordinary Setup class.
 
     Maybe this class will be removed in the future, or it could be
     made a proper base class with attributes and so on."""
 
     orbital_free = False
+    hubbard_u = None  # XXX remove me
 
     def print_info(self, text):
         self.data.print_info(text, self)
 
     def get_basis_description(self):
         return self.basis.get_description()
 
@@ -171,20 +155,20 @@
         # XXX ugly hack for pseudopotentials:
         if not hasattr(self, 'pseudo_partial_waves_j'):
             return []
 
         # The zip may cut off part of phit_j if there are more states than
         # projectors.  This should be the correct behaviour for all the
         # currently supported PAW/pseudopotentials.
-        phit_j = []
+        partial_waves_j = []
         for n, phit in zip(self.n_j, self.pseudo_partial_waves_j,
                            strict=False):
             if n > 0:
-                phit_j.append(phit)
-        return phit_j
+                partial_waves_j.append(phit)
+        return partial_waves_j
 
     def calculate_initial_occupation_numbers(self, magmom, hund, charge,
                                              nspins, f_j=None):
         """If f_j is specified, custom occupation numbers will be used.
 
         Hund rules disabled if so."""
 
@@ -248,19 +232,19 @@
 
         # Projector function indices:
         nj = len(self.n_j)  # or l_j?  Seriously.
 
         # distribute to the atomic wave functions
         i = 0
         j = 0
-        for phit in self.phit_j:
+        for phit in self.basis_functions_J:
             l = phit.get_angular_momentum_number()
 
             # Skip functions not in basis set:
-            while j < nj and self.l_orb_j[j] != l:
+            while j < nj and self.l_orb_J[j] != l:
                 j += 1
             if j < len(f_j):  # lengths of f_j and l_j may differ
                 f = f_j[j]
                 f_s = f_sj[:, j]
             else:
                 f = 0
                 f_s = np.array([0, 0])
@@ -281,26 +265,26 @@
                 for s in range(nspins):
                     f_si[s, i:i + degeneracy] = f_s[s] / degeneracy
 
             i += degeneracy
             j += 1
 
         if hund and magmom != 0:
-            raise ValueError(
+            raise WrongMagmomForHundsRuleError(
                 f'Bad magnetic moment {magmom:g} for {self.symbol} atom!')
         assert i == nao
 
         # print('fsi=', f_si)
         return f_si
 
     def get_hunds_rule_moment(self, charge=0):
         for M in range(10):
             try:
                 self.calculate_initial_occupation_numbers(M, True, charge, 2)
-            except ValueError:
+            except WrongMagmomForHundsRuleError:
                 pass
             else:
                 return M
         raise RuntimeError
 
     def initialize_density_matrix(self, f_si):
         nspins, nao = f_si.shape
@@ -308,15 +292,15 @@
 
         D_sii = np.zeros((nspins, ni, ni))
         D_sp = np.zeros((nspins, ni * (ni + 1) // 2))
         nj = len(self.pt_j)
         j = 0
         i = 0
         ib = 0
-        for phit in self.phit_j:
+        for phit in self.basis_functions_J:
             l = phit.get_angular_momentum_number()
             # Skip functions not in basis set:
             while j < nj and self.l_j[j] != l:
                 i += 2 * self.l_j[j] + 1
                 j += 1
             if j == nj:
                 break
@@ -377,35 +361,14 @@
             phi_g = phi_g.copy()
             phit_g = phit_g.copy()
             phi_g[gcut2:] = phit_g[gcut2:] = 0.0
             phi_j.append(self.rgd.spline(phi_g, rcut2, l, points=100))
             phit_j.append(self.rgd.spline(phit_g, rcut2, l, points=100))
         return phi_j, phit_j, nc, nct, tauc, tauct
 
-    def set_hubbard_u(self, U, l, scale=1, store=0, LinRes=0):
-        """Set Hubbard parameter.
-        U in atomic units, l is the orbital to which we whish to
-        add a hubbard potential and scale enables or desables the
-        scaling of the overlap between the l orbitals, if true we enforce
-        <p|p>=1
-        Note U is in atomic units
-        """
-
-        self.HubLinRes = LinRes
-        self.Hubs = scale
-        self.HubStore = store
-        self.HubOcc = []
-        self.HubU = U
-        self.Hubl = l
-        self.Hubi = 0
-        for ll in self.l_j:
-            if ll == self.Hubl:
-                break
-            self.Hubi = self.Hubi + 2 * ll + 1
-
     def four_phi_integrals(self):
         """Calculate four-phi integral.
 
         Calculate the integral over the product of four all electron
         functions in the augmentation sphere, i.e.::
 
           /
@@ -480,16 +443,16 @@
         # I4_iip = np.empty((ni, ni, _np)):
         # for p in range(_np):
         #     I4_iip[..., p] = unpack(I4_pp[:, p])
 
         return self.I4_pp
 
     def get_default_nbands(self):
-        assert len(self.l_orb_j) == len(self.n_j), (self.l_orb_j, self.n_j)
-        return sum([2 * l + 1 for (l, n) in zip(self.l_orb_j, self.n_j)
+        assert len(self.l_orb_J) == len(self.n_j), (self.l_orb_J, self.n_j)
+        return sum([2 * l + 1 for (l, n) in zip(self.l_orb_J, self.n_j)
                     if n > 0])
 
     def calculate_coulomb_corrections(self, wn_lqg, wnt_lqg, wg_lg, wnc_g,
                                       wmct_g):
         """Calculate "Coulomb" energies."""
         # Can we reduce the excessive parameter passing?
         # Seems so ....
@@ -555,15 +518,15 @@
         wmct_g = wnct_g + self.Delta0 * wg_lg[0]
         return wg_lg, wn_lqg, wnt_lqg, wnc_g, wnct_g, wmct_g
 
     def calculate_yukawa_interaction(self, gamma):
         """Calculate and return the Yukawa based interaction."""
         if self._Mg_pp is not None and gamma == self._gamma:
             return self._Mg_pp  # Cached
-        
+
         # Solves the radial screened poisson equation for density n_g
         def Yuk(self, n_g, l):
             """Solve radial screened poisson for density n_g."""
             gamma = self._gamma
             return self.local_corr.rgd2.yukawa(n_g, l, gamma) * \
                 self.local_corr.rgd2.r_g * self.local_corr.rgd2.dr_g
 
@@ -571,15 +534,15 @@
         self._Mg_pp = self.calculate_vvx_interactions(Yuk)
         return self._Mg_pp
 
     def calculate_erfc_interaction(self, omega):
         """Calculate and return erfc based valence valence
            exchange interactions."""
         hse = RadialHSE(self.local_corr.rgd2, omega).screened_coulomb_dv
-        
+
         def erfc_interaction(_, n_g, l):
             return hse(n_g, l)
         return self.calculate_vvx_interactions(erfc_interaction)
 
     def calculate_vvx_interactions(self, interaction):
         """Calculate valence valence interactions for generic
            interaction."""
@@ -591,34 +554,39 @@
 
 
 class LeanSetup(BaseSetup):
     """Setup class with minimal attribute set.
 
     A setup-like class must define at least the attributes of this
     class in order to function in a calculation."""
-    def __init__(self, s):
+    def __init__(self, s, hubbard_u=None):
         """Copies precisely the necessary attributes of the Setup s."""
-        # R_sii and HubU can be changed dynamically (which is ugly)
+        # Hubbard U is poked onto the setup in hacky ways.
+        # This needs cleaning.
+        self.hubbard_u = hubbard_u
+
+        # R_sii can be changed dynamically (which is ugly)
         self.R_sii = None  # rotations, initialized when doing sym. reductions
-        self.HubU = s.HubU  # XXX probably None
         self.lq = s.lq  # Required for LDA+U I think.
         self.type = s.type  # required for writing to file
         self.fingerprint = s.fingerprint  # also req. for writing
         self.filename = s.filename
 
         self.symbol = s.symbol
         self.Z = s.Z
         self.Nv = s.Nv
         self.Nc = s.Nc
 
         self.ni = s.ni
         self.nao = s.nao
 
         self.pt_j = s.pt_j
-        self.phit_j = s.phit_j  # basis functions
+
+        self.pseudo_partial_waves_j = s.pseudo_partial_waves_j
+        self.basis_functions_J = s.basis_functions_J
 
         self.Nct = s.Nct
         self.nct = s.nct
 
         self.lmax = s.lmax
         self.ghat_l = s.ghat_l
         self.vbar = s.vbar
@@ -641,15 +609,15 @@
 
         self.xc_correction = s.xc_correction
 
         # Required to calculate initial occupations
         self.f_j = s.f_j
         self.n_j = s.n_j
         self.l_j = s.l_j
-        self.l_orb_j = s.l_orb_j
+        self.l_orb_J = s.l_orb_J
         self.nj = len(s.l_j)
 
         self.data = s.data
 
         # Below are things which are not really used all that much,
         # i.e. shouldn't generally be necessary.  Maybe we can make a system
         # involving dictionaries for these "optional" parameters
@@ -781,28 +749,26 @@
     ``ghat_l`` Compensation charge expansion functions
     ``tauct``  Pseudo core kinetic energy density
     ========== ============================================
     """
     def __init__(self, data, xc, lmax=0, basis=None, filter=None):
         self.type = data.name
 
-        self.HubU = None
-
         if not data.is_compatible(xc):
             raise ValueError('Cannot use %s setup with %s functional' %
                              (data.setupname, xc.get_setup_name()))
 
         self.symbol = data.symbol
         self.data = data
 
         self.Nc = data.Nc
         self.Nv = data.Nv
         self.Z = data.Z
         l_j = self.l_j = data.l_j
-        self.l_orb_j = data.l_orb_j
+        self.l_orb_J = data.l_orb_J
         n_j = self.n_j = data.n_j
         self.f_j = data.f_j
         self.eps_j = data.eps_j
         nj = self.nj = len(l_j)
         rcut_j = self.rcut_j = data.rcut_j
 
         self.ExxC = data.ExxC
@@ -920,24 +886,25 @@
 
         self.pt_j = self.create_projectors(pt_jg, rcutfilter)
 
         partial_waves = self.create_basis_functions(phit_jg, rcut2, gcut2)
         self.pseudo_partial_waves_j = partial_waves.tosplines()
 
         if basis is None:
-            phit_j = self.pseudo_partial_waves_j
             basis = partial_waves
+            basis_functions_J = self.pseudo_partial_waves_j
         else:
-            phit_j = basis.tosplines()
-        self.phit_j = phit_j
+            basis_functions_J = basis.tosplines()
+
+        self.basis_functions_J = basis_functions_J
         self.basis = basis
 
         self.nao = 0
-        for phit in self.phit_j:
-            l = phit.get_angular_momentum_number()
+        for bf in self.basis_functions_J:
+            l = bf.get_angular_momentum_number()
             self.nao += 2 * l + 1
 
         rgd2 = self.local_corr.rgd2 = rgd.new(gcut2)
         r_g = rgd2.r_g
         dr_g = rgd2.dr_g
         phi_jg = np.array([phi_g[:gcut2].copy() for phi_g in phi_jg])
         phit_jg = np.array([phit_g[:gcut2].copy() for phit_g in phit_jg])
@@ -1268,38 +1235,39 @@
         #
         r_g = self.rgd.r_g
         x = (r_g[gcut2:gcut3] - rcut2) / (rcut3 - rcut2)
         a_g = 4 * x**3 * (1 - 0.75 * x)
         b_g = x**3 * (x - 1) * (rcut3 - rcut2)
 
         class PartialWaveBasis(Basis):  # yuckkk
-            def __init__(self, symbol, phit_j):
+            def __init__(self, symbol, phit_J):
                 Basis.__init__(self, symbol, 'partial-waves', readxml=False)
-                self.phit_j = phit_j
+                self._basis_functions_J = phit_J
 
             def tosplines(self):
-                return self.phit_j
+                return self._basis_functions_J
 
             def get_description(self):
                 template = 'Using partial waves for %s as LCAO basis'
                 string = template % self.symbol
                 return string
 
-        phit_j = []
+        basis_functions_J = []
         for j, phit_g in enumerate(phit_jg):
             if self.n_j[j] > 0:
                 l = self.l_j[j]
                 phit_g = phit_g.copy()
                 phit = phit_g[gcut3]
                 dphitdr = ((phit - phit_g[gcut3 - 1]) /
                            (r_g[gcut3] - r_g[gcut3 - 1]))
                 phit_g[gcut2:gcut3] -= phit * a_g + dphitdr * b_g
                 phit_g[gcut3:] = 0.0
-                phit_j.append(self.rgd.spline(phit_g, rcut3, l, points=100))
-        basis = PartialWaveBasis(self.symbol, phit_j)
+                basis_function = self.rgd.spline(phit_g, rcut3, l, points=100)
+                basis_functions_J.append(basis_function)
+        basis = PartialWaveBasis(self.symbol, basis_functions_J)
         return basis
 
     def calculate_oscillator_strengths(self, phi_jg):
         # XXX implement oscillator strengths for lcorehole != 0
         assert self.lcorehole == 0
         self.A_ci = np.zeros((3, self.ni))
         nj = len(phi_jg)
@@ -1328,15 +1296,15 @@
 
     ``nvalence``    Number of valence electrons.
     ``nao``         Number of atomic orbitals.
     ``Eref``        Reference energy.
     ``core_charge`` Core hole charge.
     """
 
-    def __init__(self, Z_a, setup_types, basis_sets, xc,
+    def __init__(self, Z_a, setup_types, basis_sets, xc, *,
                  filter=None, world=None):
         list.__init__(self)
         symbols = [chemical_symbols[Z] for Z in Z_a]
         type_a = types2atomtypes(symbols, setup_types, default='paw')
         basis_a = types2atomtypes(symbols, basis_sets, default=None)
 
         for a, _type in enumerate(type_a):
@@ -1465,51 +1433,62 @@
             if id not in e:
                 G, de, e0 = ekin(self.setups[id])
                 e[id] = -dekindecut(G, de, ecut)
             dedecut += e[id]
         return dedecut
 
     def basis_indices(self):
-        return FunctionIndices([setup.phit_j for setup in self])
+        return FunctionIndices([setup.basis_functions_J for setup in self])
 
     def projector_indices(self):
         return FunctionIndices([setup.pt_j for setup in self])
 
-    def create_pseudo_core_densities(self, layout, positions, atomdist):
+    def create_pseudo_core_densities(self, layout, positions, atomdist,
+                                     xp=np):
         spline_aj = []
         for setup in self:
             if setup.nct is None:
                 spline_aj.append([])
             else:
                 spline_aj.append([setup.nct])
         return layout.atom_centered_functions(
             spline_aj, positions,
             atomdist=atomdist,
             integral=[setup.Nct for setup in self],
-            cut=True)
+            cut=True, xp=xp)
 
-    def create_local_potentials(self, layout, positions, atomdist):
+    def create_local_potentials(self, layout, positions, atomdist, xp=np):
         return layout.atom_centered_functions(
-            [[setup.vbar] for setup in self], positions, atomdist=atomdist)
+            [[setup.vbar] for setup in self], positions,
+            atomdist=atomdist, xp=xp)
 
-    def create_compensation_charges(self, layout, positions, atomdist):
+    def create_compensation_charges(self, layout, positions, atomdist,
+                                    xp=np):
         return layout.atom_centered_functions(
             [setup.ghat_l for setup in self], positions,
             atomdist=atomdist,
-            integral=sqrt(4 * pi))
+            integral=sqrt(4 * pi),
+            xp=xp)
 
     def overlap_correction(self, P_ani, out_ani):
+        xp = P_ani.layout.xp
+
         if len(P_ani.dims) == 2:  # (band, spinor)
             subscripts = 'nsi, ij -> nsj'
         else:
             subscripts = 'ni, ij -> nj'
-        for (a, P_ni), out_ni in zip(P_ani.items(), out_ani.values()):
-            dS_ii = self[a].dO_ii
-            np.einsum(subscripts, P_ni, dS_ii, out=out_ni)
-        return out_ani
+        if xp is np:
+            for (a, P_ni), out_ni in zip(P_ani.items(), out_ani.values()):
+                dS_ii = self[a].dO_ii
+                xp.einsum(subscripts, P_ni, dS_ii, out=out_ni)
+        else:
+            # GRR. Cupy einsum doesn't have an out argument.
+            for (a, P_ni), out_ni in zip(P_ani.items(), out_ani.values()):
+                dS_ii = xp.asarray(self[a].dO_ii)
+                out_ni[:] = xp.einsum(subscripts, P_ni, dS_ii)
 
     def partial_wave_corrections(self) -> list[list[Spline]]:
         splines: dict[Setup, list[Spline]] = {}
         dphi_aj = []
         for setup in self:
             dphi_j = splines.get(setup)
             if dphi_j is None:
@@ -1580,11 +1559,11 @@
     return type_a
 
 
 if __name__ == '__main__':
     print("""\
 This is not the setup.py you are looking for!  This setup.py defines a
 Setup class used to hold the atomic data needed for a specific atom.
-For building the GPAW code you must use the setup.py distutils script
+For building the GPAW code you must use the setup.py setuptools script
 at the root of the code tree.  Just do "cd .." and you will be at the
 right place.""")
     raise SystemExit
```

### Comparing `gpaw-22.8.0/gpaw/setup_data.py` & `gpaw-23.6.0/gpaw/setup_data.py`

 * *Files 2% similar despite different names*

```diff
@@ -17,15 +17,16 @@
 from gpaw.atom.shapefunc import shape_functions
 from gpaw.mpi import broadcast
 from gpaw.xc.pawcorrection import PAWXCCorrection
 
 
 class SetupData:
     """Container class for persistent setup attributes and XML I/O."""
-    def __init__(self, symbol, xcsetupname, name='paw', readxml=True,
+    def __init__(self, symbol, xcsetupname,
+                 name='paw', readxml=True,
                  zero_reference=False, world=None,
                  generator_version=None):
         self.symbol = symbol
         self.setupname = xcsetupname
         self.name = name
         self.zero_reference = zero_reference
         self.generator_version = generator_version
@@ -42,15 +43,15 @@
         self.Z = None
         self.Nc = None
         self.Nv = None
 
         # Quantum numbers, energies
         self.n_j = []
         self.l_j = []
-        self.l_orb_j = self.l_j  # pointer to same list!
+        self.l_orb_J = self.l_j  # pointer to same list!
         self.f_j = []
         self.eps_j = []
         self.e_kin_jj = None  # <phi | T | phi> - <phit | T | phit>
 
         self.rgd = None
 
         # Parameters for compensation charge expansion functions:
@@ -108,19 +109,19 @@
         self.l0 = None
         self.e0 = None
         self.r0 = None
         self.nderiv0 = None
 
         self.orbital_free = False  # orbital-free DFT
 
+        self.version = None
+
         if readxml:
             self.read_xml(world=world)
 
-        self.version: str
-
     def __repr__(self):
         return ('{0}({symbol!r}, {setupname!r}, name={name!r}, '
                 'generator_version={generator_version!r}, ...)'
                 .format(self.__class__.__name__, **vars(self)))
 
     def append(self, n, l, f, e, rcut, phi_g, phit_g, pt_g):
         self.n_j.append(n)
@@ -150,19 +151,18 @@
         text('  Z:', self.Z)
         text('  valence:', self.Nv)
         if self.phicorehole_g is None:
             text('  core: %d' % self.Nc)
         else:
             text(f'  core: {self.Nc:.1f}')
         text('  charge:', self.Z - self.Nv - self.Nc)
-        if setup.HubU is not None:
-            for U, l, scale in zip(setup.HubU, setup.Hubl, setup.Hubs):
-                text(f'  Hubbard: {{U: {U * Ha},  # eV\n'
-                     f'            l: {l},\n'
-                     f'            scale: {bool(scale)}}}')
+        if setup.hubbard_u is not None:
+            description = ''.join([f'  {line}' for line
+                                   in setup.hubbard_u.descriptions()])
+            text(description)
         text('  file:', self.filename)
         sf = self.shape_function
         text(f'  compensation charges: {{type: {sf["type"]},\n'
              f'                         rc: {sf["rc"] * Bohr:.2f},\n'
              f'                         lmax: {setup.lmax}}}')
         text(f'  cutoffs: {{filter: {setup.rcutfilter * Bohr:.2f},\n'
              f'            core: {setup.rcore * Bohr:.2f}}}')
@@ -361,15 +361,15 @@
         print('\n  </kinetic_energy_differences>', file=xml)
 
         if self.X_p is not None:
             print('  <exact_exchange_X_matrix>\n    ', end=' ', file=xml)
             for x in self.X_p:
                 print(f'{x!r}', end=' ', file=xml)
             print('\n  </exact_exchange_X_matrix>', file=xml)
-            
+
             print(f'  <exact_exchange core-core="{self.ExxC!r}"/>', file=xml)
             for omega, Ecc in self.ExxC_w.items():
                 print(f'  <erfc_exchange omega="{omega}" core-core="{Ecc}"/>',
                       file=xml)
                 print(f'  <erfc_exchange_X_matrix omega="{omega}" X_p="',
                       end=' ', file=xml)
                 for x in self.X_wp[omega]:
```

### Comparing `gpaw-22.8.0/gpaw/solvation/__init__.py` & `gpaw-23.6.0/gpaw/solvation/__init__.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/solvation/calculator.py` & `gpaw-23.6.0/gpaw/solvation/calculator.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/solvation/cavity.py` & `gpaw-23.6.0/gpaw/solvation/cavity.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/solvation/dielectric.py` & `gpaw-23.6.0/gpaw/solvation/dielectric.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/solvation/hamiltonian.py` & `gpaw-23.6.0/gpaw/solvation/hamiltonian.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/solvation/interactions.py` & `gpaw-23.6.0/gpaw/solvation/interactions.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/solvation/poisson.py` & `gpaw-23.6.0/gpaw/solvation/poisson.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/solvation/sjm.py` & `gpaw-23.6.0/gpaw/solvation/sjm.py`

 * *Files 1% similar despite different names*

```diff
@@ -35,15 +35,15 @@
 
     The method allows the simulation of an electrochemical environment, where
     the potential can be varied by changing the charging (that is, number of
     electrons) of the system. For this purpose, it allows the usagelof non-
     neutral periodic slab systems. Cell neutrality is achieved by adding a
     background charge in the solvent region above the slab
 
-    Further details are given in http://dx.doi.org/10.1021/acs.jpcc.8b02465
+    Further details are given in https://doi.org/10.1021/acs.jpcc.8b02465
     If you use this method, we appreciate it if you cite that work.
 
     The method can be run in two modes:
 
         - Constant charge: The number of excess electrons in the simulation
           can be directly specified with the 'excess_electrons' keyword,
           leaving 'target_potential' set to None.
@@ -227,18 +227,26 @@
                 'Unexpected key(s) provided to sj dict. '
                 'Keys provided were "{}". '
                 'Only keys allowed are "{}".'
                 .format(', '.join(sj_changes),
                         ', '.join(self.default_parameters['sj'])))
         p.update(sj_changes)
         background_charge = kwargs.pop('background_charge', None)
-        parent_changed = True if len(kwargs) > 0 else False
 
         SolvationGPAW.set(self, **kwargs)
 
+        # parent_changed checks if GPAW needs to be reinitialized
+        # The following key do not need reinitialization
+        parent_changed = False
+        for key in kwargs:
+            if key not in ['mixer', 'verbose', 'txt', 'hund', 'random',
+                           'eigensolver', 'convergence', 'fixdensity',
+                           'maxiter']:
+                parent_changed = True
+
         if len(sj_changes):
             if self.wfs is None:
                 self.log('Non-default Solvated Jellium parameters:')
             else:
                 self.log('Changed Solvated Jellium parameters:')
             self.log.print_dict({i: p[i] for i in sj_changes})
             self.log()
@@ -299,19 +307,19 @@
             if self.wfs is None:
                 kwargs.update({'background_charge': background_charge})
                 SolvationGPAW.set(self, **kwargs)
             else:
                 if parent_changed:
                     self.density = None
                 else:
-                    self._quick_reinitialization()
                     if self.density.background_charge:
                         self.density.background_charge = background_charge
                         self.density.background_charge.set_grid_descriptor(
                             self.density.finegd)
+                    self._quick_reinitialization()
 
                 self.wfs.nvalence = self.setups.nvalence + p.excess_electrons
                 self.log('Number of valence electrons is now {:.5f}'
                          .format(self.wfs.nvalence))
 
     def _quick_reinitialization(self):
         """Minimal reinitialization of electronic-structure stuff when only
@@ -343,15 +351,15 @@
             SolvationGPAW.calculate(self, atoms, properties, system_changes)
             return
 
         self.log('Solvated jellium method (SJM) calculation:')
 
         p = self.parameters['sj']
 
-        if not p.target_potential:
+        if p.target_potential is None:
             self.log('Constant-charge calculation with {:.5f} excess '
                      'electrons'.format(p.excess_electrons))
             # Background charge is set here, not earlier, because atoms needed.
             self.set(background_charge=self._create_jellium())
             SolvationGPAW.calculate(self, atoms, ['energy'], system_changes)
             self.log('Potential found to be {:.5f} V (with {:+.5f} '
                      'electrons)'.format(self.get_electrode_potential(),
@@ -419,15 +427,15 @@
             SolvationGPAW.calculate(self, atoms, ['energy'], system_changes)
             true_potential = self.get_electrode_potential()
             self.log()
             msg = (f'Potential found to be {true_potential:.5f} V (with '
                    f'{p.excess_electrons:+.5f} excess electrons, attempt '
                    f'{iteration:d}/{p.max_iters:d}')
             msg += ' rerun).' if rerun else ').'
-            self.log(msg)
+            self.log(msg, flush=True)
 
             # Check if we took too big of a step.
             try:
                 stepsize = abs(true_potential - previous_potentials[-1])
             except IndexError:
                 pass
             else:
@@ -447,16 +455,16 @@
                     continue  # back to while
 
             # Increase iteration count.
             iteration += 1
             rerun = False
 
             # Store attempt and calculate slope.
-            previous_electrons += [p.excess_electrons]
-            previous_potentials += [true_potential]
+            previous_electrons.append(float(p.excess_electrons))
+            previous_potentials.append(float(true_potential))
             if len(previous_electrons) > 1:
                 slope = _calculate_slope(previous_electrons,
                                          previous_potentials)
                 self.log('Slope regressed from last {:d} attempts is '
                          '{:.4f} V/electron,'
                          .format(len(previous_electrons[-4:]), slope))
                 area = np.product(np.diag(atoms.cell[:2, :2]))
@@ -465,14 +473,15 @@
                          'muF/cm^2')
                 if p.slope is not None:
                     p.slope = p.mixer * p.slope + (1. - p.mixer) * slope
                     self.log(f'After mixing with {p.mixer:.2f}, new slope is '
                              f'{p.slope:.4f} V/electron.')
                 else:
                     p.slope = slope
+                self.log.flush()
 
             # Check if we're equilibrated and exit if always_adjust is False.
             if abs(true_potential - p.target_potential) < p.tol:
                 self.log('Potential is within tolerance. Equilibrated.')
                 if iteration >= 2:
                     self.timer.stop('Potential equilibration loop')
                 if not p.always_adjust:
@@ -502,15 +511,15 @@
                'than your potential tol. You may try setting the '
                'convergence["workfunction"] keyword. The last values of '
                'excess_electrons and the potential are listed below; '
                'plotting them could give you insight into the problem.')
         msg = textwrap.fill(msg) + '\n'
         for n, p in zip(previous_electrons, previous_potentials):
             msg += '{:+.6f} {:.6f}\n'.format(n, p)
-        self.log(msg)
+        self.log(msg, flush=True)
         raise PotentialConvergenceError(msg)
 
     def write_sjm_traces(self, path='sjm_traces', style='z',
                          props=('potential', 'cavity', 'background_charge')):
         """Write traces of quantities in `props` to file on disk; traces will
         be stored within specified path. Default is to save as vertical traces
         (style 'z'), but can also save as cube (specify `style='cube'`)."""
```

### Comparing `gpaw-22.8.0/gpaw/sphere/lebedev.py` & `gpaw-23.6.0/gpaw/sphere/lebedev.py`

 * *Files 2% similar despite different names*

```diff
@@ -64,13 +64,22 @@
     print('weight_n = np.array(%s)' % weight_n.tolist())
     print('Y_nL = np.array(%s)' % Y_nL.tolist())
     print('R_nv = np.array(%s)' % R_nv.tolist())
 
     return weight_n, Y_nL, R_nv
 
 
+def integrate_lebedev(f_nx):
+    """Integrate the function f(r) on the angular Lebedev quadrature.
+
+    Here, n is the quadrature index for the angular dependence of the function
+    defined on a spherical grid, while x are some arbitrary extra dimensions.
+    """
+    return 4. * np.pi * np.tensordot(weight_n, f_nx, axes=([0], [0]))
+
+
 if __name__ == '__main__':
     run()
 
 weight_n = np.array([0.0126984126984127, 0.0126984126984127, 0.0126984126984127, 0.0126984126984127, 0.0126984126984127, 0.0126984126984127, 0.02257495590828924, 0.02257495590828924, 0.02257495590828924, 0.02257495590828924, 0.02257495590828924, 0.02257495590828924, 0.02257495590828924, 0.02257495590828924, 0.02257495590828924, 0.02257495590828924, 0.02257495590828924, 0.02257495590828924, 0.021093750000000001, 0.021093750000000001, 0.021093750000000001, 0.021093750000000001, 0.021093750000000001, 0.021093750000000001, 0.021093750000000001, 0.021093750000000001, 0.02017333553791887, 0.02017333553791887, 0.02017333553791887, 0.02017333553791887, 0.02017333553791887, 0.02017333553791887, 0.02017333553791887, 0.02017333553791887, 0.02017333553791887, 0.02017333553791887, 0.02017333553791887, 0.02017333553791887, 0.02017333553791887, 0.02017333553791887, 0.02017333553791887, 0.02017333553791887, 0.02017333553791887, 0.02017333553791887, 0.02017333553791887, 0.02017333553791887, 0.02017333553791887, 0.02017333553791887, 0.02017333553791887, 0.02017333553791887])  # noqa
 Y_nL = np.array([[0.28209479177387814, 0.0, 0.0, -0.48860251190291992, 0.0, 0.0, -0.31539156525252005, 0.0, 0.54627421529603959, 0.0, 0.0, 0.0, 0.0, 0.45704579946446577, 0.0, -0.59004358992664352, 0.0, 0.0, 0.0, 0.0, 0.31735664074561293, 0.0, -0.47308734787878004, 0.0, 0.62583573544917614], [0.28209479177387814, 0.0, 0.0, 0.48860251190291992, 0.0, 0.0, -0.31539156525252005, 0.0, 0.54627421529603959, 0.0, 0.0, 0.0, 0.0, -0.45704579946446577, 0.0, 0.59004358992664352, 0.0, 0.0, 0.0, 0.0, 0.31735664074561293, 0.0, -0.47308734787878004, 0.0, 0.62583573544917614], [0.28209479177387814, -0.48860251190291992, 0.0, 0.0, 0.0, 0.0, -0.31539156525252005, 0.0, -0.54627421529603959, 0.59004358992664352, 0.0, 0.45704579946446577, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.31735664074561293, 0.0, 0.47308734787878004, 0.0, 0.62583573544917614], [0.28209479177387814, 0.48860251190291992, 0.0, 0.0, 0.0, 0.0, -0.31539156525252005, 0.0, -0.54627421529603959, -0.59004358992664352, 0.0, -0.45704579946446577, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.31735664074561293, 0.0, 0.47308734787878004, 0.0, 0.62583573544917614], [0.28209479177387814, 0.0, -0.48860251190291992, 0.0, 0.0, 0.0, 0.63078313050504009, 0.0, 0.0, 0.0, 0.0, 0.0, -0.7463526651802308, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.84628437532163447, 0.0, 0.0, 0.0, 0.0], [0.28209479177387814, 0.0, 0.48860251190291992, 0.0, 0.0, 0.0, 0.63078313050504009, 0.0, 0.0, 0.0, 0.0, 0.0, 0.7463526651802308, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.84628437532163447, 0.0, 0.0, 0.0, 0.0], [0.28209479177387814, -0.3454941494713355, -0.3454941494713355, 0.0, 0.0, 0.54627421529603959, 0.15769578262626005, 0.0, -0.27313710764801985, 0.2086119118163921, 0.0, -0.4847702761712262, 0.13193775767639854, 0.0, 0.51099273821664126, 0.0, 0.0, -0.44253269244498283, 0.0, 0.16726163588932241, -0.34380302747441421, 0.0, -0.59135918484847527, 0.0, 0.15645893386229406], [0.28209479177387814, -0.3454941494713355, 0.3454941494713355, 0.0, 0.0, -0.54627421529603959, 0.15769578262626005, 0.0, -0.27313710764801985, 0.2086119118163921, 0.0, -0.4847702761712262, -0.13193775767639854, 0.0, -0.51099273821664126, 0.0, 0.0, 0.44253269244498283, 0.0, -0.16726163588932241, -0.34380302747441421, 0.0, -0.59135918484847527, 0.0, 0.15645893386229406], [0.28209479177387814, 0.3454941494713355, -0.3454941494713355, 0.0, 0.0, -0.54627421529603959, 0.15769578262626005, 0.0, -0.27313710764801985, -0.2086119118163921, 0.0, 0.4847702761712262, 0.13193775767639854, 0.0, 0.51099273821664126, 0.0, 0.0, 0.44253269244498283, 0.0, -0.16726163588932241, -0.34380302747441421, 0.0, -0.59135918484847527, 0.0, 0.15645893386229406], [0.28209479177387814, 0.3454941494713355, 0.3454941494713355, 0.0, 0.0, 0.54627421529603959, 0.15769578262626005, 0.0, -0.27313710764801985, -0.2086119118163921, 0.0, 0.4847702761712262, -0.13193775767639854, 0.0, -0.51099273821664126, 0.0, 0.0, -0.44253269244498283, 0.0, 0.16726163588932241, -0.34380302747441421, 0.0, -0.59135918484847527, 0.0, 0.15645893386229406], [0.28209479177387814, 0.0, -0.3454941494713355, -0.3454941494713355, 0.0, 0.0, 0.15769578262626005, 0.54627421529603959, 0.27313710764801985, 0.0, 0.0, 0.0, 0.13193775767639854, -0.4847702761712262, -0.51099273821664126, -0.2086119118163921, 0.0, 0.0, 0.0, 0.0, -0.34380302747441421, 0.16726163588932241, 0.59135918484847527, 0.44253269244498283, 0.15645893386229406], [0.28209479177387814, 0.0, -0.3454941494713355, 0.3454941494713355, 0.0, 0.0, 0.15769578262626005, -0.54627421529603959, 0.27313710764801985, 0.0, 0.0, 0.0, 0.13193775767639854, 0.4847702761712262, -0.51099273821664126, 0.2086119118163921, 0.0, 0.0, 0.0, 0.0, -0.34380302747441421, -0.16726163588932241, 0.59135918484847527, -0.44253269244498283, 0.15645893386229406], [0.28209479177387814, 0.0, 0.3454941494713355, -0.3454941494713355, 0.0, 0.0, 0.15769578262626005, -0.54627421529603959, 0.27313710764801985, 0.0, 0.0, 0.0, -0.13193775767639854, -0.4847702761712262, 0.51099273821664126, -0.2086119118163921, 0.0, 0.0, 0.0, 0.0, -0.34380302747441421, -0.16726163588932241, 0.59135918484847527, -0.44253269244498283, 0.15645893386229406], [0.28209479177387814, 0.0, 0.3454941494713355, 0.3454941494713355, 0.0, 0.0, 0.15769578262626005, 0.54627421529603959, 0.27313710764801985, 0.0, 0.0, 0.0, -0.13193775767639854, 0.4847702761712262, 0.51099273821664126, 0.2086119118163921, 0.0, 0.0, 0.0, 0.0, -0.34380302747441421, 0.16726163588932241, 0.59135918484847527, 0.44253269244498283, 0.15645893386229406], [0.28209479177387814, -0.3454941494713355, 0.0, -0.3454941494713355, 0.54627421529603959, 0.0, -0.3153915652525201, 0.0, 0.0, -0.41722382363278415, 0.0, 0.32318018411415073, 0.0, 0.32318018411415073, 0.0, 0.41722382363278415, -1.1102230246251565e-16, 0.0, -0.47308734787878015, 0.0, 0.31735664074561298, 0.0, 0.0, 0.0, -0.62583573544917659], [0.28209479177387814, 0.3454941494713355, 0.0, -0.3454941494713355, -0.54627421529603959, 0.0, -0.3153915652525201, 0.0, 0.0, 0.41722382363278415, 0.0, -0.32318018411415073, 0.0, 0.32318018411415073, 0.0, 0.41722382363278415, 1.1102230246251565e-16, 0.0, 0.47308734787878015, 0.0, 0.31735664074561298, 0.0, 0.0, 0.0, -0.62583573544917659], [0.28209479177387814, -0.3454941494713355, 0.0, 0.3454941494713355, -0.54627421529603959, 0.0, -0.3153915652525201, 0.0, 0.0, -0.41722382363278415, 0.0, 0.32318018411415073, 0.0, -0.32318018411415073, 0.0, -0.41722382363278415, 1.1102230246251565e-16, 0.0, 0.47308734787878015, 0.0, 0.31735664074561298, 0.0, 0.0, 0.0, -0.62583573544917659], [0.28209479177387814, 0.3454941494713355, 0.0, 0.3454941494713355, 0.54627421529603959, 0.0, -0.3153915652525201, 0.0, 0.0, 0.41722382363278415, 0.0, -0.32318018411415073, 0.0, -0.32318018411415073, 0.0, -0.41722382363278415, -1.1102230246251565e-16, 0.0, -0.47308734787878015, 0.0, 0.31735664074561298, 0.0, 0.0, 0.0, -0.62583573544917659], [0.28209479177387814, -0.28209479177387814, -0.28209479177387814, -0.28209479177387814, 0.36418281019735971, 0.36418281019735971, 0.0, 0.36418281019735971, 0.0, -0.22710788365184043, -0.55629843151037861, -0.17591701023519801, 0.28727127476813386, -0.17591701023519801, 0.0, 0.22710788365184048, 0.0, 0.3933623932844289, 0.42052208700336002, -0.14867700967939762, -0.32911059040285784, -0.14867700967939762, 0.0, -0.3933623932844289, -0.27814921575518947], [0.28209479177387814, -0.28209479177387814, 0.28209479177387814, -0.28209479177387814, 0.36418281019735971, -0.36418281019735971, 0.0, -0.36418281019735971, 0.0, -0.22710788365184043, 0.55629843151037861, -0.17591701023519801, -0.28727127476813386, -0.17591701023519801, 0.0, 0.22710788365184048, 0.0, -0.3933623932844289, 0.42052208700336002, 0.14867700967939762, -0.32911059040285784, 0.14867700967939762, 0.0, 0.3933623932844289, -0.27814921575518947], [0.28209479177387814, 0.28209479177387814, -0.28209479177387814, -0.28209479177387814, -0.36418281019735971, -0.36418281019735971, 0.0, 0.36418281019735971, 0.0, 0.22710788365184043, 0.55629843151037861, 0.17591701023519801, 0.28727127476813386, -0.17591701023519801, 0.0, 0.22710788365184048, 0.0, -0.3933623932844289, -0.42052208700336002, 0.14867700967939762, -0.32911059040285784, -0.14867700967939762, 0.0, -0.3933623932844289, -0.27814921575518947], [0.28209479177387814, 0.28209479177387814, 0.28209479177387814, -0.28209479177387814, -0.36418281019735971, 0.36418281019735971, 0.0, -0.36418281019735971, 0.0, 0.22710788365184043, -0.55629843151037861, 0.17591701023519801, -0.28727127476813386, -0.17591701023519801, 0.0, 0.22710788365184048, 0.0, 0.3933623932844289, -0.42052208700336002, -0.14867700967939762, -0.32911059040285784, 0.14867700967939762, 0.0, 0.3933623932844289, -0.27814921575518947], [0.28209479177387814, -0.28209479177387814, -0.28209479177387814, 0.28209479177387814, -0.36418281019735971, 0.36418281019735971, 0.0, -0.36418281019735971, 0.0, -0.22710788365184043, 0.55629843151037861, -0.17591701023519801, 0.28727127476813386, 0.17591701023519801, 0.0, -0.22710788365184048, 0.0, 0.3933623932844289, -0.42052208700336002, -0.14867700967939762, -0.32911059040285784, 0.14867700967939762, 0.0, 0.3933623932844289, -0.27814921575518947], [0.28209479177387814, -0.28209479177387814, 0.28209479177387814, 0.28209479177387814, -0.36418281019735971, -0.36418281019735971, 0.0, 0.36418281019735971, 0.0, -0.22710788365184043, -0.55629843151037861, -0.17591701023519801, -0.28727127476813386, 0.17591701023519801, 0.0, -0.22710788365184048, 0.0, -0.3933623932844289, -0.42052208700336002, 0.14867700967939762, -0.32911059040285784, -0.14867700967939762, 0.0, -0.3933623932844289, -0.27814921575518947], [0.28209479177387814, 0.28209479177387814, -0.28209479177387814, 0.28209479177387814, 0.36418281019735971, -0.36418281019735971, 0.0, -0.36418281019735971, 0.0, 0.22710788365184043, -0.55629843151037861, 0.17591701023519801, 0.28727127476813386, 0.17591701023519801, 0.0, -0.22710788365184048, 0.0, -0.3933623932844289, 0.42052208700336002, 0.14867700967939762, -0.32911059040285784, 0.14867700967939762, 0.0, 0.3933623932844289, -0.27814921575518947], [0.28209479177387814, 0.28209479177387814, 0.28209479177387814, 0.28209479177387814, 0.36418281019735971, 0.36418281019735971, 0.0, 0.36418281019735971, 0.0, 0.22710788365184043, 0.55629843151037861, 0.17591701023519801, -0.28727127476813386, 0.17591701023519801, 0.0, -0.22710788365184048, 0.0, 0.3933623932844289, 0.42052208700336002, -0.14867700967939762, -0.32911059040285784, -0.14867700967939762, 0.0, -0.3933623932844289, -0.27814921575518947], [0.28209479177387814, -0.14731920032792212, -0.14731920032792212, -0.44195760098376641, 0.29796775379783974, 0.099322584599279895, -0.22937568382001461, 0.29796775379783974, 0.39729033839711975, -0.42050234001046305, -0.23769603892429697, 0.07516608738008182, 0.28640664895524026, 0.22549826214024549, -0.31692805189906265, -0.29111700462262841, 0.49653083143075138, 0.38035867780395194, -0.093835507017278719, -0.14376206721065715, 0.05944972884490831, -0.43128620163197151, -0.12511400935637168, 0.26332523847965916, 0.14482149250063592], [0.28209479177387814, -0.14731920032792212, 0.14731920032792212, -0.44195760098376641, 0.29796775379783974, -0.099322584599279895, -0.22937568382001461, -0.29796775379783974, 0.39729033839711975, -0.42050234001046305, 0.23769603892429697, 0.07516608738008182, -0.28640664895524026, 0.22549826214024549, 0.31692805189906265, -0.29111700462262841, 0.49653083143075138, -0.38035867780395194, -0.093835507017278719, 0.14376206721065715, 0.05944972884490831, 0.43128620163197151, -0.12511400935637168, -0.26332523847965916, 0.14482149250063592], [0.28209479177387814, 0.14731920032792212, -0.14731920032792212, -0.44195760098376641, -0.29796775379783974, -0.099322584599279895, -0.22937568382001461, 0.29796775379783974, 0.39729033839711975, 0.42050234001046305, 0.23769603892429697, -0.07516608738008182, 0.28640664895524026, 0.22549826214024549, -0.31692805189906265, -0.29111700462262841, -0.49653083143075138, -0.38035867780395194, 0.093835507017278719, 0.14376206721065715, 0.05944972884490831, -0.43128620163197151, -0.12511400935637168, 0.26332523847965916, 0.14482149250063592], [0.28209479177387814, 0.14731920032792212, 0.14731920032792212, -0.44195760098376641, -0.29796775379783974, 0.099322584599279895, -0.22937568382001461, -0.29796775379783974, 0.39729033839711975, 0.42050234001046305, -0.23769603892429697, -0.07516608738008182, -0.28640664895524026, 0.22549826214024549, 0.31692805189906265, -0.29111700462262841, -0.49653083143075138, 0.38035867780395194, 0.093835507017278719, -0.14376206721065715, 0.05944972884490831, 0.43128620163197151, -0.12511400935637168, -0.26332523847965916, 0.14482149250063592], [0.28209479177387814, -0.14731920032792212, -0.14731920032792212, 0.44195760098376641, -0.29796775379783974, 0.099322584599279895, -0.22937568382001461, -0.29796775379783974, 0.39729033839711975, -0.42050234001046305, 0.23769603892429697, 0.07516608738008182, 0.28640664895524026, -0.22549826214024549, -0.31692805189906265, 0.29111700462262841, -0.49653083143075138, 0.38035867780395194, 0.093835507017278719, -0.14376206721065715, 0.05944972884490831, 0.43128620163197151, -0.12511400935637168, -0.26332523847965916, 0.14482149250063592], [0.28209479177387814, -0.14731920032792212, 0.14731920032792212, 0.44195760098376641, -0.29796775379783974, -0.099322584599279895, -0.22937568382001461, 0.29796775379783974, 0.39729033839711975, -0.42050234001046305, -0.23769603892429697, 0.07516608738008182, -0.28640664895524026, -0.22549826214024549, 0.31692805189906265, 0.29111700462262841, -0.49653083143075138, -0.38035867780395194, 0.093835507017278719, 0.14376206721065715, 0.05944972884490831, -0.43128620163197151, -0.12511400935637168, 0.26332523847965916, 0.14482149250063592], [0.28209479177387814, 0.14731920032792212, -0.14731920032792212, 0.44195760098376641, 0.29796775379783974, -0.099322584599279895, -0.22937568382001461, -0.29796775379783974, 0.39729033839711975, 0.42050234001046305, -0.23769603892429697, -0.07516608738008182, 0.28640664895524026, -0.22549826214024549, -0.31692805189906265, 0.29111700462262841, 0.49653083143075138, -0.38035867780395194, -0.093835507017278719, 0.14376206721065715, 0.05944972884490831, 0.43128620163197151, -0.12511400935637168, -0.26332523847965916, 0.14482149250063592], [0.28209479177387814, 0.14731920032792212, 0.14731920032792212, 0.44195760098376641, 0.29796775379783974, 0.099322584599279895, -0.22937568382001461, 0.29796775379783974, 0.39729033839711975, 0.42050234001046305, 0.23769603892429697, -0.07516608738008182, -0.28640664895524026, -0.22549826214024549, 0.31692805189906265, 0.29111700462262841, 0.49653083143075138, 0.38035867780395194, -0.093835507017278719, -0.14376206721065715, 0.05944972884490831, -0.43128620163197151, -0.12511400935637168, 0.26332523847965916, 0.14482149250063592], [0.28209479177387814, -0.44195760098376641, -0.14731920032792212, -0.14731920032792212, 0.29796775379783974, 0.29796775379783974, -0.22937568382001461, 0.099322584599279895, -0.39729033839711975, 0.29111700462262841, -0.23769603892429697, 0.22549826214024549, 0.28640664895524026, 0.07516608738008182, 0.31692805189906265, 0.42050234001046305, -0.49653083143075133, -0.26332523847965916, -0.093835507017278746, -0.43128620163197157, 0.059449728844908303, -0.14376206721065715, 0.12511400935637171, -0.38035867780395199, 0.14482149250063592], [0.28209479177387814, -0.44195760098376641, -0.14731920032792212, 0.14731920032792212, -0.29796775379783974, 0.29796775379783974, -0.22937568382001461, -0.099322584599279895, -0.39729033839711975, 0.29111700462262841, 0.23769603892429697, 0.22549826214024549, 0.28640664895524026, -0.07516608738008182, 0.31692805189906265, -0.42050234001046305, 0.49653083143075133, -0.26332523847965916, 0.093835507017278746, -0.43128620163197157, 0.059449728844908303, 0.14376206721065715, 0.12511400935637171, 0.38035867780395199, 0.14482149250063592], [0.28209479177387814, -0.44195760098376641, 0.14731920032792212, -0.14731920032792212, 0.29796775379783974, -0.29796775379783974, -0.22937568382001461, -0.099322584599279895, -0.39729033839711975, 0.29111700462262841, 0.23769603892429697, 0.22549826214024549, -0.28640664895524026, 0.07516608738008182, -0.31692805189906265, 0.42050234001046305, -0.49653083143075133, 0.26332523847965916, -0.093835507017278746, 0.43128620163197157, 0.059449728844908303, 0.14376206721065715, 0.12511400935637171, 0.38035867780395199, 0.14482149250063592], [0.28209479177387814, -0.44195760098376641, 0.14731920032792212, 0.14731920032792212, -0.29796775379783974, -0.29796775379783974, -0.22937568382001461, 0.099322584599279895, -0.39729033839711975, 0.29111700462262841, -0.23769603892429697, 0.22549826214024549, -0.28640664895524026, -0.07516608738008182, -0.31692805189906265, -0.42050234001046305, 0.49653083143075133, 0.26332523847965916, 0.093835507017278746, 0.43128620163197157, 0.059449728844908303, -0.14376206721065715, 0.12511400935637171, -0.38035867780395199, 0.14482149250063592], [0.28209479177387814, 0.44195760098376641, -0.14731920032792212, -0.14731920032792212, -0.29796775379783974, -0.29796775379783974, -0.22937568382001461, 0.099322584599279895, -0.39729033839711975, -0.29111700462262841, 0.23769603892429697, -0.22549826214024549, 0.28640664895524026, 0.07516608738008182, 0.31692805189906265, 0.42050234001046305, 0.49653083143075133, 0.26332523847965916, 0.093835507017278746, 0.43128620163197157, 0.059449728844908303, -0.14376206721065715, 0.12511400935637171, -0.38035867780395199, 0.14482149250063592], [0.28209479177387814, 0.44195760098376641, -0.14731920032792212, 0.14731920032792212, 0.29796775379783974, -0.29796775379783974, -0.22937568382001461, -0.099322584599279895, -0.39729033839711975, -0.29111700462262841, -0.23769603892429697, -0.22549826214024549, 0.28640664895524026, -0.07516608738008182, 0.31692805189906265, -0.42050234001046305, -0.49653083143075133, 0.26332523847965916, -0.093835507017278746, 0.43128620163197157, 0.059449728844908303, 0.14376206721065715, 0.12511400935637171, 0.38035867780395199, 0.14482149250063592], [0.28209479177387814, 0.44195760098376641, 0.14731920032792212, -0.14731920032792212, -0.29796775379783974, 0.29796775379783974, -0.22937568382001461, -0.099322584599279895, -0.39729033839711975, -0.29111700462262841, -0.23769603892429697, -0.22549826214024549, -0.28640664895524026, 0.07516608738008182, -0.31692805189906265, 0.42050234001046305, 0.49653083143075133, -0.26332523847965916, 0.093835507017278746, -0.43128620163197157, 0.059449728844908303, 0.14376206721065715, 0.12511400935637171, 0.38035867780395199, 0.14482149250063592], [0.28209479177387814, 0.44195760098376641, 0.14731920032792212, 0.14731920032792212, 0.29796775379783974, 0.29796775379783974, -0.22937568382001461, 0.099322584599279895, -0.39729033839711975, -0.29111700462262841, 0.23769603892429697, -0.22549826214024549, -0.28640664895524026, -0.07516608738008182, -0.31692805189906265, -0.42050234001046305, -0.49653083143075133, -0.26332523847965916, -0.093835507017278746, -0.43128620163197157, 0.059449728844908303, -0.14376206721065715, 0.12511400935637171, -0.38035867780395199, 0.14482149250063592], [0.28209479177387814, -0.14731920032792212, -0.44195760098376641, -0.14731920032792212, 0.099322584599279895, 0.29796775379783974, 0.45875136764002922, 0.29796775379783974, 0.0, -0.032346333846958689, -0.23769603892429694, -0.4259411618204636, -0.36823712008530907, -0.4259411618204636, 0.0, 0.032346333846958689, 3.4694469519536142e-18, 0.087775079493219665, 0.40662053040820756, 0.49763792495996717, 0.19933144377410417, 0.49763792495996717, 0.0, -0.087775079493219665, -0.020688784642947957], [0.28209479177387814, 0.14731920032792212, -0.44195760098376641, -0.14731920032792212, -0.099322584599279895, -0.29796775379783974, 0.45875136764002922, 0.29796775379783974, 0.0, 0.032346333846958689, 0.23769603892429694, 0.4259411618204636, -0.36823712008530907, -0.4259411618204636, 0.0, 0.032346333846958689, -3.4694469519536142e-18, -0.087775079493219665, -0.40662053040820756, -0.49763792495996717, 0.19933144377410417, 0.49763792495996717, 0.0, -0.087775079493219665, -0.020688784642947957], [0.28209479177387814, -0.14731920032792212, -0.44195760098376641, 0.14731920032792212, -0.099322584599279895, 0.29796775379783974, 0.45875136764002922, -0.29796775379783974, 0.0, -0.032346333846958689, 0.23769603892429694, -0.4259411618204636, -0.36823712008530907, 0.4259411618204636, 0.0, -0.032346333846958689, -3.4694469519536142e-18, 0.087775079493219665, -0.40662053040820756, 0.49763792495996717, 0.19933144377410417, -0.49763792495996717, 0.0, 0.087775079493219665, -0.020688784642947957], [0.28209479177387814, 0.14731920032792212, -0.44195760098376641, 0.14731920032792212, 0.099322584599279895, -0.29796775379783974, 0.45875136764002922, -0.29796775379783974, 0.0, 0.032346333846958689, -0.23769603892429694, 0.4259411618204636, -0.36823712008530907, 0.4259411618204636, 0.0, -0.032346333846958689, 3.4694469519536142e-18, -0.087775079493219665, 0.40662053040820756, -0.49763792495996717, 0.19933144377410417, -0.49763792495996717, 0.0, 0.087775079493219665, -0.020688784642947957], [0.28209479177387814, -0.14731920032792212, 0.44195760098376641, -0.14731920032792212, 0.099322584599279895, -0.29796775379783974, 0.45875136764002922, -0.29796775379783974, 0.0, -0.032346333846958689, 0.23769603892429694, -0.4259411618204636, 0.36823712008530907, -0.4259411618204636, 0.0, 0.032346333846958689, 3.4694469519536142e-18, -0.087775079493219665, 0.40662053040820756, -0.49763792495996717, 0.19933144377410417, -0.49763792495996717, 0.0, 0.087775079493219665, -0.020688784642947957], [0.28209479177387814, 0.14731920032792212, 0.44195760098376641, -0.14731920032792212, -0.099322584599279895, 0.29796775379783974, 0.45875136764002922, -0.29796775379783974, 0.0, 0.032346333846958689, -0.23769603892429694, 0.4259411618204636, 0.36823712008530907, -0.4259411618204636, 0.0, 0.032346333846958689, -3.4694469519536142e-18, 0.087775079493219665, -0.40662053040820756, 0.49763792495996717, 0.19933144377410417, -0.49763792495996717, 0.0, 0.087775079493219665, -0.020688784642947957], [0.28209479177387814, -0.14731920032792212, 0.44195760098376641, 0.14731920032792212, -0.099322584599279895, -0.29796775379783974, 0.45875136764002922, 0.29796775379783974, 0.0, -0.032346333846958689, -0.23769603892429694, -0.4259411618204636, 0.36823712008530907, 0.4259411618204636, 0.0, -0.032346333846958689, -3.4694469519536142e-18, -0.087775079493219665, -0.40662053040820756, -0.49763792495996717, 0.19933144377410417, 0.49763792495996717, 0.0, -0.087775079493219665, -0.020688784642947957], [0.28209479177387814, 0.14731920032792212, 0.44195760098376641, 0.14731920032792212, 0.099322584599279895, 0.29796775379783974, 0.45875136764002922, 0.29796775379783974, 0.0, 0.032346333846958689, 0.23769603892429694, 0.4259411618204636, 0.36823712008530907, 0.4259411618204636, 0.0, -0.032346333846958689, 3.4694469519536142e-18, 0.087775079493219665, 0.40662053040820756, 0.49763792495996717, 0.19933144377410417, 0.49763792495996717, 0.0, -0.087775079493219665, -0.020688784642947957]])  # noqa
 R_nv = np.array([[-1.0, 0.0, 0.0], [1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, -1.0], [0.0, 0.0, 1.0], [0.0, -0.70710678118654757, -0.70710678118654757], [0.0, -0.70710678118654757, 0.70710678118654757], [0.0, 0.70710678118654757, -0.70710678118654757], [0.0, 0.70710678118654757, 0.70710678118654757], [-0.70710678118654757, 0.0, -0.70710678118654757], [0.70710678118654757, 0.0, -0.70710678118654757], [-0.70710678118654757, 0.0, 0.70710678118654757], [0.70710678118654757, 0.0, 0.70710678118654757], [-0.70710678118654757, -0.70710678118654757, 0.0], [-0.70710678118654757, 0.70710678118654757, 0.0], [0.70710678118654757, -0.70710678118654757, 0.0], [0.70710678118654757, 0.70710678118654757, 0.0], [-0.57735026918962573, -0.57735026918962573, -0.57735026918962573], [-0.57735026918962573, -0.57735026918962573, 0.57735026918962573], [-0.57735026918962573, 0.57735026918962573, -0.57735026918962573], [-0.57735026918962573, 0.57735026918962573, 0.57735026918962573], [0.57735026918962573, -0.57735026918962573, -0.57735026918962573], [0.57735026918962573, -0.57735026918962573, 0.57735026918962573], [0.57735026918962573, 0.57735026918962573, -0.57735026918962573], [0.57735026918962573, 0.57735026918962573, 0.57735026918962573], [-0.90453403373329089, -0.30151134457776357, -0.30151134457776357], [-0.90453403373329089, -0.30151134457776357, 0.30151134457776357], [-0.90453403373329089, 0.30151134457776357, -0.30151134457776357], [-0.90453403373329089, 0.30151134457776357, 0.30151134457776357], [0.90453403373329089, -0.30151134457776357, -0.30151134457776357], [0.90453403373329089, -0.30151134457776357, 0.30151134457776357], [0.90453403373329089, 0.30151134457776357, -0.30151134457776357], [0.90453403373329089, 0.30151134457776357, 0.30151134457776357], [-0.30151134457776357, -0.90453403373329089, -0.30151134457776357], [0.30151134457776357, -0.90453403373329089, -0.30151134457776357], [-0.30151134457776357, -0.90453403373329089, 0.30151134457776357], [0.30151134457776357, -0.90453403373329089, 0.30151134457776357], [-0.30151134457776357, 0.90453403373329089, -0.30151134457776357], [0.30151134457776357, 0.90453403373329089, -0.30151134457776357], [-0.30151134457776357, 0.90453403373329089, 0.30151134457776357], [0.30151134457776357, 0.90453403373329089, 0.30151134457776357], [-0.30151134457776357, -0.30151134457776357, -0.90453403373329089], [-0.30151134457776357, 0.30151134457776357, -0.90453403373329089], [0.30151134457776357, -0.30151134457776357, -0.90453403373329089], [0.30151134457776357, 0.30151134457776357, -0.90453403373329089], [-0.30151134457776357, -0.30151134457776357, 0.90453403373329089], [-0.30151134457776357, 0.30151134457776357, 0.90453403373329089], [0.30151134457776357, -0.30151134457776357, 0.90453403373329089], [0.30151134457776357, 0.30151134457776357, 0.90453403373329089]])  # noqa
```

### Comparing `gpaw-22.8.0/gpaw/spinorbit.py` & `gpaw-23.6.0/gpaw/spinorbit.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,42 +1,45 @@
+from __future__ import annotations
 from math import nan
-from typing import (Union, List, TYPE_CHECKING, Dict, Optional, Callable,
-                    Tuple, Iterable, Iterator)
 from operator import attrgetter
 from pathlib import Path
+from typing import (TYPE_CHECKING, Callable, Dict, Iterable, Iterator, List,
+                    Optional, Tuple)
 
 import numpy as np
-from ase.units import Ha, alpha, Bohr
+from ase.units import Bohr, Ha, alpha
 
 from gpaw.band_descriptor import BandDescriptor
 from gpaw.grid_descriptor import GridDescriptor
 from gpaw.kpoint import KPoint
 from gpaw.kpt_descriptor import KPointDescriptor
 from gpaw.mpi import broadcast_array, serial_comm
 from gpaw.occupations import OccupationNumberCalculator, ParallelLayout
 from gpaw.projections import Projections
 from gpaw.setup import Setup
-from gpaw.utilities.partition import AtomPartition
-from gpaw.utilities.ibz2bz import construct_symmetry_operators
 from gpaw.typing import Array1D, Array2D, Array3D, Array4D, ArrayND
+from gpaw.utilities.ibz2bz import construct_symmetry_operators
+from gpaw.utilities.partition import AtomPartition
+
 if TYPE_CHECKING:
     from gpaw.calculator import GPAW  # noqa
+    from gpaw.new.ase_interface import ASECalculator
 
 _L_vlmm: List[List[np.ndarray]] = []  # see get_L_vlmm() below
 
 
 class WaveFunction:
     def __init__(self,
                  eigenvalues: Array1D,
                  projections: Projections,
                  bz_index: int = None):
         self.eig_m = eigenvalues
         self.projections = projections
         self.spin_projection_mv: Optional[Array2D] = None
-        self.v_msn: Optional[Array2D] = None
+        self.v_mn: Optional[Array2D] = None
         self.f_m = np.empty_like(self.eig_m)
         self.f_m[:] = nan
         self.bz_index = bz_index
 
     def transform(self,
                   kd: KPointDescriptor,
                   setups: List[Setup],
@@ -98,53 +101,62 @@
                     P2_mi = P_msi[:, s2]
                     H_mm += np.dot(np.dot(P1_mi.conj(), H_ii), P2_mi.T)
 
         domain_comm = self.projections.atom_partition.comm
         domain_comm.sum(H_mm, 0)
         if domain_comm.rank == 0:
             H_mm += np.diag(self.eig_m)
-            self.eig_m, v_mm = np.linalg.eigh(H_mm)
-            v_msn = v_mm.copy().reshape((M // 2, 2, M)).T.copy()
+            self.eig_m, v_nm = np.linalg.eigh(H_mm)
         else:
-            v_msn = np.empty((M, 2, M // 2), complex)
+            v_nm = np.empty((M, M), complex)
 
-        domain_comm.broadcast(v_msn, 0)
+        domain_comm.broadcast(v_nm, 0)
 
         P_mI = self.projections.matrix.array
-        P_mI[:] = v_msn.transpose((0, 2, 1)).copy().reshape((M, M)).dot(P_mI)
+        P_mI[:] = v_nm.T.copy().dot(P_mI)
 
         sx_m = []
         sy_m = []
         sz_m = []
+
+        v_msn = v_nm.copy().reshape((M // 2, 2, M)).T.copy()
         for v_sn in v_msn:
             sx_m.append(np.trace(v_sn.T.conj().dot(s_vss[0]).dot(v_sn)))
             sy_m.append(np.trace(v_sn.T.conj().dot(s_vss[1]).dot(v_sn)))
             sz_m.append(np.trace(v_sn.T.conj().dot(s_vss[2]).dot(v_sn)))
 
         self.spin_projection_mv = np.array([sx_m, sy_m, sz_m]).real.T.copy()
-        self.v_msn = v_msn
+        self.v_mn = v_nm.T
 
     def wavefunctions(self, calc, periodic=True):
         kd = calc.wfs.kd
         assert kd.nibzkpts == kd.nbzkpts
 
         # For spinors the number of bands is doubled and a
         # spin dimension is added
         Ns = calc.wfs.nspins
-        Nn = calc.wfs.bd.nbands
+        Nm, Nn = self.v_mn.shape
 
-        u_snR = [[calc.wfs.get_wave_function_array(n, self.bz_index, s,
-                                                   periodic=periodic)
-                  for n in range(Nn)]
-                 for s in range(Ns)]
-        u_msR = np.empty((2 * Nn, 2) + u_snR[0][0].shape, complex)
-        np.einsum('mn, nabc -> mabc', self.v_msn[:, 0], u_snR[0],
-                  out=u_msR[:, 0])
-        np.einsum('mn, nabc -> mabc', self.v_msn[:, 1], u_snR[-1],
-                  out=u_msR[:, 1])
+        if calc.wfs.collinear:
+            u_snR = [[calc.wfs.get_wave_function_array(n, self.bz_index, s,
+                                                       periodic=periodic)
+                      for n in range(Nn // 2)]
+                     for s in range(Ns)]
+            u_msR = np.empty((Nm, 2) + u_snR[0][0].shape, complex)
+            np.einsum('mn, nabc -> mabc', self.v_mn[:, ::2], u_snR[0],
+                      out=u_msR[:, 0])
+            np.einsum('mn, nabc -> mabc', self.v_mn[:, 1::2], u_snR[-1],
+                      out=u_msR[:, 1])
+        else:
+            u_nsR = np.array(
+                [calc.wfs.get_wave_function_array(n, self.bz_index, 0,
+                                                  periodic=periodic)
+                 for n in range(Nn)])
+            u_msR = np.einsum('mn, nsxyz -> msxyz',
+                              self.v_mn, u_nsR)
 
         return u_msR
 
     @property
     def P_amj(self):
         M = self.projections.nbands
         return {
@@ -247,21 +259,27 @@
 
     def eigenvalues(self,
                     broadcast: bool = True
                     ) -> Array2D:
         """Eigenvalues in eV for the whole BZ."""
         return self._collect(attrgetter('eig_m'), broadcast=broadcast)
 
+    def occupation_numbers(self,
+                           broadcast: bool = True
+                           ) -> Array2D:
+        """Occupation numbers for the whole BZ."""
+        return self._collect(attrgetter('f_m'), broadcast=broadcast)
+
     def eigenvectors(self,
                      broadcast: bool = True
                      ) -> Array4D:
         """Eigenvectors for the whole BZ."""
         nbands = self.shape[1]
         assert nbands % 2 == 0
-        return self._collect(attrgetter('v_msn'), (2, nbands // 2), complex,
+        return self._collect(attrgetter('v_mn'), (nbands,), complex,
                              broadcast=broadcast)
 
     def spin_projections(self,
                          broadcast: bool = True
                          ) -> Array3D:
         """Spin projections for the whole BZ."""
         return self._collect(attrgetter('spin_projection_mv'), (3,),
@@ -437,22 +455,23 @@
             eig_m = np.empty(0)
 
         ibz_index = kpt_s[0].k
 
         yield ibz_index, WaveFunction(eig_m, projections)
 
 
-def soc_eigenstates(calc: Union['GPAW', str, Path],
+def soc_eigenstates(calc: ASECalculator | GPAW | str | Path,
                     n1: int = None,
                     n2: int = None,
                     scale: float = 1.0,
                     theta: float = 0.0,  # degrees
                     phi: float = 0.0,  # degrees
                     eigenvalues: Array3D = None,  # eV
-                    occcalc: OccupationNumberCalculator = None
+                    occcalc: OccupationNumberCalculator = None,
+                    projected: bool = False
                     ) -> BZWaveFunctions:
     """Calculate SOC eigenstates.
 
     Parameters:
         calc: Calculator
             GPAW calculator or path to gpw-file.
         n1, n2: int
@@ -486,18 +505,21 @@
             nbands = calc.get_number_of_bands()
         else:
             nbands = eigenvalues.shape[2]
         n2 += nbands
 
     # <phi_i|dV_adr / r * L_v|phi_j>
     dVL_avii = {a: soc(calc.wfs.setups[a],
-                       calc.hamiltonian.xc,
-                       D_sp) * scale
+                       calc.hamiltonian.xc, D_sp) * scale
                 for a, D_sp in calc.density.D_asp.items()}
 
+    if projected:
+        dVL_avii = {a: projected_soc(dVL_vii, theta=theta, phi=phi)
+                    for a, dVL_vii in dVL_avii.items()}
+
     kd = calc.wfs.kd
     bd = calc.wfs.bd
     gd = calc.wfs.gd
     spos_ac = calc.spos_ac
     setups = calc.wfs.setups
     atom_partition = calc.density.atom_partition
 
@@ -548,14 +570,31 @@
             else:
                 pass
             N2 += 2 * l2 + 1
         N1 += Nm
     return dVL_vii * alpha**2 / 4.0
 
 
+def projected_soc(dVL_vii: Array3D,
+                  theta: float = 0,
+                  phi: float = 0) -> Array3D:
+    """
+    Optional Args:
+        theta (float): The angle from z-axis in degrees
+        phi (float): The angle from x-axis in degrees
+    """
+    theta *= np.pi / 180
+    phi *= np.pi / 180
+    n_v = np.array([np.sin(theta) * np.cos(phi),
+                    np.sin(theta) * np.sin(phi),
+                    np.cos(theta)])
+    dVL_vii = (np.dot(dVL_vii.T, n_v)[:, :, np.newaxis] * n_v).T
+    return dVL_vii
+
+
 def get_radial_potential(a: Setup, xc, D_sp: Array2D) -> Array1D:
     """Calculates (dV/dr)/r for the effective potential.
     Below, f_g denotes dV/dr = minus the radial force"""
 
     rgd = a.xc_correction.rgd
     r_g = rgd.r_g.copy()
     r_g[0] = 1.0e-12
@@ -745,17 +784,17 @@
     psit_nG = np.array([calc.wfs.kpt_u[ik].psit_nG[n]
                         for n in bands])
     if spin_orbit:
         n1 = bands[0]
         n2 = bands[-1] + 1
         assert (bands == np.arange(n1, n2)).all()
         soc = soc_eigenstates(calc, n1=n1, n2=n2)
-        v_kmsn = soc.eigenvectors()
-        psit0_mG = np.dot(v_kmsn[ik, :, 0], psit_nG)
-        psit1_mG = np.dot(v_kmsn[ik, :, 1], psit_nG)
+        v_kmn = soc.eigenvectors()
+        psit0_mG = np.dot(v_kmn[ik, :, ::2], psit_nG)
+        psit1_mG = np.dot(v_kmn[ik, :, 1::2], psit_nG)
     for n in range(len(bands)):
         psit_nG[n] /= (np.sum(np.abs(psit_nG[n])**2))**0.5
     if spin_orbit:
         for n in range(2 * len(bands)):
             A = np.sum(np.abs(psit0_mG[n])**2) + np.sum(np.abs(psit1_mG[n])**2)
             psit0_mG[n] /= A**0.5
             psit1_mG[n] /= A**0.5
```

### Comparing `gpaw-22.8.0/gpaw/spline.py` & `gpaw-23.6.0/gpaw/spline.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/stress.py` & `gpaw-23.6.0/gpaw/stress.py`

 * *Files 13% similar despite different names*

```diff
@@ -9,15 +9,15 @@
     wfs = calc.wfs
     dens = calc.density
     ham = calc.hamiltonian
 
     if not isinstance(wfs, PWWaveFunctions):
         raise NotImplementedError('Calculation of stress tensor is only ' +
                                   'implemented for plane-wave mode.')
-    if ham.xc.orbital_dependent:
+    if ham.xc.orbital_dependent and ham.xc.type != 'MGGA':
         raise NotImplementedError('Calculation of stress tensor is not ' +
                                   'implemented for orbital-dependent ' +
                                   'XC functionals such as ' + ham.xc.name)
 
     assert not ham.xc.name.startswith('GLLB')
 
     calc.timer.start('Stress tensor')
@@ -28,24 +28,30 @@
         nt_xg = ham.xc_redistributor.distribute(nt_xg)
     s_vv += ham.xc.stress_tensor_contribution(nt_xg)
 
     pd = dens.pd3
     p_G = 4 * np.pi * dens.rhot_q
     G0 = 0 if pd.gd.comm.rank > 0 else 1
     p_G[G0:] /= pd.G2_qG[0][G0:]**2
-    G_Gv = pd.get_reciprocal_vectors()
+    G_Gv = pd.get_reciprocal_vectors(add_q=False)
     for v1 in range(3):
         for v2 in range(3):
             s_vv[v1, v2] += pd.integrate(p_G, dens.rhot_q *
                                          G_Gv[:, v1] * G_Gv[:, v2])
     s_vv += dens.ghat.stress_tensor_contribution(ham.vHt_q, dens.Q_aL)
 
     s_vv -= np.eye(3) * ham.estress
     s_vv += ham.vbar.stress_tensor_contribution(dens.nt_Q)
     s_vv += dens.nct.stress_tensor_contribution(ham.vt_Q)
+    if ham.xc.type == 'MGGA':
+        nspin = ham.xc.dedtaut_sG.shape[0]
+        vtau_sQ = dens.pd2.empty((nspin,), global_array=False)
+        for s in range(nspin):
+            vtau_sQ[s] = dens.pd2.fft(ham.xc.dedtaut_sG[s])
+        s_vv += ham.xc.tauct.stress_tensor_contribution(vtau_sQ.mean(axis=0))
 
     s0 = 0.0
     s0_vv = 0.0
     for kpt in wfs.kpt_u:
         a_ani = {}
         for a, P_ni in kpt.P_ani.items():
             Pf_ni = P_ni * kpt.f_n[:, None]
```

### Comparing `gpaw-22.8.0/gpaw/symmetry.py` & `gpaw-23.6.0/gpaw/symmetry.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/tddft/__init__.py` & `gpaw-23.6.0/gpaw/tddft/__init__.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/tddft/abc.py` & `gpaw-23.6.0/gpaw/tddft/abc.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/tddft/ehrenfest.py` & `gpaw-23.6.0/gpaw/tddft/ehrenfest.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/tddft/folding.py` & `gpaw-23.6.0/gpaw/tddft/folding.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/tddft/laser.py` & `gpaw-23.6.0/gpaw/tddft/laser.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/tddft/propagators.py` & `gpaw-23.6.0/gpaw/tddft/propagators.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/tddft/solvers/base.py` & `gpaw-23.6.0/gpaw/tddft/solvers/base.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/tddft/solvers/bicgstab.py` & `gpaw-23.6.0/gpaw/tddft/solvers/bicgstab.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/tddft/solvers/cscg.py` & `gpaw-23.6.0/gpaw/tddft/solvers/cscg.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/tddft/spectrum.py` & `gpaw-23.6.0/gpaw/tddft/spectrum.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/tddft/tdopers.py` & `gpaw-23.6.0/gpaw/tddft/tdopers.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/tddft/units.py` & `gpaw-23.6.0/gpaw/tddft/units.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/tddft/utils.py` & `gpaw-23.6.0/gpaw/tddft/utils.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/__init__.py` & `gpaw-23.6.0/gpaw/test/__init__.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/ase_features/autoneb.py` & `gpaw-23.6.0/gpaw/test/ase_features/autoneb.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/ase_features/test_ase3k.py` & `gpaw-23.6.0/gpaw/test/ase_features/test_ase3k.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,20 +1,24 @@
+import os
+
 import pytest
 from ase import Atoms
 from ase.io import read
+
 from gpaw import GPAW, FermiDirac
 
 
 @pytest.mark.ci
 def test_no_cell():
     with pytest.raises(ValueError):
         H = Atoms('H', calculator=GPAW())
         H.get_potential_energy()
 
 
+@pytest.mark.skipif(os.environ.get('GPAW_NEW'), reason='WIP')
 def test_read_txt(in_tmp_dir):
     a = 2.0
     calc = GPAW(gpts=(12, 12, 12), txt='H.txt', occupations=FermiDirac(0.0))
     H = Atoms('H',
               cell=(a, a, a),
               pbc=True,
               calculator=calc)
```

### Comparing `gpaw-22.8.0/gpaw/test/big/dcdft/analyse.py` & `gpaw-23.6.0/gpaw/test/big/dcdft/analyse.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/big/dcdft/pbe_abinit_fhi.py` & `gpaw-23.6.0/gpaw/test/big/dcdft/pbe_abinit_fhi.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/big/dcdft/pbe_abinit_hgh.py` & `gpaw-23.6.0/gpaw/test/big/dcdft/pbe_abinit_hgh.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/big/dcdft/pbe_abinit_paw.py` & `gpaw-23.6.0/gpaw/test/big/dcdft/pbe_abinit_paw.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/big/dcdft/pbe_aims.py` & `gpaw-23.6.0/gpaw/test/big/dcdft/pbe_aims.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/big/dcdft/pbe_gpaw_pw.py` & `gpaw-23.6.0/gpaw/test/big/dcdft/pbe_gpaw_pw.py`

 * *Files 0% similar despite different names*

```diff
@@ -99,15 +99,15 @@
         atoms.calc = GPAW(
             txt=name + '_' + code + '_' + str(n) + '.txt',
             xc='PBE',
             kpts=kpts,
             occupations=FermiDirac(width),
             parallel={'band': 1},
             maxiter=777)
-        atoms.calc.set(**kwargs)  # remaining calc keywords
+        atoms.calc = atoms.calc.new(**kwargs)  # remaining calc keywords
         t = time.time()
         atoms.get_potential_energy()
         c.write(atoms,
                 name=name, mode=mode, e=e, linspacestr=linspacestr,
                 kptdensity=kptdensity, width=width,
                 relativistic=relativistic,
                 constant_basis=constant_basis,
```

### Comparing `gpaw-22.8.0/gpaw/test/big/dcdft/pbe_gpaw_pw_verify.py` & `gpaw-23.6.0/gpaw/test/big/dcdft/pbe_gpaw_pw_verify.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/big/g2_1/analyse.py` & `gpaw-23.6.0/gpaw/test/big/g2_1/analyse.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/big/g2_1/g21gpaw.py` & `gpaw-23.6.0/gpaw/test/big/g2_1/g21gpaw.py`

 * *Files 4% similar despite different names*

```diff
@@ -16,15 +16,15 @@
     atoms.cell = [12, 13.01, 14.02]
     atoms.center()
     atoms.calc = GPAW(mode=PW(800),
                       xc='PBE',
                       occupations=FermiDirac(0.0, fixmagmom=True),
                       txt=name + '.txt')
     if name in ['Na2', 'NaCl', 'NO', 'ClO', 'Cl', 'Si']:
-        atoms.calc.set(eigensolver='dav',
-                       mixer=Mixer(0.05, 2))
+        atoms.calc = atoms.calc.new(eigensolver='dav',
+                                    mixer=Mixer(0.05, 2))
     atoms.get_forces()
     c.write(atoms, id=id, name=name, relaxed=False)
     if len(atoms) > 1:
         opt = BFGS(atoms, logfile=name + '.gpaw.log')
         opt.run(0.01)
         c.write(atoms, name=name, relaxed=True)
```

### Comparing `gpaw-22.8.0/gpaw/test/big/g2_1/g21nwchem.py` & `gpaw-23.6.0/gpaw/test/big/g2_1/g21nwchem.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/big/g2_1/pbe_gpaw_nrel_plot.py` & `gpaw-23.6.0/gpaw/test/big/g2_1/pbe_gpaw_nrel_plot.py`

 * *Files 2% similar despite different names*

```diff
@@ -153,15 +153,14 @@
     # ywindow = maxy - miny
     # pylab.gca().set_ylim(miny, maxy+ywindow/5.0)
     pylab.gca().set_ylim(miny, maxy)
     # pylab.plot(xdata, ydata, 'b.', label=label, color=color)
     # pylab.plot(xdata, ydata, 'b-', label='_nolegend_', color=color)
     pylab.bar(xdata, ydata, 0.9, label=label, color=color, alpha=alpha)
     t = pylab.title(title)
-    # http://old.nabble.com/More-space-between-title-and-secondary-x-axis-td31722298.html
     t.set_y(1.05)
     pylab.xlabel(xlabel)
     pylab.ylabel(ylabel)
     prop = matplotlib.font_manager.FontProperties(size=12)
     leg = pylab.legend(loc='upper right', fancybox=True, prop=prop)
     leg.get_frame().set_alpha(0.5)
```

### Comparing `gpaw-22.8.0/gpaw/test/big/hsk/hsk.py` & `gpaw-23.6.0/gpaw/test/big/hsk/hsk.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/big/kpb/check.py` & `gpaw-23.6.0/gpaw/test/big/kpb/check.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/big/kpb/molecules.py` & `gpaw-23.6.0/gpaw/test/big/kpb/molecules.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/conftest.py` & `gpaw-23.6.0/gpaw/utilities/__init__.py`

 * *Files 25% similar despite different names*

```diff
@@ -1,409 +1,414 @@
+# Copyright (C) 2003  CAMP
+# Please see the accompanying LICENSE file for further information.
+
+"""Utility functions and classes."""
+
 import os
-import warnings
+import re
+import sys
+import time
 from contextlib import contextmanager
+from math import sqrt
 from pathlib import Path
+from typing import Union
 
 import numpy as np
-import pytest
-from _pytest.tmpdir import _mk_tmp
 from ase import Atoms
-from ase.build import bulk
-from ase.io import read
-from gpaw import GPAW, PW, Davidson, FermiDirac, setup_paths
-from gpaw.cli.info import info
-from gpaw.mpi import broadcast, world
-from gpaw.utilities import devnull
+from ase.data import covalent_radii
+from ase.neighborlist import neighbor_list
 
+import _gpaw
+import gpaw.mpi as mpi
+from gpaw import debug
+
+# Code will crash for setups without any projectors.  Setups that have
+# no projectors therefore receive a dummy projector as a hacky
+# workaround.  The projector is assigned a certain, small size.  If
+# the grid is so coarse that no point falls within the projector's range,
+# there'll also be an error.  So this limits allowed grid spacings.
+min_locfun_radius = 0.85  # Bohr
+smallest_safe_grid_spacing = 2 * min_locfun_radius / np.sqrt(3)  # ~0.52 Ang
+
+
+class AtomsTooClose(ValueError):
+    pass
+
+
+def check_atoms_too_close(atoms: Atoms) -> None:
+    radii = covalent_radii[atoms.numbers] * 0.01
+    dists = neighbor_list('d', atoms, radii)
+    if len(dists):
+        raise AtomsTooClose(f'Atoms are too close, e.g. {dists[0]} Å')
+
+
+def check_atoms_too_close_to_boundary(atoms: Atoms,
+                                      dist: float = 0.2) -> None:
+    """Check if any atoms are too close to the boundary of the box.
+
+    >>> atoms = Atoms('H', cell=[1, 1, 1])
+    >>> check_atoms_too_close_to_boundary(atoms)
+    Traceback (most recent call last):
+    ...
+        raise AtomsTooClose('Atoms too close to boundary')
+    gpaw.utilities.AtomsTooClose: Atoms too close to boundary
+    >>> atoms.center()
+    >>> check_atoms_too_close_to_boundary(atoms)
+    >>> atoms = Atoms('H',
+    ...               positions=[[0.5, 0.5, 0.0]],
+    ...               cell=[1, 1, 0],  # no bounday in z-direction
+    ...               pbc=(1, 1, 0))
+    >>> check_atoms_too_close_to_boundary(atoms)
+    """
+    for axis_v, recip_v, pbc in zip(atoms.cell,
+                                    atoms.cell.reciprocal(),
+                                    atoms.pbc):
+        if pbc:
+            continue
+        L = np.linalg.norm(axis_v)
+        if L < 1e-12:  # L==0 means no boundary
+            continue
+        spos_a = atoms.positions @ recip_v
+        eps = dist / L
+        if (spos_a < eps).any() or (spos_a > 1 - eps).any():
+            raise AtomsTooClose('Atoms too close to boundary')
+
+
+def unpack_atomic_matrices(M_sP, setups):
+    M_asp = {}
+    P1 = 0
+    for a, setup in enumerate(setups):
+        ni = setup.ni
+        P2 = P1 + ni * (ni + 1) // 2
+        M_asp[a] = M_sP[:, P1:P2].copy()
+        P1 = P2
+    return M_asp
+
+
+def pack_atomic_matrices(M_asp):
+    M2_asp = M_asp.copy()
+    M2_asp.redistribute(M2_asp.partition.as_serial())
+    return M2_asp.toarray(axis=1)
+
+
+def h2gpts(h, cell_cv, idiv=4):
+    """Convert grid spacing to number of grid points divisible by idiv.
+
+    Note that units of h and cell_cv must match!
+
+    h: float
+        Desired grid spacing in.
+    cell_cv: 3x3 ndarray
+        Unit cell.
+    """
 
-@contextmanager
-def execute_in_tmp_path(request, tmp_path_factory):
-    if world.rank == 0:
-        # Obtain basename as
-        # * request.function.__name__  for function fixture
-        # * request.module.__name__    for module fixture
-        basename = getattr(request, request.scope).__name__
-        path = tmp_path_factory.mktemp(basename)
+    L_c = (np.linalg.inv(cell_cv)**2).sum(0)**-0.5
+    return np.maximum(idiv, (L_c / h / idiv + 0.5).astype(int) * idiv)
+
+
+def is_contiguous(array, dtype=None):
+    """Check for contiguity and type."""
+    if dtype is None:
+        return array.flags.c_contiguous
     else:
-        path = None
-    path = broadcast(path)
-    cwd = os.getcwd()
-    os.chdir(path)
-    try:
-        yield path
-    finally:
-        os.chdir(cwd)
+        return array.flags.c_contiguous and array.dtype == dtype
 
 
-@pytest.fixture(scope='function')
-def in_tmp_dir(request, tmp_path_factory):
-    """Run test function in a temporary directory."""
-    with execute_in_tmp_path(request, tmp_path_factory) as path:
-        yield path
+# Radial-grid Hartree solver:
+#
+#                       l
+#             __  __   r
+#     1      \   4||    <   * ^    ^
+#   ------ =  )  ---- ---- Y (r)Y (r'),
+#    _ _     /__ 2l+1  l+1  lm   lm
+#   |r-r'|    lm      r
+#                      >
+# where
+#
+#   r = min(r, r')
+#    <
+#
+# and
+#
+#   r = max(r, r')
+#    >
+#
+def hartree(l: int, nrdr: np.ndarray, r: np.ndarray, vr: np.ndarray) -> None:
+    """Calculates radial Coulomb integral.
+
+    The following integral is calculated::
+
+                                   ^
+                          n (r')Y (r')
+              ^    / _     l     lm
+      v (r)Y (r) = |dr' --------------,
+       l    lm     /        _   _
+                           |r - r'|
+
+    where input and output arrays `nrdr` and `vr`::
+
+              dr
+      n (r) r --  and  v (r) r.
+       l      dg        l
+    """
+    assert is_contiguous(nrdr, float)
+    assert is_contiguous(r, float)
+    assert is_contiguous(vr, float)
+    assert nrdr.shape == vr.shape and len(vr.shape) == 1
+    assert len(r.shape) == 1
+    assert len(r) >= len(vr)
+    return _gpaw.hartree(l, nrdr, r, vr)
 
 
-@pytest.fixture(scope='module')
-def module_tmp_path(request, tmp_path_factory):
-    """Run test module in a temporary directory."""
-    with execute_in_tmp_path(request, tmp_path_factory) as path:
-        yield path
+def packed_index(i1, i2, ni):
+    """Return a packed index"""
+    if i1 > i2:
+        return (i2 * (2 * ni - 1 - i2) // 2) + i1
+    else:
+        return (i1 * (2 * ni - 1 - i1) // 2) + i2
 
 
-@pytest.fixture
-def add_cwd_to_setup_paths():
-    """Temporarily add current working directory to setup_paths."""
-    try:
-        setup_paths[:0] = ['.']
-        yield
-    finally:
-        del setup_paths[:1]
+def unpacked_indices(p, ni):
+    """Return unpacked indices corresponding to upper triangle"""
+    assert 0 <= p < ni * (ni + 1) // 2
+    i1 = int(ni + .5 - sqrt((ni - .5)**2 - 2 * (p - ni)))
+    return i1, p - i1 * (2 * ni - 1 - i1) // 2
+
+
+packing_conventions = """\n
+In the code, the convention is that density matrices are constructed using
+pack / unpack2, and anything that should be multiplied onto such, e.g.
+corrections to the Hamiltonian, are constructed according to pack2 / unpack.
+"""
+
+
+def unpack(M):
+    """Unpack 1D array to 2D, assuming a packing as in ``pack2``."""
+    if M.ndim == 2:
+        return np.array([unpack(m) for m in M])
+    assert is_contiguous(M)
+    assert M.ndim == 1
+    n = int(sqrt(0.25 + 2.0 * len(M)))
+    M2 = np.zeros((n, n), M.dtype.char)
+    if M.dtype == complex:
+        _gpaw.unpack_complex(M, M2)
+    else:
+        _gpaw.unpack(M, M2)
+    return M2
 
 
-@pytest.fixture(scope='session')
-def gpw_files(request, tmp_path_factory):
-    """Reuse gpw-files.
+def unpack2(M):
+    """Unpack 1D array to 2D, assuming a packing as in ``pack``."""
+    if M.ndim == 2:
+        return np.array([unpack2(m) for m in M])
+    M2 = unpack(M)
+    M2 *= 0.5  # divide all by 2
+    M2.flat[0::len(M2) + 1] *= 2  # rescale diagonal to original size
+    return M2
 
-    Returns a dict mapping names to paths to gpw-files.  If you
-    want to reuse gpw-files from an earlier pytest session then set the
-    ``$GPW_TEST_FILES`` environment variable and the files will be written
-    to that folder.
 
-    Example::
+def pack(A: np.ndarray) -> np.ndarray:
+    r"""Pack a 2D array to 1D, adding offdiagonal terms.
 
-        def test_something(gpw_files):
-            calc = GPAW(gpw_files['h2_lcao_wfs'])
-            ...
+    The matrix::
 
-    Possible systems are:
+           / a00 a01 a02 \
+       A = | a10 a11 a12 |
+           \ a20 a21 a22 /
 
-    * Bulk BCC-Li with 3x3x3 k-points: ``bcc_li_pw``, ``bcc_li_fd``,
-      ``bcc_li_lcao``.
+    is transformed to the vector::
 
-    * O2 molecule: ``o2_pw``.
+      (a00, a01 + a10, a02 + a20, a11, a12 + a21, a22)
+    """
+    assert A.ndim == 2
+    assert A.shape[0] == A.shape[1]
+    assert A.dtype in [float, complex]
+    return _gpaw.pack(A)
 
-    * H2 molecule: ``h2_pw``, ``h2_fd``, ``h2_lcao``.
 
-    * H2 molecule (not centered): ``h2_pw_0``.
+def pack2(M2, tolerance=1e-10):
+    r"""Pack a 2D array to 1D, averaging offdiagonal terms.
 
-    * Spin-polarized H atom: ``h_pw``.
+    The matrix::
 
-    * Polyethylene chain.  One unit, 3 k-points, no symmetry:
-      ``c2h4_pw_nosym``.  Three units: ``c6h12_pw``.
+           / a00 a01 a02 \
+       A = | a10 a11 a12 |
+           \ a20 a21 a22 /
 
-    * Bulk TiO2 with 4x4x4 k-points: ``ti2o4_pw`` and ``ti2o4_pw_nosym``.
+    is transformed to the vector::
 
-    * Bulk BN (zinkblende) with 2x2x2 k-points and 9 converged bands:
-      ``bn_pw``.
+      (a00, [a01 + a10]/2, [a02 + a20]/2, a11, [a12 + a21]/2, a22)
+    """
+    if M2.ndim == 3:
+        return np.array([pack2(m2) for m2 in M2])
+    n = len(M2)
+    M = np.zeros(n * (n + 1) // 2, M2.dtype)
+    p = 0
+    for r in range(n):
+        M[p] = M2[r, r]
+        p += 1
+        for c in range(r + 1, n):
+            M[p] = (M2[r, c] + np.conjugate(M2[c, r])) / 2.  # note / 2.
+            error = abs(M2[r, c] - np.conjugate(M2[c, r]))
+            assert error < tolerance, 'Pack not symmetric by %s' % error + ' %'
+            p += 1
+    assert p == len(M)
+    return M
+
+
+for method in (unpack, unpack2, pack, pack2):
+    method.__doc__ += packing_conventions  # type: ignore
+
+
+def element_from_packed(M, i, j):
+    """Return a specific element from a packed array (by ``pack``)."""
+    n = int(sqrt(2 * len(M) + .25))
+    assert i < n and j < n
+    p = packed_index(i, j, n)
+    if i == j:
+        return M[p]
+    elif i > j:
+        return .5 * M[p]
+    else:
+        return .5 * np.conjugate(M[p])
 
-    * Graphene with 6x6x1 k-points: graphene_pw
 
-    * MoS2 with 6x6x1 k-points: mos2_pw
+def logfile(name, rank=0):
+    """Create file object from name.
 
-    Files with wave functions are also availabe (add ``_wfs`` to the names).
-    """
-    path = os.environ.get('GPW_TEST_FILES')
-    if not path:
-        warnings.warn(
-            'Note that you can speed up the tests by reusing gpw-files '
-            'from an earlier pytest session: '
-            'set the $GPW_TEST_FILES environment variable and the '
-            'files will be written to/read from that folder. '
-            'See: https://wiki.fysik.dtu.dk/gpaw/devel/testing.html'
-            '#gpaw.test.conftest.gpw_files')
-        if world.rank == 0:
-            path = _mk_tmp(request, tmp_path_factory)
+    Use None for /dev/null and '-' for sys.stdout.  Ranks > 0 will
+    get /dev/null."""
+
+    if rank == 0:
+        if name is None:
+            fd = devnull
+        elif name == '-':
+            fd = sys.stdout
+        elif isinstance(name, str):
+            fd = open(name, 'w')
         else:
-            path = None
-        path = broadcast(path)
-    return GPWFiles(Path(path))
-
-
-class GPWFiles:
-    """Create gpw-files."""
-    def __init__(self, path: Path):
-        self.path = path
-        path.mkdir(exist_ok=True)
-        self.gpw_files = {}
-        for file in path.glob('*.gpw'):
-            self.gpw_files[file.name[:-4]] = file
-
-    def __getitem__(self, name: str) -> Path:
-        if name not in self.gpw_files:
-            rawname, _, _ = name.partition('_wfs')
-            calc = getattr(self, rawname)()
-            path = self.path / (rawname + '.gpw')
-            calc.write(path)
-            self.gpw_files[rawname] = path
-            path = self.path / (rawname + '_wfs.gpw')
-            calc.write(path, mode='all')
-            self.gpw_files[rawname + '_wfs'] = path
-        return self.gpw_files[name]
-
-    def bcc_li_pw(self):
-        return self.bcc_li({'name': 'pw', 'ecut': 200})
-
-    def bcc_li_fd(self):
-        return self.bcc_li({'name': 'fd'})
-
-    def bcc_li_lcao(self):
-        return self.bcc_li({'name': 'lcao'})
-
-    def bcc_li(self, mode):
-        li = bulk('Li', 'bcc', 3.49)
-        li.calc = GPAW(mode=mode,
-                       kpts=(3, 3, 3),
-                       txt=self.path / f'bcc_li_{mode["name"]}.txt')
-        li.get_potential_energy()
-        return li.calc
-
-    def h2_pw(self):
-        return self.h2({'name': 'pw', 'ecut': 200})
-
-    def h2_fd(self):
-        return self.h2({'name': 'fd'})
-
-    def h2_lcao(self):
-        return self.h2({'name': 'lcao'})
-
-    def h2(self, mode):
-        h2 = Atoms('H2', positions=[[0, 0, 0], [0.74, 0, 0]])
-        h2.center(vacuum=2.5)
-        h2.calc = GPAW(mode=mode,
-                       txt=self.path / f'h2_{mode["name"]}.txt')
-        h2.get_potential_energy()
-        return h2.calc
-
-    def h2_pw_0(self):
-        h2 = Atoms('H2',
-                   positions=[[-0.37, 0, 0], [0.37, 0, 0]],
-                   cell=[5.74, 5, 5],
-                   pbc=True)
-        h2.calc = GPAW(mode={'name': 'pw', 'ecut': 200},
-                       txt=self.path / 'h2_pw_0.txt')
-        h2.get_potential_energy()
-        return h2.calc
-
-    def h_pw(self):
-        h = Atoms('H', magmoms=[1])
-        h.center(vacuum=4.0)
-        h.calc = GPAW(mode={'name': 'pw', 'ecut': 500},
-                      txt=self.path / 'h_pw.txt')
-        h.get_potential_energy()
-        return h.calc
-
-    def o2_pw(self):
-        d = 1.1
-        a = Atoms('O2', positions=[[0, 0, 0], [d, 0, 0]], magmoms=[1, 1])
-        a.center(vacuum=4.0)
-        a.calc = GPAW(mode={'name': 'pw', 'ecut': 800},
-                      txt=self.path / 'o2_pw.txt')
-        a.get_potential_energy()
-        return a.calc
-
-    def co_lcao(self):
-        d = 1.1
-        co = Atoms('CO', positions=[[0, 0, 0], [d, 0, 0]])
-        co.center(vacuum=4.0)
-        co.calc = GPAW(mode='lcao',
-                       txt=self.path / 'co_lcao.txt')
-        co.get_potential_energy()
-        return co.calc
-
-    def c2h4_pw_nosym(self):
-        d = 1.54
-        h = 1.1
-        x = d * (2 / 3)**0.5
-        z = d / 3**0.5
-        pe = Atoms('C2H4',
-                   positions=[[0, 0, 0],
-                              [x, 0, z],
-                              [0, -h * (2 / 3)**0.5, -h / 3**0.5],
-                              [0, h * (2 / 3)**0.5, -h / 3**0.5],
-                              [x, -h * (2 / 3)**0.5, z + h / 3**0.5],
-                              [x, h * (2 / 3)**0.5, z + h / 3**0.5]],
-                   cell=[2 * x, 0, 0],
-                   pbc=(1, 0, 0))
-        pe.center(vacuum=2.0, axis=(1, 2))
-        pe.calc = GPAW(mode='pw',
-                       kpts=(3, 1, 1),
-                       symmetry='off',
-                       txt=self.path / 'c2h4_pw_nosym.txt')
-        pe.get_potential_energy()
-        return pe.calc
-
-    def c6h12_pw(self):
-        pe = read(self['c2h4_pw_nosym'])
-        pe = pe.repeat((3, 1, 1))
-        pe.calc = GPAW(mode='pw', txt=self.path / 'c6h12_pw.txt')
-        pe.get_potential_energy()
-        return pe.calc
-
-    def h2o_lcao(self):
-        from ase.build import molecule
-        atoms = molecule('H2O', cell=[8, 8, 8], pbc=1)
-        atoms.center()
-        atoms.calc = GPAW(mode='lcao', txt=self.path / 'h2o.txt')
-        atoms.get_potential_energy()
-        return atoms.calc
-
-    def ti2o4(self, symmetry):
-        pwcutoff = 400.0
-        k = 4
-        a = 4.59
-        c = 2.96
-        u = 0.305
-
-        rutile_cell = [[a, 0, 0],
-                       [0, a, 0],
-                       [0, 0, c]]
-
-        TiO2_basis = np.array([[0.0, 0.0, 0.0],
-                               [0.5, 0.5, 0.5],
-                               [u, u, 0.0],
-                               [-u, -u, 0.0],
-                               [0.5 + u, 0.5 - u, 0.5],
-                               [0.5 - u, 0.5 + u, 0.5]])
-
-        bulk_crystal = Atoms(symbols='Ti2O4',
-                             scaled_positions=TiO2_basis,
-                             cell=rutile_cell,
-                             pbc=(1, 1, 1))
-
-        tag = '_nosym' if symmetry == 'off' else ''
-        bulk_calc = GPAW(mode=PW(pwcutoff),
-                         nbands=42,
-                         eigensolver=Davidson(1),
-                         kpts={'size': (k, k, k), 'gamma': True},
-                         xc='PBE',
-                         occupations=FermiDirac(0.00001),
-                         parallel={'band': 1},
-                         symmetry=symmetry,
-                         txt=self.path / f'ti2o4_pw{tag}.txt')
-
-        bulk_crystal.calc = bulk_calc
-        bulk_crystal.get_potential_energy()
-        return bulk_calc
-
-    def ti2o4_pw(self):
-        return self.ti2o4({})
-
-    def ti2o4_pw_nosym(self):
-        return self.ti2o4('off')
-
-    def bn_pw(self):
-        atoms = bulk('BN', 'zincblende', a=3.615)
-        atoms.calc = GPAW(mode=PW(400),
-                          kpts={'size': (2, 2, 2), 'gamma': True},
-                          nbands=12,
-                          convergence={'bands': 9},
-                          occupations=FermiDirac(0.001),
-                          txt=self.path / 'bn_pw.txt')
-        atoms.get_potential_energy()
-        return atoms.calc
-
-    def graphene_pw(self):
-        from ase.lattice.hexagonal import Graphene
-        atoms = Graphene(symbol='C',
-                         latticeconstant={'a': 2.45, 'c': 1.0},
-                         size=(1, 1, 1))
-        atoms.pbc = (1, 1, 0)
-        atoms.center(axis=2, vacuum=4.0)
-        ecut = 250
-        nkpts = 6
-        atoms.calc = GPAW(mode=PW(ecut),
-                          kpts={'size': (nkpts, nkpts, 1), 'gamma': True},
-                          nbands=len(atoms) * 6,
-                          txt=self.path / 'graphene_pw.txt')
-        atoms.get_potential_energy()
-        return atoms.calc
-
-    def mos2_pw(self):
-        from ase.build import mx2
-        atoms = mx2(formula='MoS2', kind='2H', a=3.184, thickness=3.127,
-                    size=(1, 1, 1), vacuum=5)
-        atoms.pbc = (1, 1, 1)
-        ecut = 250
-        nkpts = 6
-        atoms.calc = GPAW(mode=PW(ecut),
-                          xc='LDA',
-                          kpts={'size': (nkpts, nkpts, 1), 'gamma': True},
-                          occupations=FermiDirac(0.01),
-                          txt=self.path / 'mos2_pw.txt')
-
-        atoms.get_potential_energy()
-        return atoms.calc
-
-
-class GPAWPlugin:
-    def __init__(self):
-        if world.rank == -1:
-            print()
-            info()
-
-    def pytest_terminal_summary(self, terminalreporter, exitstatus, config):
-        from gpaw.mpi import size
-        terminalreporter.section('GPAW-MPI stuff')
-        terminalreporter.write(f'size: {size}\n')
+            fd = name
+    else:
+        fd = devnull
+    return fd
 
 
-def pytest_configure(config):
-    if world.rank != 0:
+def uncamelcase(name):
+    """Convert a CamelCase name to a string of space-seperated words."""
+    words = re.split('([A-Z]{1}[a-z]+)', name)
+    return ' '.join([word for word in words if word != ''])
+
+
+def divrl(a_g, l, r_g):
+    """Return array divided by r to the l'th power."""
+    b_g = a_g.copy()
+    if l > 0:
+        b_g[1:] /= r_g[1:]**l
+        b1, b2 = b_g[1:3]
+        r12, r22 = r_g[1:3]**2
+        b_g[0] = (b1 * r22 - b2 * r12) / (r22 - r12)
+    return b_g
+
+
+def compiled_with_sl():
+    return hasattr(_gpaw, 'new_blacs_context')
+
+
+def compiled_with_libvdwxc():
+    return hasattr(_gpaw, 'libvdwxc_create')
+
+
+def load_balance(paw, atoms):
+    try:
+        paw.initialize(atoms)
+    except SystemExit:
+        pass
+    atoms_r = np.zeros(paw.wfs.world.size)
+    rnk_a = paw.wfs.gd.get_ranks_from_positions(paw.spos_ac)
+    for rnk in rnk_a:
+        atoms_r[rnk] += 1
+    max_atoms = max(atoms_r)
+    min_atoms = min(atoms_r)
+    ave_atoms = atoms_r.sum() / paw.wfs.world.size
+    stddev_atoms = sqrt((atoms_r**2).sum() / paw.wfs.world.size - ave_atoms**2)
+    print("Information about load balancing")
+    print("--------------------------------")
+    print("Number of atoms:", len(paw.spos_ac))
+    print("Number of CPUs:", paw.wfs.world.size)
+    print("Max. number of atoms/CPU:   ", max_atoms)
+    print("Min. number of atoms/CPU:   ", min_atoms)
+    print("Average number of atoms/CPU:", ave_atoms)
+    print("    standard deviation:     %5.1f" % stddev_atoms)
+
+
+if not debug:
+    hartree = _gpaw.hartree  # noqa
+    pack = _gpaw.pack
+
+
+def unlink(path: Union[str, Path], world=None):
+    """Safely unlink path (delete file or symbolic link)."""
+
+    if isinstance(path, str):
+        path = Path(path)
+    if world is None:
+        world = mpi.world
+
+    # Remove file:
+    if world.rank == 0:
         try:
-            tw = config.get_terminal_writer()
-        except AttributeError:
+            path.unlink()
+        except FileNotFoundError:
             pass
-        else:
-            tw._file = devnull
-    config.pluginmanager.register(GPAWPlugin(), 'pytest_gpaw')
-    for line in ['soc: Spin-orbit coupling',
-                 'slow: slow test',
-                 'fast: fast test',
-                 'ci: test included in CI',
-                 'libxc: LibXC requirered',
-                 'mgga: MGGA test',
-                 'dscf: Delta-SCF',
-                 'mom: MOM',
-                 'gllb: GLLBSC tests',
-                 'elph: Electron-phonon',
-                 'intel: fails on INTEL toolchain',
-                 'response: tests of the response code',
-                 'kspair: tests of kspair in the response code',
-                 'serial: run in serial only',
-                 'skip_for_new_gpaw: know failure for new refactored GPAW']:
-        config.addinivalue_line('markers', line)
+    else:
+        while path.is_file():
+            time.sleep(1.0)
+    world.barrier()
 
 
-def pytest_runtest_setup(item):
-    """Skip some tests.
+@contextmanager
+def file_barrier(path: Union[str, Path], world=None):
+    """Context manager for writing a file.
 
-    If:
+    After the with-block all cores will be able to read the file.
 
-    * they depend on libxc and GPAW is not compiled with libxc
-    * they are before $PYTEST_START_AFTER
+    >>> with file_barrier('something.txt'):
+    ...     result = 2 + 2
+    ...     Path('something.txt').write_text(f'{result}')  # doctest: +SKIP
+
+    This will remove the file, write the file and wait for the file.
     """
-    from gpaw import libraries
 
-    if world.size > 1:
-        for mark in item.iter_markers():
-            if mark.name == 'serial':
-                pytest.skip('Only run in serial')
+    if isinstance(path, str):
+        path = Path(path)
+    if world is None:
+        world = mpi.world
+
+    # Remove file:
+    unlink(path, world)
 
-    if item.location[0] <= os.environ.get('PYTEST_START_AFTER', ''):
-        pytest.skip('Not after $PYTEST_START_AFTER')
-        return
+    yield
 
-    if libraries['libxc']:
-        return
+    # Wait for file:
+    while not path.is_file():
+        time.sleep(1.0)
+    world.barrier()
 
-    if any(mark.name in {'libxc', 'mgga'}
-           for mark in item.iter_markers()):
-        pytest.skip('No LibXC.')
 
+devnull = open(os.devnull, 'w')
 
-@pytest.fixture
-def scalapack():
-    """Skip if not compiled with sl.
 
-    This fixture otherwise does not return or do anything."""
-    from gpaw.utilities import compiled_with_sl
-    if not compiled_with_sl():
-        pytest.skip(reason='no scalapack')
+def convert_string_to_fd(name, world=None):
+    """Create a file-descriptor for text output.
+
+    Will open a file for writing with given name.  Use None for no output and
+    '-' for sys.stdout.
+    """
+    if world is None:
+        from ase.parallel import world
+    if name is None or world.rank != 0:
+        return open(os.devnull, 'w')
+    if name == '-':
+        return sys.stdout
+    if isinstance(name, (str, Path)):
+        return open(name, 'w')
+    return name  # we assume name is already a file-descriptor
```

#### encoding

```diff
@@ -1 +1 @@
-us-ascii
+utf-8
```

### Comparing `gpaw-22.8.0/gpaw/test/corehole/si_nonortho.py` & `gpaw-23.6.0/gpaw/test/corehole/si_nonortho.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/corehole/test_h2o.py` & `gpaw-23.6.0/gpaw/test/corehole/test_h2o.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,18 +1,22 @@
+from math import cos, pi, sin
+
 import numpy as np
-from math import pi, cos, sin
+import pytest
 from ase import Atom, Atoms
+
+import gpaw.mpi as mpi
 from gpaw import GPAW
+from gpaw.atom.generator2 import generate
 from gpaw.poisson import FDPoissonSolver
-from gpaw.xas import XAS
 from gpaw.test import equal
-from gpaw.atom.generator2 import generate
-import gpaw.mpi as mpi
+from gpaw.xas import XAS
 
 
+@pytest.mark.later
 def test_corehole_h2o(in_tmp_dir, add_cwd_to_setup_paths):
     # Generate setup for oxygen with half a core-hole:
     gen = generate('O', 8, '2s,s,2p,p,d', [1.2], 1.0, None, 2,
                    core_hole='1s,0.5')
     setup = gen.make_paw_setup('hch1s')
     setup.write_xml()
 
@@ -35,17 +39,17 @@
         x, y = xas.get_spectra()
         e1_n = xas.eps_n
         de1 = e1_n[1] - e1_n[0]
 
     calc.write('h2o-xas.gpw')
 
     if mpi.size == 1:
-        calc = GPAW('h2o-xas.gpw', txt=None,
-                    poissonsolver=FDPoissonSolver(use_charge_center=True))
-        calc.initialize()
+        calc = GPAW('h2o-xas.gpw')
+        # poissonsolver=FDPoissonSolver(use_charge_center=True))
+        # calc.initialize()
         xas = XAS(calc)
         x, y = xas.get_spectra()
         e2_n = xas.eps_n
         w_n = np.sum(xas.sigma_cn.real**2, axis=0)
         de2 = e2_n[1] - e2_n[0]
 
         equal(de2, 2.064, 0.005)
```

### Comparing `gpaw-22.8.0/gpaw/test/corehole/test_h2o_dks.py` & `gpaw-23.6.0/gpaw/test/corehole/test_h2o_dks.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,58 +1,54 @@
+import pytest
 from ase.build import molecule
 
 from gpaw import GPAW, FermiDirac, PoissonSolver
 from gpaw.test import equal, gen
 
-# Generate setup for oxygen with a core-hole:
-
 
+@pytest.mark.later
 def test_corehole_h2o_dks():
     def xc(name):
         return {'name': name, 'stencil': 1}
 
+    # Generate setup for oxygen with a core-hole:
     s = gen('O', name='fch1s', xcname='PBE', corehole=(1, 0, 1.0))
 
     atoms = molecule('H2O')
     atoms.center(vacuum=2.5)
 
-    calc = GPAW(xc=xc('PBE'),
-                poissonsolver=PoissonSolver('fd',
-                                            use_charge_center=True))
-    atoms.calc = calc
-    e1 = atoms.get_potential_energy() + calc.get_reference_energy()
-    niter1 = calc.get_number_of_iterations()
+    params = dict(xc=xc('PBE'),
+                  poissonsolver=PoissonSolver('fd',
+                                              use_charge_center=True))
+    atoms.calc = GPAW(**params)
+    e1 = atoms.get_potential_energy() + atoms.calc.get_reference_energy()
 
     atoms[0].magmom = 1
-    calc.set(charge=-1,
-             setups={'O': s},
-             occupations=FermiDirac(0.0, fixmagmom=True))
-    e2 = atoms.get_potential_energy() + calc.get_reference_energy()
-    niter2 = calc.get_number_of_iterations()
+    atoms.calc = GPAW(charge=-1,
+                      setups={'O': s},
+                      occupations=FermiDirac(0.0, fixmagmom=True),
+                      **params)
+    e2 = atoms.get_potential_energy() + atoms.calc.get_reference_energy()
 
     atoms[0].magmom = 0
-    calc.set(charge=0,
-             setups={'O': s},
-             occupations=FermiDirac(0.0, fixmagmom=True),
-             spinpol=True)
-    e3 = atoms.get_potential_energy() + calc.get_reference_energy()
-    niter3 = calc.get_number_of_iterations()
+    atoms.calc = GPAW(charge=0,
+                      setups={'O': s},
+                      occupations=FermiDirac(0.0, fixmagmom=True),
+                      spinpol=True,
+                      **params)
+    e3 = atoms.get_potential_energy() + atoms.calc.get_reference_energy()
 
     print('Energy difference %.3f eV' % (e2 - e1))
     print('XPS %.3f eV' % (e3 - e1))
 
     print(e2 - e1)
     print(e3 - e1)
     assert abs(e2 - e1 - 533.070) < 0.001
     assert abs(e3 - e1 - 538.549) < 0.001
 
     energy_tolerance = 0.02
-    print(e1, niter1)
-    print(e2, niter2)
-    print(e3, niter3)
+    print(e1)
+    print(e2)
+    print(e3)
     equal(e1, -2080.3651, energy_tolerance)
     equal(e2, -1547.2944, energy_tolerance)
     equal(e3, -1541.8152, energy_tolerance)
-
-
-if __name__ == '__main__':
-    test_corehole_h2o_dks()
```

### Comparing `gpaw-22.8.0/gpaw/test/corehole/test_h2o_recursion.py` & `gpaw-23.6.0/gpaw/test/corehole/test_h2o_recursion.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,13 +1,17 @@
-from math import pi, cos, sin
+from math import cos, pi, sin
+
+import pytest
 from ase import Atom, Atoms
-from gpaw import GPAW, PoissonSolver, Mixer, Davidson
+
+from gpaw import GPAW, Davidson, Mixer, PoissonSolver
 from gpaw.test import equal, gen
 
 
+@pytest.mark.later
 def test_corehole_h2o_recursion(in_tmp_dir):
     # Generate setup for oxygen with half a core-hole:
     s = gen('O', name='hch1s', corehole=(1, 0, 0.5))
 
     a = 5.0
     d = 0.9575
     t = pi / 180 * 104.51
```

### Comparing `gpaw-22.8.0/gpaw/test/corehole/test_si.py` & `gpaw-23.6.0/gpaw/test/corehole/test_si.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,29 +1,28 @@
+import pytest
 from ase import Atoms
+
 from gpaw import GPAW, FermiDirac
-from gpaw.xas import XAS, RecursionMethod
 from gpaw.test import gen
+from gpaw.xas import XAS, RecursionMethod
 
 
+@pytest.mark.later
 def test_corehole_si(in_tmp_dir, add_cwd_to_setup_paths):
     # Generate setup for oxygen with half a core-hole:
     gen('Si', name='hch1s', corehole=(1, 0, 0.5), gpernode=30, write_xml=True)
     a = 2.6
     si = Atoms('Si', cell=(a, a, a), pbc=True)
 
     import numpy as np
     calc = GPAW(nbands=None,
                 h=0.25,
                 occupations=FermiDirac(width=0.05),
-                setups='hch1s')
-
-    def stopcalc():
-        calc.scf.converged = 1
-
-    calc.attach(stopcalc, 1)
+                setups='hch1s',
+                convergence={'maximum iterations': 1})
     si.calc = calc
     _ = si.get_potential_energy()
     calc.write('si.gpw')
 
     # restart from file
     calc = GPAW('si.gpw')
 
@@ -31,16 +30,16 @@
     if mpi.size == 1:
         xas = XAS(calc)
         x, y = xas.get_spectra()
     else:
         x = np.linspace(0, 10, 50)
 
     k = 2
-    calc.set(kpts=(k, k, k))
-    calc.initialize()
+    calc = calc.new(kpts=(k, k, k))
+    calc.initialize(si)
     calc.set_positions(si)
     assert calc.wfs.dtype == complex
 
     r = RecursionMethod(calc)
     r.run(40)
     if mpi.size == 1:
         z = r.get_spectra(x)
```

### Comparing `gpaw-22.8.0/gpaw/test/crontab.py` & `gpaw-23.6.0/gpaw/test/crontab.py`

 * *Files 10% similar despite different names*

```diff
@@ -14,17 +14,17 @@
 pip install pytest sphinx-rtd-theme coverage
 pip install -q git+https://gitlab.com/ase/ase.git@master
 git clone git@gitlab.com:gpaw/gpaw
 cd gpaw
 pip install -e .
 coverage run -m pytest > test-1.out
 coverage html
-gpaw -P 2 python -m pytest -- -x > test-2.out
-gpaw -P 4 python -m pytest -- -x > test-4.out
-gpaw -P 8 python -m pytest -- -x > test-8.out"""
+gpaw -P 2 python -m pytest -x > test-2.out
+gpaw -P 4 python -m pytest -x > test-4.out
+gpaw -P 8 python -m pytest -x > test-8.out"""
 
 
 def run_tests():
     home = Path.cwd()
     root = Path('/tmp/gpaw-tests')
     if root.is_dir():
         sys.exit('Locked')
```

### Comparing `gpaw-22.8.0/gpaw/test/dipole_me_test.py` & `gpaw-23.6.0/gpaw/test/test_dipole_me.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/dipole_test.py` & `gpaw-23.6.0/gpaw/test/test_dipole_new.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/dscf/dscf_forces.py` & `gpaw-23.6.0/gpaw/test/dscf/dscf_forces.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/dscf/test_dscf_lcao.py` & `gpaw-23.6.0/gpaw/test/dscf/test_dscf_lcao.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/eigen/test_blocked_rmm_diis.py` & `gpaw-23.6.0/gpaw/test/eigen/test_blocked_rmm_diis.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/eigen/test_cg.py` & `gpaw-23.6.0/gpaw/test/eigen/test_cg.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/eigen/test_cg2.py` & `gpaw-23.6.0/gpaw/test/eigen/test_cg2.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/eigen/test_davidson.py` & `gpaw-23.6.0/gpaw/test/eigen/test_davidson.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/eigen/test_keep_htpsit.py` & `gpaw-23.6.0/gpaw/test/eigen/test_keep_htpsit.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/elph/test_electronphonon.py` & `gpaw-23.6.0/gpaw/test/elph/test_electronphonon.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/elph/test_elph_li.py` & `gpaw-23.6.0/gpaw/test/elph/test_elph_li.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/ext_potential/stark_shift.py` & `gpaw-23.6.0/gpaw/test/ext_potential/stark_shift.py`

 * *Files 4% similar despite different names*

```diff
@@ -169,15 +169,16 @@
         e = []
         e1s = []
         d = []
         fields = np.linspace(-maxfield, maxfield, nfs)
         for field in fields:
             if rank == 0 and debug:
                 print(field)
-            c.set(external=ConstantElectricField(field))
+            c = c.new(external=ConstantElectricField(field))
+            a.calc = c
             etot = a.get_potential_energy()
             e += [etot]
             ev0 = c.get_eigenvalues(0)
             ev1 = c.get_eigenvalues(1)
             e1s += [min(ev0[0], ev1[0])]
             dip = c.get_dipole_moment()
             d += [dip[2]]
@@ -211,15 +212,16 @@
         d = []
         charges = np.linspace(-maxcharge, maxcharge, nfs)
         fields = []
         for charge in charges:
             ex = PointCharges(positions=[[a0 / 2, a0 / 2, -pcd / 2 + a0 / 2],
                                          [a0 / 2, a0 / 2, pcd / 2 + a0 / 2]],
                               charges=[charge, -charge])
-            c.set(external=ex)
+            c = c.new(external=ex)
+            a.calc = c
             etot = a.get_potential_energy()
             e += [etot]
             ev0 = c.get_eigenvalues(0)
             ev1 = c.get_eigenvalues(1)
             e1s += [min(ev0[0], ev1[0])]
             dip = c.get_dipole_moment()
             d += [dip[2]]
```

### Comparing `gpaw-22.8.0/gpaw/test/ext_potential/test_b_field.py` & `gpaw-23.6.0/gpaw/test/ext_potential/test_b_field.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,14 +1,15 @@
 import pytest
 from ase import Atoms
 
 from gpaw import GPAW
 from gpaw.bfield import BField
 
 
+@pytest.mark.later
 @pytest.mark.serial
 def test_b_field():
     """Hydrogen atom in a magnetic field."""
     L = 2.0
     atom = Atoms('H', magmoms=[1], cell=[L, L, L], pbc=True)
     atom.calc = GPAW(mode='pw')
     E1 = atom.get_potential_energy()
```

### Comparing `gpaw-22.8.0/gpaw/test/ext_potential/test_collection.py` & `gpaw-23.6.0/gpaw/test/ext_potential/test_collection.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/ext_potential/test_constant_e_field.py` & `gpaw-23.6.0/gpaw/test/ext_potential/test_constant_e_field.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,19 +1,20 @@
-"""A proton in an electric field."""
 import pytest
 import numpy as np
 from ase import Atoms
 from ase.units import Hartree, Bohr
 
 from gpaw import GPAW
 from gpaw.external import ConstantElectricField
 from gpaw.external import static_polarizability
 
 
+@pytest.mark.later
 def test_ext_potential_constant_e_field(in_tmp_dir):
+    """A proton in an electric field."""
     h = Atoms('H')
     h.center(vacuum=2.5)
     h.calc = GPAW(external=ConstantElectricField(1.0),  # 1 V / Ang
                   charge=1,
                   txt='h.txt')
     e = h.get_potential_energy()
     f1 = h.get_forces()[0, 2]
@@ -26,21 +27,27 @@
 
     # Check writing and reading:
     h.calc.write('h')
     vext = GPAW('h', txt=None).hamiltonian.vext
     assert abs(vext.field_v[2] - 1.0 * Bohr / Hartree) < 1e-13
 
 
+@pytest.mark.later
 def test_polarizability(in_tmp_dir):
     H2 = Atoms('H2', positions=[(0, 0, 0), (0.7, 0, 0)])
     H2.center(vacuum=2.5)
-    H2.calc = GPAW()
+    H2.calc = GPAW(symmetry={'point_group': False})
 
     strength = 0.1  # V/Ang
     alpha_cc = static_polarizability(H2, strength)
 
     # make sure no external potential is left over
     assert H2.calc.parameters.external is None
 
     assert alpha_cc.shape == (3, 3)
     assert alpha_cc == pytest.approx(
         np.diag([6.48529231e-02, 4.61303856e-2, 4.61303856e-2]))
+
+    # displace positions and make sure that you can still
+    # get the energy
+    H2[1].position[0] -= 0.001
+    H2.get_potential_energy()
```

### Comparing `gpaw-22.8.0/gpaw/test/ext_potential/test_external.py` & `gpaw-23.6.0/gpaw/test/ext_potential/test_external.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,15 +1,16 @@
-
+import pytest
 from ase import Atoms
-from gpaw import GPAW
-from gpaw.test import equal
 
+from gpaw import GPAW
 from gpaw.external import ConstantPotential
+from gpaw.test import equal
 
 
+@pytest.mark.later
 def test_ext_potential_external():
     sc = 2.9
     R = 0.7  # approx. experimental bond length
     R = 1.0
     a = 2 * sc
     c = 3 * sc
     H2 = Atoms('HH', [(a / 2, a / 2, (c - R) / 2),
```

### Comparing `gpaw-22.8.0/gpaw/test/ext_potential/test_harmonic.py` & `gpaw-23.6.0/gpaw/test/ext_potential/test_harmonic.py`

 * *Files 3% similar despite different names*

```diff
@@ -15,14 +15,15 @@
         r_vg = gd.get_grid_point_coordinates()
         self.vext_g = 0.5 * ((r_vg - a / 2)**2).sum(0)
 
     def todict(self):
         return {'name': 'HarmonicPotential'}
 
 
+@pytest.mark.later
 def test_ext_potential_harmonic(in_tmp_dir):
     """Test againts analytic result (no xc, no Coulomb)."""
     a = 4.0
     x = Atoms(cell=(a, a, a))  # no atoms
 
     calc = GPAW(charge=-8,
                 nbands=4,
@@ -58,14 +59,15 @@
         lam = 2
         self.vext_g = -lam * (lam + 1) / 2 * np.cosh(r_vg[2] - a / 2)**-2
 
     def todict(self):
         return {'name': 'HarmonicPotential'}
 
 
+@pytest.mark.later
 def test_pt_potential():
     """Test againts analytic result (no xc, no Coulomb)."""
     d = 6.0
     a = 2
     x = Atoms(cell=(a, a, d), pbc=[1, 1, 0])  # no atoms
 
     calc = GPAW(charge=-12,
```

### Comparing `gpaw-22.8.0/gpaw/test/ext_potential/test_point_charge.py` & `gpaw-23.6.0/gpaw/test/ext_potential/test_point_charge.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,19 +1,21 @@
 import numpy as np
+import pytest
 from ase import Atoms
 from ase.calculators.test import numeric_force
-from gpaw import GPAW, PoissonSolver, Mixer
+
+import _gpaw
+from gpaw import GPAW, Mixer, PoissonSolver
 from gpaw.external import PointChargePotential
 from gpaw.test import equal
-import _gpaw
-
-# Find coefs for polynomial:
 
 
+@pytest.mark.later
 def test_ext_potential_point_charge(in_tmp_dir):
+    # Find coefs for polynomial:
     c = np.linalg.solve([[1, 1, 1, 1],
                          [0, 2, 4, 6],
                          [0, 2, 12, 30],
                          [1 / 3, 1 / 5, 1 / 7, 1 / 9]],
                         [1, -1, 2, 0.5])
     print(c)
     print(c * 32)
```

### Comparing `gpaw-22.8.0/gpaw/test/ext_potential/test_step.py` & `gpaw-23.6.0/gpaw/test/ext_potential/test_step.py`

 * *Files 20% similar despite different names*

```diff
@@ -2,14 +2,15 @@
 
 from ase import Atoms
 
 from gpaw import GPAW
 from gpaw.external import StepPotentialz
 
 
+@pytest.mark.later
 def test_He():
     a = 3
     b = 3 * a
     atoms = Atoms('He', positions=[(a, a, a)],
                   cell=(2 * a, 2 * a, b))
 
     c00 = GPAW(charge=1)
```

### Comparing `gpaw-22.8.0/gpaw/test/exx/test_coarse.py` & `gpaw-23.6.0/gpaw/test/exx/test_coarse.py`

 * *Files 5% similar despite different names*

```diff
@@ -6,14 +6,15 @@
 
 from gpaw import GPAW
 from gpaw.test import equal
 from gpaw.xc.hybrid import HybridXC
 
 
 @pytest.mark.libxc
+@pytest.mark.hybrids
 def test_exx_coarse(in_tmp_dir):
     timer = Timer()
 
     loa = Atoms('Be2',
                 [(0, 0, 0), (2.45, 0, 0)],
                 magmoms=[0.5, 0.5],
                 cell=[5.9, 4.8, 5.0])
@@ -26,30 +27,29 @@
     niter = {}
     for fg in fgl:
         if fg:
             tstr = 'Exx on fine grid'
         else:
             tstr = 'Exx on coarse grid'
         timer.start(tstr)
-        calc = GPAW(h=0.3,
-                    eigensolver='rmm-diis',
-                    xc=dict(name='PBE', stencil=1),
-                    poissonsolver={'name': 'fd'},
-                    nbands=4,
-                    convergence={'eigenstates': 1e-4},
-                    charge=-1)
-        loa.calc = calc
+        loa.calc = GPAW(h=0.3,
+                        eigensolver='rmm-diis',
+                        xc=dict(name='PBE', stencil=1),
+                        poissonsolver={'name': 'fd'},
+                        nbands=4,
+                        convergence={'eigenstates': 1e-4},
+                        charge=-1)
         E[fg] = loa.get_potential_energy()
-        calc.set(xc=HybridXC('PBE0', stencil=1, finegrid=fg))
+        loa.calc = loa.calc.new(xc=HybridXC('PBE0', stencil=1, finegrid=fg))
         E[fg] = loa.get_potential_energy()
-        niter[fg] = calc.get_number_of_iterations()
+        niter[fg] = loa.calc.get_number_of_iterations()
         timer.stop(tstr)
         if not fg:
             fname = 'exx_load.gpw'
-            calc.write(fname)
+            loa.calc.write(fname)
             calcl = GPAW(fname)
             func = calcl.parameters.xc
 
             assert func['name'] == 'PBE0', 'wrong name for functional'
             assert func['hybrid'] == 0.25, 'wrong factor for functional'
 
     timer.write(sys.stdout)
```

### Comparing `gpaw-22.8.0/gpaw/test/exx/test_derivs.py` & `gpaw-23.6.0/gpaw/test/exx/test_derivs.py`

 * *Files 2% similar despite different names*

```diff
@@ -5,15 +5,15 @@
 from gpaw.grid_descriptor import GridDescriptor
 from gpaw.hybrids.kpts import PWKPoint
 from gpaw.kpt_descriptor import KPointDescriptor
 from gpaw.mpi import world
 from gpaw.projections import Projections
 from gpaw.pw.descriptor import PWDescriptor
 from gpaw.pw.lfc import PWLFC
-from gpaw.response.wstc import WignerSeitzTruncatedCoulomb as WSTC
+from gpaw.hybrids.wstc import WignerSeitzTruncatedCoulomb as WSTC
 from gpaw.spline import Spline
 from gpaw.symmetry import Symmetry
 from gpaw.wavefunctions.arrays import PlaneWaveExpansionWaveFunctions
 
 
 class AP:
     my_indices = [0]
```

### Comparing `gpaw-22.8.0/gpaw/test/exx/test_exx.py` & `gpaw-23.6.0/gpaw/test/exx/test_exx.py`

 * *Files 5% similar despite different names*

```diff
@@ -8,24 +8,18 @@
 
 
 def xc1(name):
     return dict(name=name, stencil=1)
 
 
 @pytest.mark.libxc
+@pytest.mark.hybrids
 def test_exx_exx(in_tmp_dir):
     be2 = Atoms('Be2', [(0, 0, 0), (2.45, 0, 0)])
     be2.center(vacuum=2.0)
-    calc = GPAW(h=0.21,
-                eigensolver='rmm-diis',
-                nbands=3,
-                convergence={'eigenstates': 1e-6},
-                txt='exx.txt')
-
-    be2.calc = calc
 
     ref_1871 = {  # Values from revision 1871. Not true reference values
         # xc         Energy          eigenvalue 0    eigenvalue 1
         'PBE': (5.424066548470926, -3.84092, -0.96192),
         'PBE0': (-790.919942, -4.92321, -1.62948),
         'EXX': (-785.5837828306236, -7.16802337336, -2.72602997017)}
 
@@ -35,15 +29,21 @@
                HybridXC('EXX', stencil=1, finegrid=True),
                XC(xc1('PBE'))]:  # , 'oldPBE', 'LDA']:
         # Generate setup
         # g = Generator('Be', setup, scalarrel=True, nofiles=True, txt=None)
         # g.run(exx=True, **parameters['Be'])
 
         # switch to new xc functional
-        calc.set(xc=xc)
+        calc = GPAW(xc=xc,
+                    h=0.21,
+                    eigensolver='rmm-diis',
+                    nbands=3,
+                    convergence={'eigenstates': 1e-6},
+                    txt='exx.txt')
+        be2.calc = calc
         E = be2.get_potential_energy()
         if xc.name != 'PBE':
             E += calc.get_reference_energy()
         bands = calc.get_eigenvalues()[:2]  # not 3 as unocc. eig are random!?
         res = (E,) + tuple(bands)
         print(xc.name, res)
```

### Comparing `gpaw-22.8.0/gpaw/test/exx/test_exx_scf.py` & `gpaw-23.6.0/gpaw/test/exx/test_exx_scf.py`

 * *Files 2% similar despite different names*

```diff
@@ -28,16 +28,16 @@
         work_atom.set_initial_magnetic_moments([2.0])
         calculator = GPAW(convergence={'energy': 0.01,
                                        'eigenstates': 3,
                                        'density': 3},
                           eigensolver=RMMDIIS(),
                           poissonsolver=PoissonSolver(use_charge_center=True),
                           occupations=FermiDirac(width=0.0, fixmagmom=True),
-                          h=h, maxiter=35)   # Up to 24 are needed by now
-        calculator.set(xc=HybridXC('PBE0'))
-        calculator.set(txt=atom + '-PBE0.txt')
+                          h=h, maxiter=35,  # Up to 24 are needed by now
+                          xc=HybridXC('PBE0'),
+                          txt=atom + '-PBE0.txt')
         work_atom.calc = calculator
         try:
             work_atom.get_potential_energy()
         except KohnShamConvergenceError:
             pass
         assert calculator.scf.converged, 'Calculation not converged'
```

### Comparing `gpaw-22.8.0/gpaw/test/exx/test_forces_ut.py` & `gpaw-23.6.0/gpaw/test/exx/test_forces_ut.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/exx/test_kpts.py` & `gpaw-23.6.0/gpaw/test/exx/test_kpts.py`

 * *Files 20% similar despite different names*

```diff
@@ -3,29 +3,34 @@
 
 import pytest
 import numpy as np
 from ase import Atoms
 
 from gpaw import GPAW, PW
 from gpaw.hybrids.eigenvalues import non_self_consistent_eigenvalues
-from gpaw.xc.exx import EXX
-from gpaw.mpi import world
+from gpaw.mpi import size
 
 n = 7
 
 
 @pytest.fixture(scope='module')
-def atoms():
+def atoms() -> Atoms:
     a = Atoms('HH',
               cell=[2, 2, 2.5, 90, 90, 60],
               pbc=1,
               positions=[[0, 0, 0], [0, 0, 0.75]])
+    parallel = dict(zip(['domain', 'kpt', 'band'],
+                        {1: [1, 1, 1],
+                         2: [2, 1, 1],
+                         4: [2, 2, 1],
+                         8: [2, 2, 2]}[size]))
     a.calc = GPAW(mode=PW(200),
                   kpts=(n, n, 1),
-                  xc='PBE')
+                  xc='PBE',
+                  parallel=parallel)
     a.get_potential_energy()
     return a
 
 
 def bandgap(eps: np.ndarray) -> Tuple[int, int, float]:
     """Find band-gap."""
     k1 = eps[0, :, 0].argmax()
@@ -37,22 +42,17 @@
         'PBE0': 13.93,
         'HSE06': 14.44,
         'PBE': 11.63}
 
 
 @pytest.mark.libxc
 @pytest.mark.parametrize('xc', ['EXX', 'PBE0', 'HSE06'])
-def test_kpts(xc, atoms):
+def test_kpts(xc: str, atoms: Atoms) -> None:
     c = atoms.calc
     e0, v0, v = non_self_consistent_eigenvalues(c, xc)
     e = e0 - v0 + v
     k1, k2, gap = bandgap(e)
     assert k1 == 4 and k2 == 7
     assert gap == pytest.approx(gaps[xc], abs=0.01)
     k1, k2, gap = bandgap(e0)
     assert k1 == 4 and k2 == 7
     assert gap == pytest.approx(gaps['PBE'], abs=0.01)
-    if world.size == 1:
-        xc2 = EXX(c.gs_adapter(), xc=xc, bands=(0, c.wfs.bd.nbands), txt=None)
-        xc2.calculate()
-        v2 = xc2.get_eigenvalue_contributions()
-        assert np.allclose(v, v2), (v, v2)
```

### Comparing `gpaw-22.8.0/gpaw/test/exx/test_unocc.py` & `gpaw-23.6.0/gpaw/test/exx/test_unocc.py`

 * *Files 6% similar despite different names*

```diff
@@ -4,14 +4,15 @@
 
 from gpaw import GPAW
 from gpaw.test import equal
 from gpaw.xc.hybrid import HybridXC
 
 
 @pytest.mark.libxc
+@pytest.mark.hybrids
 def test_exx_unocc():
 
     loa = Atoms('Be2',
                 [(0, 0, 0), (2.45, 0, 0)],
                 cell=[5.9, 4.8, 5.0])
     loa.center()
```

### Comparing `gpaw-22.8.0/gpaw/test/fd_ops/test_gd.py` & `gpaw-23.6.0/gpaw/test/fd_ops/test_gd.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/fd_ops/test_gradient.py` & `gpaw-23.6.0/gpaw/test/fd_ops/test_gradient.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/fd_ops/test_laplace.py` & `gpaw-23.6.0/gpaw/test/fd_ops/test_laplace.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/fd_ops/test_nabla.py` & `gpaw-23.6.0/gpaw/test/fd_ops/test_nabla.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/fd_ops/test_non_periodic.py` & `gpaw-23.6.0/gpaw/test/fd_ops/test_non_periodic.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/fd_ops/test_transformations.py` & `gpaw-23.6.0/gpaw/test/fd_ops/test_transformations.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/fdtd/test_ed.py` & `gpaw-23.6.0/gpaw/test/fdtd/test_ed.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,19 +1,21 @@
+import numpy as np
+import pytest
 from ase import Atoms
 from gpaw import GPAW
 from gpaw.fdtd.poisson_fdtd import FDTDPoissonSolver
 from gpaw.fdtd.polarizable_material import (PermittivityPlus,
                                             PolarizableMaterial,
                                             PolarizableSphere)
 from gpaw.mpi import world
 from gpaw.tddft import TDDFT, DipoleMomentWriter
 from gpaw.test import equal
-import numpy as np
 
 
+@pytest.mark.later
 def test_fdtd_ed(in_tmp_dir):
     # Accuracy
     energy_eps = 0.0005
 
     # Whole simulation cell (Angstroms)
     large_cell = [20, 20, 30]
```

### Comparing `gpaw-22.8.0/gpaw/test/fdtd/test_ed_inducedfield.py` & `gpaw-23.6.0/gpaw/test/fdtd/test_ed_inducedfield.py`

 * *Files 0% similar despite different names*

```diff
@@ -1,23 +1,25 @@
+import numpy as np
+import pytest
 from ase import Atoms
 from gpaw import GPAW
 from gpaw.fdtd.poisson_fdtd import FDTDPoissonSolver
 from gpaw.fdtd.polarizable_material import (PermittivityPlus,
                                             PolarizableMaterial,
                                             PolarizableSphere)
-from gpaw.mpi import world
-from gpaw.tddft import TDDFT, DipoleMomentWriter
-from gpaw.inducedfield.inducedfield_tddft import TDDFTInducedField
+from gpaw.inducedfield.inducedfield_base import BaseInducedField
 from gpaw.inducedfield.inducedfield_fdtd import (
     FDTDInducedField, calculate_hybrid_induced_field)
-from gpaw.inducedfield.inducedfield_base import BaseInducedField
+from gpaw.inducedfield.inducedfield_tddft import TDDFTInducedField
+from gpaw.mpi import world
+from gpaw.tddft import TDDFT, DipoleMomentWriter
 from gpaw.test import equal
-import numpy as np
 
 
+@pytest.mark.later
 def test_fdtd_ed_inducedfield(in_tmp_dir):
     do_print_values = 0  # Use this for printing the reference values
 
     # Accuracy
     energy_eps = 0.0005
     poisson_eps = 1e-12
     density_eps = 1e-6
```

### Comparing `gpaw-22.8.0/gpaw/test/fdtd/test_ed_shapes.py` & `gpaw-23.6.0/gpaw/test/fdtd/test_ed_shapes.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,16 +1,18 @@
 # flake8: noqa
 from gpaw.fdtd.poisson_fdtd import QSFDTD
 from gpaw.fdtd.polarizable_material import PermittivityPlus, PolarizableMaterial, \
     PolarizableSphere, PolarizableBox, \
     PolarizableEllipsoid, PolarizableRod, \
     PolarizableTetrahedron
 from gpaw.test import equal
+import pytest
 
 
+@pytest.mark.later
 def test_fdtd_ed_shapes(in_tmp_dir):
     # Whole simulation cell (Angstroms)
     cell = [40, 40, 20]
 
     # Classical subsystem
     classical_material = PolarizableMaterial()
     classical_material.add_component(PolarizableSphere(permittivity = PermittivityPlus(data = [[1.20, 0.20, 25.0]]),
```

### Comparing `gpaw-22.8.0/gpaw/test/fdtd/test_ed_wrapper.py` & `gpaw-23.6.0/gpaw/test/fdtd/test_ed_wrapper.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,17 +1,19 @@
 import numpy as np
+import pytest
 from ase import Atoms
 from gpaw.fdtd.poisson_fdtd import QSFDTD
 from gpaw.fdtd.polarizable_material import (PermittivityPlus,
                                             PolarizableMaterial,
                                             PolarizableSphere)
 from gpaw.mpi import world
 from gpaw.test import equal
 
 
+@pytest.mark.later
 def test_fdtd_ed_wrapper(in_tmp_dir):
     # This test does the same calculation as ed.py, but using
     # QSFDTD wrapper instead
 
     # Accuracy
     energy_eps = 0.0005
```

### Comparing `gpaw-22.8.0/gpaw/test/fermilevel_test.py` & `gpaw-23.6.0/gpaw/test/test_fermilevel.py`

 * *Files 0% similar despite different names*

```diff
@@ -17,14 +17,15 @@
     atoms.get_potential_energy()
     assert np.isinf(atoms.calc.get_fermi_level())
 
     params['nbands'] = 3
     params['convergence'] = {'bands': 2}
     atoms.calc = GPAW(**params)
     atoms.get_potential_energy()
+
     homo, lumo = atoms.calc.get_homo_lumo()
     assert homo == pytest.approx(-15.4473, abs=0.01)
     assert lumo == pytest.approx(-0.2566, abs=0.01)
 
     atoms.calc.write('test.gpw')
     print(GPAW('test.gpw').get_homo_lumo(), homo, lumo)
     assert np.all(GPAW('test.gpw').get_homo_lumo() == (homo, lumo))
```

### Comparing `gpaw-22.8.0/gpaw/test/fileio/test_ascii_art.py` & `gpaw-23.6.0/gpaw/test/fileio/test_ascii_art.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/fileio/test_file_reference.py` & `gpaw-23.6.0/gpaw/test/fileio/test_file_reference.py`

 * *Files 12% similar despite different names*

```diff
@@ -19,15 +19,15 @@
     # Only a short, non-converged calculation
     conv = {'eigenstates': 1.24, 'energy': 2e-1, 'density': 1e-1}
     calc = GPAW(h=0.30, kpts=(1, 1, 3),
                 setups={'Na': '1'},
                 nbands=3, convergence=conv)
     atoms.calc = calc
     atoms.get_potential_energy()
-    wf0 = calc.get_pseudo_wave_function(2, 1, 1, broadcast=True)
+    wf0 = calc.get_pseudo_wave_function(2, 1, 1)
 
     calc.write('tmp', 'all')
 
     # Now read with single process
     comm = world.new_communicator(np.array((rank,)))
     calc = GPAW('tmp', communicator=comm)
     wf1 = calc.get_pseudo_wave_function(2, 1, 1)
```

### Comparing `gpaw-22.8.0/gpaw/test/fileio/test_parallel.py` & `gpaw-23.6.0/gpaw/test/fileio/test_parallel.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/fileio/test_refine.py` & `gpaw-23.6.0/gpaw/test/fileio/test_refine.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,14 +1,17 @@
 """Test automatically write out of restart files"""
 
+import pytest
 from ase import Atoms
+
 from gpaw import GPAW
 from gpaw.test import equal
 
 
+@pytest.mark.later
 def test_fileio_refine(in_tmp_dir):
     restart_wf = 'gpaw-restart-wf.gpw'
     # H2
     H = Atoms('HH', [(0, 0, 0), (0, 0, 1)])
     H.center(vacuum=2.0)
 
     if 1:
@@ -17,15 +20,15 @@
                                  'energy': 0.1,
                                  'density': 0.1})
         H.calc = calc
         H.get_potential_energy()
         calc.write(restart_wf, 'all')
 
         # refine the result directly
-        calc.set(convergence={'energy': 0.00001})
+        H.calc = calc.new(convergence={'energy': 0.00001})
         Edirect = H.get_potential_energy()
 
     # refine the result after reading from a file
     H = GPAW(restart_wf, convergence={'energy': 0.00001}).get_atoms()
     Erestart = H.get_potential_energy()
 
     print(Edirect, Erestart)
```

### Comparing `gpaw-22.8.0/gpaw/test/fileio/test_restart.py` & `gpaw-23.6.0/gpaw/test/fileio/test_restart.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,14 +1,18 @@
 from math import sqrt
+
 import numpy as np
+import pytest
 from ase import Atoms
+
 from gpaw import GPAW, PW, restart
 from gpaw.test import equal
 
 
+@pytest.mark.later
 def test_fileio_restart(in_tmp_dir):
     d = 3.0
     atoms = Atoms('Na3',
                   positions=[(0, 0, 0),
                              (0, 0, d),
                              (0, d * sqrt(3 / 4), d / 2)],
                   magmoms=[1.0, 1.0, 1.0],
```

### Comparing `gpaw-22.8.0/gpaw/test/fileio/test_restart_density.py` & `gpaw-23.6.0/gpaw/test/fileio/test_restart_density.py`

 * *Files 4% similar despite different names*

```diff
@@ -28,19 +28,16 @@
     f0 = atoms.get_forces()
     m0 = atoms.get_magnetic_moments()
     eig00 = calc.get_eigenvalues(spin=0)
     eig01 = calc.get_eigenvalues(spin=1)
     # Write the restart file
     calc.write('tmp.gpw')
 
-    del atoms, calc
     # Try restarting from all the files
     atoms, calc = restart('tmp.gpw')
-    # Force new calculation
-    calc.scf.converged = False
     e1 = atoms.get_potential_energy()
     f1 = atoms.get_forces()
     m1 = atoms.get_magnetic_moments()
     eig10 = calc.get_eigenvalues(spin=0)
     eig11 = calc.get_eigenvalues(spin=1)
     print(e0, e1)
     equal(e0, e1, 2e-3)
```

### Comparing `gpaw-22.8.0/gpaw/test/fuzz.py` & `gpaw-23.6.0/gpaw/test/fuzz.py`

 * *Files 2% similar despite different names*

```diff
@@ -55,15 +55,15 @@
         return 0
 
     many = args.all or args.fuzz
 
     if many:
         system_names = args.system or list(systems)
         args.repeat = args.repeat or '1x1x1,2x1x1'
-        args.vacuum = args.vacuum or '0.0,2.0,3.0'
+        args.vacuum = args.vacuum or '0.0,4.0'
         args.pbc = args.pbc or '0,1'
         args.mode = args.mode or 'pw,lcao,fd'
         args.code = args.code or 'new,old'
         args.ncores = args.ncores or '1,2,3,4'
         args.kpts = args.kpts or '2.0,3.0'
         args.use_symmetry = args.use_symmetry or '1,0'
         args.complex = args.complex or '0,1'
@@ -170,20 +170,21 @@
         print(' ...', end='', flush=True)
         ncores = params.pop('ncores')
         if ncores == world.size:
             result = run2(atoms, params, result_file)
         else:
             pckl_file = result_file.with_suffix('.pckl')
             pckl_file.write_bytes(pickle.dumps((atoms, params, result_file)))
-            subprocess.run(
-                ['mpiexec', '-np', str(ncores),
-                 sys.executable, '-m', 'gpaw.test.fuzz',
-                 '--pickle', str(pckl_file)],
-                check=True,
-                env=os.environ)
+            args = ['mpiexec', '-np', str(ncores),
+                    sys.executable, '-m', 'gpaw.test.fuzz',
+                    '--pickle', str(pckl_file)]
+            extra = os.environ.get('GPAW_MPI_OPTIONS')
+            if extra:
+                args[1:1] = extra.split()
+            subprocess.run(args, check=True, env=os.environ)
             result, _ = json.loads(result_file.read_text())
             pckl_file.unlink()
     else:
         print('    ', end='')
         result, _ = json.loads(result_file.read_text())
     print(f' {result["energy"]:14.6f} eV, {result["time"]:9.3f} s')
     return result
@@ -191,22 +192,20 @@
 
 def run2(atoms: Atoms,
          params: dict[str, Any],
          result_file: Path) -> dict[str, Any]:
     params = params.copy()
 
     code = params.pop('code')
-    if code == 'new':
+    if code[0] == 'n':
+        if params.pop('dtype', None) == complex:
+            params['mode']['force_complex_dtype'] = True
         calc = NewGPAW(**params)
     else:
-        params['mode'] = {
-            'name': params['mode'],
-            'force_complex_dtype': params.pop('force_complex_dtype')}
         calc = OldGPAW(**params)
-
     atoms.calc = calc
 
     t1 = time()
     energy = atoms.get_potential_energy()
     try:
         forces = atoms.get_forces()
     except NotImplementedError:
@@ -220,24 +219,26 @@
 
     gpw_file = result_file.with_suffix('.gpw')
     calc.write(gpw_file, mode='all')
 
     calculation = NewGPAW(gpw_file).calculation
 
     energy2 = calculation.results['energy'] * Ha
-    assert abs(energy2 - energy) < 1e-14, (energy2, energy)
+    assert abs(energy2 - energy) < 1e-13, (energy2, energy)
 
     if forces is not None:
         forces2 = calculation.results['forces'] * Ha / Bohr
         assert abs(forces2 - forces).max() < 1e-14
 
     # ibz_index = atoms.calc.wfs.kd.bz2ibz_k[p.kpt]
     # eigs = atoms.calc.get_eigenvalues(ibz_index, p.spin)
 
     if world.rank == 0:
+        if 'dtype' in params:
+            params['dtype'] = 'complex'
         result_file.write_text(json.dumps([result, params], indent=2))
 
     atoms.calc = None
 
     return result
 
 
@@ -259,15 +260,15 @@
         return False
     if f0 is None:
         if f is not None:
             calculations[tag]['forces'] = f
         return True
     if f is not None:
         error = abs(np.array(f) - f0).max()
-        if error > 0.0005:
+        if error > 0.001:
             print('Force error:', error)
             return False
     return True
 
 
 def create_systems(system_names: list[str],
                    repeats: list[list[int]],
@@ -286,15 +287,15 @@
                     vatoms = ratoms.copy()
                     axes = [a for a, p in enumerate(atoms.pbc) if not p]
                     if axes:
                         vatoms.center(vacuum=vacuum, axis=axes)
                     else:
                         continue
                 else:
-                    vatoms = atoms
+                    vatoms = ratoms
                 for pbc in pick(pbcs):
                     if pbc:
                         if vatoms.pbc.all():
                             continue
                         patoms = vatoms.copy()
                         patoms.pbc = pbc
                     else:
@@ -336,19 +337,20 @@
             params = {'code': code,
                       'ncores': ncores}
             for use_symm in pick(symmetry_all):
                 if not use_symm:
                     sparams = {**params, 'symmetry': 'off'}
                 else:
                     sparams = params
-                for for_complex_dtype in pick(complex_all):
-                    sparams['force_complex_dtype'] = for_complex_dtype
+                for force_complex_dtype in pick(complex_all):
+                    if force_complex_dtype:
+                        sparams['dtype'] = complex
                     yield (sparams,
                            (f'-c{code} -n{ncores} -s{int(use_symm)} '
-                            f'-x{int(for_complex_dtype)}'))
+                            f'-x{int(force_complex_dtype)}'))
 
 
 systems = {}
 
 
 def system(func):
     systems[func.__name__] = func()
```

### Comparing `gpaw-22.8.0/gpaw/test/generic/colinear.py` & `gpaw-23.6.0/gpaw/test/generic/colinear.py`

 * *Files 2% similar despite different names*

```diff
@@ -13,13 +13,13 @@
     c = GPAW(txt='c.txt',
              mode='lcao',
              basis='dz(dzp)',
              # setups='ncpp',
              h=0.25,
              xc=xc,
              # occupations=FermiDirac(0.01),
+             nbands=1,
              mixer=Mixer(),
              # noncolinear=[(2,0,0)],
              )  # eigensolver=NonColinearLCAOEigensolver())
-    c.set(nbands=1)
     h.calc = c
     h.get_potential_energy()
```

### Comparing `gpaw-22.8.0/gpaw/test/generic/test_2Al.py` & `gpaw-23.6.0/gpaw/test/generic/test_2Al.py`

 * *Files 7% similar despite different names*

```diff
@@ -10,24 +10,24 @@
                   Atom('Al', (0, 0, d))],
                  cell=(4 * d, 4 * d, 2 * d),
                  pbc=1)
     n = 16
     calc = GPAW(gpts=(2 * n, 2 * n, 1 * n),
                 nbands=1 * 8,
                 kpts=(1, 1, 4),
-                convergence={'eigenstates': 2.3e-9},
-                xc='LDA')
+                convergence={'eigenstates': 2.3e-9})
     bulk.calc = calc
     e2 = bulk.get_potential_energy()
 
     bulk = bulk.repeat((1, 1, 2))
+    calc = GPAW(gpts=(2 * n, 2 * n, 2 * n),
+                nbands=16,
+                kpts=(1, 1, 2),
+                convergence={'eigenstates': 2.3e-9})
     bulk.calc = calc
-    calc.set(nbands=16,
-             kpts=(1, 1, 2),
-             gpts=(2 * n, 2 * n, 2 * n))
     e4 = bulk.get_potential_energy()
 
     # checks
     energy_tolerance = 0.002
 
     print(e2, e4)
     equal(e4 / 2, e2, 48e-6)
```

### Comparing `gpaw-22.8.0/gpaw/test/generic/test_8Si.py` & `gpaw-23.6.0/gpaw/test/generic/test_8Si.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/generic/test_Cu.py` & `gpaw-23.6.0/gpaw/test/generic/test_Cu.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/generic/test_H_force.py` & `gpaw-23.6.0/gpaw/test/generic/test_H_force.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/generic/test_IP_oxygen.py` & `gpaw-23.6.0/gpaw/test/generic/test_IP_oxygen.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,20 +1,23 @@
-from ase import Atom, Atoms
+from ase import Atoms
 from gpaw import GPAW
 from gpaw.test import equal
 
 
 def test_generic_IP_oxygen():
     a = 6.0
-    calc = GPAW(gpts=(32, 36, 32), nbands=4)
-    O = Atoms([Atom('O', (a / 2, a / 2 + 0.5, a / 2), magmom=2)],
-              pbc=False, cell=(a, a + 1, a), calculator=calc)
+    O = Atoms('O',
+              [(a / 2, a / 2 + 0.5, a / 2)],
+              magmoms=[2],
+              pbc=False,
+              cell=(a, a + 1, a))
+    O.calc = GPAW(gpts=(32, 36, 32), nbands=4)
     e0 = O.get_potential_energy()
 
-    calc.set(charge=1)
+    O.calc = GPAW(gpts=(32, 36, 32), nbands=4, charge=1)
 
     e1 = O.get_potential_energy()
 
     print(e1 - e0)
     assert abs(e1 - e0 - 13.989) < 0.04
 
     energy_tolerance = 0.004
```

### Comparing `gpaw-22.8.0/gpaw/test/generic/test_al_chain.py` & `gpaw-23.6.0/gpaw/test/generic/test_al_chain.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/generic/test_asym_box.py` & `gpaw-23.6.0/gpaw/test/generic/test_asym_box.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/generic/test_bulk.py` & `gpaw-23.6.0/gpaw/test/generic/test_bulk.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/generic/test_guc_force.py` & `gpaw-23.6.0/gpaw/test/generic/test_guc_force.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,20 +1,23 @@
 # This tests calculates the force on the atoms of a
 # slightly distorted Silicon primitive cell.
 #
 # If the test fails, set the fd boolean below to enable a (costly) finite
 # difference check.
 
 import numpy as np
+import pytest
 from ase import Atoms
+
 from gpaw import GPAW
 from gpaw.atom.basis import BasisMaker
 from gpaw.test import equal
 
 
+@pytest.mark.later
 def test_generic_guc_force():
     sibasis = BasisMaker('Si').generate(
         2, 1, energysplit=0.3, tailnorm=0.03**.5)
     basis = {'Si': sibasis}
 
     a = 5.475
     system = Atoms(symbols='Si2', pbc=True,
@@ -60,15 +63,15 @@
     equal(err, 0, 6e-3)
 
     # Set boolean to run new FD check
     fd = False
 
     if fd:
         from ase.calculators.test import numeric_force
-        calc.set(symmetry='off')
+        system.calc = calc.new(symmetry='off')
         F_ac_fd = [[numeric_force(system, a, i) for i in range(3)]
                    for a in range(2)]
         print('Self-consistent forces')
         print(F_ac)
         print('FD')
         print(F_ac_fd)
         print(repr(F_ac_fd))
```

### Comparing `gpaw-22.8.0/gpaw/test/generic/test_hydrogen.py` & `gpaw-23.6.0/gpaw/test/generic/test_hydrogen.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,36 +1,42 @@
 from math import log
+
+import pytest
 from ase import Atoms
-from ase.io import read, write, iread
-from ase.units import Bohr
 from ase.db import connect
+from ase.io import iread, read, write
+from ase.units import Bohr
+
 from gpaw import GPAW, FermiDirac
 from gpaw.test import equal
 
 
+@pytest.mark.later
 def test_generic_hydrogen(in_tmp_dir):
     a = 4.0
     h = 0.2
     hydrogen = Atoms('H',
                      [(a / 2, a / 2, a / 2)],
                      cell=(a, a, a))
 
-    hydrogen.calc = GPAW(h=h,
-                         nbands=1,
-                         convergence={'energy': 1e-7},
+    params = dict(h=h,
+                  nbands=1,
+                  convergence={'energy': 1e-7})
+    hydrogen.calc = GPAW(**params,
                          txt='h.txt')
     e1 = hydrogen.get_potential_energy()
     equal(e1, 0.526939, 0.001)
 
     dens = hydrogen.calc.density
     c = dens.gd.find_center(dens.nt_sG[0]) * Bohr
     equal(abs(c - a / 2).max(), 0, 1e-13)
 
     kT = 0.001
-    hydrogen.calc.set(occupations=FermiDirac(width=kT))
+    hydrogen.calc = GPAW(**params,
+                         occupations=FermiDirac(width=kT))
     e2 = hydrogen.get_potential_energy()
     equal(e1, e2 + log(2) * kT, 3.0e-7)
 
     # Test ase.db a bit:
     for name in ['h.json', 'h.db']:
         con = connect(name, append=False)
         con.write(hydrogen)
```

### Comparing `gpaw-22.8.0/gpaw/test/generic/test_move_across_cell.py` & `gpaw-23.6.0/gpaw/test/generic/test_move_across_cell.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,15 +1,18 @@
+import pytest
 from ase.build import molecule
-from gpaw import GPAW, MixerSum, Davidson
+
+from gpaw import GPAW, Davidson, MixerSum
 
 # Move atom infinitesimally across cell border and test that SCF loop is still
 # well converged afterwards.  If it is /not/ well converged, then the code
 # which compensates for discontinuity of phases is probably broken.
 
 
+@pytest.mark.later
 def test_generic_move_across_cell():
     def test(calc):
         atoms = molecule('H2O', vacuum=2.5)
         atoms.pbc = 1
 
         # Translate O to corner:
         atoms.positions -= atoms.positions[0, None, :]
```

### Comparing `gpaw-22.8.0/gpaw/test/generic/test_proton.py` & `gpaw-23.6.0/gpaw/test/generic/test_proton.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,39 +1,42 @@
 """Test calculation for bare proton.
+
 Also, its interaction with an external potential in the form of a point charge
 is tested.
 """
 import numpy as np
+import pytest
 from ase import Atoms
 from ase.units import Bohr, Hartree
+
 from gpaw import GPAW
 from gpaw.external import PointChargePotential
 
 
+@pytest.mark.later
 def test_generic_proton(in_tmp_dir):
     a = 4.5
     H = Atoms('H', [(a / 2, a / 2, a / 2)],
               pbc=0,
               cell=(a, a, a))
-    calc = GPAW(nbands=1, h=0.2, charge=1, txt='H.txt')
-    H.calc = calc
+    H.calc = GPAW(nbands=1, h=0.2, charge=1, txt='H.txt')
     e0 = H.get_potential_energy()
-    assert abs(e0 + calc.get_reference_energy()) < 0.014
+    assert abs(e0 + H.calc.get_reference_energy()) < 0.014
 
     # Test the point charge potential with a smooth cutoff:
     pcp = PointChargePotential([-1], rc2=5.5, width=1.5)
-    calc.set(external=pcp)
+    H.calc = H.calc.new(external=pcp)
     E = []
     F = []
     D = np.linspace(2, 6, 30)
     for d in D:
         pcp.set_positions([[a / 2, a / 2, a / 2 + d]])
         e = H.get_potential_energy() - e0
         f1 = H.get_forces()
-        f2 = pcp.get_forces(calc)
+        f2 = pcp.get_forces(H.calc)
         eref = -1 / d * Bohr * Hartree
         print(d, e, eref, abs(f1 + f2).max())
         if d < 4.0:
             error = e + 1 / d * Bohr * Hartree
             assert abs(error) < 0.01, error
         assert abs(f1 + f2).max() < 0.01
         E.append(e)
```

### Comparing `gpaw-22.8.0/gpaw/test/generic/test_relax.py` & `gpaw-23.6.0/gpaw/test/generic/test_relax.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,16 +1,20 @@
 from time import time
+
+import pytest
 from ase import Atoms
-from ase.optimize import BFGS
 from ase.io import read
+from ase.optimize import BFGS
+
 from gpaw import GPAW
-from gpaw.test import equal
 from gpaw.mpi import world
+from gpaw.test import equal
 
 
+@pytest.mark.later
 def test_generic_relax(in_tmp_dir):
     a = 4.0    # Size of unit cell (Angstrom)
     c = a / 2
     d = 0.74  # Experimental bond length
     molecule = Atoms('H2',
                      [(c - d / 2, c, c),
                       (c + d / 2, c, c)],
```

### Comparing `gpaw-22.8.0/gpaw/test/generic/test_si.py` & `gpaw-23.6.0/gpaw/test/generic/test_si.py`

 * *Files 16% similar despite different names*

```diff
@@ -16,24 +16,21 @@
                                    (0.75, 0.25, 0.75),
                                    (0.75, 0.75, 0.25)],
                  pbc=True, cell=(a, a, a))
     n = 20
     calc = GPAW(gpts=(n, n, n),
                 nbands=8 * 3,
                 occupations=FermiDirac(width=0.01),
-                verbose=1,
                 kpts=(1, 1, 1))
     bulk.calc = calc
     e1 = bulk.get_potential_energy()
     eigs = calc.get_eigenvalues(kpt=0)
     calc.write('temp.gpw')
 
-    bulk.calc = GPAW('temp.gpw').fixed_density()
-    e2 = bulk.get_potential_energy()
-    eigs2 = bulk.calc.get_eigenvalues(kpt=0)
+    calc = GPAW('temp.gpw').fixed_density()
+    eigs2 = calc.get_eigenvalues(kpt=0)
     print('Orginal', eigs)
     print('Fixdensity', eigs2)
     print('Difference', eigs2 - eigs)
 
     assert np.fabs(eigs2 - eigs)[:-1].max() < 3e-5
     equal(e1, -36.767, 0.003)
-    equal(e1, e2, 1e-4)
```

### Comparing `gpaw-22.8.0/gpaw/test/generic/test_si_primitive.py` & `gpaw-23.6.0/gpaw/test/generic/test_si_primitive.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/gllb/test_atomic.py` & `gpaw-23.6.0/gpaw/test/gllb/test_atomic.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/gllb/test_diamond.py` & `gpaw-23.6.0/gpaw/test/gllb/test_diamond.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/gllb/test_metallic.py` & `gpaw-23.6.0/gpaw/test/gllb/test_metallic.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/gllb/test_ne.py` & `gpaw-23.6.0/gpaw/test/gllb/test_ne.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/gllb/test_ne_disc.py` & `gpaw-23.6.0/gpaw/test/gllb/test_ne_disc.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/gllb/test_restart_eigenvalues.py` & `gpaw-23.6.0/gpaw/test/gllb/test_restart_eigenvalues.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/gllb/test_spin.py` & `gpaw-23.6.0/gpaw/test/gllb/test_spin.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/gllb/test_variants.py` & `gpaw-23.6.0/gpaw/test/gllb/test_variants.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,12 +1,12 @@
-import pytest
 import numpy as np
+import pytest
 from ase.build import bulk
-from gpaw.test import gen
 from gpaw import GPAW
+from gpaw.test import gen
 
 
 def run(xc):
     setup_name = {'GLLBLDA': 'LDA', 'GLLBPBE': 'PBE', 'GLLBM': 'GLLB'}.get(xc,
                                                                            xc)
     if setup_name in ['GLLB', 'GLLBC', 'GLLBCP86', 'GLLBNORESP']:
         gen('Si', xcname=setup_name, write_xml=True)
@@ -15,15 +15,15 @@
     calc = GPAW(mode='lcao',
                 basis='sz(dzp)',
                 h=0.3,
                 nbands=8,
                 xc=xc,
                 convergence={'density': 1e-5},
                 kpts={'size': (1, 1, 1), 'gamma': True},
-                txt='{}.out'.format(xc))
+                txt=f'{xc}.out')
     atoms.calc = calc
     atoms.get_potential_energy()
     eig_n = calc.get_eigenvalues(kpt=0)
     return eig_n
 
 
 @pytest.mark.gllb
@@ -31,15 +31,15 @@
 @pytest.mark.parametrize('xc', ['GLLBLDA', 'GLLBPBE'])
 def test_wrappers(xc, in_tmp_dir, add_cwd_to_setup_paths):
     eig_n = run(xc)
 
     # Check values against regular xc
     ref_eig_n = run({'GLLBLDA': 'LDA', 'GLLBPBE': 'PBE'}[xc])
     assert np.allclose(eig_n, ref_eig_n, rtol=0, atol=1e-8), \
-        "{} error = {}".format(xc, np.max(np.abs(eig_n - ref_eig_n)))
+        f'{xc} error = {np.max(np.abs(eig_n - ref_eig_n))}'
 
 
 refs = {'GLLB':
         [-7.39405717, 5.01549354, 5.01549354, 5.01636595, 7.96095802,
          7.96095802, 7.96694721, 8.88669699],
         'GLLBM':
         [-5.74729132, 6.72606263, 6.72626409, 6.72626409, 9.58974119,
@@ -66,9 +66,9 @@
 @pytest.mark.libxc
 @pytest.mark.parametrize('xc', ['GLLB', 'GLLBM', 'GLLBC',
                                 'GLLBCP86', 'GLLBNORESP',
                                 'GLLBSC', 'GLLBSCM'])
 def test_eigenvalues(xc, in_tmp_dir, add_cwd_to_setup_paths):
     eig_n = run(xc)
     ref_eig_n = refs[xc]
-    assert np.allclose(eig_n, ref_eig_n, rtol=0, atol=5e-6), \
-        "{} error = {}".format(xc, np.max(np.abs(eig_n - ref_eig_n)))
+    assert np.allclose(eig_n, ref_eig_n, rtol=0, atol=2e-5), \
+        f'{xc} error = {np.max(np.abs(eig_n - ref_eig_n))}'
```

### Comparing `gpaw-22.8.0/gpaw/test/lcao/restart.py` & `gpaw-23.6.0/gpaw/test/lcao/restart.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/lcao/test_atomic_corrections.py` & `gpaw-23.6.0/gpaw/test/lcao/test_atomic_corrections.py`

 * *Files 12% similar despite different names*

```diff
@@ -23,14 +23,15 @@
     return system
 
 
 def system2():
     return bulk('Cu', orthorhombic=True) * (2, 1, 2)
 
 
+@pytest.mark.later
 @pytest.mark.parametrize('atoms, kpts', [
     (system1(), [1, 1, 1]),
     (system2(), [2, 3, 4]),
 ])
 def test_lcao_atomic_corrections(atoms, in_tmp_dir, scalapack, kpts):
     # Use a cell large enough that some overlaps are zero.
     # Thus the matrices will have at least some sparsity.
@@ -46,20 +47,16 @@
             # if correction.name != 'dense':
             parallel['sl_auto'] = True
         calc = GPAW(mode=LCAO(atomic_correction=correction),
                     basis='sz(dzp)',
                     # spinpol=True,
                     parallel=parallel,
                     txt='gpaw.{}.txt'.format(next(counter)),
-                    h=0.35, kpts=kpts)
-
-        def stopcalc():
-            calc.scf.converged = True
-
-        calc.attach(stopcalc, 2)
+                    h=0.35, kpts=kpts,
+                    convergence={'maximum iterations': 2})
         atoms.calc = calc
         energy = atoms.get_potential_energy()
         energies.append(energy)
         if calc.world.rank == 0:
             print('e', energy)
 
     master = calc.wfs.world.rank == 0
```

### Comparing `gpaw-22.8.0/gpaw/test/lcao/test_bsse.py` & `gpaw-23.6.0/gpaw/test/lcao/test_bsse.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,21 +1,25 @@
+import pytest
 from ase.build import molecule
+
 from gpaw import GPAW
-from gpaw.poisson import FDPoissonSolver as PoissonSolver
 from gpaw.atom.basis import BasisMaker
+from gpaw.poisson import FDPoissonSolver as PoissonSolver
 from gpaw.test import equal
 
-# Tests basis set super position error correction
 
-# Compares a single hydrogen atom to a system of one hydrogen atom
-# and one ghost hydrogen atom.  The systems should have identical properties,
-# i.e. the ghost orbital should have a coefficient of 0.
+@pytest.mark.later
+def test_lcao_bsse():
+    """Tests basis set super position error correction.
 
+    Compares a single hydrogen atom to a system of one hydrogen atom
+    and one ghost hydrogen atom.  The systems should have identical properties,
+    i.e. the ghost orbital should have a coefficient of 0.
+    """
 
-def test_lcao_bsse():
     b = BasisMaker('H').generate(1, 0, energysplit=0.005)
 
     system = molecule('H2')
     system.center(vacuum=6.0)
 
     def prepare(setups):
         calc = GPAW(basis={'H': b}, mode='lcao',
```

### Comparing `gpaw-22.8.0/gpaw/test/lcao/test_bulk.py` & `gpaw-23.6.0/gpaw/test/lcao/test_bulk.py`

 * *Files 0% similar despite different names*

```diff
@@ -34,10 +34,10 @@
     for i in range(len(A)):
         equal(e[i], e_ref[i], energy_tolerance)
         equal(niter[i], niter_ref[i], niter_tolerance)
 
     wf1 = calc.get_pseudo_wave_function(kpt=3, band=0)
     calc.write('Li', mode='all')
     calc2 = GPAW('Li')
-    calc2.initialize_positions()
+    # calc2.initialize_positions()
     wf2 = calc2.get_pseudo_wave_function(kpt=3, band=0)
     equal(abs(wf1 - wf2).max(), 0, 1e-9)
```

### Comparing `gpaw-22.8.0/gpaw/test/lcao/test_density.py` & `gpaw-23.6.0/gpaw/test/lcao/test_density.py`

 * *Files 9% similar despite different names*

```diff
@@ -6,31 +6,34 @@
  * axpy used on the Phit_MG[i] * Phit_MG[j] * rho[j, i], where Phit_MG
    are the actual basis functions on the grid, constructed using lcao_to_grid
 
 TODO: non-gamma-point test
 
 """
 import numpy as np
+import pytest
 from ase.build import molecule
 
 from gpaw import GPAW, ConvergenceError
+from gpaw.new.scf import SCFConvergenceError
 from gpaw.utilities.blas import axpy
 
 
+@pytest.mark.later
 def test_lcao_density():
     system = molecule('H2O')
     system.center(vacuum=2.5)
 
     calc = GPAW(mode='lcao',
                 maxiter=1)
 
     system.calc = calc
     try:
         system.get_potential_energy()
-    except ConvergenceError:
+    except (ConvergenceError, SCFConvergenceError):
         pass
 
     wfs = calc.wfs
     kpt = wfs.kpt_u[0]
     nt_G = calc.density.gd.zeros()
     bfs = wfs.basis_functions
     nao = wfs.setups.nao
```

### Comparing `gpaw-22.8.0/gpaw/test/lcao/test_dos.py` & `gpaw-23.6.0/gpaw/test/lcao/test_dos.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,13 +1,16 @@
-# Check that the LCAODOS works.
+"""Check that the LCAODOS works."""
 
-from gpaw import GPAW
+import pytest
 from ase.build import molecule
 
+from gpaw import GPAW
+
 
+@pytest.mark.later
 def test_lcao_dos():
     system = molecule('H2O')
     system.center(vacuum=3.0)
     system.pbc = 1
 
     calc = GPAW(mode='lcao', basis='dzp', h=0.3, xc='oldLDA',
                 kpts=[2, 1, 1],  # parallel=dict(sl_auto=True),
@@ -15,14 +18,15 @@
                 # kpts=[4, 4, 4]
                 )
 
     system.calc = calc
     system.get_potential_energy()
 
     from gpaw.utilities.dos import LCAODOS
+
     # Use RestartLCAODOS if you just restarted from a file.
     # Requires one diagonalization though!
 
     lcaodos = LCAODOS(calc)
 
     def printdos(eps, w):
         print('sum of weights', sum(w))
```

### Comparing `gpaw-22.8.0/gpaw/test/lcao/test_fd2lcao_restart.py` & `gpaw-23.6.0/gpaw/test/lcao/test_fd2lcao_restart.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,15 +1,18 @@
 """Test read/write of restart files between fd and lcao mode"""
 import os
 
+import pytest
 from ase import Atom, Atoms
-from gpaw import GPAW, restart, FermiDirac
+
+from gpaw import GPAW, FermiDirac, restart
 from gpaw.test import equal
 
 
+@pytest.mark.later
 def test_lcao_fd2lcao_restart(in_tmp_dir):
     energy_tolerance = 0.001
 
     if not os.path.isfile('Na4_fd.gpw'):
         # Do grid kpts calculation
         a = 3.31
         atoms = Atoms([Atom('Na', (i * a, 0, 0))
```

### Comparing `gpaw-22.8.0/gpaw/test/lcao/test_force.py` & `gpaw-23.6.0/gpaw/test/lcao/test_force.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,18 +1,21 @@
 # This tests calculates the force on the atoms of a small molecule.
 #
 # If the test fails, set the fd boolean below to enable a (costly) finite
 # difference check.
 
 import numpy as np
+import pytest
 from ase.build import molecule
+
 from gpaw import GPAW
 from gpaw.atom.basis import BasisMaker
 
 
+@pytest.mark.later  # basis set cutoff?
 def test_lcao_force():
     obasis = BasisMaker('O').generate(2, 1, energysplit=0.3, tailnorm=0.03**.5)
     hbasis = BasisMaker('H').generate(2, 1, energysplit=0.3, tailnorm=0.03**.5)
     basis = {'O': obasis, 'H': hbasis}
 
     system = molecule('H2O')
     system.center(vacuum=1.5)
@@ -23,39 +26,47 @@
                 mode='lcao',
                 basis=basis,
                 kpts=[(0., 0., 0.), (.3, .1, .4)],
                 convergence={'density': 1e-5, 'energy': 1e-6})
 
     system.calc = calc
 
-    F_ac = system.get_forces()
-
     # Previous FD result, generated by disabled code below
     F_ac_ref = np.array([[1.05022478, 1.63103681, -5.00612007],
                          [-0.69739179, -0.89624274, 3.03203147],
                          [-0.34438181, -0.7042696, 1.77209023]])
 
-    err_ac = np.abs(F_ac - F_ac_ref)
-    err = err_ac.max()
-
-    print('Force')
-    print(F_ac)
-    print()
-    print('Reference result')
-    print(F_ac_ref)
-    print()
-    print('Error')
-    print(err_ac)
-    print()
-    print('Max error')
-    print(err)
-
-    # ASE uses dx = [+|-] 0.001 by default,
-    # error should be around 2e-3.  In fact 4e-3 would probably be acceptable
-    assert err < 3e-3
+    for use_rho in [0, 1]:
+        if use_rho:
+            for kpt in calc.wfs.kpt_u:
+                kpt.rho_MM = calc.wfs.calculate_density_matrix(kpt.f_n,
+                                                               kpt.C_nM)
+
+        F_ac = system.get_forces()
+        system.calc.results.pop('forces')
+
+        err_ac = np.abs(F_ac - F_ac_ref)
+        err = err_ac.max()
+
+        print('Force')
+        print(F_ac)
+        print()
+        print('Reference result')
+        print(F_ac_ref)
+        print()
+        print('Error')
+        print(err_ac)
+        print()
+        print('Max error')
+        print(err)
+
+        # ASE uses dx = [+|-] 0.001 by default,
+        # error should be around 2e-3.
+        # In fact 4e-3 would probably be acceptable
+        assert err < 3e-3
 
     # Set boolean to run new FD check
     fd = False
 
     if fd:
         from ase.calculators.test import numeric_force
         F_ac_fd = np.array([[numeric_force(system, a, i)
```

### Comparing `gpaw-22.8.0/gpaw/test/lcao/test_generate_ngto.py` & `gpaw-23.6.0/gpaw/test/lcao/test_generate_ngto.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/lcao/test_gllb_si.py` & `gpaw-23.6.0/gpaw/test/lcao/test_gllb_si.py`

 * *Files 12% similar despite different names*

```diff
@@ -10,29 +10,24 @@
 @pytest.fixture
 def calc():
     with GPAW(mode=LCAO(interpolation=2),
               h=0.3,
               basis='sz(dzp)',
               xc='GLLBSC',
               kpts={'size': (2, 2, 2), 'gamma': True},
+              convergence={'maximum iterations': 1},
               txt='si.txt') as calc:
         yield calc
 
 
-@pytest.mark.skip_for_new_gpaw
+@pytest.mark.later
 @pytest.mark.gllb
 @pytest.mark.libxc
 def test_lcao_gllb_si(in_tmp_dir, calc):
     si = bulk('Si', 'diamond', a=5.421)
-
-    def stopcalc():
-        calc.scf.converged = True
-
-    calc.attach(stopcalc, 1)
-
     si.calc = calc
     si.get_potential_energy()
 
     homo, lumo = calc.get_homo_lumo()
     response = calc.hamiltonian.xc.response
     dxc_pot = response.calculate_discontinuity_potential(homo, lumo)
     EKs, Dxc = response.calculate_discontinuity(dxc_pot)
```

### Comparing `gpaw-22.8.0/gpaw/test/lcao/test_h2o.py` & `gpaw-23.6.0/gpaw/test/lcao/test_h2o.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,13 +1,16 @@
+import pytest
 from ase import Atoms
+
 from gpaw import GPAW, LCAO
-from gpaw.test import equal
 from gpaw.poisson import FDPoissonSolver
+from gpaw.test import equal
 
 
+@pytest.mark.later  # basis set cutoff??
 def test_lcao_h2o():
     a = 6.0
     b = a / 2
     mol = Atoms('OHH',
                 [(b, b, 0.1219 + b),
                  (b, 0.7633 + b, -0.4876 + b),
                  (b, -0.7633 + b, -0.4876 + b)],
```

### Comparing `gpaw-22.8.0/gpaw/test/lcao/test_kpts_many_combinations.py` & `gpaw-23.6.0/gpaw/test/lcao/test_kpts_many_combinations.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,7 +1,8 @@
+import pytest
 from itertools import count
 from ase.build import bulk
 from gpaw import GPAW
 from gpaw.mpi import world
 from gpaw.utilities import compiled_with_sl
 
 
@@ -25,14 +26,15 @@
                                 band=band,
                                 domain=domain,
                                 sl_auto=sl_auto,
                                 augment_grids=augment_grids)
                 yield dict(parallel=parallel)
 
 
+@pytest.mark.later
 def test_lcao_kpts_many_combinations(in_tmp_dir):
     counter = count()
 
     for spinpol in [False, True]:
         # We want a non-trivial cell:
         atoms0 = bulk('Ti') * (2, 1, 1)
         atoms0.cell[0] *= 1.2
@@ -63,19 +65,16 @@
             calc = GPAW(
                 mode='lcao',
                 basis='sz(dzp)',
                 xc='PBE', h=0.3,
                 symmetry={'point_group': False},  # No symmetry here anyway
                 txt='gpaw.{:02d}.spin{}.txt'.format(int(spinpol), i),
                 kpts=(4, 1, 1),
+                convergence={'maximum iterations': 2},
                 **kwargs)
-
-            def stopcalc():
-                calc.scf.converged = True
-            calc.attach(stopcalc, 2)
             atoms = atoms0.copy()
             t1 = time()
             atoms.calc = calc
             e = atoms.get_potential_energy()
             f = atoms.get_forces()
             t2 = time()
             if world.rank == 0:
```

### Comparing `gpaw-22.8.0/gpaw/test/lcao/test_largecellforce.py` & `gpaw-23.6.0/gpaw/test/lcao/test_largecellforce.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/lcao/test_lcao_complicated.py` & `gpaw-23.6.0/gpaw/test/lcao/test_lcao_complicated.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,14 +1,14 @@
 import numpy as np
+import pytest
 from ase.build import fcc111
 
+from gpaw import GPAW, LCAO, FermiDirac
 from gpaw.mpi import world
-from gpaw import GPAW
 from gpaw.utilities import compiled_with_sl
-from gpaw import FermiDirac, LCAO
 
 # This test verifies that energy and forces are (approximately)
 # parallelization independent
 #
 # Tests the LCAO energy and forces in non-orthogonal cell with
 # simultaneous parallelization over bands, domains and k-points (if
 # enough CPUs are available), both with and without scalapack
@@ -18,14 +18,15 @@
 #
 # This test covers many cases not caught by lcao_parallel or
 # lcao_parallel_kpt
 #
 # Written November 24, 2011, r8567
 
 
+@pytest.mark.later
 def test_lcao_complicated():
     system = fcc111('Au', size=(1, 3, 1))
     system.numbers[0] = 8
     # It is important that the number of atoms is uneven; this
     # tests the case where the band parallelization does not match
     # the partitioning of orbitals between atoms (the middle atom has orbitals
     # on distinct band descriptor ranks)
```

### Comparing `gpaw-22.8.0/gpaw/test/lcao/test_lcao_elpa.py` & `gpaw-23.6.0/gpaw/test/lcao/test_lcao_elpa.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/lcao/test_lcao_elpa_kpts.py` & `gpaw-23.6.0/gpaw/test/lcao/test_lcao_elpa_kpts.py`

 * *Files 11% similar despite different names*

```diff
@@ -18,20 +18,16 @@
         calc = GPAW(mode='lcao', basis='sz(dzp)',
                     kpts=[2, 2, 2],
                     parallel=dict(sl_auto=True,
                                   use_elpa=elpasolver is not None,
                                   band=2 if world.size > 4 else 1,
                                   kpt=2 if world.size > 2 else 1,
                                   elpasolver=elpasolver),
+                    convergence={'maximum iterations': 2},
                     txt='-')
-
-        def stopcalc():
-            calc.scf.converged = True
-
-        calc.attach(stopcalc, 2)
         atoms.calc = calc
         E = atoms.get_potential_energy()
         energies.append(E)
 
         err = abs(E - energies[0])
         assert err < 1e-10, ' '.join(['err',
                                       str(err), 'energies:', str(energies)])
```

### Comparing `gpaw-22.8.0/gpaw/test/lcao/test_lcao_hamiltonian.py` & `gpaw-23.6.0/gpaw/test/lcao/test_lcao_hamiltonian.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,16 +1,19 @@
 import numpy as np
+import pytest
 from ase import Atoms
+
 from gpaw import GPAW, restart
+from gpaw.atom.basis import BasisMaker
 from gpaw.lcao.tools import get_lcao_hamiltonian
 from gpaw.mpi import world
-from gpaw.atom.basis import BasisMaker
 from gpaw.test import equal
 
 
+@pytest.mark.later
 def test_lcao_lcao_hamiltonian(in_tmp_dir, add_cwd_to_setup_paths):
     if world.rank == 0:
         basis = BasisMaker('Li').generate(1, 1)
         basis.write_xml()
     world.barrier()
 
     if 1:
```

### Comparing `gpaw-22.8.0/gpaw/test/lcao/test_lcao_parallel.py` & `gpaw-23.6.0/gpaw/test/lcao/test_lcao_parallel.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/lcao/test_lcao_parallel_kpt.py` & `gpaw-23.6.0/gpaw/test/lcao/test_lcao_parallel_kpt.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/lcao/test_lcao_projections.py` & `gpaw-23.6.0/gpaw/test/lcao/test_lcao_projections.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,15 +1,17 @@
 import numpy as np
+import pytest
 from ase.build import molecule
 
 from gpaw import GPAW
-from gpaw.poisson import FDPoissonSolver
 from gpaw.lcao.projected_wannier import get_lcao_projections_HSP
+from gpaw.poisson import FDPoissonSolver
 
 
+@pytest.mark.later
 def test_lcao_lcao_projections():
     atoms = molecule('C2H2')
     atoms.center(vacuum=3.0)
     calc = GPAW(gpts=(32, 32, 48),
                 experimental={'niter_fixdensity': 2},
                 poissonsolver=FDPoissonSolver(),
                 eigensolver='rmm-diis')
```

### Comparing `gpaw-22.8.0/gpaw/test/lcao/test_pair_and_coulomb.py` & `gpaw-23.6.0/gpaw/test/lcao/test_pair_and_coulomb.py`

 * *Files 4% similar despite different names*

```diff
@@ -8,14 +8,15 @@
 from gpaw.mpi import world, rank, serial_comm
 from gpaw.test import equal
 
 pytestmark = pytest.mark.skipif(world.size > 1,
                                 reason='world.size > 1')
 
 
+@pytest.mark.later
 def test_lcao_pair_and_coulomb(in_tmp_dir):
     atoms = molecule('H2')
     atoms.set_cell([6.4, 6.4, 6.4])
     atoms.center()
     calc = GPAW(mode='lcao', occupations=FermiDirac(0.1),
                 poissonsolver={'name': 'fd'})
     atoms.calc = calc
```

### Comparing `gpaw-22.8.0/gpaw/test/lcao/test_scissors.py` & `gpaw-23.6.0/gpaw/test/lcao/test_scissors.py`

 * *Files 23% similar despite different names*

```diff
@@ -1,13 +1,14 @@
 import pytest
 from ase import Atoms
 from gpaw import GPAW
 from gpaw.lcao.scissors import Scissors
 
 
+@pytest.mark.later
 def test_scissors():
     h2 = Atoms('2H2', [[0, 0, 0], [0, 0, 0.74],
                        [4, 0, 0], [4, 0, 0.74]])
     h2.center(vacuum=3.0)
     d = 1.0
     h2.calc = GPAW(mode='lcao',
                    basis='sz(dzp)',
```

### Comparing `gpaw-22.8.0/gpaw/test/lcaotddft/__init__.py` & `gpaw-23.6.0/gpaw/test/lcaotddft/__init__.py`

 * *Files 13% similar despite different names*

```diff
@@ -65,16 +65,16 @@
         err = np.nan
     err = broadcast_float(err, world)
     return err
 
 
 def check_txt_data(ref_fpath, data_fpath, atol):
     world.barrier()
-    ref = np.loadtxt(ref_fpath)
-    data = np.loadtxt(data_fpath)
+    ref = np.loadtxt(ref_fpath, encoding='utf-8')
+    data = np.loadtxt(data_fpath, encoding='utf-8')
     err = calculate_error(data, ref)
     assert err < atol
 
 
 def check_wfs(wf_ref_fpath, wf_fpath, atol=1e-12):
     wfr_ref = WaveFunctionReader(wf_ref_fpath)
     wfr = WaveFunctionReader(wf_fpath)
@@ -83,15 +83,15 @@
         ref = wfr_ref[i].wave_functions.coefficients
         coeff = wfr[i].wave_functions.coefficients
         err = calculate_error(coeff, ref)
         assert err < atol, f'error at i={i}'
 
 
 def copy_and_cut_file(src, dst, *, cut_lines=0):
-    with open(src, 'r') as fd:
+    with open(src, 'r', encoding='utf-8') as fd:
         lines = fd.readlines()
         if cut_lines > 0:
             lines = lines[:-cut_lines]
 
-    with open(dst, 'w') as fd:
+    with open(dst, 'w', encoding='utf-8') as fd:
         for line in lines:
             fd.write(line)
```

### Comparing `gpaw-22.8.0/gpaw/test/lcaotddft/demo_tddft.py` & `gpaw-23.6.0/gpaw/test/lcaotddft/demo_tddft.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/lcaotddft/test_circular_dichroism.py` & `gpaw-23.6.0/gpaw/test/lcaotddft/test_circular_dichroism.py`

 * *Files 4% similar despite different names*

```diff
@@ -54,18 +54,18 @@
                          origin='zero', origin_shift=[1.0, 2.0, 3.0])
     td_calc.absorption_kick([1e-5, 0., 0.])
     td_calc.propagate(100, 3)
     td_calc.write('td.gpw', mode='all')
     td_calc.propagate(100, 2)
 
 
-@pytest.mark.skip_for_new_gpaw
+@pytest.mark.rttddft
 def test_magnetic_moment_values(initialize_system, module_tmp_path,
                                 in_tmp_dir):
-    with open('mm_ref.dat', 'w') as f:
+    with open('mm_ref.dat', 'w', encoding='utf-8') as f:
         f.write('''
 # MagneticMomentWriter[version=4](origin='COM')
 # origin_v = [7.634300, 5.000000, 4.302858] Å
 #            time               mmx                    mmy                    mmz
           0.00000000     0.000000000000e+00     0.000000000000e+00     0.000000000000e+00
 # Kick = [    1.000000000000e-05,     0.000000000000e+00,     0.000000000000e+00]; Time = 0.00000000
           0.00000000     8.192189793082e-06     1.038446327373e-05    -2.730498071751e-05
@@ -75,21 +75,21 @@
          16.53654934     3.058296873929e-06     4.443905967036e-06    -6.697375210691e-06
          20.67068667     6.247451722277e-07     1.298788405738e-06     1.460017881082e-06
 '''.strip())  # noqa: E501
 
     check_txt_data(module_tmp_path / 'mm.dat', 'mm_ref.dat', atol=2e-14)
 
 
-@pytest.mark.skip_for_new_gpaw
+@pytest.mark.rttddft
 def test_magnetic_moment_grid_evaluation(initialize_system, module_tmp_path):
     dpath = module_tmp_path
     check_txt_data(dpath / 'mm.dat', dpath / 'mm_grid.dat', atol=2e-8)
 
 
-@pytest.mark.skip_for_new_gpaw
+@pytest.mark.rttddft
 @pytest.mark.parametrize('parallel', parallel_i)
 def test_magnetic_moment_parallel(initialize_system, module_tmp_path, parallel,
                                   in_tmp_dir):
     td_calc = LCAOTDDFT(module_tmp_path / 'gs.gpw',
                         parallel=parallel,
                         txt='td.out')
     MagneticMomentWriter(td_calc, 'mm.dat')
@@ -99,15 +99,15 @@
     td_calc.absorption_kick([1e-5, 0., 0.])
     td_calc.propagate(100, 5)
 
     for fname in ['mm.dat', 'mm_grid.dat', 'mm_origin.dat']:
         check_txt_data(module_tmp_path / fname, fname, atol=7e-14)
 
 
-@pytest.mark.skip_for_new_gpaw
+@pytest.mark.rttddft
 @pytest.mark.parametrize('parallel', parallel_i)
 def test_magnetic_moment_restart(initialize_system, module_tmp_path, parallel,
                                  in_tmp_dir):
     td_calc = LCAOTDDFT(module_tmp_path / 'td.gpw',
                         parallel=parallel,
                         txt='td.out')
     for fname in ['mm.dat', 'mm_grid.dat', 'mm_origin.dat']:
@@ -138,15 +138,15 @@
         data_tv = np.zeros((len(time_t), 4))
         data_tv[:, 0] = time_t
         # Fill unused columns with random values
         data_tv[:, 1:] = np.random.rand(len(time_t), 3)
         # Diagonal column has the data used for spectrum
         data_tv[:, v + 1] = (kick_strength * strength_v[v]
                              * np.cos(frequency_v[v] * time_t))
-        with open(f'mm-{kick}.dat', 'w') as f:
+        with open(f'mm-{kick}.dat', 'w', encoding='utf-8') as f:
             f.write(f'''
 # MagneticMomentWriter[version=4](origin='COM')
 #            time               mmx                    mmy                    mmz
           0.00000000     0.000000000000e+00     0.000000000000e+00     0.000000000000e+00
 # Kick = {kick_v}; Time = 0.00000000
 ''')  # noqa: E501
             np.savetxt(f, data_tv)
```

### Comparing `gpaw-22.8.0/gpaw/test/lcaotddft/test_fxc_is_xc.py` & `gpaw-23.6.0/gpaw/test/lcaotddft/test_fxc_is_xc.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,20 +1,19 @@
 import numpy as np
-
+import pytest
 from ase.build import molecule
+
 from gpaw import GPAW
 from gpaw.lcaotddft import LCAOTDDFT
 from gpaw.lcaotddft.dipolemomentwriter import DipoleMomentWriter
 from gpaw.mpi import world
-
 from gpaw.test import equal
 
-# Atoms
-
 
+@pytest.mark.rttddft
 def test_lcaotddft_fxc_is_xc(in_tmp_dir):
     atoms = molecule('Na2')
     atoms.center(vacuum=4.0)
 
     # Ground-state calculation
     calc = GPAW(nbands=2, h=0.4, setups=dict(Na='1'),
                 basis='dzp', mode='lcao',
```

### Comparing `gpaw-22.8.0/gpaw/test/lcaotddft/test_fxc_rpa.py` & `gpaw-23.6.0/gpaw/test/lcaotddft/test_fxc_rpa.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,21 +1,19 @@
 import numpy as np
-
+import pytest
 from ase.build import molecule
 from gpaw import GPAW
 from gpaw.lcaotddft import LCAOTDDFT
-from gpaw.poisson import PoissonSolver
 from gpaw.lcaotddft.dipolemomentwriter import DipoleMomentWriter
 from gpaw.mpi import world
-
+from gpaw.poisson import PoissonSolver
 from gpaw.test import equal
 
-# Atoms
-
 
+@pytest.mark.rttddft
 def test_lcaotddft_fxc_rpa(in_tmp_dir):
     atoms = molecule('Na2')
     atoms.center(vacuum=4.0)
 
     # Ground-state calculation
     calc = GPAW(nbands=2, h=0.4, setups=dict(Na='1'),
                 basis='dzp', mode='lcao',
```

### Comparing `gpaw-22.8.0/gpaw/test/lcaotddft/test_fxc_vs_linearize.py` & `gpaw-23.6.0/gpaw/test/lcaotddft/test_fxc_vs_linearize.py`

 * *Files 2% similar despite different names*

```diff
@@ -6,14 +6,15 @@
 from gpaw.lcaotddft.dipolemomentwriter import DipoleMomentWriter
 from gpaw.mpi import world
 from gpaw.test import equal
 
 
 @pytest.mark.gllb
 @pytest.mark.libxc
+@pytest.mark.rttddft
 def test_lcaotddft_fxc_vs_linearize(in_tmp_dir):
     atoms = molecule('SiH4')
     atoms.center(vacuum=4.0)
 
     # Ground-state calculation
     calc = GPAW(nbands=7, h=0.4,
                 basis='dzp', mode='lcao',
```

### Comparing `gpaw-22.8.0/gpaw/test/lcaotddft/test_laser.py` & `gpaw-23.6.0/gpaw/test/lcaotddft/test_laser.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,28 +1,28 @@
 import numpy as np
-
+import pytest
 from ase.build import molecule
-from ase.units import Hartree, Bohr
+from ase.units import Bohr, Hartree
 from gpaw import GPAW
-from gpaw.lcaotddft import LCAOTDDFT
-from gpaw.lcaotddft.laser import GaussianPulse
 from gpaw.external import ConstantElectricField
+from gpaw.lcaotddft import LCAOTDDFT
 from gpaw.lcaotddft.dipolemomentwriter import DipoleMomentWriter
-from gpaw.tddft.units import as_to_au
+from gpaw.lcaotddft.laser import GaussianPulse
 from gpaw.mpi import world
-
+from gpaw.tddft.units import as_to_au
 from gpaw.test import equal
 
 # Settings
 dt = 20.0
 N1 = 5
 N = 5 + N1
 kick_v = np.ones(3) * 1e-5
 
 
+@pytest.mark.rttddft
 def test_laser(in_tmp_dir):
     # Atoms
     atoms = molecule('Na2')
     atoms.center(vacuum=4.0)
 
     # Ground-state calculation
     calc = GPAW(nbands=2, h=0.4, setups=dict(Na='1'),
```

### Comparing `gpaw-22.8.0/gpaw/test/lcaotddft/test_lcaotddft_vs_lrtddft.py` & `gpaw-23.6.0/gpaw/test/lcaotddft/test_lcaotddft_vs_lrtddft.py`

 * *Files 3% similar despite different names*

```diff
@@ -85,27 +85,30 @@
     # broadened spectra in RT-TDDFT and LR-TDDFT
     data_ej = np.loadtxt('spec_lr2.dat')
     spec_e = data_ej[:, 5]
     spec_e[1:] /= lr2.lr_transitions.get_transitions()[0][0]
     return spec_e
 
 
+@pytest.mark.rttddft
 def test_lcaotddft_vs_lrtddft(time_propagation_calculation,
                               lrtddft_calculation):
     # One can decrease the tolerance by decreasing the time step
     # and other parameters
     assert (time_propagation_calculation
             == pytest.approx(lrtddft_calculation, abs=1e-2))
 
 
+@pytest.mark.rttddft
 def test_lcaotddft_vs_lrtddft2(time_propagation_calculation,
                                lrtddft2_calculation):
     # One can decrease the tolerance by decreasing the time step
     # and other parameters
     assert (time_propagation_calculation
             == pytest.approx(lrtddft2_calculation, abs=1e-2))
 
 
+@pytest.mark.rttddft
 def test_lrtddft_vs_lrtddft2(lrtddft_calculation,
                              lrtddft2_calculation):
     assert (lrtddft_calculation
             == pytest.approx(lrtddft2_calculation, abs=1e-3))
```

### Comparing `gpaw-22.8.0/gpaw/test/lcaotddft/test_lcaotddft_vs_lrtddft2_rpa.py` & `gpaw-23.6.0/gpaw/test/lcaotddft/test_lcaotddft_vs_lrtddft2_rpa.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,22 +1,20 @@
 import numpy as np
-
+import pytest
 from ase.build import molecule
 from gpaw import GPAW
 from gpaw.lcaotddft import LCAOTDDFT
 from gpaw.lcaotddft.dipolemomentwriter import DipoleMomentWriter
-from gpaw.tddft.spectrum import photoabsorption_spectrum
 from gpaw.lrtddft2 import LrTDDFT2
 from gpaw.mpi import world
-
+from gpaw.tddft.spectrum import photoabsorption_spectrum
 from gpaw.test import equal
 
-# Atoms
-
 
+@pytest.mark.rttddft
 def test_lcaotddft_lcaotddft_vs_lrtddft2_rpa(in_tmp_dir):
     atoms = molecule('Na2')
     atoms.center(vacuum=4.0)
 
     # Ground-state calculation
     calc = GPAW(nbands=2, h=0.4, setups=dict(Na='1'),
                 basis='sz(dzp)', mode='lcao', xc='oldLDA',
```

### Comparing `gpaw-22.8.0/gpaw/test/lcaotddft/test_molecule.py` & `gpaw-23.6.0/gpaw/test/lcaotddft/test_molecule.py`

 * *Files 8% similar despite different names*

```diff
@@ -54,15 +54,15 @@
     unocc_calc = calc.fixed_density(nbands='nao',
                                     communicator=comm,
                                     txt='unocc.out')
     unocc_calc.write('unocc.gpw', mode='all')
     return unocc_calc, fdm
 
 
-@pytest.mark.skip_for_new_gpaw
+@pytest.mark.rttddft
 def test_propagated_wave_function(initialize_system, module_tmp_path):
     wfr = WaveFunctionReader(module_tmp_path / 'wf.ulm')
     coeff = wfr[-1].wave_functions.coefficients
     # Pick a few coefficients corresponding to non-degenerate states;
     # degenerate states should be normalized so that they can be compared
     coeff = coeff[np.ix_([0], [0], [0, 1, 4], [0, 1, 2])]
     # Normalize the wave function sign
@@ -73,18 +73,18 @@
              [1.5177089239371724e-01 + 7.6502712023931621e-02j,
               8.0497556154952932e-01 + 4.0573839188792121e-01j,
               -5.1505952970811632e-06 - 1.1507918955641119e-05j],
              [2.5116252101774323e+00 + 3.6776360873471503e-01j,
               1.9024613198566329e-01 + 2.7843314959952882e-02j,
               -1.3848736953929574e-05 - 2.6402210145403184e-05j]]]]
     err = calculate_error(coeff, ref)
-    assert err < 2e-12
+    assert err < 3e-12
 
 
-@pytest.mark.skip_for_new_gpaw
+@pytest.mark.rttddft
 @pytest.mark.parametrize('parallel', parallel_i)
 def test_propagation(initialize_system, module_tmp_path, parallel, in_tmp_dir):
     calculate_time_propagation(module_tmp_path / 'gs.gpw',
                                kick=np.ones(3) * 1e-5,
                                parallel=parallel)
     check_wfs(module_tmp_path / 'wf.ulm', 'wf.ulm', atol=1e-12)
 
@@ -156,24 +156,24 @@
 @pytest.fixture(scope='module')
 def ksd_transform(load_ksd):
     ksd, fdm = load_ksd
     rho_iwp = ksd_transform_fdm(ksd, fdm)
     return rho_iwp
 
 
-@pytest.mark.skip_for_new_gpaw
+@pytest.mark.rttddft
 def test_ksd_transform(ksd_transform, ksd_transform_reference):
     ref_iwp = ksd_transform_reference
     rho_iwp = ksd_transform
     err = calculate_error(rho_iwp, ref_iwp)
     atol = 1e-18
     assert err < atol
 
 
-@pytest.mark.skip_for_new_gpaw
+@pytest.mark.rttddft
 def test_ksd_transform_real_only(load_ksd, ksd_transform_reference):
     ksd, fdm = load_ksd
     ref_iwp = ksd_transform_reference
     rho_iwp = np.empty((2, len(fdm.freq_w), len(ksd.w_p)), dtype=complex)
     rho_iwp[:] = np.nan + 1j * np.nan
     for i, rho_wuMM in enumerate([fdm.FReDrho_wuMM, fdm.FImDrho_wuMM]):
         for w in range(len(fdm.freq_w)):
@@ -182,15 +182,15 @@
                 + 1j * ksd.transform([rho_uMM[0].imag], broadcast=True)[0]
             rho_iwp[i, w, :] = rho_p
     err = calculate_error(rho_iwp, ref_iwp)
     atol = 1e-18
     assert err < atol
 
 
-@pytest.mark.skip_for_new_gpaw
+@pytest.mark.rttddft
 def test_dipole_moment_from_ksd(ksd_transform, load_ksd,
                                 dipole_moment_reference):
     ksd, fdm = load_ksd
     dm_wv = np.empty((len(fdm.freq_w), 3), dtype=complex)
     dm_wv[:] = np.nan + 1j * np.nan
     rho_wp = ksd_transform[0]
     for w in range(len(fdm.freq_w)):
@@ -225,15 +225,15 @@
 def density_reference(ksd_reference):
     ksd, fdm = ksd_reference
     dmat_rho_wg = get_density_fdm(ksd, fdm, 'dmat')
     ksd_rho_wg = get_density_fdm(ksd, fdm, 'ksd')
     return dict(dmat=dmat_rho_wg, ksd=ksd_rho_wg)
 
 
-@pytest.mark.skip_for_new_gpaw
+@pytest.mark.rttddft
 def test_ksd_vs_dmat_density(density_reference):
     ref_wg = density_reference['dmat']
     rho_wg = density_reference['ksd']
     err = calculate_error(rho_wg, ref_wg)
     atol = 2e-10
     assert err < atol
 
@@ -244,26 +244,26 @@
     if ksd.ksl.using_blacs:
         pytest.xfail('Scalapack is not supported')
     dmat_rho_wg = get_density_fdm(ksd, fdm, 'dmat')
     ksd_rho_wg = get_density_fdm(ksd, fdm, 'ksd')
     return dict(dmat=dmat_rho_wg, ksd=ksd_rho_wg)
 
 
-@pytest.mark.skip_for_new_gpaw
+@pytest.mark.rttddft
 @pytest.mark.parametrize('kind', ['ksd', 'dmat'])
 def test_density(kind, density, load_ksd, density_reference):
     ksd, fdm = load_ksd
     ref_wg = density_reference[kind]
     rho_wg = fdm.dmat.density.finegd.collect(density[kind])
     err = calculate_error(rho_wg, ref_wg)
     atol = 3e-19
     assert err < atol
 
 
-@pytest.mark.skip_for_new_gpaw
+@pytest.mark.rttddft
 @pytest.mark.parametrize('kind', ['ksd', 'dmat'])
 def test_dipole_moment_from_density(kind, density, load_ksd,
                                     dipole_moment_reference):
     ksd, fdm = load_ksd
     rho_wg = density[kind]
     dm_wv = np.empty((len(fdm.freq_w), 3), dtype=complex)
     dm_wv[:] = np.nan + 1j * np.nan
@@ -285,25 +285,25 @@
     calculate_ground_state(communicator=comm, spinpol=True)
     calculate_time_propagation('gs.gpw',
                                kick=np.ones(3) * 1e-5,
                                communicator=comm,
                                do_fdm=True)
 
 
-@pytest.mark.skip_for_new_gpaw
+@pytest.mark.rttddft
 def test_spinpol_dipole_moment(initialize_system, initialize_system_spinpol,
                                module_tmp_path):
     # The test system has even number of electrons and is non-magnetic
     # so spin-paired and spin-polarized calculation should give same result
     check_txt_data(module_tmp_path / 'dm.dat',
                    module_tmp_path / 'spinpol' / 'dm.dat',
-                   atol=4e-14)
+                   atol=5e-14)
 
 
-@pytest.mark.skip_for_new_gpaw
+@pytest.mark.rttddft
 @pytest.mark.parametrize('parallel', parallel_i)
 def test_spinpol_propagation(initialize_system_spinpol, module_tmp_path,
                              parallel, in_tmp_dir):
     ref_path = module_tmp_path / 'spinpol'
     calculate_time_propagation(ref_path / 'gs.gpw',
                                kick=np.ones(3) * 1e-5,
                                parallel=parallel)
```

### Comparing `gpaw-22.8.0/gpaw/test/lcaotddft/test_periodic.py` & `gpaw-23.6.0/gpaw/test/lcaotddft/test_periodic.py`

 * *Files 4% similar despite different names*

```diff
@@ -12,14 +12,15 @@
                check_wfs)
 
 pytestmark = pytest.mark.usefixtures('module_tmp_path')
 
 parallel_i = parallel_options(include_kpt=True)
 
 
+@pytest.mark.rttddft
 @pytest.fixture(scope='module')
 @only_on_master(world)
 def initialize_system():
     comm = serial_comm
 
     # Ground-state calculation
     atoms = fcc111('Al', size=(1, 1, 2), vacuum=4.0)
@@ -39,15 +40,15 @@
 
     # Time-propagation calculation
     calculate_time_propagation('gs.gpw',
                                kick=[0, 0, 1e-5],
                                communicator=comm)
 
 
-@pytest.mark.skip_for_new_gpaw
+@pytest.mark.rttddft
 def test_propagated_wave_function(initialize_system, module_tmp_path):
     wfr = WaveFunctionReader(module_tmp_path / 'wf.ulm')
     coeff = wfr[-1].wave_functions.coefficients
     coeff = coeff[np.ix_([0], [0, 1], [1, 3], [0, 1, 2])]
     # Normalize the wave function sign
     coeff = np.sign(coeff.real[..., 0, np.newaxis]) * coeff
     ref = [[[[5.4119034398864430e-01 + 4.6958807325576735e-01j,
@@ -59,17 +60,17 @@
             [[1.9820345503468246e+00 + 1.0562314330323577e+00j,
               -1.5008623926242098e-01 + 4.5817475674967340e-01j,
               -4.8385783015916195e-01 - 5.3676335879786385e-01j],
              [2.4227856141643818e+00 + 3.7767002050641824e-01j,
               -2.6174901880264838e+00 + 1.9885717875694848e+00j,
               7.2641847473298660e-01 + 1.6020733667409095e+00j]]]]
     err = calculate_error(coeff, ref)
-    assert err < 5e-9
+    assert err < 7e-9
 
 
-@pytest.mark.skip_for_new_gpaw
+@pytest.mark.rttddft
 @pytest.mark.parametrize('parallel', parallel_i)
 def test_propagation(initialize_system, module_tmp_path, parallel, in_tmp_dir):
     calculate_time_propagation(module_tmp_path / 'gs.gpw',
                                kick=[0, 0, 1e-5],
                                parallel=parallel)
     check_wfs(module_tmp_path / 'wf.ulm', 'wf.ulm', atol=1e-12)
```

### Comparing `gpaw-22.8.0/gpaw/test/lcaotddft/test_replay.py` & `gpaw-23.6.0/gpaw/test/lcaotddft/test_replay.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,20 +1,20 @@
 import numpy as np
-
+import pytest
 from ase.build import molecule
 from gpaw import GPAW
 from gpaw.lcaotddft import LCAOTDDFT
 from gpaw.lcaotddft.dipolemomentwriter import DipoleMomentWriter
 from gpaw.lcaotddft.wfwriter import WaveFunctionWriter
-from gpaw.tddft.spectrum import photoabsorption_spectrum
 from gpaw.mpi import world
-
+from gpaw.tddft.spectrum import photoabsorption_spectrum
 from gpaw.test import equal
 
 
+@pytest.mark.rttddft
 def test_lcaotddft_replay(in_tmp_dir):
     atoms = molecule('Na2')
     atoms.center(vacuum=4.0)
 
     # Ground-state calculation
     calc = GPAW(nbands=2, h=0.4, setups=dict(Na='1'),
                 basis='dzp', mode='lcao',
```

### Comparing `gpaw-22.8.0/gpaw/test/lcaotddft/test_restart.py` & `gpaw-23.6.0/gpaw/test/lcaotddft/test_restart.py`

 * *Files 2% similar despite different names*

```diff
@@ -11,14 +11,15 @@
 from gpaw.mpi import world
 from gpaw.tddft.folding import frequencies
 from gpaw.test import equal
 
 
 @pytest.mark.gllb
 @pytest.mark.libxc
+@pytest.mark.rttddft
 def test_lcaotddft_restart(in_tmp_dir):
     atoms = molecule('SiH4')
     atoms.center(vacuum=4.0)
 
     # Ground-state calculation
     calc = GPAW(nbands=7, h=0.4,
                 basis='dzp', mode='lcao',
```

### Comparing `gpaw-22.8.0/gpaw/test/lcaotddft/test_rremission.py` & `gpaw-23.6.0/gpaw/test/lcaotddft/test_rremission.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,17 +1,19 @@
+import pytest
 from ase.build import molecule
 from ase.parallel import paropen
 from gpaw import GPAW
 from gpaw.lcaotddft import LCAOTDDFT
 from gpaw.lcaotddft.dipolemomentwriter import DipoleMomentWriter
 from gpaw.lcaotddft.qed import RRemission
 
 from . import check_txt_data
 
 
+@pytest.mark.rttddft
 def test_rremission(in_tmp_dir):
     atoms = molecule('Na2')
     atoms.center(vacuum=4.0)
     calc = GPAW(mode='lcao', h=0.4, basis='dzp',
                 setups={'Na': '1'},
                 convergence={'density': 1e-12})
     atoms.calc = calc
```

### Comparing `gpaw-22.8.0/gpaw/test/lcaotddft/test_simple.py` & `gpaw-23.6.0/gpaw/test/lcaotddft/test_simple.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,22 +1,20 @@
 import numpy as np
-
+import pytest
 from ase.build import molecule
 from gpaw import GPAW
 from gpaw.lcaotddft import LCAOTDDFT
-from gpaw.poisson import PoissonSolver
 from gpaw.lcaotddft.dipolemomentwriter import DipoleMomentWriter
-from gpaw.tddft.spectrum import photoabsorption_spectrum
 from gpaw.mpi import world
-
+from gpaw.poisson import PoissonSolver
+from gpaw.tddft.spectrum import photoabsorption_spectrum
 from gpaw.test import equal
 
-# Atoms
-
 
+@pytest.mark.rttddft
 def test_lcaotddft_simple(in_tmp_dir):
     atoms = molecule('Na2')
     atoms.center(vacuum=4.0)
 
     # Ground-state calculation
     calc = GPAW(nbands=2, h=0.4, setups=dict(Na='1'),
                 basis='dzp', mode='lcao',
```

### Comparing `gpaw-22.8.0/gpaw/test/lfc/test_derivatives.py` & `gpaw-23.6.0/gpaw/test/lfc/test_derivatives.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/lfc/test_lf.py` & `gpaw-23.6.0/gpaw/test/lfc/test_lf.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/lfc/test_second_derivative.py` & `gpaw-23.6.0/gpaw/test/lfc/test_second_derivative.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/linalg/test_blas.py` & `gpaw-23.6.0/gpaw/test/linalg/test_blas.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/linalg/test_dot.py` & `gpaw-23.6.0/gpaw/test/linalg/test_dot.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/linalg/test_gemm.py` & `gpaw-23.6.0/gpaw/test/linalg/test_gemm.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/linalg/test_gemm_complex.py` & `gpaw-23.6.0/gpaw/test/linalg/test_gemm_complex.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/linalg/test_mmm.py` & `gpaw-23.6.0/gpaw/test/linalg/test_mmm.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/linalg/test_zher.py` & `gpaw-23.6.0/gpaw/test/linalg/test_zher.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/lrtddft/d2Excdn2.py` & `gpaw-23.6.0/gpaw/test/lrtddft/d2Excdn2.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/lrtddft/rraman.py` & `gpaw-23.6.0/gpaw/test/lrtddft/rraman.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/lrtddft/rraman_albrecht.py` & `gpaw-23.6.0/gpaw/test/lrtddft/rraman_albrecht.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/lrtddft/test_1.py` & `gpaw-23.6.0/gpaw/test/lrtddft/test_1.py`

 * *Files 11% similar despite different names*

```diff
@@ -57,31 +57,31 @@
 @pytest.fixture
 def lr_spin(H2spin):
     lr = LrTDDFT(H2spin.calc, xc='LDA', nspins=2)
     lr.diagonalize()
     return lr
 
 
-@pytest.mark.skip_for_new_gpaw
+@pytest.mark.lrtddft
 def test_finegrid(H2, lr):
     for finegrid in [1, 0]:
         lr2 = LrTDDFT(H2.calc, xc='LDA', finegrid=finegrid)
         lr2.diagonalize()
         parprint('finegrid, t1, t3=', finegrid, lr[0], lr2[0])
         equal(lr[0].get_energy(), lr2[0].get_energy(), 5.e-4)
 
 
-@pytest.mark.skip_for_new_gpaw
+@pytest.mark.lrtddft
 def test_velocity_form(lr):
     for ozr, ozv in zip(lr[0].get_oscillator_strength(),
                         lr[0].get_oscillator_strength('v')):
         equal(ozr, ozv, 0.1)
 
 
-@pytest.mark.skip_for_new_gpaw
+@pytest.mark.lrtddft
 def test_singlet_triplet(lr_vspin, lr_spin):
     # singlet/triplet separation
     singlet, triplet = lr_vspin.singlets_triplets()
 
     # singlet/triplet separation
     precision = 1.e-5
     singlet.diagonalize()
@@ -90,15 +90,15 @@
           lr_spin[1].get_oscillator_strength()[0], precision)
     triplet.diagonalize()
     equal(triplet[0].get_oscillator_strength()[0], 0)
     equal(triplet[0].get_energy(), lr_spin[0].get_energy(), precision)
     equal(triplet[0].get_oscillator_strength()[0], 0)
 
 
-@pytest.mark.skip_for_new_gpaw
+@pytest.mark.lrtddft
 def test_spin(lr, lr_vspin, lr_spin):
     # without spin
     t1 = lr[0]
     ex = ExcitedState(lr, 0)
     den = ex.get_pseudo_density() * Bohr**3
 
     # with spin
@@ -138,15 +138,15 @@
                  finegd.integrate(ex_vspin.get_all_electron_density()
                                   * Bohr**3),
                  finegd.integrate(ex_spin.get_all_electron_density()
                                   * Bohr**3))
         assert ddiff < 3.e-3, ddiff
 
 
-@pytest.mark.skip_for_new_gpaw
+@pytest.mark.lrtddft
 def test_io(in_tmp_dir, lr):
     fname = 'lr.dat.gz'
     lr.write(fname)
     world.barrier()
 
     lr2 = LrTDDFT.read(fname)
     lr2.diagonalize()
```

### Comparing `gpaw-22.8.0/gpaw/test/lrtddft/test_2.py` & `gpaw-23.6.0/gpaw/test/lrtddft/test_2.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,13 +1,15 @@
+import pytest
 from ase import Atoms
 from gpaw import GPAW
 from gpaw.lrtddft import LrTDDFT
 from gpaw.lrtddft.spectrum import spectrum
 
 
+@pytest.mark.lrtddft
 def test_lrtddft_2(in_tmp_dir):
     txt = '-'
     txt = None
     xc = 'LDA'
 
     R = 0.7  # approx. experimental bond length
     a = 4.0
```

### Comparing `gpaw-22.8.0/gpaw/test/lrtddft/test_3.py` & `gpaw-23.6.0/gpaw/test/lrtddft/test_3.py`

 * *Files 2% similar despite different names*

```diff
@@ -10,14 +10,15 @@
 from gpaw.mpi import rank, world
 from gpaw.test import equal
 from gpaw.gauss import Gauss
 from gpaw.lrtddft import LrTDDFT, photoabsorption_spectrum
 from gpaw.lrtddft.kssingle import KSSingles
 
 
+@pytest.mark.lrtddft
 @pytest.mark.slow
 def test_lrtddft_3(in_tmp_dir):
     from io import StringIO
 
     L = 10.0
     txt = None
     txt = '-'
```

### Comparing `gpaw-22.8.0/gpaw/test/lrtddft/test_apmb.py` & `gpaw-23.6.0/gpaw/test/lrtddft/test_apmb.py`

 * *Files 5% similar despite different names*

```diff
@@ -3,14 +3,15 @@
 from ase.parallel import parprint
 
 from gpaw.test import equal
 from gpaw import GPAW, mpi
 from gpaw.lrtddft import LrTDDFT
 
 
+@pytest.mark.lrtddft
 @pytest.mark.libxc
 def test_lrtddft_apmb():
     txt = '-'
     txt = '/dev/null'
 
     load = False
```

### Comparing `gpaw-22.8.0/gpaw/test/lrtddft/test_dielectric.py` & `gpaw-23.6.0/gpaw/test/lrtddft/test_dielectric.py`

 * *Files 14% similar despite different names*

```diff
@@ -23,20 +23,20 @@
 @pytest.fixture
 def lrtddft(H2):
     exlst = LrTDDFT(txt=None)
     exlst.calculate(H2)
     return exlst
 
 
-@pytest.mark.skip_for_new_gpaw
+@pytest.mark.lrtddft
 def test_get(H2, lrtddft):
     energies, eps1, eps2, N, K, R = get_dielectric(lrtddft, H2.get_volume())
     for res in [eps1, eps2, N, K, R]:
         assert energies.shape == res.shape
     assert (energies >= 0).all()
 
 
-@pytest.mark.skip_for_new_gpaw
+@pytest.mark.lrtddft
 def test_write(H2, lrtddft, in_tmp_dir):
     fname = 'dielectric.dat'
     dielectric(lrtddft, H2.get_volume(), fname)
     assert Path(fname).is_file()
```

### Comparing `gpaw-22.8.0/gpaw/test/lrtddft/test_excited_state.py` & `gpaw-23.6.0/gpaw/test/lrtddft/test_excited_state.py`

 * *Files 4% similar despite different names*

```diff
@@ -39,14 +39,15 @@
 
     if calculator is not None:
         H3.calc = calculator
 
     return H3
 
 
+@pytest.mark.lrtddft
 def test_split(in_tmp_dir):
     fname = 'exlst.out'
     calc = GPAW(xc='PBE', h=0.25, nbands=3, txt=fname)
     exlst = LrTDDFT(calc, txt=fname)
     exst = ExcitedState(exlst, 0, txt=fname)
     H2 = get_H2(exst)
     H2.get_potential_energy()
@@ -58,14 +59,15 @@
     if world.rank == 0:
         with open(fname) as f:
             string = f.read()
             assert 'Total number of cores used: {0}'.format(n) in string
             assert 'Total number of cores used: 1' in string
 
 
+@pytest.mark.lrtddft
 def test_lrtddft_excited_state():
     txt = None
 
     calc = GPAW(xc='PBE', h=0.25, nbands=3, spinpol=False, txt=txt)
     H2 = get_H2(calc)
 
     xc = 'LDA'
@@ -109,14 +111,15 @@
     H2.set_positions(p)
 
     t0 = time.time()
     exst.get_forces(H2)
     parprint("time used:", time.time() - t0)
 
 
+@pytest.mark.lrtddft
 def test_io(in_tmp_dir):
     """Test output and input from files"""
     calc = GPAW(xc='PBE', h=0.25, nbands=3, txt=None)
     exlst = LrTDDFT(calc, txt=None)
     exst = ExcitedState(exlst, 0, txt=None)
     H2 = get_H2(exst)
 
@@ -146,14 +149,15 @@
 
     parprint('----------- read trajectory')
     atoms = io.read(ftraj)
     assert atoms.get_potential_energy() == pytest.approx(E1, 1.e-5)
     assert atoms.get_forces() == pytest.approx(F, 1.e-5)
 
 
+@pytest.mark.lrtddft
 def test_log(in_tmp_dir):
     fname = 'ex0_silent.out'
     calc = GPAW(xc='PBE', h=0.25, nbands=5, txt=None)
     calc.calculate(get_H2(calc))
     exlst = LrTDDFT(calc, restrict={'eps': 0.4, 'jend': 3}, txt=None)
     exst = ExcitedState(exlst, 0, txt=fname)
     del calc
@@ -190,14 +194,15 @@
                 # one eq + 3 * 2 displacements + one eq. = 8 calculations
                 n = 8
             assert string.count('Converged after') == n
             assert string.count('Kohn-Sham single transitions') == n
             assert string.count('Linear response TDDFT calculation') == n
 
 
+@pytest.mark.lrtddft
 def test_forces():
     """Test whether force calculation works"""
     calc = GPAW(xc='PBE', h=0.25, nbands=3, txt=None)
     exlst = LrTDDFT(calc)
     exst = ExcitedState(exlst, 0)
     H2 = get_H2(exst)
 
@@ -220,14 +225,15 @@
     if world.size > 1:
         parprint('---------------- parallel', world.size)
         exstp = ExcitedState(exlst, 0, parallel=2)
         forcesp = exstp.get_forces(H2)
         assert forcesp == pytest.approx(forces, abs=0.001)
 
 
+@pytest.mark.lrtddft
 def test_unequal_parralel_work():
     """Test whether parallel force calculation works for three atoms"""
     if world.size == 1:
         return
 
     calc = GPAW(xc='PBE', charge=1, h=0.25, nbands=3, txt=None)
     exlst = LrTDDFT(calc, txt=None)
```

### Comparing `gpaw-22.8.0/gpaw/test/lrtddft/test_kssingles.py` & `gpaw-23.6.0/gpaw/test/lrtddft/test_kssingles.py`

 * *Files 10% similar despite different names*

```diff
@@ -3,14 +3,15 @@
 from ase.build import molecule
 
 from gpaw.mpi import world
 from gpaw import GPAW
 from gpaw.lrtddft.kssingle import KSSingles
 
 
+@pytest.mark.lrtddft
 def test_old_io(in_tmp_dir):
     """Test reading of old style output files"""
     fname = 'veryold.dat'
     if world.rank == 0:
         with open(fname, 'w') as f:
             f.write("""# KSSingles
 2
@@ -43,26 +44,27 @@
     ch4 = molecule('CH4')
     ch4.center(vacuum=2)
     ch4.calc = GPAW(h=0.25, nbands=8, txt=None)
     ch4.get_potential_energy()
     return ch4
 
 
+@pytest.mark.lrtddft
 def test_io(in_tmp_dir, ch4):
     # full KSSingles
     kssfull = KSSingles(restrict={'eps': 0.9})
     kssfull.calculate(ch4)
     fullname = 'kssfull.dat'
     kssfull.write(fullname)
     world.barrier()
 
     # read full
     kss1 = KSSingles.read(fullname)
     assert len(kss1) == 16
-    
+
     # restricted KSSingles
     istart, jend = 1, 4
     kss = KSSingles(restrict={'eps': 0.9, 'istart': istart, 'jend': jend})
     kss.calculate(ch4)
     f14name = 'kss_1_4.dat'
     kss.write(f14name)
     world.barrier()
@@ -76,14 +78,15 @@
     kss3 = KSSingles.read(fullname,
                           restrict={'istart': istart, 'jend': jend})
     assert len(kss3) == len(kss)
     assert kss3.restrict['istart'] == istart
     assert kss3.restrict['jend'] == jend
 
 
+@pytest.mark.lrtddft
 def test_mul(ch4):
     """Test multiplication with a number"""
     istart, jend = 1, 4
     kss = KSSingles(restrict={'eps': 0.9, 'istart': istart, 'jend': jend})
     kss.calculate(ch4)
 
     ks0 = kss[0]
```

### Comparing `gpaw-22.8.0/gpaw/test/lrtddft/test_kssingles_Be.py` & `gpaw-23.6.0/gpaw/test/lrtddft/test_kssingles_Be.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,19 +1,21 @@
+import pytest
 import numpy as np
 
 from ase import Atoms
 from ase.parallel import parprint
 from ase.units import Hartree
 
 import gpaw.mpi as mpi
 from gpaw import GPAW
 from gpaw.test import equal
 from gpaw.lrtddft.kssingle import KSSingles
 
 
+@pytest.mark.lrtddft
 def test_lrtddft_kssingles_Be(in_tmp_dir):
     Be = Atoms('Be')
     Be.center(vacuum=4)
     if 1:
         # introduce a sligth non-orthgonality
         cell = Be.get_cell()
         cell[1] += 0.001 * cell[0]
```

### Comparing `gpaw-22.8.0/gpaw/test/lrtddft/test_lrtddft2.py` & `gpaw-23.6.0/gpaw/test/lrtddft/test_lrtddft2.py`

 * *Files 6% similar despite different names*

```diff
@@ -35,15 +35,15 @@
                           'eigenstates': 1e-4,
                           'bands': jend},
                       txt=None)
     atoms.get_potential_energy()
     return atoms
 
 
-@pytest.mark.skip_for_new_gpaw
+@pytest.mark.later
 def test_lrtddft2(C3H6O, in_tmp_dir):
     """Test equivalence"""
     atoms = C3H6O
 
     istart = 10  # HOMO-1
 
     evs = atoms.calc.get_eigenvalues() / Ha
```

### Comparing `gpaw-22.8.0/gpaw/test/lrtddft/test_lrtddft_basics.py` & `gpaw-23.6.0/gpaw/test/lrtddft/test_lrtddft_basics.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,7 +1,8 @@
+import pytest
 from ase import Atom, Atoms
 
 from gpaw import GPAW
 from gpaw.lrtddft import LrTDDFT
 from gpaw.mpi import world
 
 
@@ -9,28 +10,29 @@
     """Define H2 and set calculator if given"""
     R = 0.7  # approx. experimental bond length
     a = 3.0
     c = 4.0
     H2 = Atoms([Atom('H', (a / 2, a / 2, (c - R) / 2)),
                 Atom('H', (a / 2, a / 2, (c + R) / 2))],
                cell=(a, a, c))
-    
+
     if calculator is not None:
         H2.calc = calculator
 
     return H2
 
 
+@pytest.mark.lrtddft
 def test_io(in_tmp_dir):
     calc = GPAW(xc='PBE', h=0.25, nbands=5, txt=None)
     calc.calculate(get_H2(calc))
     exlst = LrTDDFT(calc, restrict={'eps': 0.4, 'jend': 3})
     assert len(exlst) == 3
     assert exlst.kss.restrict['eps'] == 0.4
-    
+
     fname = 'lr.dat.gz'
     exlst.write(fname)
     world.barrier()
 
     lr2 = LrTDDFT.read(fname)
     assert len(lr2) == 3
 
@@ -39,14 +41,15 @@
     assert len(lr3.kss) == 2
     assert len(lr3.Om.fullkss) == 3
 
     lr4 = LrTDDFT.read(fname, restrict={'energy_range': 20})
     assert len(lr4) == 1
 
 
+@pytest.mark.lrtddft
 def test_invocation():
     calc = GPAW(xc='PBE', h=0.25, nbands=5, txt=None)
     H2 = get_H2(calc)
     exlst = LrTDDFT(restrict={'eps': 0.4, 'jend': 3}, txt=None)
     exlst.calculate(H2)
     assert exlst.xc is not None
     assert hasattr(exlst, 'Om')
```

### Comparing `gpaw-22.8.0/gpaw/test/lrtddft/test_lrtddft_log.py` & `gpaw-23.6.0/gpaw/test/lrtddft/test_lrtddft_log.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,7 +1,8 @@
+import pytest
 from ase import Atom, Atoms
 from ase.parallel import world
 
 from gpaw import GPAW
 from gpaw.lrtddft import LrTDDFT
 
 
@@ -26,14 +27,15 @@
     calc.calculate(get_H2(calc))
     exlst = LrTDDFT(calc, restrict={'eps': 0.4, 'jend': 3}, txt=txt)
     del calc
     del exlst
     world.barrier()
 
 
+@pytest.mark.lrtddft
 def test_log(in_tmp_dir):
     defname = 'gpawlog.txt'
     # LrTDDFT outputs to the same log like gpaw
     run_and_delete(txt=defname)
     with open(defname) as f:
         string = f.read()
         assert 'Kohn-Sham single transitions' in string
```

### Comparing `gpaw-22.8.0/gpaw/test/lrtddft/test_pes.py` & `gpaw-23.6.0/gpaw/test/lrtddft/test_pes.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,18 +1,20 @@
+import pytest
 from ase import Atom, Atoms
 from ase.parallel import parprint
 
 from gpaw import GPAW, mpi
 from gpaw.test import equal
 from gpaw.lrtddft import LrTDDFT
 from gpaw.poisson import FDPoissonSolver
 from gpaw.pes.dos import DOSPES
 from gpaw.pes.tddft import TDDFTPES
 
 
+@pytest.mark.lrtddft
 def test_lrtddft_pes(in_tmp_dir):
     txt = None
     R = 0.7  # approx. experimental bond length
     a = 3.0
     c = 3.0
     H2 = Atoms([Atom('H', (a / 2, a / 2, (c - R) / 2)),
                 Atom('H', (a / 2, a / 2, (c + R) / 2))],
@@ -30,15 +32,15 @@
     H2.calc = calc
     e_H2 = H2.get_potential_energy()
 
     calc_plus = GPAW(gpts=(12, 12, 12), xc=xc, nbands=2,
                      poissonsolver=FDPoissonSolver(),
                      parallel={'domain': mpi.world.size},
                      spinpol=True, txt=txt)
-    calc_plus.set(charge=+1)
+    calc_plus = calc_plus.new(charge=+1)
     H2_plus.calc = calc_plus
     e_H2_plus = H2_plus.get_potential_energy()
 
     out = 'dospes.dat'
     pes = DOSPES(calc, calc_plus, shift=True)
     pes.save_folded_pes(filename=out, folding=None)
     parprint('DOS:')
```

### Comparing `gpaw-22.8.0/gpaw/test/lrtddft/test_placzek_profeta_albrecht.py` & `gpaw-23.6.0/gpaw/test/lrtddft/test_placzek_profeta_albrecht.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,7 +1,8 @@
+import pytest
 from ase import Atom, Atoms
 
 from gpaw import GPAW
 from gpaw.analyse.overlap import Overlap
 from gpaw.lrtddft.kssingle import KSSingles
 from gpaw.test import equal
 
@@ -14,14 +15,15 @@
 # run
 
 R = 0.7  # approx. experimental bond length
 a = 4.0
 c = 5.0
 
 
+@pytest.mark.lrtddft
 def test_lrtddft_placzek_profeta_albrecht(in_tmp_dir):
     from ase.vibrations.albrecht import Albrecht
     from ase.vibrations.placzek import Placzek, Profeta
     from ase.vibrations.resonant_raman import ResonantRamanCalculator
 
     H2 = Atoms([Atom('H', (a / 2, a / 2, (c - R) / 2)),
                 Atom('H', (a / 2, a / 2, (c + R) / 2))],
```

### Comparing `gpaw-22.8.0/gpaw/test/lrtddft/test_rraman.py` & `gpaw-23.6.0/gpaw/test/lrtddft/test_rraman.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,14 +1,16 @@
+import pytest
 from ase.build import molecule
 
 from gpaw import GPAW, FermiDirac
 from gpaw.cluster import Cluster
 from gpaw.lrtddft import LrTDDFT
 
 
+@pytest.mark.lrtddft
 def test_lrtddft(in_tmp_dir):
     from ase.vibrations.resonant_raman import ResonantRamanCalculator
     h = 0.25
     H2 = Cluster(molecule('H2'))
     H2.minimal_box(3., h=h)
     H2.calc = GPAW(h=h, occupations=FermiDirac(width=0.2),
                    symmetry='off')
```

### Comparing `gpaw-22.8.0/gpaw/test/lrtddft/test_select.py` & `gpaw-23.6.0/gpaw/test/lrtddft/test_select.py`

 * *Files 25% similar despite different names*

```diff
@@ -1,13 +1,14 @@
+import pytest
 from ase import Atoms
-
 from gpaw import GPAW, FermiDirac
 from gpaw.lrtddft import LrTDDFT
 
 
+@pytest.mark.lrtddft
 def test_digonalize():
     """Test selection at diagonalization stage"""
     atoms = Atoms('O')
     atoms.cell = [3, 4, 5]
     atoms.center()
 
     atoms.calc = GPAW(occupations=FermiDirac(width=0.1),
```

### Comparing `gpaw-22.8.0/gpaw/test/lrtddft2/test_Al2.py` & `gpaw-23.6.0/gpaw/test/lrtddft2/test_Al2.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,15 +1,17 @@
+import pytest
 from gpaw import GPAW, FermiDirac
 from gpaw.mpi import world, size, rank
 from gpaw.lrtddft2 import LrTDDFT2
 from gpaw.lrtddft2.lr_communicators import LrCommunicators
 from gpaw.test import equal
 from ase.atoms import Atoms
 
 
+@pytest.mark.lrtddft
 def test_lrtddft2_Al2(in_tmp_dir):
     debug = False
     restart_file = 'Al2_gs.gpw'
 
     d = 2.563
     atoms = Atoms('Al2', positions=((0, 0, 0),
                                     (0, 0, d)))
```

### Comparing `gpaw-22.8.0/gpaw/test/lrtddft2/test_H2O-lcao.py` & `gpaw-23.6.0/gpaw/test/lrtddft2/test_H2O-lcao.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,16 +1,18 @@
+import pytest
 import numpy as np
 
 from ase.build import molecule
 
 from gpaw import GPAW
 from gpaw.lrtddft2 import LrTDDFT2
 from gpaw.test import equal
 
 
+@pytest.mark.lrtddft
 def test_lrtddft2_H2O_lcao(in_tmp_dir):
     name = 'H2O-lcao'
     atoms = molecule('H2O')
     atoms.center(vacuum=4)
 
     # Ground state
     calc = GPAW(h=0.4, mode='lcao', basis='dzp', txt='%s-gs.out' % name,
```

### Comparing `gpaw-22.8.0/gpaw/test/maths/test_fftw.py` & `gpaw-23.6.0/gpaw/test/maths/test_fftw.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/maths/test_fsbt.py` & `gpaw-23.6.0/gpaw/test/maths/test_fsbt.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 import numpy as np
 
-from gpaw.atom.radialgd import fsbt, RadialGridDescriptor as RGD
+from gpaw.atom.radialgd import fsbt, EquidistantRadialGridDescriptor as RGD
 
 
 def test_maths_fsbt():
     N = 1024
     L = 50.0
     h = L / N
     alpha = 5.0
@@ -16,16 +16,16 @@
         f = fsbt(l, n * r**l, r, G)
         f0 = (np.pi**0.5 / alpha**(l + 1.5) / 2**l * G**l / 4 *
               np.exp(-G**2 / (4 * alpha)))
         tol = 3e-6 * 10**(-7 + l)
         print(l, abs(f - f0).max(), 'tol=', tol)
         assert abs(f - f0).max() < tol
 
-    rgd = RGD(r, r * 0 + r[1])
+    rgd = RGD(r[1], len(r))
     g, f = rgd.fft(n * r)
     f0 = 4 * np.pi**1.5 / alpha**1.5 / 4 * np.exp(-g**2 / 4 / alpha)
     assert abs(f - f0).max() < 1e-6
 
     # This is how to do the inverse FFT:
-    ggd = RGD(g, g * 0 + g[1])
+    ggd = RGD(g[1], len(g))
     r, f = ggd.fft(f * g)
     assert abs(np.exp(-alpha * r**2) - f / 8 / np.pi**3).max() < 2e-3
```

### Comparing `gpaw-22.8.0/gpaw/test/mgga/test_mgga_restart.py` & `gpaw-23.6.0/gpaw/test/mgga/test_mgga_restart.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/mgga/test_mgga_sc.py` & `gpaw-23.6.0/gpaw/test/mgga/test_mgga_sc.py`

 * *Files 18% similar despite different names*

```diff
@@ -13,12 +13,12 @@
         return dict(eigensolver=Davidson(4), mixer=MixerSum(0.5, 5, 10.0))
 
     n.calc = GPAW(xc='TPSS', **getkwargs())
     e1 = n.get_potential_energy()
 
     n.calc = GPAW(xc='PBE', **getkwargs())
     n.get_potential_energy()
-    n.calc.set(xc='TPSS')
+    n.calc = n.calc.new(xc='TPSS')
     e2 = n.get_potential_energy()
     err = abs(e2 - e1)
     print('Energy difference', err)
     assert err < 3e-5, err
```

### Comparing `gpaw-22.8.0/gpaw/test/mgga/test_nsc_MGGA.py` & `gpaw-23.6.0/gpaw/test/mgga/test_nsc_MGGA.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/mom/test_mom_fd_energy.py` & `gpaw-23.6.0/gpaw/test/mom/test_mom_fd_energy.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/mom/test_mom_lcao_forces.py` & `gpaw-23.6.0/gpaw/test/mom/test_mom_lcao_forces.py`

 * *Files 0% similar despite different names*

```diff
@@ -51,9 +51,9 @@
 
         E.append(atoms.get_potential_energy())
 
     f = np.sqrt(((F[1, :] - F[0, :])**2).sum()) * 0.5
     fnum = (E[0] - E[1]) / (2. * delta)  # central difference
 
     print(fnum)
-    assert fnum == pytest.approx(11.52, abs=0.015)
+    assert fnum == pytest.approx(11.52, abs=0.016)
     assert f == pytest.approx(fnum, abs=0.1)
```

### Comparing `gpaw-22.8.0/gpaw/test/mom/test_mom_lcao_smearing.py` & `gpaw-23.6.0/gpaw/test/mom/test_mom_lcao_smearing.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/noncollinear/o2_test.py` & `gpaw-23.6.0/gpaw/test/noncollinear/test_o2.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,13 +1,17 @@
 from unittest import SkipTest
+
+import pytest
 from ase import Atoms
+
 from gpaw import GPAW
 from gpaw.mpi import size
 
 
+@pytest.mark.later
 def test_noncollinear_o2(in_tmp_dir):
     if size > 2:
         raise SkipTest()
 
     a = Atoms('OO', [[0, 0, 0], [0, 0, 1.1]], magmoms=[1, 1], pbc=(1, 0, 0))
     a.center(vacuum=2.5)
     a.calc = GPAW(mode='pw',
```

### Comparing `gpaw-22.8.0/gpaw/test/noncollinear/rad_pot_test.py` & `gpaw-23.6.0/gpaw/test/noncollinear/test_rad_pot.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,12 +1,12 @@
 import pytest
 
 from gpaw.new.density import atomic_occupation_numbers
 from gpaw.setup import create_setup
-from gpaw.spinorbit import soc
+from gpaw.spinorbit import soc, projected_soc
 from gpaw.xc import XC
 
 
 def test_rad_pot():
     xc = XC('LDA', collinear=False)
     setup = create_setup('Cr', xc=xc)
     mz = 1.0
@@ -14,7 +14,21 @@
     print(f_si)
     D_sp = setup.initialize_density_matrix(f_si)
     dv_vii = soc(setup, xc, D_sp)
     # Reversing magmom should give same potential
     D_sp[3] *= -1
     dv_vii -= soc(setup, xc, D_sp)
     assert abs(dv_vii).max() == pytest.approx(0.0, abs=1e-12)
+
+
+def test_proj_soc():
+    xc = XC('LDA', collinear=False)
+    setup = create_setup('Cr', xc=xc)
+    mz = 1.0
+    f_si = atomic_occupation_numbers(setup, [0, 0, mz], 4)
+    D_sp = setup.initialize_density_matrix(f_si)
+    dv_vii = projected_soc(soc(setup, xc, D_sp),
+                           theta=0, phi=0)
+    # Reversing normal plane direction should give same potential
+    dv_vii -= projected_soc(soc(setup, xc, D_sp),
+                            theta=180, phi=0)
+    assert abs(dv_vii).max() == pytest.approx(0.0, abs=1e-12)
```

### Comparing `gpaw-22.8.0/gpaw/test/noncollinear/soc_test.py` & `gpaw-23.6.0/gpaw/test/noncollinear/test_soc.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/ofdft/test_ofdft.py` & `gpaw-23.6.0/gpaw/test/ofdft/test_ofdft.py`

 * *Files 8% similar despite different names*

```diff
@@ -2,14 +2,15 @@
 from ase import Atoms
 from gpaw import GPAW
 from gpaw.mixer import Mixer
 from gpaw.test import equal
 from gpaw.test import gen
 
 
+@pytest.mark.ofdft
 @pytest.mark.libxc
 def test_ofdft_ofdft(in_tmp_dir):
     a = 6.0
     c = a / 2
     # d = 1.8
 
     elements = ['C', 'Be']
```

### Comparing `gpaw-22.8.0/gpaw/test/ofdft/test_ofdft_pbc.py` & `gpaw-23.6.0/gpaw/test/ofdft/test_ofdft_pbc.py`

 * *Files 2% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 from ase.build import bulk
 from gpaw import GPAW
 from gpaw.mixer import Mixer
 from gpaw.test import equal
 from gpaw.test import gen
 
 
-@pytest.mark.skip_for_new_gpaw
+@pytest.mark.ofdft
 @pytest.mark.libxc
 def test_ofdft_ofdft_pbc(in_tmp_dir):
     symbol = 'C'
     result = -224.206
     electrons = 48
 
     xcname = 'LDA_K_TF+LDA_X'
```

### Comparing `gpaw-22.8.0/gpaw/test/ofdft/test_ofdft_scale.py` & `gpaw-23.6.0/gpaw/test/ofdft/test_ofdft_scale.py`

 * *Files 8% similar despite different names*

```diff
@@ -3,14 +3,15 @@
 from gpaw import GPAW
 from gpaw.mixer import Mixer
 from gpaw.test import equal
 from gpaw.test import gen
 from gpaw.eigensolvers import CG
 
 
+@pytest.mark.ofdft
 @pytest.mark.libxc
 def test_ofdft_ofdft_scale(in_tmp_dir):
     h = 0.18
     a = 10.0
     c = a / 2
 
     elements = ['C']
```

### Comparing `gpaw-22.8.0/gpaw/test/parallel/scalapack_pdlasrt_hang.py` & `gpaw-23.6.0/gpaw/test/parallel/scalapack_pdlasrt_hang.py`

 * *Files 7% similar despite different names*

```diff
@@ -13,20 +13,23 @@
 def test_scalapack_pdlasrt_hang():
     assert world.size == 4
 
     slab = fcc100('Cu', size=(2, 2, 2))
     add_adsorbate(slab, 'O', 1.1, 'hollow')
     slab.center(vacuum=3.0, axis=2)
 
+    if compiled_with_sl():
+        parallel = {'domain': (1, 1, 4), 'sl_default': (2, 2, 64)}
+    else:
+        parallel = None
+
     calc = GPAW(mode='lcao',
                 kpts=(2, 2, 1),
                 txt='-',
-                maxiter=1,)
-
-    if compiled_with_sl():
-        calc.set(parallel={'domain': (1, 1, 4), 'sl_default': (2, 2, 64)})
+                maxiter=1,
+                parallel=parallel)
 
     slab.calc = calc
     try:
         slab.get_potential_energy()
     except ConvergenceError:
         pass
```

### Comparing `gpaw-22.8.0/gpaw/test/parallel/test_arraydict_redist.py` & `gpaw-23.6.0/gpaw/test/parallel/test_arraydict_redist.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/parallel/test_augment_grid.py` & `gpaw-23.6.0/gpaw/test/parallel/test_augment_grid.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,13 +1,15 @@
+import pytest
 import numpy as np
 from gpaw import GPAW
 from ase.build import molecule
 from gpaw.mpi import world
 
 
+@pytest.mark.later
 def test_parallel_augment_grid(in_tmp_dir):
     system = molecule('H2O')
     system.cell = (4, 4, 4)
     system.pbc = 1
 
     for mode in ['fd',
                  'pw',
@@ -32,20 +34,19 @@
                         gpts=(20, 20, 20),
                         txt='gpaw.%s.%d.txt' % (mode, int(augment_grids)),
                         eigensolver=eigensolver,
                         parallel=dict(augment_grids=augment_grids,
                                       band=band, domain=domain),
                         basis='szp(dzp)',
                         kpts=[1, 1, 4],
-                        nbands=8)
-
-            def stopcalc():
-                calc.scf.converged = True
-            # Iterate enough for density to update so it depends on potential
-            calc.attach(stopcalc, 3 if mode == 'lcao' else 5)
+                        nbands=8,
+                        # Iterate enough for density to update so it depends
+                        # on potential
+                        convergence={'maximum iterations':
+                                     3 if mode == 'lcao' else 5})
             system.calc = calc
             energy.append(system.get_potential_energy())
             force.append(system.get_forces())
             if mode == 'pw':
                 stress.append(system.get_stress())
         ferr = np.abs(force[1] - force[0]).max()
         eerr = abs(energy[1] - energy[0])
```

### Comparing `gpaw-22.8.0/gpaw/test/parallel/test_blacsdist.py` & `gpaw-23.6.0/gpaw/test/parallel/test_blacsdist.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/parallel/test_diamond_gllb.py` & `gpaw-23.6.0/gpaw/test/parallel/test_diamond_gllb.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/parallel/test_fd_parallel.py` & `gpaw-23.6.0/gpaw/test/parallel/test_fd_parallel.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/parallel/test_fd_parallel_kpt.py` & `gpaw-23.6.0/gpaw/test/parallel/test_fd_parallel_kpt.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/parallel/test_kptpar.py` & `gpaw-23.6.0/gpaw/test/parallel/test_kptpar.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/parallel/test_parallel_eigh.py` & `gpaw-23.6.0/gpaw/test/parallel/test_parallel_eigh.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/parallel/test_pblas.py` & `gpaw-23.6.0/gpaw/test/parallel/test_pblas.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/parallel/test_scalapack.py` & `gpaw-23.6.0/gpaw/test/parallel/test_scalapack.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/parallel/test_scalapack_diag_simple.py` & `gpaw-23.6.0/gpaw/test/parallel/test_scalapack_diag_simple.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/parallel/test_scalapack_mpirecv_crash.py` & `gpaw-23.6.0/gpaw/test/parallel/test_scalapack_mpirecv_crash.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/parallel/test_submatrix_redist.py` & `gpaw-23.6.0/gpaw/test/parallel/test_submatrix_redist.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/pathological/test_lcao_spos_derivative.py` & `gpaw-23.6.0/gpaw/test/pathological/test_lcao_spos_derivative.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,12 +1,15 @@
 import numpy as np
+import pytest
 from ase.build import bulk
+
 from gpaw import GPAW, FermiDirac, Mixer
 
 
+@pytest.mark.later
 def test_pathological_lcao_spos_derivative(in_tmp_dir):
     atoms = bulk('Si', 'diamond', a=5.4834322363595565)
     atoms *= (3, 3, 3)
     atoms.calc = GPAW(
         gpts=(32, 32, 32),
         mixer=Mixer(0.5, 5, 50.0),
         txt='grumble.txt',
```

### Comparing `gpaw-22.8.0/gpaw/test/pathological/test_nonlocalset.py` & `gpaw-23.6.0/gpaw/test/pathological/test_nonlocalset.py`

 * *Files 10% similar despite different names*

```diff
@@ -13,18 +13,19 @@
 import pytest
 from ase import Atoms
 from gpaw import GPAW, Mixer
 from gpaw.test import equal
 
 
 @pytest.mark.libxc
+@pytest.mark.legacy
 def test_pathological_nonlocalset():
     atoms = Atoms('HF', positions=[(0.0, 0.0, 0.0), (1.0, 0.0, 0.0)])
     atoms.set_pbc((True, True, True))
-    atoms.set_cell((2.0, 2.0, 2.0))
+    atoms.set_cell((2.01, 2.01, 2.01))  # make sure we get 12 gpts and not 8
 
     def MGGA_fail():
         calc = GPAW(xc='TPSS',
                     mixer=Mixer(0.5, 5, 50.0),
                     eigensolver='cg',
                     kpts=(1, 2, 1),
                     convergence={'density': 1e-8})
```

### Comparing `gpaw-22.8.0/gpaw/test/poisson/test_fastpoisson.py` & `gpaw-23.6.0/gpaw/test/poisson/test_fastpoisson.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/poisson/test_generalizedlaue.py` & `gpaw-23.6.0/gpaw/test/poisson/test_generalizedlaue.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/poisson/test_metallic_poisson.py` & `gpaw-23.6.0/gpaw/test/poisson/test_metallic_poisson.py`

 * *Files 6% similar despite different names*

```diff
@@ -18,20 +18,18 @@
                          'energy': 1e-1,
                          'eigenstates': 1e-1},
             kpts=(2, 2, 1),
             poissonsolver=PoissonSolver(metallic_electrodes=electrode))
 
         _ = slab.get_potential_energy()
         phi0 = slab.calc.get_electrostatic_potential()
-        if electrode == 'single':
-            assert np.all(abs(phi0[:, :, 0]) < 1e-10)
-        else:
+        assert np.all(abs(phi0[:, :, 0]) < 1e-10)
+        if electrode == 'both':
             print(phi0[:, :, 0])
             print(phi0[:, :, 1])
-            assert np.all(abs(phi0[:, :, 0]) < 1e-10)
             # The last zero boundary condition is implicit, so extrapolate
             d = phi0[:, :, -1] - phi0[:, :, -2]
             assert np.all(abs(phi0[:, :, -1] + d) < 1e-5)
 
         slab.calc.write('%s.gpw' % electrode)
 
         atoms, calc = restart('%s.gpw' % electrode, txt='restart.txt')
```

### Comparing `gpaw-22.8.0/gpaw/test/poisson/test_poisson.py` & `gpaw-23.6.0/gpaw/test/poisson/test_poisson.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/poisson/test_poisson_asym.py` & `gpaw-23.6.0/gpaw/test/poisson/test_poisson_asym.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/poisson/test_poisson_extravacuum.py` & `gpaw-23.6.0/gpaw/test/poisson/test_poisson_extravacuum.py`

 * *Files 1% similar despite different names*

```diff
@@ -102,15 +102,15 @@
     poisson = PoissonSolver('fd', eps=poissoneps)
     phiref_g, npoisson = poisson_init_solve(gd, rho_g, poisson)
 
     # Test agreement with default
     poisson = ExtraVacuumPoissonSolver(
         N_c, PoissonSolver('fd', eps=poissoneps))
     phi_g, npoisson = poisson_init_solve(gd, rho_g, poisson)
-    compare(phi_g, phiref_g, 0.0, 1e-24)
+    compare(phi_g, phiref_g, 0.0, 1e-15)
 
     # New reference with extra vacuum
     gpts = N_c * 4
     poisson = ExtraVacuumPoissonSolver(
         gpts, PoissonSolver('fd', eps=poissoneps))
     phi_g, npoisson = poisson_init_solve(gd, rho_g, poisson)
     # print poisson.get_description()
```

### Comparing `gpaw-22.8.0/gpaw/test/poisson/test_poisson_moment.py` & `gpaw-23.6.0/gpaw/test/poisson/test_poisson_moment.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/poisson/test_poisson_restart.py` & `gpaw-23.6.0/gpaw/test/poisson/test_poisson_restart.py`

 * *Files 1% similar despite different names*

```diff
@@ -10,14 +10,15 @@
 from gpaw.poisson_moment import MomentCorrectionPoissonSolver
 from gpaw.poisson_extravacuum import ExtraVacuumPoissonSolver
 
 pytestmark = pytest.mark.skipif(world.size > 2,
                                 reason='world.size > 2')
 
 
+@pytest.mark.later
 def test_poisson_poisson_restart(in_tmp_dir):
     name = 'Na2'
     gpts = np.array([16, 16, 24])
     # Uncomment the following line if you want to run the test with 4 cpus
     # gpts *= 2
 
     poissonsolver_i = []
```

### Comparing `gpaw-22.8.0/gpaw/test/poisson/test_pw_charged.py` & `gpaw-23.6.0/gpaw/test/poisson/test_pw_charged.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/poisson/test_screened_poisson.py` & `gpaw-23.6.0/gpaw/test/poisson/test_screened_poisson.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/pseudopotential/H_pz_hgh.py` & `gpaw-23.6.0/gpaw/test/pseudopotential/H_pz_hgh.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/pseudopotential/H_sg15.py` & `gpaw-23.6.0/gpaw/test/pseudopotential/H_sg15.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/pseudopotential/O_pz_hgh.py` & `gpaw-23.6.0/gpaw/test/pseudopotential/O_pz_hgh.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/pseudopotential/test_atompaw.py` & `gpaw-23.6.0/gpaw/test/pseudopotential/test_atompaw.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/pseudopotential/test_hgh_h2o.py` & `gpaw-23.6.0/gpaw/test/pseudopotential/test_hgh_h2o.py`

 * *Files 5% similar despite different names*

```diff
@@ -71,15 +71,20 @@
         print()
         err = np.abs(F_ac - F_ac_fd).max()
         print('max err', err)
 
     wfs = calc.wfs
     gd = wfs.gd
     psit_nG = wfs.kpt_u[0].psit_nG
-    dH_asp = calc.hamiltonian.dH_asp
+    try:
+        dH_asp = calc.hamiltonian.dH_asp
+    except AttributeError:
+        from gpaw.utilities import pack2
+        dH_asii = calc.calculation.state.potential.dH_asii
+        dH_asp = {a: pack2(dH_sii) for a, dH_sii in dH_asii.items()}
 
     assert eerr < 1e-3, 'energy changed from reference'
     assert ferr < 0.015, 'forces do not match FD check'
 
     # Sanity check.  In HGH, the atomic Hamiltonian is constant.
     # Also the projectors should be normalized
     for a, dH_sp in dH_asp.items():
```

### Comparing `gpaw-22.8.0/gpaw/test/pw/test_augment_grids.py` & `gpaw-23.6.0/gpaw/test/pw/test_augment_grids.py`

 * *Files 23% similar despite different names*

```diff
@@ -1,40 +1,54 @@
+import os
+
 import numpy as np
+import pytest
 from ase import Atoms
-from gpaw import GPAW, PW, FermiDirac
+
+from gpaw import PW, FermiDirac
+from gpaw.calculator import GPAW
+from gpaw.new.calculation import DFTCalculation
 
 
+@pytest.mark.stress
 def test_pw_augment_grids(in_tmp_dir):
     ecut = 200
     kpoints = [1, 1, 4]
     atoms = Atoms('HLi', cell=[6, 6, 3.4], pbc=True,
                   positions=[[3, 3, 0], [3, 3, 1.6]])
 
-    for xc in ['LDA', 'PBE']:
-        def calculate(aug):
+    def calculate(aug):
+        if os.environ.get('GPAW_NEW'):
+            dft = DFTCalculation.from_parameters(
+                atoms,
+                dict(mode=PW(ecut),
+                     txt=f'gpaw.aug{aug}.txt',
+                     parallel={'augment_grids': aug},
+                     kpts={'size': kpoints},
+                     occupations=FermiDirac(width=0.1)))
+            dft.converge(steps=4)
+            e = dft.energies()
+            f = dft.forces()
+            s = dft.stress()
+        else:
             atoms.calc = GPAW(mode=PW(ecut),
-                              xc=xc,
-                              txt='gpaw.{}.aug{}.txt'.format(xc, aug),
+                              txt=f'gpaw.aug{aug}.txt',
                               parallel={'augment_grids': aug},
                               kpts={'size': kpoints},
-                              occupations=FermiDirac(width=0.1))
-
-            def stopcalc():
-                atoms.calc.scf.converged = True
-            atoms.calc.attach(stopcalc, 4)
-
+                              occupations=FermiDirac(width=0.1),
+                              convergence={'maximum iterations': 4})
             e = atoms.get_potential_energy()
             f = atoms.get_forces()
             s = atoms.get_stress()
-            return e, f, s
+        return e, f, s
 
-        e1, f1, s1 = calculate(False)
-        e2, f2, s2 = calculate(True)
+    e1, f1, s1 = calculate(False)
+    e2, f2, s2 = calculate(True)
 
-        eerr = abs(e2 - e1)
-        ferr = np.abs(f2 - f1).max()
-        serr = np.abs(s2 - s1).max()
-        if atoms.calc.wfs.world.rank == 0:
-            print('errs', eerr, ferr, serr)
-        assert eerr < 5e-12, 'bad {} energy: err={}'.format(xc, eerr)
-        assert ferr < 5e-12, 'bad {} forces: err={}'.format(xc, ferr)
-        assert serr < 5e-12, 'bad {} stress: err={}'.format(xc, serr)
+    eerr = abs(e2 - e1)
+    ferr = np.abs(f2 - f1).max()
+    serr = np.abs(s2 - s1).max()
+    if atoms.calc.wfs.world.rank == 0:
+        print('errs', eerr, ferr, serr)
+    assert eerr < 5e-12, f'bad energy: err={eerr}'
+    assert ferr < 5e-12, f'bad forces: err={ferr}'
+    assert serr < 5e-12, f'bad stress: err={serr}'
```

### Comparing `gpaw-22.8.0/gpaw/test/pw/test_bulk.py` & `gpaw-23.6.0/gpaw/test/pw/test_bulk.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/pw/test_davidson_pw.py` & `gpaw-23.6.0/gpaw/test/pw/test_davidson_pw.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/pw/test_direct.py` & `gpaw-23.6.0/gpaw/test/pw/test_direct.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/pw/test_expert_diag.py` & `gpaw-23.6.0/gpaw/test/pw/test_expert_diag.py`

 * *Files 4% similar despite different names*

```diff
@@ -6,14 +6,15 @@
 from gpaw.mpi import world
 
 # This test is asserting that the expert diagonalization
 # routine gives the same result as the non-expert version
 # in terms of eigenvalues and wavefunctions
 
 
+@pytest.mark.later
 def test_pw_expert_diag(in_tmp_dir, scalapack):
     wfs_e = []
     for i, expert in enumerate([True, False]):
         si = bulk('Si')
         name = 'si_{0:d}'.format(i)
         si.center()
         calc = GPAW(mode=PW(120), kpts=(1, 1, 2),
```

### Comparing `gpaw-22.8.0/gpaw/test/pw/test_fulldiag.py` & `gpaw-23.6.0/gpaw/test/pw/test_fulldiag.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/pw/test_fulldiagk.py` & `gpaw-23.6.0/gpaw/test/pw/test_fulldiagk.py`

 * *Files 25% similar despite different names*

```diff
@@ -1,9 +1,7 @@
-import os
-
 from ase import Atoms
 
 from gpaw import GPAW
 from gpaw.mpi import serial_comm, world
 
 
 def test_pw_fulldiagk(in_tmp_dir, scalapack):
@@ -53,17 +51,14 @@
 
     for e in [e2, e3, e4]:
         err = abs(e[0] - e1[0])
         assert err < 2e-9, err
         err = abs(e[-1] - e2[-1])
         assert err < 1e-10, err
 
-    if os.environ.get('GPAW_NEW'):
-        return
-
     a.calc = GPAW(mode='pw',
                   h=0.15,
                   kpts=(4, 1, 1),
                   convergence={'bands': 'CBM+10'},
                   nbands=4)
     a.get_potential_energy()
```

### Comparing `gpaw-22.8.0/gpaw/test/pw/test_h.py` & `gpaw-23.6.0/gpaw/test/pw/test_h.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/pw/test_interpol.py` & `gpaw-23.6.0/gpaw/test/pw/test_interpol.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/pw/test_lfc.py` & `gpaw-23.6.0/gpaw/test/pw/test_lfc.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/pw/test_reallfc.py` & `gpaw-23.6.0/gpaw/test/pw/test_reallfc.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/pw/test_si_stress.py` & `gpaw-23.6.0/gpaw/test/pw/test_si_stress.py`

 * *Files 21% similar despite different names*

```diff
@@ -1,37 +1,37 @@
 import numpy as np
+import pytest
 from ase.build import bulk
+
 from gpaw import GPAW, PW, Mixer
 from gpaw.mpi import world
 
 
+@pytest.mark.stress
 def test_pw_si_stress(in_tmp_dir):
     xc = 'PBE'
     si = bulk('Si')
-    k = 3
-    si.calc = GPAW(mode=PW(250),
+    si.calc = GPAW(mode=PW(200),
                    mixer=Mixer(0.7, 5, 50.0),
                    xc=xc,
-                   kpts=(k, k, k),
+                   kpts=(1, 1, 2),  # Run (1, 1, 2) to avoid gamma pt code
                    convergence={'energy': 1e-8},
                    parallel={'domain': min(2, world.size)},
-                   txt='si.txt')
+                   txt='si_stress.txt')
 
     si.set_cell(np.dot(si.cell,
                        [[1.02, 0, 0.03],
                         [0, 0.99, -0.02],
                         [0.2, -0.01, 1.03]]),
                 scale_atoms=True)
 
     si.get_potential_energy()
 
     # Trigger nasty bug (fixed in !486):
     si.calc.wfs.pt.blocksize = si.calc.wfs.pd.maxmyng - 1
-
+    
+    # Compute error in stress as numerical - analytical
     s_analytical = si.get_stress()
     s_numerical = si.calc.calculate_numerical_stress(si, 1e-5)
     s_err = s_numerical - s_analytical
 
-    print('Analytical stress:\n', s_analytical)
-    print('Numerical stress:\n', s_numerical)
-    print('Error in stress:\n', s_err)
     assert np.all(abs(s_err) < 1e-4)
```

### Comparing `gpaw-22.8.0/gpaw/test/pw/test_stresstest.py` & `gpaw-23.6.0/gpaw/test/pw/test_stresstest.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/radial/test_two_phi_plw_integrals.py` & `gpaw-23.6.0/gpaw/test/radial/test_two_phi_plw_integrals.py`

 * *Files 27% similar despite different names*

```diff
@@ -1,17 +1,18 @@
 import pytest
 
 
-@pytest.mark.skip(reason='TODO')
+@pytest.mark.response
 def test_two_phi_plw_integrals():
     import numpy as np
     from gpaw.lfc import LocalizedFunctionsCollection as LFC
-    from gpaw.grid_descriptor import GridDescriptor, RadialGridDescriptor
+    from gpaw.grid_descriptor import GridDescriptor
+    from gpaw.atom.radialgd import EquidistantRadialGridDescriptor
     from gpaw.spline import Spline
-    from gpaw.response.math_func import two_phi_planewave_integrals
+    from gpaw.response.paw import two_phi_planewave_integrals, Setuplet
     # Initialize s, p, d (9 in total) wave and put them on grid
     rc = 2.0
     a = 2.5 * rc
     n = 64
     lmax = 2
     b = 8.0
     m = (lmax + 1)**2
@@ -29,34 +30,32 @@
 
     # Calculate on 3d-grid < phi_i | e**(-ik.r) | phi_j >
     R_a = np.array([a / 2, a / 2, a / 2])
     rr = gd.get_grid_point_coordinates()
     for dim in range(3):
         rr[dim] -= R_a[dim]
 
-    k_G = np.array([[11., 0.2, 0.1], [10., 0., 10.]])
+    k_G = np.array([[0.0, 0.0, 0.0], [1., 0.2, 0.1], [10., 0., 10.]])
     nkpt = k_G.shape[0]
 
     d0 = np.zeros((nkpt, m, m), dtype=complex)
     for i in range(m):
         for j in range(m):
             for ik in range(nkpt):
                 k = k_G[ik]
                 # kk = np.sqrt(np.inner(k, k))
                 kr = np.inner(k, rr.T).T
                 expkr = np.exp(-1j * kr)
                 d0[ik, i, j] = gd.integrate(psi[i] * psi[j] * expkr)
 
     # Calculate on 1d-grid < phi_i | e**(-ik.r) | phi_j >
-    rgd = RadialGridDescriptor(r, np.ones_like(r) * r[1])
+    rgd = EquidistantRadialGridDescriptor(r[1], len(r))
     g = [np.exp(-(r / rc * b)**2) * r**l for l in range(lmax + 1)]
     l_j = range(lmax + 1)
-    d1 = two_phi_planewave_integrals(k_G, rgd=rgd, phi_jg=g,
-                                     phit_jg=np.zeros_like(g), l_j=l_j)
+    rcut_j = [rc] * (lmax + 1)
+    d1 = two_phi_planewave_integrals(k_G, pawdata=Setuplet(rgd=rgd, phi_jg=g,
+                                     phit_jg=np.zeros_like(g), l_j=l_j,
+                                     rcut_j=rcut_j))
 
     d1 = d1.reshape(nkpt, m, m)
 
-    for i in range(m):
-        for j in range(m):
-            for ik in range(nkpt):
-                if np.abs(d0[ik, i, j] - d1[ik, i, j]) > 1e-10:
-                    print(i, j, d0[ik, i, j] - d1[ik, i, j])
+    assert d0 == pytest.approx(d1, abs=1e-8)
```

### Comparing `gpaw-22.8.0/gpaw/test/radial/test_ylexpand.py` & `gpaw-23.6.0/gpaw/test/radial/test_ylexpand.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/radial/test_yukawa_radial.py` & `gpaw-23.6.0/gpaw/test/radial/test_yukawa_radial.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/ralda/ralda_He_test.py` & `gpaw-23.6.0/gpaw/test/ralda/test_ralda_He.py`

 * *Files 19% similar despite different names*

```diff
@@ -3,49 +3,49 @@
 
 from gpaw import GPAW, FermiDirac
 from gpaw.mpi import serial_comm
 from gpaw.xc.fxc import FXCCorrelation
 from gpaw.xc.rpa import RPACorrelation
 
 
-@pytest.mark.response
-def test_ralda_ralda_energy_He(in_tmp_dir, scalapack):
+@pytest.fixture(scope='module')
+def calc():
     a = 3.0
     atoms = Atoms('He', cell=[a, a, a], pbc=True)
     calc = GPAW(mode=dict(name='pw', ecut=200),
                 kpts=dict(size=(2, 2, 2), gamma=True),
                 nbands=2,
+                txt='gpaw.txt',
                 occupations=FermiDirac(0.001),
                 # FXCCorrelation needs a serial-comm GPAW object:
                 communicator=serial_comm)
     atoms.calc = calc
     atoms.get_potential_energy()
     calc.diagonalize_full_hamiltonian(nbands=20)
+    return calc
 
-    ecuts = [20, 30]
-    rpa = RPACorrelation(calc, nfrequencies=8)
-    E_rpa1 = rpa.calculate(ecut=ecuts)[-1]
 
-    def fxc(xc, nfrequencies=8, **kwargs):
-        return FXCCorrelation(calc, xc=xc, **kwargs).calculate(ecut=ecuts)[-1]
+whyskip_rapbe = 'https://gitlab.com/gpaw/gpaw/-/issues/723'
+
+
+@pytest.mark.rpa
+@pytest.mark.response
+@pytest.mark.parametrize('xc, kwargs, ref_energy', [
+    ('RPA', dict(nlambda=16), -0.1054),
+    ('rALDA', dict(unit_cells=[1, 1, 2]), -0.0560),
+    pytest.param('rAPBE', dict(unit_cells=[1, 1, 2]), -0.0523,
+                 marks=pytest.mark.skip(reason=whyskip_rapbe)),
+    ('rALDA', dict(avg_scheme='wavevector'), -0.0241),
+    ('rAPBE', dict(avg_scheme='wavevector'), -0.0288),
+])
+def test_ralda_ralda_energy_He(in_tmp_dir, scalapack, calc, xc, kwargs,
+                               ref_energy):
+    ecuts = [20, 30]
+    fxc = FXCCorrelation(calc, xc=xc, ecut=ecuts, **kwargs)
+    energy = fxc.calculate()[-1]
 
-    energies = [
-        fxc('RPA', nlambda=16),
-        fxc('rALDA', unit_cells=[1, 1, 2]),
-        fxc('rAPBE', unit_cells=[1, 1, 2]),
-        fxc('rALDA', av_scheme='wavevector'),
-        fxc('rAPBE', av_scheme='wavevector'),
-        fxc('JGMs', av_scheme='wavevector', Eg=3.1, nlambda=2),
-        fxc('CP_dyn', av_scheme='wavevector', nfrequencies=2, nlambda=2)]
-
-    assert E_rpa1 == pytest.approx(energies[0], abs=0.01)
-
-    refs = [-0.1054,
-            -0.0560,
-            -0.0523,
-            -0.0241,
-            -0.0288,
-            -0.0263,
-            -0.0275]
+    assert energy == pytest.approx(ref_energy, abs=0.001)
 
-    for val, ref in zip(energies, refs):
-        assert val == pytest.approx(ref, abs=0.001)
+    if xc == 'RPA':
+        rpa = RPACorrelation(calc, nfrequencies=8, ecut=ecuts)
+        E_rpa1 = rpa.calculate()[-1]
+        assert E_rpa1 == pytest.approx(ref_energy, abs=0.001)
```

### Comparing `gpaw-22.8.0/gpaw/test/raman/test_dipole_transition.py` & `gpaw-23.6.0/gpaw/test/lcao/test_dipole_transition.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,24 +1,24 @@
 import numpy as np
 import pytest
 
 from ase.parallel import world, parprint
 from ase.units import Bohr
 from gpaw import GPAW
-from gpaw.raman.dipoletransition import get_dipole_transitions
+from gpaw.lcao.dipoletransition import get_dipole_transitions
 from gpaw.utilities.dipole import dipole_matrix_elements_from_calc
 from gpaw.lrtddft.kssingle import KSSingles
 
 
+@pytest.mark.later
 def test_dipole_transition(gpw_files, tmp_path_factory):
     """Check dipole matrix-elements for H20."""
     calc = GPAW(gpw_files['h2o_lcao_wfs'])
     # Initialize calculator if necessary
     if not hasattr(calc.wfs, 'C_nM'):
-        calc.wfs.set_positions
         calc.initialize_positions(calc.atoms)
     dip_skvnm = get_dipole_transitions(calc.wfs).real
     parprint("Dipole moments calculated")
     assert dip_skvnm.shape == (1, 1, 3, 6, 6)
     dip_vnm = dip_skvnm[0, 0] * Bohr
 
     print(world.rank, dip_vnm[0, 0, 3])
```

### Comparing `gpaw-22.8.0/gpaw/test/raman/test_dipole_transition2.py` & `gpaw-23.6.0/gpaw/test/lcao/test_dipole_transition2.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,17 +1,18 @@
 import numpy as np
 import pytest
 
 from ase.parallel import world, parprint
 from ase.units import Bohr
 from gpaw import GPAW
-from gpaw.raman.dipoletransition import get_dipole_transitions
+from gpaw.lcao.dipoletransition import get_dipole_transitions
 from gpaw.lrtddft.kssingle import KSSingles
 
 
+@pytest.mark.later
 def test_dipole_transition(gpw_files, tmp_path_factory):
     """Check dipole matrix-elements for Li."""
     calc = GPAW(gpw_files['bcc_li_lcao_wfs'], parallel=dict(sl_auto=True))
     # Initialize calculator if necessary
     if not hasattr(calc.wfs, 'C_nM'):
         calc.wfs.set_positions
         calc.initialize_positions(calc.atoms)
```

### Comparing `gpaw-22.8.0/gpaw/test/response/hyd_chain_response.py` & `gpaw-23.6.0/gpaw/test/response/hyd_chain_response.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/response/test_afm_hchain_sf_gssALDA.py` & `gpaw-23.6.0/gpaw/test/response/test_afm_hchain_sf_gssALDA.py`

 * *Files 12% similar despite different names*

```diff
@@ -7,18 +7,25 @@
 # Script modules
 from ase import Atoms
 from ase.dft.kpoints import monkhorst_pack
 
 from gpaw import PW, GPAW
 from gpaw.mpi import world
 from gpaw.test import findpeak
-from gpaw.response.tms import TransverseMagneticSusceptibility
-from gpaw.response.susceptibility import read_macroscopic_component
 
+from gpaw.response import ResponseGroundStateAdapter
+from gpaw.response.frequencies import ComplexFrequencyDescriptor
+from gpaw.response.chiks import ChiKSCalculator
+from gpaw.response.susceptibility import ChiFactory
+from gpaw.response.fxc_kernels import AdiabaticFXCCalculator
+from gpaw.response.dyson import HXCScaling
+from gpaw.response.pair_functions import read_pair_function
 
+
+@pytest.mark.later  # interpolate=3 for PW-mode not implemented!
 @pytest.mark.kspair
 @pytest.mark.response
 def test_response_afm_hchain_gssALDA(in_tmp_dir):
     # ---------- Inputs ---------- #
 
     # Part 1: Ground state calculation
     # Define atomic structure
@@ -34,86 +41,98 @@
     conv = {'bands': nbands}
 
     # # Part 2: Magnetic response calculation
     q_qc = [[0., 0., 0.],
             [1. / 6., 0., 0.],
             [1. / 3., 0., 0.]]
     fxc = 'ALDA'
-    fxc_scaling = [True, None, 'afm']
+    hxc_scaling = HXCScaling('afm')
     rshelmax = -1
     rshewmin = 1e-8
     ecut = 120
     frq_w = np.linspace(-0.6, 0.6, 41)
     eta = 0.24
-    if world.size > 1:
+    zd = ComplexFrequencyDescriptor.from_array(frq_w + 1.j * eta)
+    if world.size % 4 == 0:
+        nblocks = 4
+    elif world.size % 2 == 0:
         nblocks = 2
     else:
         nblocks = 1
 
     # ---------- Script ---------- #
 
     # Part 1: Ground state calculation
 
     Hatom = Atoms('H',
                   cell=[a, 0, 0],
-                  pbc=[1, 0, 0])
+                  # Use pbc to allow for real-space density interpolation
+                  pbc=[1, 1, 1])
     Hatom.center(vacuum=vfactor * a, axis=(1, 2))
     Hchain = Hatom.repeat((2, 1, 1))
     Hchain.set_initial_magnetic_moments([mm, -mm])
 
     calc = GPAW(xc=xc,
-                mode=PW(pw),
+                mode=PW(pw,
+                        # Interpolate the density in real space
+                        interpolation=3),
                 kpts=monkhorst_pack((kpts, 1, 1)),
                 nbands=nbands + ebands,
                 convergence=conv,
                 symmetry={'point_group': True},
                 parallel={'domain': 1})
 
     Hchain.calc = calc
     Hchain.get_potential_energy()
 
     # Part 2: Magnetic response calculation
-    fxckwargs = {'rshelmax': rshelmax,
-                 'rshewmin': rshewmin,
-                 'fxc_scaling': fxc_scaling}
-    tms = TransverseMagneticSusceptibility(calc,
-                                           nbands=nbands,
-                                           fxc=fxc,
-                                           eta=eta,
-                                           ecut=ecut,
-                                           fxckwargs=fxckwargs,
-                                           gammacentered=True,
-                                           nblocks=nblocks)
+    gs = ResponseGroundStateAdapter(calc)
+    chiks_calc = ChiKSCalculator(gs,
+                                 nbands=nbands,
+                                 ecut=ecut,
+                                 gammacentered=True,
+                                 nblocks=nblocks)
+    fxc_calculator = AdiabaticFXCCalculator.from_rshe_parameters(
+        gs, chiks_calc.context,
+        rshelmax=rshelmax,
+        rshewmin=rshewmin)
+    chi_factory = ChiFactory(chiks_calc, fxc_calculator)
+
     for q, q_c in enumerate(q_qc):
-        tms.get_macroscopic_component('+-', q_c, frq_w,
-                                      filename=('h-chain_macro_tms'
-                                                + '_q%d.csv' % q))
+        filename = 'h-chain_macro_tms_q%d.csv' % q
+        txt = 'h-chain_macro_tms_q%d.txt' % q
+        _, chi = chi_factory('+-', q_c, zd,
+                             fxc=fxc,
+                             hxc_scaling=hxc_scaling,
+                             txt=txt)
+        chi.write_macroscopic_component(filename)
 
-    tms.write_timer()
+    chi_factory.context.write_timer()
     world.barrier()
 
     # Part 3: Identify magnon peak in finite q scattering function
-    w0_w, _, chi0_w = read_macroscopic_component('h-chain_macro_tms_q0.csv')
-    w1_w, _, chi1_w = read_macroscopic_component('h-chain_macro_tms_q1.csv')
-    w2_w, _, chi2_w = read_macroscopic_component('h-chain_macro_tms_q2.csv')
+    w0_w, chi0_w = read_pair_function('h-chain_macro_tms_q0.csv')
+    w1_w, chi1_w = read_pair_function('h-chain_macro_tms_q1.csv')
+    w2_w, chi2_w = read_pair_function('h-chain_macro_tms_q2.csv')
 
     wpeak1, Ipeak1 = findpeak(w1_w, -chi1_w.imag / np.pi)
     wpeak2, Ipeak2 = findpeak(w2_w, -chi2_w.imag / np.pi)
     mw1 = calculate_afm_mw(wpeak1, eta) * 1000  # to meV
     mw2 = calculate_afm_mw(wpeak2, eta) * 1000  # to meV
 
     # Part 4: compare new results to test values
     test_fxcs = 1.04744
     test_mw1 = 285.  # meV
     test_mw2 = 494.  # meV  # Remark that mw2 < 2 * mw1 (linear dispersion)
     test_Ipeak1 = 0.0131  # a.u.
     test_Ipeak2 = 0.0290
 
     # Test fxc_scaling:
-    assert abs(fxc_scaling[1] - test_fxcs) < 0.005
+    fxcs = hxc_scaling.lambd
+    assert abs(fxcs - test_fxcs) < 0.005
 
     # Magnon peak at q=1/3 q_X:
     assert abs(mw1 - test_mw1) < 10.
 
     # Magnon peak at q=2/3 q_X:
     assert abs(mw2 - test_mw2) < 10.
```

### Comparing `gpaw-22.8.0/gpaw/test/response/test_aluminum_EELS_ALDA.py` & `gpaw-23.6.0/gpaw/test/response/test_aluminum_EELS_ALDA.py`

 * *Files 22% similar despite different names*

```diff
@@ -3,15 +3,15 @@
 import pytest
 import numpy as np
 from ase.build import bulk
 from ase.parallel import parprint
 
 from gpaw import GPAW, PW
 from gpaw.test import findpeak
-from gpaw.response.df import DielectricFunction
+from gpaw.response.df import DielectricFunction, read_response_function
 from gpaw.mpi import size, world
 
 
 @pytest.mark.response
 @pytest.mark.libxc
 def test_response_aluminum_EELS_ALDA(in_tmp_dir):
     assert size <= 4**3
@@ -46,18 +46,19 @@
 
     t3 = time.time()
 
     parprint('For ground  state calc, it took', (t2 - t1) / 60, 'minutes')
     parprint('For excited state calc, it took', (t3 - t2) / 60, 'minutes')
 
     world.barrier()
-    d = np.loadtxt('EELS_Al_ALDA.csv', delimiter=',')
+    omega_w, eels0_w, eels_w = read_response_function('EELS_Al_ALDA.csv')
+
     # New results are compared with test values
-    wpeak1, Ipeak1 = findpeak(d[:, 0], d[:, 1])
-    wpeak2, Ipeak2 = findpeak(d[:, 0], d[:, 2])
+    wpeak1, Ipeak1 = findpeak(omega_w, eels0_w)
+    wpeak2, Ipeak2 = findpeak(omega_w, eels_w)
 
     test_wpeak1 = 15.7002862696  # eV
     test_Ipeak1 = 28.5590363176
     test_wpeak2 = 15.5196459206
     test_Ipeak2 = 26.5680624522
 
     if abs(test_wpeak1 - wpeak1) > 0.02 or abs(test_wpeak2 - wpeak2) > 0.02:
```

### Comparing `gpaw-22.8.0/gpaw/test/response/test_au02_absorption.py` & `gpaw-23.6.0/gpaw/test/response/test_diamond_absorption.py`

 * *Files 21% similar despite different names*

```diff
@@ -1,78 +1,112 @@
 import pytest
 import numpy as np
-from ase import Atoms
-from gpaw import GPAW, FermiDirac, PW
+from ase.units import Bohr
+from ase.build import bulk
+from gpaw import GPAW, FermiDirac
 from gpaw.response.df import DielectricFunction
 from gpaw.test import equal, findpeak
 
 
 @pytest.mark.response
-@pytest.mark.slow
-def test_response_au02_absorption(scalapack, in_tmp_dir):
-    GS = 1
-    ABS = 1
-    if GS:
-        cluster = Atoms('Au2', [(0, 0, 0), (0, 0, 2.564)])
-        cluster.set_cell((6, 6, 6), scale_atoms=False)
-        cluster.center()
-        calc = GPAW(mode=PW(ecut=180, force_complex_dtype=True),
-                    xc={'name': 'RPBE', 'stencil': 1},
-                    nbands=16,
-                    eigensolver='rmm-diis',
-                    parallel={'domain': 1},
-                    occupations=FermiDirac(0.01))
-
-        cluster.calc = calc
-        cluster.get_potential_energy()
-        calc.diagonalize_full_hamiltonian(nbands=24, scalapack=True)
-        calc.write('Au2.gpw', 'all')
-
-    nw = 141
-    frequencies = np.linspace(0, 14, nw)
-
-    if ABS:
-        df = DielectricFunction('Au2.gpw',
-                                frequencies=frequencies,
-                                hilbert=not True,
-                                eta=0.1,
-                                ecut=10)
-
-        b0, b = df.get_dielectric_function(filename=None,
-                                           direction='z')
-        a0, a = df.get_polarizability(filename=None,
-                                      direction='z')
-        df_ws = DielectricFunction('Au2.gpw',
-                                   frequencies=frequencies,
-                                   hilbert=not True,
-                                   eta=0.1,
-                                   ecut=10,
-                                   truncation='wigner-seitz')
-
-        a0_ws, a_ws = df_ws.get_polarizability(filename=None,
-                                               direction='z')
-
-        w0_ = 5.60491055
-        I0_ = 227.23392824591642
-        w_ = 5.644900254787107
-        I_ = 184.4086028397282
-
-        w, I = findpeak(frequencies, b0.imag)
-        equal(w, w0_, 0.05)
-        equal(6**3 * I / (4 * np.pi), I0_, 0.5)
-        w, I = findpeak(frequencies, a0.imag)
-        equal(w, w0_, 0.05)
-        equal(I, I0_, 0.5)
-        w, I = findpeak(frequencies, a0_ws.imag)
-        equal(w, w0_, 0.05)
-        equal(I, I0_, 0.5)
-        w, I = findpeak(frequencies, b.imag)
-        equal(w, w_, 0.05)
-        equal(6**3 * I / (4 * np.pi), I_, 0.5)
-        w, I = findpeak(frequencies, a.imag)
-        equal(w, w_, 0.05)
-        equal(I, I_, 0.5)
-        # The Wigner-Seitz truncation does not give exactly the
-        # same for small cell
-        w, I = findpeak(frequencies, a_ws.imag)
-        equal(w, w_, 0.2)
-        equal(I, I_, 8.0)
+@pytest.mark.libxc
+def test_response_diamond_absorption(in_tmp_dir):
+    a = 6.75 * Bohr
+    atoms = bulk('C', 'diamond', a=a)
+
+    calc = GPAW(mode='pw',
+                kpts=(3, 3, 3),
+                eigensolver='rmm-diis',
+                occupations=FermiDirac(0.001))
+
+    atoms.calc = calc
+    atoms.get_potential_energy()
+    calc.write('C.gpw', 'all')
+
+    eM1_ = 9.727
+    eM2_ = 9.548
+    w0_ = 10.7782
+    I0_ = 5.47
+    w_ = 10.7532
+    I_ = 5.98
+
+    # Macroscopic dielectric constant calculation
+    df = DielectricFunction('C.gpw', frequencies=(0.,), eta=0.001, ecut=50,
+                            hilbert=False)
+    eM1, eM2 = df.get_macroscopic_dielectric_constant()
+    equal(eM1, eM1_, 0.01)
+    equal(eM2, eM2_, 0.01)
+
+    # Absorption spectrum calculation RPA
+    df = DielectricFunction('C.gpw',
+                            eta=0.25,
+                            ecut=50,
+                            frequencies=np.linspace(0, 24., 241),
+                            hilbert=False)
+    a0, a = df.get_dielectric_function(filename=None)
+    df.check_sum_rule(a.imag)
+
+    equal(a0[0].real, eM1_, 0.01)
+    equal(a[0].real, eM2_, 0.01)
+    w, I = findpeak(np.linspace(0, 24., 241), a0.imag)
+    equal(w, w0_, 0.01)
+    equal(I / (4 * np.pi), I0_, 0.1)
+    w, I = findpeak(np.linspace(0, 24., 241), a.imag)
+    equal(w, w_, 0.01)
+    equal(I / (4 * np.pi), I_, 0.1)
+
+    a0, a = df.get_polarizability(filename=None)
+
+    w, I = findpeak(np.linspace(0, 24., 241), a0.imag)
+    equal(w, w0_, 0.01)
+    equal(I, I0_, 0.01)
+    w, I = findpeak(np.linspace(0, 24., 241), a.imag)
+    equal(w, w_, 0.01)
+    equal(I, I_, 0.01)
+
+    # Absorption spectrum calculation ALDA
+    w0_ = 10.7931
+    I0_ = 5.36
+    w_ = 10.7562
+    I_ = 5.8803
+
+    df.get_polarizability(xc='ALDA', filename='ALDA_pol.csv')
+    # Here we base the check on a written results file
+    df.context.comm.barrier()
+    d = np.loadtxt('ALDA_pol.csv', delimiter=',')
+
+    w, I = findpeak(d[:, 0], d[:, 2])
+    equal(w, w0_, 0.01)
+    equal(I, I0_, 0.1)
+    w, I = findpeak(d[:, 0], d[:, 4])
+    equal(w, w_, 0.01)
+    equal(I, I_, 0.1)
+
+    # Absorption spectrum calculation long-range kernel
+    w0_ = 10.2189
+    I0_ = 5.14
+    w_ = 10.2906
+    I_ = 5.6955
+
+    a0, a = df.get_polarizability(filename=None, xc='LR0.25')
+
+    w, I = findpeak(np.linspace(0, 24., 241), a0.imag)
+    equal(w, w0_, 0.01)
+    equal(I, I0_, 0.1)
+    w, I = findpeak(np.linspace(0, 24., 241), a.imag)
+    equal(w, w_, 0.01)
+    equal(I, I_, 0.1)
+
+    # Absorption spectrum calculation Bootstrap
+    w0_ = 10.37
+    I0_ = 5.27
+    w_ = 10.4600
+    I_ = 6.0263
+
+    a0, a = df.get_polarizability(filename=None, xc='Bootstrap')
+
+    w, I = findpeak(np.linspace(0, 24., 241), a0.imag)
+    equal(w, w0_, 0.02)
+    equal(I, I0_, 0.2)
+    w, I = findpeak(np.linspace(0, 24., 241), a.imag)
+    equal(w, w_, 0.02)
+    equal(I, I_, 0.2)
```

### Comparing `gpaw-22.8.0/gpaw/test/response/test_bse_MoS2_cut.py` & `gpaw-23.6.0/gpaw/test/response/test_bse_MoS2_cut.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,66 +1,72 @@
 import pytest
 import numpy as np
 from ase import Atoms
 from ase.lattice.hexagonal import Hexagonal
 from gpaw import GPAW, FermiDirac, PW
+from gpaw.mpi import world
 from gpaw.test import findpeak, equal
 from gpaw.response.bse import BSE
+from gpaw.response.df import read_response_function
 
 
 @pytest.mark.response
 def test_response_bse_MoS2_cut(in_tmp_dir, scalapack):
-    if 1:
-        calc = GPAW(mode=PW(180),
-                    xc='PBE',
-                    nbands='nao',
-                    setups={'Mo': '6'},
-                    parallel={'band': 1, 'domain': 1},
-                    occupations=FermiDirac(0.001),
-                    convergence={'bands': -5},
-                    kpts=(9, 9, 1))
-
-        a = 3.1604
-        c = 10.0
-
-        cell = Hexagonal(symbol='Mo',
-                         latticeconstant={'a': a, 'c': c}).get_cell()
-        layer = Atoms(symbols='MoS2', cell=cell, pbc=(1, 1, 0),
-                      scaled_positions=[(0, 0, 0),
-                                        (2 / 3, 1 / 3, 0.3),
-                                        (2 / 3, 1 / 3, -0.3)])
-
-        pos = layer.get_positions()
-        pos[1][2] = pos[0][2] + 3.172 / 2
-        pos[2][2] = pos[0][2] - 3.172 / 2
-        layer.set_positions(pos)
-        layer.center(axis=2)
-        layer.calc = calc
-        layer.get_potential_energy()
-        calc.write('MoS2.gpw', mode='all')
+    calc = GPAW(mode=PW(180),
+                xc='PBE',
+                nbands='nao',
+                setups={'Mo': '6'},
+                occupations=FermiDirac(0.001),
+                convergence={'bands': -5},
+                kpts=(5, 5, 1))
+
+    a = 3.1604
+    c = 10.0
+
+    cell = Hexagonal(symbol='Mo',
+                     latticeconstant={'a': a, 'c': c}).get_cell()
+    layer = Atoms(symbols='MoS2', cell=cell, pbc=(1, 1, 0),
+                  scaled_positions=[(0, 0, 0),
+                                    (2 / 3, 1 / 3, 0.3),
+                                    (2 / 3, 1 / 3, -0.3)])
+
+    pos = layer.get_positions()
+    pos[1][2] = pos[0][2] + 3.172 / 2
+    pos[2][2] = pos[0][2] - 3.172 / 2
+    layer.set_positions(pos)
+    layer.center(axis=2)
+    layer.calc = calc
+    layer.get_potential_energy()
+    calc.write('MoS2.gpw', mode='all')
 
     bse = BSE('MoS2.gpw',
               spinors=True,
               ecut=10,
               valence_bands=[8],
               conduction_bands=[9],
               eshift=0.8,
               nbands=15,
               write_h=False,
               write_v=False,
               wfile=None,
               mode='BSE',
               truncation='2D')
 
-    w_w, alpha_w = bse.get_polarizability(filename=None,
-                                          write_eig=None,
-                                          eta=0.02,
-                                          w_w=np.linspace(0., 5., 5001))
+    outw_w, outalpha_w = bse.get_polarizability(write_eig=None,
+                                                eta=0.02,
+                                                w_w=np.linspace(0., 5., 5001))
+    world.barrier()
+    w_w, alphareal_w, alphaimag_w = read_response_function('pol_bse.csv')
+
+    # Check consistency with written results
+    assert np.allclose(outw_w, w_w, atol=1e-5, rtol=1e-4)
+    assert np.allclose(outalpha_w.real, alphareal_w, atol=1e-5, rtol=1e-4)
+    assert np.allclose(outalpha_w.imag, alphaimag_w, atol=1e-5, rtol=1e-4)
 
-    w0, I0 = findpeak(w_w[:1100], alpha_w.imag[:1100])
-    w1, I1 = findpeak(w_w[1100:1300], alpha_w.imag[1100:1300])
+    w0, I0 = findpeak(w_w[:1100], alphaimag_w[:1100])
+    w1, I1 = findpeak(w_w[1100:1300], alphaimag_w[1100:1300])
     w1 += 1.1
 
-    equal(w0, 1.02, 0.01)
-    equal(I0, 13.1, 0.35)
-    equal(w1, 2.26, 0.01)
-    equal(I1, 12.8, 0.35)
+    equal(w0, 0.58, 0.01)
+    equal(I0, 38.8, 0.35)
+    equal(w1, 2.22, 0.01)
+    equal(I1, 6.3, 0.35)
```

### Comparing `gpaw-22.8.0/gpaw/test/response/test_bse_aluminum.py` & `gpaw-23.6.0/gpaw/test/response/test_bse_aluminum.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,14 +1,14 @@
 import pytest
 from gpaw.mpi import world
 import numpy as np
 from ase.build import bulk
 from gpaw import GPAW
 from gpaw.response.df import DielectricFunction
-from gpaw.response.bse import BSE
+from gpaw.response.bse import BSE, read_spectrum
 from gpaw.test import findpeak, equal
 
 pytestmark = pytest.mark.skipif(world.size < 4,
                                 reason='world.size < 4')
 
 
 @pytest.mark.response
@@ -41,28 +41,30 @@
                   conduction_bands=range(4),
                   mode='RPA',
                   nbands=4,
                   ecut=ecut,
                   write_h=False,
                   write_v=False,
                   )
-        bse_w = bse.get_eels_spectrum(filename=None,
-                                      q_c=q_c,
-                                      w_w=w_w,
-                                      eta=eta)[1]
+        bse.get_eels_spectrum(filename='bse_eels.csv',
+                              q_c=q_c,
+                              w_w=w_w,
+                              eta=eta)
+        omega_w, bse_w = read_spectrum('bse_eels.csv')
 
     if df:
         df = DielectricFunction(calc='Al.gpw',
                                 frequencies=w_w,
                                 eta=eta,
                                 ecut=ecut,
                                 hilbert=False)
         df_w = df.get_eels_spectrum(q_c=q_c, filename=None)[1]
 
     if check_spectrum:
+        assert w_w == pytest.approx(omega_w)
         w_ = 15.1423
         I_ = 25.4359
         wbse, Ibse = findpeak(w_w, bse_w)
         wdf, Idf = findpeak(w_w, df_w)
         equal(wbse, w_, 0.01)
         equal(wdf, w_, 0.01)
         equal(Ibse, I_, 0.1)
```

### Comparing `gpaw-22.8.0/gpaw/test/response/test_bse_silicon.py` & `gpaw-23.6.0/gpaw/test/response/test_bse_silicon.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,12 +1,13 @@
 import pytest
 import numpy as np
 from ase.build import bulk
 from gpaw import GPAW, FermiDirac
-from gpaw.response.bse import BSE
+from gpaw.response.bse import BSE, read_bse_eigenvalues
+from gpaw.response.df import read_response_function
 from gpaw.test import findpeak, equal
 
 
 @pytest.mark.response
 def test_response_bse_silicon(in_tmp_dir, scalapack):
     GS = 1
     nosym = 1
@@ -32,21 +33,21 @@
                   ecut=50.,
                   valence_bands=range(4),
                   conduction_bands=range(4, 8),
                   eshift=eshift,
                   nbands=8,
                   write_h=False,
                   write_v=False)
-        w_w, eps_w = bse.get_dielectric_function(filename=None,
-                                                 eta=0.2,
-                                                 w_w=np.linspace(0, 10, 2001))
+        bse.get_dielectric_function(eta=0.2,
+                                    w_w=np.linspace(0, 10, 2001))
+        w_w, epsreal_w, epsimag_w = read_response_function('df_bse.csv')
     if check:
         w_ = 2.552
         I_ = 421.15
-        w, I = findpeak(w_w, eps_w.imag)
+        w, I = findpeak(w_w, epsimag_w)
         equal(w, w_, 0.01)
         equal(I, I_, 0.1)
 
     if GS and nosym:
         atoms = bulk('Si', 'diamond', a=a)
         calc = GPAW(mode='pw',
                     kpts={'size': (2, 2, 2), 'gamma': True},
@@ -71,7 +72,13 @@
                                                  eta=0.2,
                                                  w_w=np.linspace(0, 10, 2001))
 
     if check and nosym:
         w, I = findpeak(w_w, eps_w.imag)
         equal(w, w_, 0.01)
         equal(I, I_, 0.1)
+
+        # Read eigenvalues file and test first 3 weights:
+        _, C_w = read_bse_eigenvalues('eig.dat')
+        assert C_w[0] == pytest.approx(22.37, abs=0.05)
+        # These two have degenerate eigenvalues:
+        assert np.sum(C_w[1:3]) == pytest.approx(44.29, abs=0.05)
```

### Comparing `gpaw-22.8.0/gpaw/test/response/test_chi0.py` & `gpaw-23.6.0/gpaw/test/response/test_chi0.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,75 +1,72 @@
 import pytest
 import numpy as np
 from ase.build import bulk
 from ase.dft.kpoints import monkhorst_pack
 # from ase.units import Bohr
 
-from gpaw import GPAW, FermiDirac
+from gpaw import GPAW, FermiDirac, PW
 from gpaw.response.chi0 import Chi0
 from gpaw.mpi import serial_comm
+from itertools import product
 
 
 @pytest.mark.response
 @pytest.mark.slow
 def test_response_chi0(in_tmp_dir):
-    omega = np.array([0, 1.0, 2.0])
-    for k in [2, 3]:
+    # inputs to loop over [k, gamma, center, sym]
+    settings = product([2, 3], *[[False, True]] * 3)
+
+    for k, gamma, center, sym in settings:
+        if k == 3 and gamma:
+            continue
+        a = bulk('Si', 'diamond')
         q_c = [0, 0, 1.0 / k]
-        for gamma in [False, True]:
-            if k == 3 and gamma:
-                continue
-            kpts = monkhorst_pack((k, k, k))
-            if gamma:
-                kpts += 0.5 / k
-            for center in [False, True]:
-                a = bulk('Si', 'diamond')
-                if center:
-                    a.center()
-                for sym in [False, True]:
-                    name = 'si.k%d.g%d.c%d.s%d' % (k, gamma, center, bool(sym))
-                    print(name)
-                    if 1:
-                        calc = a.calc = GPAW(
-                            kpts=kpts,
-                            eigensolver='rmm-diis',
-                            symmetry={'point_group': sym},
-                            mode='pw',
-                            occupations=FermiDirac(width=0.001),
-                            txt=name + '.txt')
-                        a.get_potential_energy()
-                        calc.write(name, 'all')
-
-                    calc = GPAW(name, txt=None, communicator=serial_comm)
-
-                    chi = Chi0(calc, frequencies=omega, hilbert=False,
-                               ecut=100, txt=name + '.log')
-                    chi0 = chi.calculate(q_c)
-                    chi0_wGG = chi0.chi0_wGG
-
-                    if not sym and not center:
-                        chi00_w = chi0_wGG[:, 0, 0]
-                    elif -1 not in calc.wfs.kd.bz2bz_ks:
-                        assert abs(chi0_wGG[:, 0, 0] - chi00_w).max() < 3e-5
-
-                    if not sym:
-                        chi00_wGG = chi0_wGG
-                    elif -1 not in calc.wfs.kd.bz2bz_ks:
-                        assert abs(chi0_wGG - chi00_wGG).max() < 2e-5
-
-                    # q0_c = [0, 1e-7, 1e-7]
-                    # q0_v = np.dot(q0_c,
-                    #               a.get_reciprocal_cell() * 2 * np.pi) * Bohr
-                    # q0 = (q0_v**2).sum()**0.5
-
-                    chi0 = chi.calculate([0, 0, 0])
-                    chi0_wGG = chi0.chi0_wGG
-
-                    if not sym and not center:
-                        chi000_w = chi0_wGG[:, 0, 0]
-                    elif -1 not in calc.wfs.kd.bz2bz_ks:
-                        assert abs(chi0_wGG[:, 0, 0] - chi000_w).max() < 0.001
-
-                    if not sym:
-                        chi000_wGG = chi0_wGG
-                    elif -1 not in calc.wfs.kd.bz2bz_ks:
-                        assert abs(chi0_wGG - chi000_wGG).max() < 0.001
+        kpts = monkhorst_pack((k, k, k))
+        if gamma:
+            kpts += 0.5 / k
+        if center:
+            a.center()
+        name = 'si.k%d.g%d.c%d.s%d' % (k, gamma, center, bool(sym))
+
+        calc = a.calc = GPAW(
+            kpts=kpts,
+            symmetry={'point_group': sym},
+            mode=PW(150),
+            occupations=FermiDirac(width=0.001),
+            convergence={'bands': 8},
+            txt=name + '.txt')
+        a.get_potential_energy()
+        calc.write(name, 'all')
+
+        calc = GPAW(name, txt=None, communicator=serial_comm)
+
+        chi = Chi0(calc, frequencies=np.array([0, 1.0, 2.0]), hilbert=False,
+                   ecut=100, txt=name + '.log')
+        chi0 = chi.calculate(q_c)
+        assert chi0.blockdist.blockcomm.size == 1
+        chi0_wGG = chi0.chi0_WgG  # no block distribution
+
+        # sym and center: False
+        if not sym and not center:
+            chi00_w = chi0_wGG[:, 0, 0]
+        elif -1 not in calc.wfs.kd.bz2bz_ks:
+            assert abs(chi0_wGG[:, 0, 0] - chi00_w).max() < 35e-5
+
+        if not sym:
+            chi00_wGG = chi0_wGG
+        elif -1 not in calc.wfs.kd.bz2bz_ks:
+            assert abs(chi0_wGG - chi00_wGG).max() < 2e-5
+
+        chi0 = chi.calculate([0, 0, 0])
+        assert chi0.blockdist.blockcomm.size == 1
+        chi0_wGG = chi0.chi0_WgG  # no block distribution
+
+        if not sym and not center:
+            chi000_w = chi0_wGG[:, 0, 0]
+        elif -1 not in calc.wfs.kd.bz2bz_ks:
+            assert abs(chi0_wGG[:, 0, 0] - chi000_w).max() < 0.0015
+
+        if not sym:
+            chi000_wGG = chi0_wGG
+        elif -1 not in calc.wfs.kd.bz2bz_ks:
+            assert abs(chi0_wGG - chi000_wGG).max() < 0.0015
```

### Comparing `gpaw-22.8.0/gpaw/test/response/test_chi0_intraband_test.py` & `gpaw-23.6.0/gpaw/test/response/test_na_plasmon.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,111 +1,124 @@
-import os
-
-import numpy as np
 import pytest
+import numpy as np
 
+from ase import Atoms
 from gpaw import GPAW, PW
 from gpaw.mpi import world
 from gpaw.test import equal, findpeak
+from gpaw.utilities import compiled_with_sl
 from gpaw.response.df import DielectricFunction
-from ase.build import bulk
-from ase.units import Bohr, Hartree
+
+# Comparing the plasmon peaks found in bulk sodium for two different
+# atomic structures. Testing for idential plasmon peaks. Not using
+# physical sodium cell.
 
 
 @pytest.mark.response
-@pytest.mark.slow
-def test_chi0_intraband(in_tmp_dir):
-    """Comparing the plasmon peaks found in bulk sodium for two different
-    atomic structures. Testing for idential plasmon peaks. Not using
-    physical sodium cell."""
-    a1 = bulk('Na')
-    a2 = bulk('Na')
-    a2.set_initial_magnetic_moments([[0.1, ]])
-    a1.calc = GPAW(mode=PW(300),
+def test_response_na_plasmon(in_tmp_dir):
+    a = 4.23 / 2.0
+    a1 = Atoms('Na',
+               scaled_positions=[[0, 0.1, 0]],
+               cell=(a, a, a),
+               pbc=True)
+
+    # Expanding along x-direction
+    a2 = Atoms('Na2',
+               scaled_positions=[[0, 0.1, 0], [0.5, 0.1, 0]],
+               cell=(2 * a, a, a),
+               pbc=True)
+
+    a1.calc = GPAW(mode=PW(250),
                    kpts={'size': (8, 8, 8), 'gamma': True},
                    parallel={'band': 1},
-                   txt='na_spinpaired.txt')
-    a2.calc = GPAW(mode=PW(300),
-                   kpts={'size': (8, 8, 8), 'gamma': True},
+                   # txt='small.txt',
+                   )
+
+    # Kpoint sampling should be halved in the expanded direction.
+    a2.calc = GPAW(mode=PW(250),
+                   kpts={'size': (4, 8, 8), 'gamma': True},
                    parallel={'band': 1},
-                   txt='na_spinpol.txt')
+                   # txt='large.txt',
+                   )
+
     a1.get_potential_energy()
     a2.get_potential_energy()
 
     # Use twice as many bands for expanded structure
     a1.calc.diagonalize_full_hamiltonian(nbands=20)
-    a2.calc.diagonalize_full_hamiltonian(nbands=20)
+    a2.calc.diagonalize_full_hamiltonian(nbands=40)
+
+    a1.calc.write('gs_Na_small.gpw', 'all')
+    a2.calc.write('gs_Na_large.gpw', 'all')
 
-    a1.calc.write('intraband_spinpaired.gpw', 'all')
-    a2.calc.write('intraband_spinpolarized.gpw', 'all')
+    # Settings that should yield the same result
+    settings = [{'disable_point_group': True, 'disable_time_reversal': True},
+                {'disable_point_group': False, 'disable_time_reversal': True},
+                {'disable_point_group': True, 'disable_time_reversal': False},
+                {'disable_point_group': False, 'disable_time_reversal': False}]
+
+    # Test block parallelization (needs scalapack)
+    if world.size > 1 and compiled_with_sl():
+        settings.append({'disable_point_group': False,
+                         'disable_time_reversal': False,
+                         'nblocks': 2})
 
     # Calculate the dielectric functions
-    if world.rank == 0:
-        try:
-            os.remove('intraband_spinpaired+0+0+0.pckl')
-        except OSError:
-            pass
-
-    df1 = DielectricFunction('intraband_spinpaired.gpw',
-                             frequencies={'type': 'nonlinear',
-                                          'domega0': 0.03},
-                             ecut=10,
-                             rate=0.1,
-                             integrationmode='tetrahedron integration',
-                             name='intraband_spinpaired',
-                             txt='intraband_spinpaired_df.txt')
-
-    df1NLFCx, df1LFCx = df1.get_dielectric_function(direction='x')
-    df1NLFCy, df1LFCy = df1.get_dielectric_function(direction='y')
-    df1NLFCz, df1LFCz = df1.get_dielectric_function(direction='z')
-    wp1_vv = df1.chi0.plasmafreq_vv**0.5
-    wp1 = wp1_vv[0, 0]
-    if world.rank == 0:
-        try:
-            os.remove('intraband_spinpolarized+0+0+0.pckl')
-        except OSError:
-            pass
-
-    df2 = DielectricFunction('intraband_spinpolarized.gpw',
-                             frequencies={'type': 'nonlinear',
-                                          'domega0': 0.03},
-                             ecut=10,
-                             rate=0.1,
-                             integrationmode='tetrahedron integration',
-                             name='intraband_spinpolarized',
-                             txt='intraband_spinpolarized_df.txt')
-
-    df2NLFCx, df2LFCx = df2.get_dielectric_function(direction='x')
-    df2NLFCy, df2LFCy = df2.get_dielectric_function(direction='y')
-    df2NLFCz, df2LFCz = df2.get_dielectric_function(direction='z')
-    wp2_vv = df2.chi0.plasmafreq_vv**0.5
-    wp2 = wp2_vv[0, 0]
-
-    # Compare plasmon frequencies and intensities
-    w_w = df1.chi0.wd.omega_w
-
-    # Analytical Drude result
-    n = 1 / (a1.get_volume() * Bohr**-3)
-
-    wp = np.sqrt(4 * np.pi * n)
-
-    # From http://pubs.acs.org/doi/abs/10.1021/jp810808h
-    wpref = 5.71 / Hartree
-
-    equal(wp1, wp2, 1e-2)
-    equal(wp1, wp, 0.5)  # Use larger margin when comparing to Drude
-    equal(wp1, wpref, 0.1)
-
-    w1, I1 = findpeak(w_w, -(1. / df1LFCx).imag)
-    w2, I2 = findpeak(w_w, -(1. / df2LFCx).imag)
-    equal(w1, w2, 1e-2)
-    equal(I1, I2, 1e-1)
-
-    w1, I1 = findpeak(w_w, -(1. / df1LFCy).imag)
-    w2, I2 = findpeak(w_w, -(1. / df2LFCy).imag)
-    equal(w1, w2, 1e-2)
-    equal(I1, I2, 1e-1)
-
-    w1, I1 = findpeak(w_w, -(1. / df1LFCz).imag)
-    w2, I2 = findpeak(w_w, -(1. / df2LFCz).imag)
-    equal(w1, w2, 1e-2)
-    equal(I1, I2, 1e-1)
+    dfs0 = []  # Arrays to check for self-consistency
+    dfs1 = []
+    dfs2 = []
+    dfs3 = []
+    dfs4 = []
+    dfs5 = []
+    for kwargs in settings:
+        df1 = DielectricFunction('gs_Na_small.gpw',
+                                 ecut=40,
+                                 rate=0.001,
+                                 **kwargs)
+
+        df1NLFCx, df1LFCx = df1.get_dielectric_function(direction='x')
+        df1NLFCy, df1LFCy = df1.get_dielectric_function(direction='y')
+        df1NLFCz, df1LFCz = df1.get_dielectric_function(direction='z')
+
+        df2 = DielectricFunction('gs_Na_large.gpw',
+                                 ecut=40,
+                                 rate=0.001,
+                                 **kwargs)
+
+        df2NLFCx, df2LFCx = df2.get_dielectric_function(direction='x')
+        df2NLFCy, df2LFCy = df2.get_dielectric_function(direction='y')
+        df2NLFCz, df2LFCz = df2.get_dielectric_function(direction='z')
+
+        dfs0.append(df1NLFCx)
+        dfs1.append(df1LFCx)
+        dfs2.append(df1NLFCy)
+        dfs3.append(df1LFCy)
+        dfs4.append(df1NLFCz)
+        dfs5.append(df1LFCz)
+
+        # Compare plasmon frequencies and intensities
+        w_w = df1.wd.omega_w
+        w1, I1 = findpeak(w_w, -(1. / df1LFCx).imag)
+        w2, I2 = findpeak(w_w, -(1. / df2LFCx).imag)
+        equal(w1, w2, 1e-2)
+        equal(I1, I2, 1e-3)
+
+        w1, I1 = findpeak(w_w, -(1. / df1LFCy).imag)
+        w2, I2 = findpeak(w_w, -(1. / df2LFCy).imag)
+        equal(w1, w2, 1e-2)
+        equal(I1, I2, 1e-3)
+
+        w1, I1 = findpeak(w_w, -(1. / df1LFCz).imag)
+        w2, I2 = findpeak(w_w, -(1. / df2LFCz).imag)
+        equal(w1, w2, 1e-2)
+        equal(I1, I2, 1e-3)
+
+    # Check for self-consistency
+    for i, dfs in enumerate([dfs0, dfs1, dfs2, dfs3, dfs4, dfs5]):
+        while len(dfs):
+            df = dfs.pop()
+            for df2 in dfs:
+                try:
+                    assert np.max(np.abs((df - df2) / df)) < 1e-3
+                except AssertionError:
+                    print(np.max(np.abs((df - df2) / df)))
+                    raise AssertionError
```

### Comparing `gpaw-22.8.0/gpaw/test/response/test_graphene.py` & `gpaw-23.6.0/gpaw/test/response/test_graphene.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/response/test_graphene_EELS.py` & `gpaw-23.6.0/gpaw/test/response/test_graphene_EELS.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/response/test_gw_MoS2_cut.py` & `gpaw-23.6.0/gpaw/test/response/test_gw_MoS2_cut.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,54 +1,62 @@
 import pytest
 from ase import Atoms
 from ase.lattice.hexagonal import Hexagonal
 from gpaw import GPAW, FermiDirac
 from gpaw.response.g0w0 import G0W0
 
 
-@pytest.mark.response
-def test_response_gw_MoS2_cut(in_tmp_dir, scalapack):
-    if 1:
-        calc = GPAW(mode='pw',
-                    xc='PBE',
-                    experimental={'niter_fixdensity': 2},
-                    nbands=16,
-                    setups={'Mo': '6'},
-                    eigensolver='rmm-diis',
-                    occupations=FermiDirac(0.001),
-                    kpts={'size': (6, 6, 1), 'gamma': True})
-
-        a = 3.1604
-        c = 10.0
-
-        cell = Hexagonal(symbol='Mo',
-                         latticeconstant={'a': a, 'c': c}).get_cell()
-        layer = Atoms(symbols='MoS2', cell=cell, pbc=True,
-                      scaled_positions=[(0, 0, 0),
-                                        (2 / 3, 1 / 3, 0.3),
-                                        (2 / 3, 1 / 3, -0.3)])
-
-        pos = layer.get_positions()
-        pos[1][2] = pos[0][2] + 3.172 / 2
-        pos[2][2] = pos[0][2] - 3.172 / 2
-        layer.set_positions(pos)
-        layer.calc = calc
-        layer.get_potential_energy()
-        calc.write('MoS2.gpw', mode='all')
+@pytest.fixture
+def gpwfile(in_tmp_dir):
+    calc = GPAW(
+        mode='pw',
+        xc='PBE',
+        experimental={'niter_fixdensity': 2},
+        nbands=16,
+        convergence={'bands': 15},
+        setups={'Mo': '6'},
+        occupations=FermiDirac(0.001),
+        kpts={'size': (3, 3, 1), 'gamma': True})
+
+    a = 3.1604
+    c = 10.0
+
+    cell = Hexagonal(symbol='Mo',
+                     latticeconstant={'a': a, 'c': c}).get_cell()
+    layer = Atoms(symbols='MoS2', cell=cell, pbc=True,
+                  scaled_positions=[(0, 0, 0),
+                                    (2 / 3, 1 / 3, 0.3),
+                                    (2 / 3, 1 / 3, -0.3)])
+
+    pos = layer.get_positions()
+    pos[1][2] = pos[0][2] + 3.172 / 2
+    pos[2][2] = pos[0][2] - 3.172 / 2
+    layer.set_positions(pos)
+    layer.calc = calc
+    layer.get_potential_energy()
+    fname = 'MoS2.gpw'
+    calc.write(fname, mode='all')
+    return fname
+
 
-    gw = G0W0('MoS2.gpw',
+@pytest.mark.response
+def test_response_gw_MoS2_cut(scalapack, gpwfile, needs_ase_master):
+    gw = G0W0(gpwfile,
               'gw-test',
               nbands=15,
               ecut=10,
               eta=0.2,
               frequencies={'type': 'nonlinear', 'domega0': 0.1},
               truncation='2D',
               kpts=[((1 / 3, 1 / 3, 0))],
-              bands=(8, 10),
-              savepckl=True)
+              bands=(8, 10))
 
     e_qp = gw.calculate()['qp'][0, 0]
 
-    ev = 2.669
-    ec = 6.831
+    paths = gw.savepckl()
+    for path in paths.values():
+        assert path.exists()
+
+    ev = 2.392
+    ec = 7.337
     assert e_qp[0] == pytest.approx(ev, abs=0.01)
     assert e_qp[1] == pytest.approx(ec, abs=0.01)
```

### Comparing `gpaw-22.8.0/gpaw/test/response/test_gw_restart_file.py` & `gpaw-23.6.0/gpaw/test/response/test_gw_restart_file.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,45 +1,40 @@
 import pytest
 import numpy as np
 from gpaw.response.g0w0 import G0W0
-from os.path import exists
 from gpaw.mpi import world
 
 
 class FragileG0W0(G0W0):
     def calculate_q(self, *args, **kwargs):
         if not hasattr(self, 'doom'):
             self.doom = 0
         self.doom += 1  # Advance doom
         if self.doom == 12:
             raise ValueError('Cthulhu awakens')
         G0W0.calculate_q(self, *args, **kwargs)
 
 
 @pytest.mark.response
-def test_restart_file(in_tmp_dir, gpw_files):
+def test_restart_file(in_tmp_dir, gpw_files, needs_ase_master):
     kwargs = dict(bands=(3, 5),
                   nbands=9,
                   nblocks=world.size,
                   ecut=40,
-                  kpts=[0, 1],
-                  restartfile='restartfile')
+                  kpts=[0, 1])
     gw = FragileG0W0(gpw_files['bn_pw_wfs'], **kwargs)
     with pytest.raises(ValueError, match='Cthulhu*'):
         gw.calculate()
 
     assert gw.doom == 12
 
-    assert exists('restartfile.sigma.pckl')
-
     # Use FragileG0W0 also in the restart.
     # The FragileG0W0 cannot by itself calculate the full thing because
     # calculate_q is called 16 times in total. Thus, it must be that
     # it was helped by the previous calculation.
     gw = FragileG0W0(gpw_files['bn_pw_wfs'], **kwargs)
     results = gw.calculate()
 
-    kwargs.pop('restartfile')
-    gw = G0W0(gpw_files['bn_pw_wfs'], **kwargs)
+    gw = G0W0(gpw_files['bn_pw_wfs'], filename='referencecalc', **kwargs)
     results2 = gw.calculate()
 
     assert np.allclose(results['qp'], results2['qp'])
```

### Comparing `gpaw-22.8.0/gpaw/test/response/test_gw_si.py` & `gpaw-23.6.0/gpaw/test/response/test_gw_si.py`

 * *Files 20% similar despite different names*

```diff
@@ -26,56 +26,82 @@
                       convergence={'density': 1e-7},
                       parallel={'domain': 1},
                       txt='si.txt')
     e = atoms.get_potential_energy()
     scalapack = atoms.calc.wfs.bd.comm.size
     atoms.calc.diagonalize_full_hamiltonian(nbands=8, scalapack=scalapack)
     atoms.calc.write('si.gpw', mode='all')
-    # The first iteration of the loop has very few frequencies.
-    # The test is, that code should still not crash.
-    # The second iteration is the actual numerical test, which
-    # will be returned and asserted outside this function.
-    for omegamax in [0.2, None]:
-        gw = G0W0('si.gpw',
-                  'gw',
-                  nbands=8,
-                  integrate_gamma=0,
-                  kpts=[(0, 0, 0), (0.5, 0.5, 0)],  # Gamma, X
-                  ecut=40,
-                  nblocks=nblocks,
-                  frequencies={'type': 'nonlinear',
-                               'domega0': 0.1, 'omegamax': omegamax},
-                  eta=0.2,
-                  relbands=(-1, 2))
-        results = gw.calculate()
+
+    # This tests checks the actual numerical accuracy which is asserted below
+    gw = G0W0('si.gpw', 'gw_None',
+              nbands=8, integrate_gamma=0,
+              kpts=[(0, 0, 0), (0.5, 0.5, 0)],  # Gamma, X
+              ecut=40, nblocks=nblocks,
+              frequencies={'type': 'nonlinear',
+                           'domega0': 0.1, 'omegamax': None},
+              eta=0.2, relbands=(-1, 2))
+    results = gw.calculate()
 
     G, X = results['eps'][0]
     output = [e, G[0], G[1] - G[0], X[1] - G[0], X[2] - X[1]]
     G, X = results['qp'][0]
     output += [G[0], G[1] - G[0], X[1] - G[0], X[2] - X[1]]
 
     return output
 
 
 reference = pytest.approx([-9.253, 5.442, 2.389, 0.403, 0.000,
-                           6.261, 3.570, 1.323, 0.001], abs=0.003)
+                           6.261, 3.570, 1.323, 0.001], abs=0.0035)
 
 
 @pytest.mark.response
 @pytest.mark.slow
 @pytest.mark.parametrize('si', generate_si_systems())
 @pytest.mark.parametrize('symm', [{},
                                   'off',
                                   {'time_reversal': False},
                                   {'point_group': False}])
 @pytest.mark.parametrize('nblocks',
                          [x for x in [1, 2, 4, 8] if x <= world.size])
-def test_response_gwsi(in_tmp_dir, si, symm, nblocks, scalapack):
+def test_response_gwsi(in_tmp_dir, si, symm, nblocks, scalapack,
+                       needs_ase_master):
     assert run(si, symm, nblocks) == reference
 
 
 @pytest.mark.response
 @pytest.mark.ci
 @pytest.mark.parametrize('si', generate_si_systems())
 @pytest.mark.parametrize('symm', [{}])
-def test_small_response_gwsi(in_tmp_dir, si, symm, scalapack):
+def test_small_response_gwsi(in_tmp_dir, si, symm, scalapack,
+                             needs_ase_master):
     assert run(si, symm, 1) == reference
+
+
+@pytest.mark.response
+@pytest.mark.ci
+def test_few_freq_response_gwsi(in_tmp_dir, scalapack, needs_ase_master):
+    if world.size > 1:
+        nblocks = 2
+    else:
+        nblocks = 1
+
+    # This test has very few frequencies and tests that the code doesn't crash.
+    atoms = bulk('Si', 'diamond', a=5.43)
+    atoms.calc = GPAW(mode=PW(250),
+                      eigensolver='rmm-diis',
+                      occupations=FermiDirac(0.01),
+                      kpts={'size': (2, 2, 2), 'gamma': True},
+                      convergence={'density': 1e-7},
+                      parallel={'domain': 1},
+                      txt='si.txt')
+    atoms.get_potential_energy()
+    scalapack = atoms.calc.wfs.bd.comm.size
+    atoms.calc.diagonalize_full_hamiltonian(nbands=8, scalapack=scalapack)
+    atoms.calc.write('si.gpw', mode='all')
+    gw = G0W0('si.gpw', 'gw_0.2',
+              nbands=8, integrate_gamma=0,
+              kpts=[(0, 0, 0), (0.5, 0.5, 0)],  # Gamma, X
+              ecut=40, nblocks=nblocks,
+              frequencies={'type': 'nonlinear',
+                           'domega0': 0.1, 'omegamax': 0.2},
+              eta=0.2, relbands=(-1, 2))
+    gw.calculate()
```

### Comparing `gpaw-22.8.0/gpaw/test/response/test_gw_too.py` & `gpaw-23.6.0/gpaw/test/response/test_gw_too.py`

 * *Files 22% similar despite different names*

```diff
@@ -2,36 +2,33 @@
 from gpaw.mpi import world
 import numpy as np
 from gpaw.response.g0w0 import G0W0
 import pickle
 
 
 @pytest.mark.response
-def test_do_GW_too(in_tmp_dir, gpw_files, scalapack):
-
-    ecut_extrapolation = True
-    gw0 = G0W0(gpw_files['bn_pw_wfs'],
+def test_do_GW_too(in_tmp_dir, gpw_files, scalapack, needs_ase_master):
+    gw0 = G0W0(gpw_files['c_pw_wfs'], 'gw0',
                bands=(3, 5),
                nblocks=1,
-               ecut_extrapolation=ecut_extrapolation,
-               ecut=40,
-               restartfile=None)
-
+               ecut_extrapolation=True,
+               ecut=40)
     results0 = gw0.calculate()
 
-    gw = G0W0(gpw_files['bn_pw_wfs'],
+    gw = G0W0(gpw_files['c_pw_wfs'], 'gwtoo',
               bands=(3, 5),
               nblocks=1,
               xc='rALDA',
-              ecut_extrapolation=ecut_extrapolation,
+              ecut_extrapolation=True,
               ecut=40,
               fxc_mode='GWP',
-              do_GW_too=True,
-              restartfile=None)
+              do_GW_too=True)
 
     gw.calculate()
 
     world.barrier()
 
-    with open('gw_results_GW.pckl', 'rb') as handle:
+    files = gw.savepckl()
+
+    with open(files['GW'], 'rb') as handle:
         results_GW = pickle.load(handle)
     np.testing.assert_allclose(results0['qp'], results_GW['qp'], rtol=1e-03)
```

### Comparing `gpaw-22.8.0/gpaw/test/response/test_gw_vertex.py` & `gpaw-23.6.0/gpaw/test/response/test_gw_vertex.py`

 * *Files 23% similar despite different names*

```diff
@@ -3,17 +3,17 @@
 from gpaw.response.g0w0 import G0W0
 
 
 @pytest.mark.response
 @pytest.mark.parametrize('fxc_mode, ref_gap', [
     ('GWP', 4.667170),
     ('GWS', 4.988230),
-    ('GWG', 4.894904)
-])
-def test_fxc_mode(in_tmp_dir, gpw_files, fxc_mode, ref_gap, scalapack):
+    ('GWG', 4.894904)])
+def test_fxc_mode(in_tmp_dir, gpw_files, fxc_mode, ref_gap, scalapack,
+                  needs_ase_master):
     gw = G0W0(gpw_files['bn_pw_wfs'],
               bands=(3, 5),
               nbands=9,
               nblocks=1,
               xc='rALDA',
               ecut=40,
               fxc_mode=fxc_mode)
```

### Comparing `gpaw-22.8.0/gpaw/test/response/test_heisenberg.py` & `gpaw-23.6.0/gpaw/test/response/test_heisenberg.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/response/test_iron_sf_ALDA.py` & `gpaw-23.6.0/gpaw/test/response/test_iron_sf_ALDA.py`

 * *Files 22% similar despite different names*

```diff
@@ -6,177 +6,137 @@
  * Different kernel calculation strategies
  * Different chi0 transitions summation strategies
 """
 
 import numpy as np
 import pytest
 
-import time
-
-from ase.build import bulk
-from ase.dft.kpoints import monkhorst_pack
-from ase.parallel import parprint
-
-from gpaw import GPAW, PW
-from gpaw.response.tms import TransverseMagneticSusceptibility
-from gpaw.response.susceptibility import read_macroscopic_component
-from gpaw.test import findpeak, equal
+from gpaw import GPAW
+from gpaw.test import findpeak
 from gpaw.mpi import world
 
+from gpaw.response import ResponseGroundStateAdapter
+from gpaw.response.chiks import ChiKSCalculator
+from gpaw.response.susceptibility import ChiFactory
+from gpaw.response.fxc_kernels import AdiabaticFXCCalculator
+from gpaw.response.pair_functions import read_pair_function
+from gpaw.test.conftest import response_band_cutoff
 
 pytestmark = pytest.mark.skipif(world.size < 4, reason='world.size < 4')
 
 
 @pytest.mark.kspair
 @pytest.mark.response
-def test_response_iron_sf_ALDA(in_tmp_dir, scalapack):
-    # ------------------- Inputs ------------------- #
-
-    # Part 1: ground state calculation
-    xc = 'LDA'
-    kpts = 4
-    nb = 6
-    pw = 300
-    conv = {'density': 1.e-8,
-            'forces': 1.e-8}
-    a = 2.867
-    mm = 2.21
+def test_response_iron_sf_ALDA(in_tmp_dir, gpw_files, scalapack):
+    # ---------- Inputs ---------- #
 
-    # Part 2: magnetic response calculation
+    # Magnetic response calculation
     q_c = [0.0, 0.0, 1 / 4.]
     fxc = 'ALDA'
     ecut = 300
-    eta = 0.01
+    eta = 0.1
 
     # Test different kernel, summation and symmetry strategies
-    # rshelmax, rshewmin, bandsummation, bundle_integrals, disable_syms
-    strat_sd = [(None, None, 'pairwise', True, False),
-                (-1, 0.001, 'pairwise', True, False),
-                (-1, 0.001, 'pairwise', False, False),
-                (-1, 0.000001, 'pairwise', True, False),
-                (-1, 0.000001, 'double', True, False),
-                (-1, 0.000001, 'double', True, True),
-                (-1, None, 'pairwise', True, False),
-                (3, None, 'pairwise', True, False)]
-    frq_sw = [np.linspace(0.160, 0.320, 21),
-              np.linspace(0.320, 0.480, 21),
-              np.linspace(0.320, 0.480, 21),
-              np.linspace(0.320, 0.480, 21),
-              np.linspace(0.320, 0.480, 21),
-              np.linspace(0.320, 0.480, 21),
-              np.linspace(0.320, 0.480, 21),
-              np.linspace(0.320, 0.480, 21),
-              np.linspace(0.320, 0.480, 21)]
-
-    # ------------------- Script ------------------- #
-
-    # Part 1: ground state calculation
-
-    t1 = time.time()
-
-    Febcc = bulk('Fe', 'bcc', a=a)
-    Febcc.set_initial_magnetic_moments([mm])
-
-    calc = GPAW(xc=xc,
-                mode=PW(pw),
-                kpts=monkhorst_pack((kpts, kpts, kpts)),
-                nbands=nb,
-                convergence=conv,
-                symmetry={'point_group': False},
-                parallel={'domain': 1})
-
-    Febcc.calc = calc
-    Febcc.get_potential_energy()
-    t2 = time.time()
-
-    # Part 2: magnetic response calculation
+    # rshelmax, rshewmin, bandsummation, disable_syms
+    strat_sd = [(None, None, 'pairwise', False),
+                (-1, 0.001, 'pairwise', False),
+                (-1, 0.000001, 'pairwise', False),
+                (-1, 0.000001, 'double', False),
+                (-1, 0.000001, 'double', True),
+                (-1, None, 'pairwise', False),
+                (3, None, 'pairwise', False)]
+    frq_sw = [np.linspace(0.320, 0.480, 21),
+              np.linspace(0.420, 0.580, 21),
+              np.linspace(0.420, 0.580, 21),
+              np.linspace(0.420, 0.580, 21),
+              np.linspace(0.420, 0.580, 21),
+              np.linspace(0.420, 0.580, 21),
+              np.linspace(0.420, 0.580, 21),
+              np.linspace(0.420, 0.580, 21)]
+
+    # ---------- Script ---------- #
+
+    calc = GPAW(gpw_files['fe_pw_wfs'], parallel=dict(domain=1))
+    nbands = response_band_cutoff['fe_pw_wfs']
+    gs = ResponseGroundStateAdapter(calc)
 
-    for s, ((rshelmax, rshewmin, bandsummation, bundle_integrals,
+    for s, ((rshelmax, rshewmin, bandsummation,
              disable_syms), frq_w) in enumerate(zip(strat_sd, frq_sw)):
-        tms = TransverseMagneticSusceptibility(
-            calc,
-            fxc=fxc,
-            eta=eta,
-            ecut=ecut,
-            bandsummation=bandsummation,
-            fxckwargs={'rshelmax': rshelmax,
-                       'rshewmin': rshewmin},
-            bundle_integrals=bundle_integrals,
-            disable_point_group=disable_syms,
-            disable_time_reversal=disable_syms,
-            nblocks=2)
-        tms.get_macroscopic_component(
-            '+-', q_c, frq_w,
-            filename='iron_dsus' + '_G%d.csv' % (s + 1))
-        tms.write_timer()
-
-    t3 = time.time()
-
-    parprint('Ground state calculation took', (t2 - t1) / 60, 'minutes')
-    parprint('Excited state calculations took', (t3 - t2) / 60, 'minutes')
+        complex_frequencies = frq_w + 1.j * eta
+        chiks_calc = ChiKSCalculator(gs,
+                                     nbands=nbands,
+                                     ecut=ecut,
+                                     bandsummation=bandsummation,
+                                     disable_point_group=disable_syms,
+                                     disable_time_reversal=disable_syms,
+                                     nblocks=2)
+        fxc_calculator = AdiabaticFXCCalculator.from_rshe_parameters(
+            gs, chiks_calc.context,
+            rshelmax=rshelmax,
+            rshewmin=rshewmin)
+        chi_factory = ChiFactory(chiks_calc, fxc_calculator)
+        _, chi = chi_factory('+-', q_c, complex_frequencies, fxc=fxc)
+        chi.write_macroscopic_component('iron_dsus' + '_G%d.csv' % (s + 1))
+        chi_factory.context.write_timer()
 
     world.barrier()
 
-    # Part 3: identify magnon peak in scattering functions
-    w1_w, chiks1_w, chi1_w = read_macroscopic_component('iron_dsus_G1.csv')
-    w2_w, chiks2_w, chi2_w = read_macroscopic_component('iron_dsus_G2.csv')
-    w3_w, chiks3_w, chi3_w = read_macroscopic_component('iron_dsus_G3.csv')
-    w4_w, chiks4_w, chi4_w = read_macroscopic_component('iron_dsus_G4.csv')
-    w5_w, chiks5_w, chi5_w = read_macroscopic_component('iron_dsus_G5.csv')
-    w6_w, chiks6_w, chi6_w = read_macroscopic_component('iron_dsus_G6.csv')
-    w7_w, chiks7_w, chi7_w = read_macroscopic_component('iron_dsus_G7.csv')
-    w8_w, chiks8_w, chi8_w = read_macroscopic_component('iron_dsus_G8.csv')
+    # Identify magnon peak in scattering functions
+    w1_w, chi1_w = read_pair_function('iron_dsus_G1.csv')
+    w2_w, chi2_w = read_pair_function('iron_dsus_G2.csv')
+    w3_w, chi3_w = read_pair_function('iron_dsus_G3.csv')
+    w4_w, chi4_w = read_pair_function('iron_dsus_G4.csv')
+    w5_w, chi5_w = read_pair_function('iron_dsus_G5.csv')
+    w6_w, chi6_w = read_pair_function('iron_dsus_G6.csv')
+    w7_w, chi7_w = read_pair_function('iron_dsus_G7.csv')
+    print(-chi1_w.imag)
+    print(-chi2_w.imag)
 
     wpeak1, Ipeak1 = findpeak(w1_w, -chi1_w.imag)
     wpeak2, Ipeak2 = findpeak(w2_w, -chi2_w.imag)
     wpeak3, Ipeak3 = findpeak(w3_w, -chi3_w.imag)
     wpeak4, Ipeak4 = findpeak(w4_w, -chi4_w.imag)
     wpeak5, Ipeak5 = findpeak(w5_w, -chi5_w.imag)
     wpeak6, Ipeak6 = findpeak(w6_w, -chi6_w.imag)
     wpeak7, Ipeak7 = findpeak(w7_w, -chi7_w.imag)
-    wpeak8, Ipeak8 = findpeak(w8_w, -chi8_w.imag)
 
     mw1 = wpeak1 * 1000
     mw2 = wpeak2 * 1000
     mw3 = wpeak3 * 1000
     mw4 = wpeak4 * 1000
     mw5 = wpeak5 * 1000
     mw6 = wpeak6 * 1000
     mw7 = wpeak7 * 1000
-    mw8 = wpeak8 * 1000
 
-    # Part 4: compare new results to test values
-    test_mw1 = 234.63  # meV
-    test_mw2 = 397.33  # meV
-    test_mw4 = 398.83  # meV
-    test_Ipeak1 = 56.74  # a.u.
-    test_Ipeak2 = 55.80  # a.u.
-    test_Ipeak4 = 58.23  # a.u.
+    # Compare new results to test values
+    print(mw1, mw2, mw3, Ipeak1, Ipeak2, Ipeak3)
+    test_mw1 = 402.  # meV
+    test_mw2 = 490.  # meV
+    test_mw3 = 490.  # meV
+    test_Ipeak1 = 4.10  # a.u.
+    test_Ipeak2 = 5.05  # a.u.
+    test_Ipeak3 = 5.04  # a.u.
 
     # Different kernel strategies should remain the same
     # Magnon peak:
-    equal(mw1, test_mw1, eta * 250)
-    equal(mw2, test_mw2, eta * 250)
-    equal(mw4, test_mw4, eta * 250)
+    assert mw1 == pytest.approx(test_mw1, abs=25.)
+    assert mw2 == pytest.approx(test_mw2, abs=25.)
+    assert mw3 == pytest.approx(test_mw3, abs=25.)
 
     # Scattering function intensity:
-    equal(Ipeak1, test_Ipeak1, 2.5)
-    equal(Ipeak2, test_Ipeak2, 2.5)
-    equal(Ipeak4, test_Ipeak4, 2.5)
-
-    # The bundled and unbundled integration methods should give the same
-    equal(mw2, mw3, eta * 100)
-    equal(Ipeak2, Ipeak3, 1.0)
+    assert Ipeak1 == pytest.approx(test_Ipeak1, abs=0.5)
+    assert Ipeak2 == pytest.approx(test_Ipeak2, abs=0.5)
+    assert Ipeak3 == pytest.approx(test_Ipeak3, abs=0.5)
 
     # The two transitions summation strategies should give identical results
-    equal(mw4, mw5, eta * 100)
-    equal(Ipeak4, Ipeak5, 1.0)
+    assert mw3 == pytest.approx(mw4, abs=25.)
+    assert Ipeak3 == pytest.approx(Ipeak4, abs=0.5)
 
     # Toggling symmetry should preserve the result
-    equal(mw6, mw4, eta * 100)
-    equal(Ipeak6, Ipeak4, 1.0)
+    assert mw5 == pytest.approx(mw4, abs=25.)
+    assert Ipeak5 == pytest.approx(Ipeak4, abs=0.5)
 
     # Including vanishing coefficients should not matter for the result
-    equal(mw7, mw4, eta * 100)
-    equal(Ipeak7, Ipeak4, 1.0)
-    equal(mw8, mw2, eta * 100)
-    equal(Ipeak8, Ipeak2, 1.0)
+    assert mw6 == pytest.approx(mw3, abs=2.)
+    assert Ipeak6 == pytest.approx(Ipeak3, abs=0.1)
+    assert mw7 == pytest.approx(mw2, abs=2.)
+    assert Ipeak7 == pytest.approx(Ipeak2, abs=0.1)
```

### Comparing `gpaw-22.8.0/gpaw/test/response/test_iron_sf_gssALDA.py` & `gpaw-23.6.0/gpaw/utilities/hilbert.py`

 * *Files 27% similar despite different names*

```diff
@@ -1,123 +1,111 @@
+import numpy as np
+from numpy.fft import fft, ifft
+
 """
-Calculate the magnetic response in iron using ALDA.
+Methods for perfoming the Hilbert transform of a function::
 
-Fast test, where the kernel is scaled to fulfill the Goldstone theorem.
+                     +oo
+            1       /     f(x)
+  H[f](y) = -- p.v. | dx -----
+            pi      /    x - y
+                     -oo
 """
 
-# Workflow modules
-import pytest
-import numpy as np
 
-# Script modules
-import time
+def hilbert_kernel_simple(n):
+    """Construct Hilbert kernel with n grid points.
 
-from ase.build import bulk
-from ase.dft.kpoints import monkhorst_pack
-from ase.parallel import parprint
-
-from gpaw import GPAW, PW
-from gpaw.response.tms import TransverseMagneticSusceptibility
-from gpaw.response.susceptibility import read_macroscopic_component
-from gpaw.test import findpeak, equal
-from gpaw.mpi import world
-
-
-@pytest.mark.kspair
-@pytest.mark.response
-def test_response_iron_sf_gssALDA(in_tmp_dir):
-    # ------------------- Inputs ------------------- #
-
-    # Part 1: ground state calculation
-    xc = 'LDA'
-    kpts = 4
-    nb = 6
-    pw = 300
-    a = 2.867
-    mm = 2.21
-
-    # Part 2: magnetic response calculation
-    q_qc = [[0.0, 0.0, 0.0], [0.0, 0.0, 1. / 4.]]  # Two q-points along G-N
-    frq_qw = [np.linspace(-0.080, 0.120, 26), np.linspace(0.100, 0.300, 26)]
-    fxc = 'ALDA'
-    fxc_scaling = [True, None, 'fm']
-    ecut = 300
-    eta = 0.01
-    if world.size > 1:
-        nblocks = 2
+    This is just the discrete Fourier transform of 1 / x.
+    """
+    ker = np.zeros(n, dtype=complex)
+    ker[1: n / 2] = 1.j
+    ker[n / 2 + 1:] = -1.j
+    return ker
+
+
+def hilbert_kernel_interpolate(n):
+    """Construct Hilbert kernel with n grid points.
+
+    This is just the discrete Hilbert transform of the linear
+    interpolation kernel `L(s) = (1 - |s|) Heaviside(1 - |s|)`.
+    """
+    # middle grid point
+    mid = (n + 1) / 2
+
+    # Make auxiliary array
+    aux = np.arange(mid + 1, dtype=float)
+    np.multiply(aux[1:], np.log(aux[1:]), aux[1:])
+
+    # Make kernel
+    ker = np.zeros(n, float)
+    ker[1: mid] = aux[2:] - 2 * aux[1:-1] + aux[:-2]
+    ker[-1: -mid: -1] = -ker[1: mid]
+
+    return -fft(ker) / np.pi
+
+
+def hilbert(f, ker=None, nfft=None, axis=0,
+            kerneltype='interpolate', translate=0):
+    """Perform Hilbert transform *f* along specified *axis*. The transform is
+       made as a convolution of *f* with the Hilbert kernel.
+
+       *ker* is the Hilbert kernel, which will be calculated if set to None.
+
+       *nfft* is the number of grid points used in the fft. If *nfft* is larger
+       than *f* along the transform axis, *f* will be zero-padded to make up
+       the difference. If *nfft* is smaller, the first *nfft* elements of *f*
+       will be used. *nfft* defaults to two times the the length of *f* along
+       *axis*.
+
+       *kerneltype* specifies the kerneltype, and can be one of 'interpolate'
+       or 'simple'.
+
+       *translate* is the number of grid points *f* should be shifted. This can
+       be a non-integer amount. translate=10 means that f(x + 10) is
+       transformed instead of f(x).
+    """
+    # Number of transform grid points
+    n = f.shape[axis]
+
+    # Number of grid points in fft
+    if nfft is None:
+        nfft = 2 * n
+
+    # Generate new kernel if needed
+    if ker is None:
+        ker = eval('hilbert_kernel_' + kerneltype)(nfft)
+
+    # Reshape kernel
+    ker_shape = [1] * len(f.shape)
+    ker_shape[axis] = nfft
+    ker.shape = tuple(ker_shape)
+
+    # Construct translation operator
+    if translate == 0:
+        trans = 1
     else:
-        nblocks = 1
-
-    # ------------------- Script ------------------- #
-
-    # Part 1: ground state calculation
-
-    t1 = time.time()
+        trans = (np.arange(nfft) + (nfft - 1) / 2) % nfft - (nfft - 1) / 2
+#          nfft = 8 ->       [ 0  1  2  3  4 -3 -2 -1]
+#       trans = (np.arange(nfft) + nfft / 2) % nfft - nfft / 2
+#          nfft = 8 ->       [ 0  1  2  3 -4 -3 -2 -1]
+        trans = np.exp(1.j * translate * 2 * np.pi / nfft * trans)
+        trans.shape = ker.shape
+
+    # Make convolution of f and kernel
+    hil = ifft(fft(f, n=nfft, axis=axis) * ker * trans, axis=axis)
+    return hil[0:n]
+
+
+def analytic_transforms(x):
+    """Returns a list of functions and their Hilbert transforms"""
+    func_l = [np.sin(x),
+              np.cos(x),
+              np.where(x == 0, 1, np.sin(x) / x),
+              1 / (1 + x**2)]
+
+    hfunc_l = [np.cos(x),
+               -np.sin(x),
+               np.where(x == 0, 0, (np.cos(x) - 1) / x),
+               -x / (1 + x**2)]
 
-    Febcc = bulk('Fe', 'bcc', a=a)
-    Febcc.set_initial_magnetic_moments([mm])
-
-    calc = GPAW(xc=xc,
-                mode=PW(pw),
-                kpts=monkhorst_pack((kpts, kpts, kpts)),
-                nbands=nb,
-                symmetry={'point_group': False},
-                parallel={'domain': 1})
-
-    Febcc.calc = calc
-    Febcc.get_potential_energy()
-    calc.write('Fe', 'all')
-    t2 = time.time()
-
-    # Part 2: magnetic response calculation
-    fxckwargs = {'rshelmax': None, 'fxc_scaling': fxc_scaling}
-    tms = TransverseMagneticSusceptibility('Fe',
-                                           fxc=fxc,
-                                           eta=eta,
-                                           ecut=ecut,
-                                           fxckwargs=fxckwargs,
-                                           gammacentered=True,
-                                           nblocks=nblocks)
-
-    for q in range(2):
-        tms.get_macroscopic_component(
-            '+-', q_qc[q], frq_qw[q],
-            filename='iron_dsus' + '_%d.csv' % (q + 1))
-        tms.write_timer()
-
-    t3 = time.time()
-
-    parprint('Ground state calculation took', (t2 - t1) / 60, 'minutes')
-    parprint('Excited state calculation took', (t3 - t2) / 60, 'minutes')
-
-    world.barrier()
-
-    # Part 3: identify magnon peaks in scattering function
-    w1_w, chiks1_w, chi1_w = read_macroscopic_component('iron_dsus_1.csv')
-    w2_w, chiks2_w, chi2_w = read_macroscopic_component('iron_dsus_2.csv')
-
-    print(w1_w, -chi1_w.imag)
-    print(w2_w, -chi2_w.imag)
-
-    wpeak1, Ipeak1 = findpeak(w1_w, -chi1_w.imag)
-    wpeak2, Ipeak2 = findpeak(w2_w, -chi2_w.imag)
-
-    mw1 = wpeak1 * 1000
-    mw2 = wpeak2 * 1000
-
-    # Part 4: compare new results to test values
-    test_fxcs = 1.033
-    test_mw1 = -0.03  # meV
-    test_mw2 = 176.91  # meV
-    test_Ipeak1 = 71.20  # a.u.
-    test_Ipeak2 = 44.46  # a.u.
-
-    # fxc_scaling:
-    equal(fxc_scaling[1], test_fxcs, 0.005)
-
-    # Magnon peak:
-    equal(mw1, test_mw1, 0.1)
-    equal(mw2, test_mw2, eta * 650)
-
-    # Scattering function intensity:
-    equal(Ipeak1, test_Ipeak1, 5)
-    equal(Ipeak2, test_Ipeak2, 5)
+    return func_l, hfunc_l
```

### Comparing `gpaw-22.8.0/gpaw/test/response/test_na_plasmons.py` & `gpaw-23.6.0/gpaw/test/response/test_na_plasmons.py`

 * *Files 2% similar despite different names*

```diff
@@ -35,22 +35,22 @@
     df1 = DielectricFunction('gs_Na.gpw',
                              nblocks=1,
                              ecut=40,
                              rate=0.001,
                              txt='1block.txt')
 
     df1NLFCx, df1LFCx = df1.get_dielectric_function(direction='x')
-    
+
     df2 = DielectricFunction('gs_Na.gpw',
                              nblocks=4,
                              ecut=40,
                              rate=0.001,
                              txt='4block.txt')
 
     df2NLFCx, df2LFCx = df2.get_dielectric_function(direction='x')
 
     # Compare plasmon frequencies and intensities
-    w_w = df1.chi0.wd.omega_w
+    w_w = df1.wd.omega_w
     w1, I1 = findpeak(w_w, -(1. / df1LFCx).imag)
     w2, I2 = findpeak(w_w, -(1. / df2LFCx).imag)
     equal(w1, w2, 1e-2)
     equal(I1, I2, 1e-3)
```

### Comparing `gpaw-22.8.0/gpaw/test/response/test_na_plasmons_tetrahedron.py` & `gpaw-23.6.0/gpaw/test/response/test_na_plasmons_tetrahedron.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,13 +1,13 @@
 import pytest
 from ase import Atoms
 from gpaw.mpi import world
 from gpaw import GPAW, PW
 from gpaw.response.df import DielectricFunction
-from gpaw.test import equal, findpeak
+from gpaw.test import findpeak
 
 # Comparing the EELS spectrum of sodium for different block
 # parallelizations. Intended to be run with 8 cores.
 
 pytestmark = pytest.mark.skipif(world.size < 4, reason='world.size < 4')
 
 
@@ -28,35 +28,55 @@
     a1.get_potential_energy()
     a1.calc.diagonalize_full_hamiltonian(nbands=20)
     a1.calc.write('gs_Na.gpw', 'all')
 
     kwargs = {'integrationmode': 'tetrahedron integration',
               'ecut': 40}
 
-    # Calculate the dielectric functions
+    # Calculate the dielectric functions: tetrahedral 1 block
     df1 = DielectricFunction('gs_Na.gpw',
                              rate=0.001,
                              nblocks=1,
                              txt='1block.txt',
                              **kwargs)
-
     df1NLFCx, df1LFCx = df1.get_dielectric_function(direction='x')
-    # df1NLFCy, df1LFCy = df1.get_dielectric_function(direction='y')
-    # df1NLFCz, df1LFCz = df1.get_dielectric_function(direction='z')
 
+    # tetrahedral 4 blocks
     df2 = DielectricFunction('gs_Na.gpw',
                              rate=0.001,
                              nblocks=4,
                              txt='4block.txt',
                              **kwargs)
-
     df2NLFCx, df2LFCx = df2.get_dielectric_function(direction='x')
-    # df2NLFCy, df2LFCy = df2.get_dielectric_function(direction='y')
-    # df2NLFCz, df2LFCz = df2.get_dielectric_function(direction='z')
+
+    # tetrahedron integration 4 blocks with large eta
+    kwargs.update({'eta': 4.25})
+    df3 = DielectricFunction('gs_Na.gpw',
+                             rate=0.001,
+                             nblocks=4,
+                             txt='4block.txt',
+                             **kwargs)
+    df3NLFCx, df3LFCx = df3.get_dielectric_function(direction='x')
+
+    # point integration 4 blocks with large eta (smearing)
+    kwargs.update({'integrationmode': None, 'eta': 4.25})
+    df4 = DielectricFunction('gs_Na.gpw',
+                             rate=0.001,
+                             nblocks=4,
+                             txt='4block.txt',
+                             **kwargs)
+    df4NLFCx, df4LFCx = df4.get_dielectric_function(direction='x')
 
     # Compare plasmon frequencies and intensities
-    w_w = df1.chi0.wd.omega_w
+    w_w = df1.wd.omega_w
 
     w1, I1 = findpeak(w_w, -(1. / df1LFCx).imag)
     w2, I2 = findpeak(w_w, -(1. / df2LFCx).imag)
-    equal(w1, w2, 1e-2)
-    equal(I1, I2, 1e-3)
+    w3, I3 = findpeak(w_w, -(1. / df3LFCx).imag)
+    w4, I4 = findpeak(w_w, -(1. / df4LFCx).imag)
+
+    # omegas don't change
+    assert [w3, w4] == pytest.approx([0.283057, 0.300520], 1e-2)
+    assert w1 == pytest.approx(w2, 1e-2)  # omega: serial vs parallel
+    # omega: PI & TI w/ large eta are aprx equal
+    assert w4 == pytest.approx(w3, 2e-2, abs=True)
+    assert I1 == pytest.approx(I2, 1e-3)  # intensity: serial vs parallel
```

### Comparing `gpaw-22.8.0/gpaw/test/response/test_pdens_tool.py` & `gpaw-23.6.0/gpaw/test/response/test_pdens_tool.py`

 * *Files 2% similar despite different names*

```diff
@@ -47,36 +47,39 @@
     atoms.calc = calc
     atoms.get_potential_energy()  # get ground state density
 
     calc.write('si.gpw', 'all')  # write wavefunctions
 
     # Part 2: optical transition calculation
 
-    pair, pd, domainarg_td = get_bz_transitions('si.gpw', q_c, bzk_kc,
-                                                spins=spins,
-                                                ecut=10)
+    pair, qpd, domainarg_td = get_bz_transitions('si.gpw', q_c, bzk_kc,
+                                                 spins=spins,
+                                                 ecut=10)
+
+    nocc1, nocc2 = pair.gs.count_occupied_bands(1e-6)
+    # XXX should we know 1e-6?
 
     # non-empty bands
-    n_n = np.arange(0, pair.nocc2)
+    n_n = np.arange(0, nocc2)
     # not completely filled bands
-    m_m = np.arange(pair.nocc1, pair.calc.wfs.bd.nbands)
+    m_m = np.arange(nocc1, pair.gs.bd.nbands)
 
     nt = len(domainarg_td)
     nn = len(n_n)
     nm = len(m_m)
-    nG = pd.ngmax
+    nG = qpd.ngmax
     optical_limit = np.allclose(q_c, 0.)
 
     n_tnmG = np.zeros((nt, nn, nm, nG + 2 * optical_limit), dtype=complex)
     df_tnm = np.zeros((nt, nn, nm), dtype=float)
     eps_tn = np.zeros((nt, nn), dtype=float)
     eps_tm = np.zeros((nt, nm), dtype=float)
     for t, domainarg_d in enumerate(domainarg_td):
         (n_tnmG[t], df_tnm[t],
-         eps_tn[t], eps_tm[t]) = get_chi0_integrand(pair, pd,
+         eps_tn[t], eps_tm[t]) = get_chi0_integrand(pair, qpd,
                                                     n_n, m_m,
                                                     *domainarg_d)
 
     testNM_ibN = [[[0], [4, 5, 6]], [[0], [7]],
                   [[1, 2, 3], [4, 5, 6]], [[1, 2, 3], [7]]]
     testts_iG = np.array([[0.07, 0.07, 0.07], [0.00, 0.00, 0.00],
                           [51.34, 51.34, 51.34], [22.69, 22.69, 22.69]])
```

### Comparing `gpaw-22.8.0/gpaw/test/response/test_qeh.py` & `gpaw-23.6.0/gpaw/test/response/test_qeh.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/response/test_site_kernels.py` & `gpaw-23.6.0/gpaw/test/response/test_site_kernels.py`

 * *Files 6% similar despite different names*

```diff
@@ -12,15 +12,15 @@
 from gpaw.response.site_kernels import (SphericalSiteKernels,
                                         CylindricalSiteKernels,
                                         ParallelepipedicSiteKernels,
                                         sinc,
                                         spherical_geometry_factor,
                                         cylindrical_geometry_factor,
                                         parallelepipedic_geometry_factor)
-from gpaw.response.susceptibility import get_pw_coordinates
+from gpaw.response.pair_functions import get_pw_coordinates
 
 
 # ---------- Actual tests ---------- #
 
 
 pytestmark = pytest.mark.kspair
 
@@ -265,17 +265,17 @@
                 kpts={'size': (kpts, kpts, kpts),
                       'gamma': True}
                 )
 
     # Perform inexpensive calculator initialization
     calc.initialize(atoms)
 
-    pd0 = get_PWDescriptor(atoms, calc, q_c,
-                           ecut=ecut,
-                           gammacentered=gammacentered)
+    qpd0 = get_pw_descriptor(atoms, calc, q_c,
+                             ecut=ecut,
+                             gammacentered=gammacentered)
 
     # Part 2: Calculate site kernels
     positions = atoms.get_positions()
 
     # Generate spherical site kernels instances
     # Normally
     sph_sitekernels = SphericalSiteKernels(positions, rc_pa)
@@ -327,70 +327,76 @@
     # to show, that we can compute them in parallel
     all_sitekernels_sum = sph_sitekernels + cyl_sitekernels + parlp_sitekernels
     all_sitekernels_app = sph_sitekernels.copy()
     all_sitekernels_app.append(cyl_sitekernels)
     all_sitekernels_app.append(parlp_sitekernels)
 
     # Calculate spherical site kernels
-    Ksph_paGG = np.array([K_aGG for K_aGG in sph_sitekernels.calculate(pd0)])
-    Ksph0_paGG = np.array([K_aGG for K_aGG in sph_sitekernels0.calculate(pd0)])
-    Ksph1_paGG = np.array([K_aGG for K_aGG in sph_sitekernels1.calculate(pd0)])
+    Ksph_paGG = np.array([K_aGG for K_aGG in
+                          sph_sitekernels.calculate(qpd0)])
+    Ksph0_paGG = np.array([K_aGG for K_aGG in
+                           sph_sitekernels0.calculate(qpd0)])
+    Ksph1_paGG = np.array([K_aGG for K_aGG in
+                           sph_sitekernels1.calculate(qpd0)])
     Ksph_sum_paGG = np.array([K_aGG for K_aGG in
-                              sph_sitekernels_sum.calculate(pd0)])
+                              sph_sitekernels_sum.calculate(qpd0)])
     Ksphp0_paGG = np.array([K_aGG for K_aGG in
-                            sph_sitekernelsp0.calculate(pd0)])
+                            sph_sitekernelsp0.calculate(qpd0)])
     Ksphp1_paGG = np.array([K_aGG for K_aGG in
-                            sph_sitekernelsp1.calculate(pd0)])
+                            sph_sitekernelsp1.calculate(qpd0)])
     Ksph_app_paGG = np.array([K_aGG for K_aGG in
-                              sph_sitekernels_app.calculate(pd0)])
+                              sph_sitekernels_app.calculate(qpd0)])
 
     # Calculate cylindrical site kernels
-    Kcyl_paGG = np.array([K_aGG for K_aGG in cyl_sitekernels.calculate(pd0)])
-    Kcyl0_paGG = np.array([K_aGG for K_aGG in cyl_sitekernels0.calculate(pd0)])
-    Kcyl1_paGG = np.array([K_aGG for K_aGG in cyl_sitekernels1.calculate(pd0)])
+    Kcyl_paGG = np.array([K_aGG for K_aGG in
+                          cyl_sitekernels.calculate(qpd0)])
+    Kcyl0_paGG = np.array([K_aGG for K_aGG in
+                           cyl_sitekernels0.calculate(qpd0)])
+    Kcyl1_paGG = np.array([K_aGG for K_aGG in
+                           cyl_sitekernels1.calculate(qpd0)])
     Kcyl_sum_paGG = np.array([K_aGG for K_aGG in
-                              cyl_sitekernels_sum.calculate(pd0)])
+                              cyl_sitekernels_sum.calculate(qpd0)])
     Kcylp0_paGG = np.array([K_aGG for K_aGG in
-                            cyl_sitekernelsp0.calculate(pd0)])
+                            cyl_sitekernelsp0.calculate(qpd0)])
     Kcylp1_paGG = np.array([K_aGG for K_aGG in
-                            cyl_sitekernelsp1.calculate(pd0)])
+                            cyl_sitekernelsp1.calculate(qpd0)])
     Kcyl_app_paGG = np.array([K_aGG for K_aGG in
-                              cyl_sitekernels_app.calculate(pd0)])
+                              cyl_sitekernels_app.calculate(qpd0)])
 
     # Calculate parallelepipedic site kernels
     Kparlp_paGG = np.array([K_aGG for K_aGG in
-                            parlp_sitekernels.calculate(pd0)])
+                            parlp_sitekernels.calculate(qpd0)])
     Kparlp0_paGG = np.array([K_aGG for K_aGG in
-                             parlp_sitekernels0.calculate(pd0)])
+                             parlp_sitekernels0.calculate(qpd0)])
     Kparlp1_paGG = np.array([K_aGG for K_aGG in
-                             parlp_sitekernels1.calculate(pd0)])
+                             parlp_sitekernels1.calculate(qpd0)])
     Kparlp_sum_paGG = np.array([K_aGG for K_aGG in
-                                parlp_sitekernels_sum.calculate(pd0)])
+                                parlp_sitekernels_sum.calculate(qpd0)])
     Kparlpp0_paGG = np.array([K_aGG for K_aGG in
-                              parlp_sitekernelsp0.calculate(pd0)])
+                              parlp_sitekernelsp0.calculate(qpd0)])
     Kparlpp1_paGG = np.array([K_aGG for K_aGG in
-                              parlp_sitekernelsp1.calculate(pd0)])
+                              parlp_sitekernelsp1.calculate(qpd0)])
     Kparlp_app_paGG = np.array([K_aGG for K_aGG in
-                                parlp_sitekernels_app.calculate(pd0)])
+                                parlp_sitekernels_app.calculate(qpd0)])
 
     # Calculate all site kernels together
     Kall_sum_paGG = np.array([K_aGG for K_aGG in
-                              all_sitekernels_sum.calculate(pd0)])
+                              all_sitekernels_sum.calculate(qpd0)])
     Kall_app_paGG = np.array([K_aGG for K_aGG in
-                              all_sitekernels_app.calculate(pd0)])
+                              all_sitekernels_app.calculate(qpd0)])
 
     # Calculate all site kernels at opposite qs
-    pd_q = [get_PWDescriptor(atoms, calc, qpm_c,
-                             ecut=ecut,
-                             gammacentered=gammacentered)
-            for qpm_c in qpm_qc]
+    qpd_q = [get_pw_descriptor(atoms, calc, qpm_c,
+                               ecut=ecut,
+                               gammacentered=gammacentered)
+             for qpm_c in qpm_qc]
     Kall_pm_qpaGG = [np.array([K_aGG for K_aGG in
-                               all_sitekernels_app.calculate(pd)])
-                     for pd in pd_q]
-
+                               all_sitekernels_app.calculate(qpd)])
+                     for qpd in qpd_q]
+    
     # Part 4: Check the calculated kernels
 
     # Check geometry shapes of basic arrays
     assert all([gs == 'sphere' for gs in sph_sitekernels.geometry_shapes])
     assert all([gs == 'cylinder' for gs in cyl_sitekernels.geometry_shapes])
     assert all([gs == 'parallelepiped'
                 for gs in parlp_sitekernels.geometry_shapes])
@@ -410,15 +416,15 @@
     assert all([gs == 'parallelepiped'
                 for gs in parlp_sitekernels_app.geometry_shapes])
     gs_refs = 2 * ['sphere'] + 2 * ['cylinder'] + 2 * ['parallelepiped']
     assert all([gs == ref for gs, ref in
                 zip(all_sitekernels_app.geometry_shapes, gs_refs)])
 
     # Check shape of spherical kernel arrays
-    nG = len(get_pw_coordinates(pd0))
+    nG = len(get_pw_coordinates(qpd0))
     assert sph_sitekernels.shape == Ksph_paGG.shape[:2]
     assert Ksph_paGG.shape == rc_pa.shape + (nG, nG)
     assert Ksph0_paGG.shape == (rc_pa.shape[0], 1) + (nG, nG)
     assert Ksph0_paGG.shape == Ksph1_paGG.shape
     assert Ksph_sum_paGG.shape == rc_pa.shape + (nG, nG)
     assert Ksphp0_paGG.shape == (1, rc_pa.shape[1]) + (nG, nG)
     assert Ksphp0_paGG.shape == Ksphp1_paGG.shape
@@ -533,21 +539,19 @@
     Kall_mH_paGG = np.conjugate(np.transpose(Kall_pm_qpaGG[1], (0, 1, 3, 2)))
     assert np.allclose(Kall_pm_qpaGG[0], Kall_mH_paGG)
 
 
 # ---------- Test functionality ---------- #
 
 
-def get_PWDescriptor(atoms, calc, q_c, ecut=50., gammacentered=False):
-    """Mock-up of PlaneWaveKSLRF.get_PWDescriptor working on a bare calculator
-    instance without any actual data in it."""
+def get_pw_descriptor(atoms, calc, q_c, ecut=50., gammacentered=False):
+    """Mock-up of ChiKSCalculator.get_pw_descriptor.
+
+    Works on a bare calculator instance without any actual data in it."""
     from ase.units import Ha
-    from gpaw.pw.descriptor import PWDescriptor
-    from gpaw.kpt_descriptor import KPointDescriptor
+    from gpaw.response.pair_functions import SingleQPWDescriptor
 
     # Create the plane wave descriptor
     q_c = np.asarray(q_c, dtype=float)
-    qd = KPointDescriptor([q_c])
-    pd = PWDescriptor(ecut / Ha, calc.wfs.gd,
-                      complex, qd, gammacentered=gammacentered)
-
-    return pd
+    qpd = SingleQPWDescriptor.from_q(q_c, ecut / Ha, calc.wfs.gd,
+                                     gammacentered=gammacentered)
+    return qpd
```

### Comparing `gpaw-22.8.0/gpaw/test/response/test_test_unit_sphere_area.py` & `gpaw-23.6.0/gpaw/test/response/test_test_unit_sphere_area.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,36 +1,38 @@
 from itertools import product
 
 import pytest
 import numpy as np
 
-from gpaw.response.integrators import TetrahedronIntegrator
-from gpaw.response.chi0 import FrequencyGridDescriptor
-# from gpaw.test import equal
+from gpaw.response.integrators import TetrahedronIntegrator, Integrand
+from gpaw.response.frequencies import FrequencyGridDescriptor
 
+from gpaw.response import ResponseContext
 
-def unit(x_c):
-    return np.array([[1.]], complex)
 
+class MyIntegrand(Integrand):
+    def matrix_element(self, x_c):
+        return np.array([[1.]], complex)
 
-def unit_sphere(x_c):
-    return np.array([(x_c**2).sum()**0.5], float)
+    def eigenvalues(self, x_c):
+        return np.array([(x_c**2).sum()**0.5], float)
 
 
 @pytest.mark.response
 def test_tetrahedron_integrator():
     cell_cv = np.eye(3)
-    integrator = TetrahedronIntegrator(cell_cv)
+    context = ResponseContext()
+    integrator = TetrahedronIntegrator(cell_cv, context)
     x_g = np.linspace(-1, 1, 30)
     x_gc = np.array([comb for comb in product(*([x_g] * 3))])
 
     domain = (x_gc,)
     out_wxx = np.zeros((1, 1, 1), complex)
     integrator.integrate(kind='spectral function',
                          domain=domain,
-                         integrand=(unit, unit_sphere),
+                         integrand=MyIntegrand(),
                          x=FrequencyGridDescriptor([-1.0]),
                          out_wxx=out_wxx)
 
     assert abs(out_wxx[0, 0, 0] - 4 * np.pi) < 1e-2
     # equal(out_wxx[0, 0, 0], 4 * np.pi, 1e-2,
     #       msg='Integrated area of unit sphere is not 4 * pi')
```

### Comparing `gpaw-22.8.0/gpaw/test/response/test_two-aluminum_chi_RPA.py` & `gpaw-23.6.0/gpaw/test/response/test_two-aluminum_chi_RPA.py`

 * *Files 17% similar despite different names*

```diff
@@ -3,18 +3,21 @@
 import time
 
 from ase.build import bulk
 from ase.parallel import parprint
 
 from gpaw import GPAW, PW
 from gpaw.test import findpeak, equal
-from gpaw.response.susceptibility import FourComponentSusceptibilityTensor
-from gpaw.response.susceptibility import read_component
 from gpaw.mpi import size, world
 
+from gpaw.response import ResponseGroundStateAdapter
+from gpaw.response.chiks import ChiKSCalculator
+from gpaw.response.susceptibility import ChiFactory
+from gpaw.response.pair_functions import read_susceptibility_array
+
 
 @pytest.mark.kspair
 @pytest.mark.response
 def test_response_two_aluminum_chi_RPA(in_tmp_dir):
     assert size <= 4**3
 
     # Ground state calculation
@@ -48,47 +51,37 @@
     t3 = time.time()
 
     # Excited state calculation
     q1_qc = [np.array([1 / 8., 0., 0.]), np.array([3 / 8., 0., 0.])]
     q2_qc = [np.array([1 / 4., 0., 0.]), np.array([- 1 / 4., 0., 0.])]
     w = np.linspace(0, 24, 241)
 
-    # Calculate susceptibility using Al
-    fcst = FourComponentSusceptibilityTensor(calc1, fxc='RPA',
-                                             eta=0.2, ecut=50)
-    for q, q_c in enumerate(q1_qc):
-        fcst.get_component_array('00', q_c, w, array_ecut=25,
-                                 filename='Al1_chiGG_q%d.pckl' % (q + 1))
-        world.barrier()
+    # Calculate susceptibility using Al1
+    calculate_chi(calc1, q1_qc, w, filename_prefix='Al1')
 
     t4 = time.time()
 
     # Calculate susceptibility using Al2
-    fcst = FourComponentSusceptibilityTensor(calc2, fxc='RPA',
-                                             eta=0.2, ecut=50)
-    for q, q_c in enumerate(q2_qc):
-        fcst.get_component_array('00', q_c, w, array_ecut=25,
-                                 filename='Al2_chiGG_q%d.pckl' % (q + 1))
-        world.barrier()
+    calculate_chi(calc2, q2_qc, w, filename_prefix='Al2')
 
     t5 = time.time()
 
     parprint('')
     parprint('Ground state calc 1 took', (t2 - t1), 'seconds')
     parprint('Ground state calc 2 took', (t3 - t2), 'seconds')
     parprint('Susceptibility calc 1 took', (t4 - t3), 'seconds')
     parprint('Susceptibility calc 2 took', (t5 - t4), 'seconds')
 
     # Check that results are consistent, when structure is simply repeated
 
     # Read results
-    w11_w, G11_Gc, chiks11_wGG, chi11_wGG = read_component('Al1_chiGG_q1.pckl')
-    w21_w, G21_Gc, chiks21_wGG, chi21_wGG = read_component('Al2_chiGG_q1.pckl')
-    w12_w, G12_Gc, chiks12_wGG, chi12_wGG = read_component('Al1_chiGG_q2.pckl')
-    w22_w, G22_Gc, chiks22_wGG, chi22_wGG = read_component('Al2_chiGG_q2.pckl')
+    w11_w, G11_Gc, chi11_wGG = read_susceptibility_array('Al1_chiGG_q1.pckl')
+    w21_w, G21_Gc, chi21_wGG = read_susceptibility_array('Al2_chiGG_q1.pckl')
+    w12_w, G12_Gc, chi12_wGG = read_susceptibility_array('Al1_chiGG_q2.pckl')
+    w22_w, G22_Gc, chi22_wGG = read_susceptibility_array('Al2_chiGG_q2.pckl')
 
     # Check that reciprocal lattice vectors remain as assumed in check below
     equal(np.linalg.norm(G11_Gc[0]), 0., 1e-6)
     equal(np.linalg.norm(G21_Gc[0]), 0., 1e-6)
     equal(np.linalg.norm(G12_Gc[0]), 0., 1e-6)
     equal(np.linalg.norm(G22_Gc[1] - np.array([1, 0, 0])), 0., 1e-6)
 
@@ -97,7 +90,28 @@
     wpeak21, Ipeak21 = findpeak(w21_w, -chi21_wGG[:, 0, 0].imag)
     equal(wpeak11, wpeak21, 0.02)
     equal(Ipeak11, Ipeak21, 1.0)
     wpeak12, Ipeak12 = findpeak(w12_w, -chi12_wGG[:, 0, 0].imag)
     wpeak22, Ipeak22 = findpeak(w22_w, -chi22_wGG[:, 1, 1].imag)
     equal(wpeak12, wpeak22, 0.05)
     equal(Ipeak12, Ipeak22, 1.0)
+
+
+def calculate_chi(calc, q_qc, w,
+                  eta=0.2, ecut=50,
+                  spincomponent='00', fxc='RPA',
+                  filename_prefix=None, reduced_ecut=25):
+    gs = ResponseGroundStateAdapter(calc)
+    chiks_calc = ChiKSCalculator(gs, ecut=ecut)
+    chi_factory = ChiFactory(chiks_calc)
+
+    if filename_prefix is None:
+        filename = 'chiGG_qXXX.pckl'
+    else:
+        filename = filename_prefix + '_chiGG_qXXX.pckl'
+
+    for q, q_c in enumerate(q_qc):
+        fname = filename.replace('XXX', str(q + 1))
+        _, chi = chi_factory(spincomponent, q_c, w + 1.j * eta, fxc=fxc)
+        chi = chi.copy_with_reduced_ecut(reduced_ecut)
+        chi.write_array(fname)
+        world.barrier()
```

### Comparing `gpaw-22.8.0/gpaw/test/rpa/rpa_C6_He.py` & `gpaw-23.6.0/gpaw/test/rpa/rpa_C6_He.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/rpa/test_rpa_energy_N2.py` & `gpaw-23.6.0/gpaw/test/rpa/test_rpa_energy_N2.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,54 +1,57 @@
 import pytest
 from ase.build import molecule
 from gpaw import GPAW, PW
-from gpaw.test import equal
 from gpaw.xc.rpa import RPACorrelation
 from gpaw.hybrids.energy import non_self_consistent_energy as nsc_energy
 
 
+@pytest.mark.rpa
 @pytest.mark.response
 def test_rpa_rpa_energy_N2(in_tmp_dir, scalapack):
     ecut = 25
 
     N2 = molecule('N2')
     N2.center(vacuum=2.0)
 
     calc = GPAW(mode=PW(force_complex_dtype=True),
                 xc='PBE',
                 parallel={'domain': 1},
                 eigensolver='rmm-diis')
     N2.calc = calc
     E_n2_pbe = N2.get_potential_energy()
 
+    E_n2_hf = nsc_energy(N2.calc, 'EXX')
+
     calc.diagonalize_full_hamiltonian(nbands=104, scalapack=True)
     calc.write('N2.gpw', mode='all')
 
-    E_n2_hf = nsc_energy('N2.gpw', 'EXX')
-
-    rpa = RPACorrelation('N2.gpw', nfrequencies=8)
-    E_n2_rpa = rpa.calculate(ecut=[ecut])
+    rpa = RPACorrelation('N2.gpw', nfrequencies=8, ecut=[ecut])
+    E_n2_rpa = rpa.calculate()
 
     N = molecule('N')
     N.set_cell(N2.cell)
+    N.center()
 
     calc = GPAW(mode=PW(force_complex_dtype=True),
                 xc='PBE',
                 parallel={'domain': 1},
                 eigensolver='rmm-diis')
     N.calc = calc
     E_n_pbe = N.get_potential_energy()
 
     calc.diagonalize_full_hamiltonian(nbands=104, scalapack=True)
     calc.write('N.gpw', mode='all')
 
     E_n_hf = nsc_energy('N.gpw', 'EXX')
 
-    rpa = RPACorrelation('N.gpw', nfrequencies=8)
-    E_n_rpa = rpa.calculate(ecut=[ecut])
+    rpa = RPACorrelation('N.gpw', nfrequencies=8, ecut=[ecut])
+    E_n_rpa = rpa.calculate()
 
     print('Atomization energies:')
     print('PBE: ', E_n2_pbe - 2 * E_n_pbe)
     print('HF: ', E_n2_hf - 2 * E_n_hf)
     print('HF+RPA: ', E_n2_hf - 2 * E_n_hf + E_n2_rpa[0] - 2 * E_n_rpa[0])
 
-    equal(E_n2_rpa - 2 * E_n_rpa, -1.68, 0.02)
+    assert E_n2_rpa - 2 * E_n_rpa == pytest.approx(-1.68, abs=0.02)
+    assert (E_n2_hf - 2 * E_n_hf) == pytest.approx(
+        [-10.47, 3.03, 0, 0, -0.06, 2.79], abs=0.01)
```

### Comparing `gpaw-22.8.0/gpaw/test/rpa/test_rpa_energy_Na.py` & `gpaw-23.6.0/gpaw/test/rpa/test_rpa_energy_Na.py`

 * *Files 16% similar despite different names*

```diff
@@ -2,14 +2,15 @@
 from ase.build import bulk
 from gpaw import GPAW, FermiDirac, PW
 from gpaw.mpi import serial_comm
 from gpaw.xc.rpa import RPACorrelation
 from gpaw.test import equal
 
 
+@pytest.mark.rpa
 @pytest.mark.response
 def test_rpa_rpa_energy_Na(in_tmp_dir):
     blk = bulk('Na', 'bcc', a=4.23)
 
     ecut = 350
     calc = GPAW(mode=PW(ecut),
                 basis='dzp',
@@ -25,10 +26,10 @@
 
     calc = GPAW('gs_occ_pw.gpw', txt='gs_pw.txt', parallel={'band': 1})
     calc.diagonalize_full_hamiltonian(nbands=520)
     calc.write('gs_pw.gpw', 'all')
 
     ecut = 120
     calc = GPAW('gs_pw.gpw', communicator=serial_comm, txt=None)
-    rpa = RPACorrelation(calc, txt='rpa_%s.txt' % ecut)
-    E = rpa.calculate(ecut=[ecut])
+    rpa = RPACorrelation(calc, txt='rpa_%s.txt' % ecut, ecut=[ecut])
+    E = rpa.calculate()
     equal(E, -1.106, 0.005)
```

### Comparing `gpaw-22.8.0/gpaw/test/rpa/test_rpa_energy_Ni.py` & `gpaw-23.6.0/gpaw/test/rpa/test_rpa_energy_Ni.py`

 * *Files 26% similar despite different names*

```diff
@@ -3,29 +3,31 @@
 from gpaw import GPAW, FermiDirac
 from gpaw.mpi import serial_comm
 from gpaw.test import equal
 from gpaw.xc.rpa import RPACorrelation
 from gpaw.xc.fxc import FXCCorrelation
 
 
+@pytest.mark.rpa
 @pytest.mark.response
 def test_rpa_rpa_energy_Ni(in_tmp_dir):
     Ni = bulk('Ni', 'fcc')
     Ni.set_initial_magnetic_moments([0.7])
 
     calc = GPAW(mode='pw',
                 kpts=(3, 3, 3),
                 occupations=FermiDirac(0.001),
                 setups={'Ni': '10'},
                 communicator=serial_comm)
     Ni.calc = calc
     Ni.get_potential_energy()
     calc.diagonalize_full_hamiltonian(nbands=50)
 
-    rpa = RPACorrelation(calc, nfrequencies=8, skip_gamma=True)
-    E_rpa = rpa.calculate(ecut=[50])
+    rpa = RPACorrelation(calc, nfrequencies=8, skip_gamma=True, ecut=[50])
+    E_rpa = rpa.calculate()
 
-    fxc = FXCCorrelation(calc, nlambda=16, nfrequencies=8, skip_gamma=True)
-    E_fxc = fxc.calculate(ecut=[50])
+    fxc = FXCCorrelation(calc, nlambda=16, nfrequencies=8, skip_gamma=True,
+                         ecut=[50])
+    E_fxc = fxc.calculate()
 
     equal(E_rpa, -7.826, 0.01)
     equal(E_fxc, -7.826, 0.01)
```

### Comparing `gpaw-22.8.0/gpaw/test/rsf_yukawa/test_lrtddft_short.py` & `gpaw-23.6.0/gpaw/test/rsf_yukawa/test_lrtddft_short.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,47 +1,53 @@
 """Check TDDFT ionizations with Yukawa potential."""
+import pytest
 from ase import Atoms
 from ase.units import Hartree
+
+import _gpaw
 from gpaw import GPAW
-from gpaw.mpi import world
 from gpaw.cluster import Cluster
-from gpaw.occupations import FermiDirac
-from gpaw.test import equal
 from gpaw.eigensolvers import RMMDIIS
 from gpaw.lrtddft import LrTDDFT
-import _gpaw
+from gpaw.mpi import world
+from gpaw.occupations import FermiDirac
+from gpaw.test import equal
 
 
+@pytest.mark.hybrids
 def test_rsf_yukawa_lrtddft_short(in_tmp_dir):
     libxc_version = getattr(_gpaw, 'libxc_version', '2.x.y')
     if int(libxc_version.split('.')[0]) < 3:
         from unittest import SkipTest
         raise SkipTest
 
     o_plus = Cluster(Atoms('Be', positions=[[0, 0, 0]]))
     o_plus.set_initial_magnetic_moments([1.0])
     o_plus.minimal_box(2.5, h=0.35)
 
-    def get_paw():
+    def get_paw(**kwargs):
         """Return calculator object."""
         c = {'energy': 0.05, 'eigenstates': 0.05, 'density': 0.05}
         return GPAW(convergence=c, eigensolver=RMMDIIS(),
                     nbands=3,
                     xc='PBE',
-                    #                experimental={'niter_fixdensity': 2},
                     parallel={'domain': world.size}, h=0.35,
-                    occupations=FermiDirac(width=0.0, fixmagmom=True))
+                    occupations=FermiDirac(width=0.0, fixmagmom=True),
+                    **kwargs)
 
-    calc_plus = get_paw()
-    calc_plus.set(txt='Be_plus_LCY_PBE_083.log', charge=1)
+    calc_plus = get_paw(txt='Be_plus_PBE.log', charge=1)
     o_plus.calc = calc_plus
     o_plus.get_potential_energy()
-    calc_plus.set(xc='LCY-PBE:omega=0.83:unocc=True',
-                  experimental={'niter_fixdensity': 2})
+
+    calc_plus = calc_plus.new(xc='LCY-PBE:omega=0.83:unocc=True',
+                              experimental={'niter_fixdensity': 2},
+                              txt='Be_plus_LCY_PBE_083.log')
+    o_plus.calc = calc_plus
     o_plus.get_potential_energy()
+
     lr = LrTDDFT(calc_plus, txt='LCY_TDDFT_Be.log',
                  restrict={'istart': 0, 'jend': 1})
     equal(lr.xc.omega, 0.83)
     lr.write('LCY_TDDFT_Be.ex.gz')
     e_ion = 9.3
     ip_i = 13.36
     # reading is problematic with EXX on more than one core
```

### Comparing `gpaw-22.8.0/gpaw/test/rsf_yukawa/test_rsf_general.py` & `gpaw-23.6.0/gpaw/test/rsf_yukawa/test_rsf_general.py`

 * *Files 14% similar despite different names*

```diff
@@ -6,14 +6,15 @@
 from gpaw.eigensolvers import RMMDIIS
 from gpaw.xc.hybrid import HybridXC
 from gpaw.occupations import FermiDirac
 from gpaw.test import gen
 import _gpaw
 
 
+@pytest.mark.hybrids
 def test_rsf_yukawa_rsf_general(in_tmp_dir, add_cwd_to_setup_paths):
     libxc_version = getattr(_gpaw, 'libxc_version', '2.x.y')
     if int(libxc_version.split('.')[0]) < 3:
         from unittest import SkipTest
         raise SkipTest
 
     for atom in ['Be']:
@@ -31,16 +32,14 @@
     xc = HybridXC('LCY-PBE', omega=0.83)
     fname = 'Be_rsf.gpw'
 
     calc = GPAW(txt='Be.txt', xc=xc, convergence=c,
                 eigensolver=RMMDIIS(), h=h,
                 occupations=FermiDirac(width=0.0), spinpol=False)
     be.calc = calc
-    # energy = na2.get_potential_energy()
-    # calc.set(xc=xc)
     energy_083 = be.get_potential_energy()
     (eps_homo, eps_lumo) = calc.get_homo_lumo()
     assert eps_homo == pytest.approx(-IP, abs=0.15)
     xc2 = 'LCY-PBE'
     energy_075 = calc.get_xc_difference(HybridXC(xc2))
     assert energy_083 - energy_075 == pytest.approx(21.13, abs=0.2)
     calc.write(fname)
```

### Comparing `gpaw-22.8.0/gpaw/test/rsf_yukawa/test_rsf_ivo_sing_mg.py` & `gpaw-23.6.0/gpaw/test/rsf_yukawa/test_rsf_ivo_sing_mg.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,20 +1,23 @@
 """Test the calculation of the excitation energy of Na2 by RSF and IVOs."""
+import pytest
 from ase import Atoms
 from ase.units import Hartree
+
+import _gpaw
 from gpaw import GPAW
+from gpaw.cluster import Cluster
+from gpaw.eigensolvers import RMMDIIS
+from gpaw.lrtddft import LrTDDFT
 from gpaw.mpi import world
 from gpaw.occupations import FermiDirac
 from gpaw.test import equal, gen
-from gpaw.eigensolvers import RMMDIIS
-from gpaw.cluster import Cluster
-from gpaw.lrtddft import LrTDDFT
-import _gpaw
 
 
+@pytest.mark.hybrids
 def test_rsf_yukawa_rsf_ivo_sing_mg(in_tmp_dir, add_cwd_to_setup_paths):
     libxc_version = getattr(_gpaw, 'libxc_version', '2.x.y')
     if int(libxc_version.split('.')[0]) < 3:
         from unittest import SkipTest
         raise SkipTest
 
     h = 0.35  # Gridspacing
```

### Comparing `gpaw-22.8.0/gpaw/test/setups/setup_basis_spec_test.py` & `gpaw-23.6.0/gpaw/test/setups/test_setup_basis_spec.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/setups/test_derivative_integrals.py` & `gpaw-23.6.0/gpaw/test/setups/test_derivative_integrals.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/setups/test_generator2.py` & `gpaw-23.6.0/gpaw/test/setups/test_generator2.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/sic/test_nscfsic.py` & `gpaw-23.6.0/gpaw/test/sic/test_nscfsic.py`

 * *Files 6% similar despite different names*

```diff
@@ -4,28 +4,29 @@
 from gpaw import GPAW
 from gpaw.utilities.sic import NSCFSIC
 
 pytestmark = pytest.mark.skipif(world.size > 1,
                                 reason='world.size > 1')
 
 
+@pytest.mark.later
 def test_sic_nscfsic(in_tmp_dir):
     atoms = ['He', 'Be']  # ,'Ne'] # Ne deviates already 2.5 eV
     EE = []
     EREF = [-79.4, -399.8, -3517.6]
 
     for a in atoms:
         s = Atoms(a)
         s.center(vacuum=4.0)
         calc = GPAW(h=0.15, txt=a + '.txt')
         s.calc = calc
         s.get_potential_energy()
         EE.append(NSCFSIC(calc).calculate())
 
     print("Difference to table VI of Phys. Rev. B 23, 5048 in eV")
-    # http://prola.aps.org/abstract/PRB/v23/i10/p5048_1
+    # https://journals.aps.org/prb/abstract/10.1103/PhysRevB.23.5048
     print("%10s%10s%10s%10s" % ("atom", "ref.", "gpaw", "diff"))
     for a, er, e in zip(atoms, EREF, EE):
         print("%10s%10.2f%10.2f%10.2f" % (a, er, e, er - e))
         assert abs(er - e) < 0.1
         # Arbitrary 0.1 eV tolerance for non-self consistent SIC
         # Note that Ne already deviates 2.5 eV
```

### Comparing `gpaw-22.8.0/gpaw/test/sic/test_scfsic_h2.py` & `gpaw-23.6.0/gpaw/test/sic/test_scfsic_h2.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,13 +1,15 @@
+import pytest
 from ase import Atoms
-from gpaw import GPAW, restart
 
+from gpaw import GPAW, restart
 from gpaw.test import equal
 
 
+@pytest.mark.later
 def test_sic_scfsic_h2(in_tmp_dir):
     a = 6.0
     atom = Atoms('H', magmoms=[1.0], cell=(a, a, a))
     molecule = Atoms('H2', positions=[
                      (0, 0, 0), (0, 0, 0.737)], cell=(a, a, a))
     atom.center()
     molecule.center()
```

### Comparing `gpaw-22.8.0/gpaw/test/solvation/test_adm12.py` & `gpaw-23.6.0/gpaw/test/solvation/test_adm12.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/solvation/test_forces.py` & `gpaw-23.6.0/gpaw/test/solvation/test_forces.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/solvation/test_forces_symmetry.py` & `gpaw-23.6.0/gpaw/test/solvation/test_forces_symmetry.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/solvation/test_lrtddft.py` & `gpaw-23.6.0/gpaw/test/solvation/test_lrtddft.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/solvation/test_nan_radius.py` & `gpaw-23.6.0/gpaw/test/solvation/test_nan_radius.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/solvation/test_overlap.py` & `gpaw-23.6.0/gpaw/test/solvation/test_overlap.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/solvation/test_pbc.py` & `gpaw-23.6.0/gpaw/test/solvation/test_pbc.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/solvation/test_pbc_pos_repeat.py` & `gpaw-23.6.0/gpaw/test/solvation/test_pbc_pos_repeat.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/solvation/test_poisson.py` & `gpaw-23.6.0/gpaw/test/solvation/test_poisson.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/solvation/test_sfgcm06.py` & `gpaw-23.6.0/gpaw/test/solvation/test_sfgcm06.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/solvation/test_sjm.py` & `gpaw-23.6.0/gpaw/test/solvation/test_sjm.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/solvation/test_solvation_api.py` & `gpaw-23.6.0/gpaw/test/solvation/test_solvation_api.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/solvation/test_spinpol.py` & `gpaw-23.6.0/gpaw/test/solvation/test_spinpol.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/solvation/test_sss09.py` & `gpaw-23.6.0/gpaw/test/solvation/test_sss09.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/solvation/test_swap_atoms.py` & `gpaw-23.6.0/gpaw/test/solvation/test_swap_atoms.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/solvation/test_vacuum.py` & `gpaw-23.6.0/gpaw/test/solvation/test_vacuum.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/solvation/test_water_water.py` & `gpaw-23.6.0/gpaw/test/solvation/test_water_water.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/solvation/test_water_water_etdm_lcao.py` & `gpaw-23.6.0/gpaw/test/solvation/test_water_water_etdm_lcao.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/spin/test_spinFe3plus.py` & `gpaw-23.6.0/gpaw/test/spin/test_spinFe3plus.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/spin/test_spin_contamination.py` & `gpaw-23.6.0/gpaw/test/spin/test_spin_contamination.py`

 * *Files 5% similar despite different names*

```diff
@@ -3,14 +3,15 @@
 from gpaw import GPAW
 from gpaw.cluster import Cluster
 
 h = 0.25
 box = 3.0
 
 
+@pytest.mark.later
 def test_spin_spin_contamination_B():
     # B should not have spin contamination
     s = Cluster([Atom('B')])
     s.minimal_box(box, h=h)
     s.set_initial_magnetic_moments([-1])
 
     c = GPAW(xc='LDA', nbands=-3,
@@ -25,14 +26,15 @@
 
     contamination = min(c.density.get_spin_contamination(s, 0),
                         c.density.get_spin_contamination(s, 1))
 
     assert contamination == pytest.approx(0.0, abs=0.01)
 
 
+@pytest.mark.later
 def test_spin_spin_contamination_H2():
     # setup H2 at large distance with different spins for the atoms
     s = Cluster([Atom('H'), Atom('H', [0, 0, 3.0])])
     s.minimal_box(box, h=h)
     s.set_initial_magnetic_moments([-1, 1])
 
     c = GPAW(xc='LDA',
```

### Comparing `gpaw-22.8.0/gpaw/test/spin/test_spinpol.py` & `gpaw-23.6.0/gpaw/test/spin/test_spinpol.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,23 +1,27 @@
+import pytest
 from ase import Atom, Atoms
 from gpaw import GPAW, FermiDirac
-from gpaw.test import equal
 
 
 def test_spin_spinpol():
     a = 4.0
     n = 16
     hydrogen = Atoms([Atom('H')], cell=(a, a, a), pbc=True)
     hydrogen.center()
-    calc = GPAW(gpts=(n, n, n), nbands=1, convergence={'energy': 1e-5},
-                occupations=FermiDirac(0.0))
-    hydrogen.calc = calc
+    hydrogen.calc = GPAW(
+        gpts=(n, n, n),
+        nbands=1,
+        convergence={'energy': 1e-5},
+        occupations=FermiDirac(0.0))
     e1 = hydrogen.get_potential_energy()
-    hydrogen.set_initial_magnetic_moments([1.0])
+
+    hydrogen.calc = hydrogen.calc.new(hund=True)
     e2 = hydrogen.get_potential_energy()
+
     de = e1 - e2
     print(de)
-    equal(de, 0.7871, 1.e-4)
+    assert de == pytest.approx(0.7871, abs=1.e-4)
 
     energy_tolerance = 0.0006
-    equal(e1, -0.499854, energy_tolerance)
-    equal(e2, -1.287, energy_tolerance)
+    assert e1 == pytest.approx(-0.499854, abs=energy_tolerance)
+    assert e2 == pytest.approx(-1.287, abs=energy_tolerance)
```

### Comparing `gpaw-22.8.0/gpaw/test/symmetry/test_check.py` & `gpaw-23.6.0/gpaw/test/symmetry/test_check.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/symmetry/test_fractional_translations.py` & `gpaw-23.6.0/gpaw/test/symmetry/test_fractional_translations.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/symmetry/test_fractional_translations_big.py` & `gpaw-23.6.0/gpaw/test/symmetry/test_fractional_translations_big.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/symmetry/test_fractional_translations_med.py` & `gpaw-23.6.0/gpaw/test/symmetry/test_fractional_translations_med.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/symmetry/test_kpoint_mapping.py` & `gpaw-23.6.0/gpaw/test/symmetry/test_kpoint_mapping.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/symmetry/test_symmetry.py` & `gpaw-23.6.0/gpaw/test/symmetry/test_symmetry.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/symmetry/test_symmetry2.py` & `gpaw-23.6.0/gpaw/test/symmetry/test_symmetry2.py`

 * *Files 13% similar despite different names*

```diff
@@ -14,15 +14,15 @@
 @pytest.mark.response
 @pytest.mark.slow
 def test_response_symmetry(gpw_files):
     data_s = []
     for name in ['ti2o4_pw_nosym_wfs', 'ti2o4_pw_wfs']:
         X = Chi0(gpw_files[name])
         chi_t = X.calculate([1. / 4, 0, 0])
-        data_s.append((chi_t.chi0_wGG, chi_t.chi0_wxvG, chi_t.chi0_wvv))
+        data_s.append((chi_t.chi0_WgG, chi_t.chi0_WxvG, chi_t.chi0_Wvv))
 
     msg = 'Difference in Chi when turning off symmetries!'
 
     while len(data_s):
         data1 = data_s.pop()
         for data2 in data_s:
             for dat1, dat2 in zip(data1, data2):
```

### Comparing `gpaw-22.8.0/gpaw/test/symmetry/test_symmetry_ft.py` & `gpaw-23.6.0/gpaw/test/symmetry/test_symmetry_ft.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/symmetry/test_usesymm.py` & `gpaw-23.6.0/gpaw/test/symmetry/test_usesymm.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/symmetry/test_usesymm2.py` & `gpaw-23.6.0/gpaw/test/symmetry/test_usesymm2.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/tddft/test_be_nltd_ip.py` & `gpaw-23.6.0/gpaw/test/tddft/test_be_nltd_ip.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,15 +1,17 @@
 import numpy as np
 from ase import Atoms
 from gpaw import GPAW
 from gpaw.tddft import TDDFT
 from gpaw.tddft.abc import LinearAbsorbingBoundary
 from gpaw.tddft.laser import CWField
+import pytest
 
 
+@pytest.mark.later
 def test_tddft_be_nltd_ip(in_tmp_dir):
     atoms = Atoms('Be', [(0, 0, 0)], pbc=False)
     atoms.center(vacuum=6)
     calc = GPAW(h=0.35)
     atoms.calc = calc
     atoms.get_potential_energy()
```

### Comparing `gpaw-22.8.0/gpaw/test/tddft/test_ehrenfest_nacl.py` & `gpaw-23.6.0/gpaw/test/tddft/test_ehrenfest_nacl.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,14 +1,16 @@
 from ase import Atoms
 from gpaw import GPAW
 from gpaw.tddft import TDDFT
 from gpaw.tddft.ehrenfest import EhrenfestVelocityVerlet
 from gpaw.test import equal
+import pytest
 
 
+@pytest.mark.later
 def test_tddft_ehrenfest_nacl(in_tmp_dir):
     d = 4.0
     atoms = Atoms('NaCl', [(0, 0, 0), (0, 0, d)])
     atoms.center(vacuum=4.5)
 
     gs_calc = GPAW(nbands=4, eigensolver='cg', gpts=(32, 32, 44), xc='LDA',
                    setups={'Na': '1'})
```

### Comparing `gpaw-22.8.0/gpaw/test/tddft/test_fxc_linearize.py` & `gpaw-23.6.0/gpaw/test/tddft/test_fxc_linearize.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/tddft/test_molecule.py` & `gpaw-23.6.0/gpaw/test/tddft/test_molecule.py`

 * *Files 5% similar despite different names*

```diff
@@ -81,15 +81,15 @@
 @only_on_master(world)
 def time_propagation_reference(ground_state):
     calculate_time_propagation('gs.gpw',
                                communicator=serial_comm,
                                write_and_continue=True)
 
 
-@pytest.mark.skip_for_new_gpaw
+@pytest.mark.later
 def test_dipole_moment_values(time_propagation_reference,
                               module_tmp_path, in_tmp_dir):
     with open('dm.dat', 'w') as fd:
         fd.write('''
 # DipoleMomentWriter[version=1](center=False, density='comp')
 #            time            norm                    dmx                    dmy                    dmz
           0.00000000       6.92701356e-16    -3.798602757097e-08    -3.850923113536e-10    -2.506988148420e-10
@@ -112,15 +112,15 @@
 
     rtol = 5e-4
     atol = 1e-8
     check_dm('dm.dat', module_tmp_path / 'dm.dat', rtol=rtol, atol=atol)
     check_dm('dm2.dat', module_tmp_path / 'dm2.dat', rtol=rtol, atol=atol)
 
 
-@pytest.mark.skip_for_new_gpaw
+@pytest.mark.later
 @pytest.mark.parametrize('parallel', parallel_i)
 @pytest.mark.parametrize('propagator', [
     'SICN', 'ECN', 'ETRSCN', 'SIKE'])
 def test_propagation(time_propagation_reference,
                      parallel, propagator,
                      module_tmp_path, in_tmp_dir):
     calculate_time_propagation(module_tmp_path / 'gs.gpw',
@@ -130,25 +130,25 @@
     if propagator == 'SICN':
         # This is the same propagator as the reference;
         # error comes only from parallelization
         rtol = 1e-8
         if 'band' in parallel:
             # XXX band parallelization is inaccurate!
             rtol = 7e-4
-            atol = 3e-8
+            atol = 5e-8
     else:
         # Other propagators match qualitatively
         rtol = 5e-2
         if 'band' in parallel:
             # XXX band parallelization is inaccurate!
-            atol = 3e-8
+            atol = 5e-8
     check_dm(module_tmp_path / 'dm.dat', 'dm.dat', rtol=rtol, atol=atol)
 
 
-@pytest.mark.skip_for_new_gpaw
+@pytest.mark.later
 @pytest.mark.parametrize('parallel', parallel_i)
 def test_restart(time_propagation_reference,
                  parallel,
                  module_tmp_path, in_tmp_dir):
     calculate_time_propagation(module_tmp_path / 'td.gpw',
                                kick=None,
                                force_new_dm_file=True,
```

### Comparing `gpaw-22.8.0/gpaw/test/tddft/test_td_na2.py` & `gpaw-23.6.0/gpaw/test/tddft/test_td_na2.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,14 +1,16 @@
+import pytest
 from ase import Atoms
 
 from gpaw import GPAW
 from gpaw.tddft import TDDFT, DipoleMomentWriter, photoabsorption_spectrum
-from gpaw.tddft.abc import LinearAbsorbingBoundary, P4AbsorbingBoundary, PML
+from gpaw.tddft.abc import PML, LinearAbsorbingBoundary, P4AbsorbingBoundary
 
 
+@pytest.mark.later
 def test_tddft_td_na2(in_tmp_dir):
     """Sodium dimer, Na2."""
     d = 1.5
     atoms = Atoms(symbols='Na2',
                   positions=[(0, 0, d),
                              (0, 0, -d)],
                   pbc=False)
```

### Comparing `gpaw-22.8.0/gpaw/test/test_AA_enthalpy.py` & `gpaw-23.6.0/gpaw/test/test_AA_enthalpy.py`

 * *Files 6% similar despite different names*

```diff
@@ -33,15 +33,15 @@
         'BPW91': (1.103, -8.5, 'BPW91', 'gga'),
         'B3LYP': (1.092, -1.03, 'BLYP', 'hyb_gga'),
         'B3PW91': (1.091, 2.8, 'PW91', 'hyb_gga'),
         'PBE0': (1.090, 3.1, 'PBE', 'hyb_gga'),
         'PBEH': (1.090, 3.1, 'PBE', 'hyb_gga'),
         'magmom': 3.0,
         # tables.pdf:
-        # http://ftp.aip.org/epaps/journ_chem_phys/E-JCPSA6-119-302348/tables.pdf
+        # https://aip.scitation.org/doi/suppl/10.1063/1.1626543/suppl_file/tables.pdf
         'R_AA_B3LYP': 1.092,  # (from tables.pdf of 10.1063/1.1626543) (Ang)
         'ZPE_AA_B3LYP': 0.005457 * Hartree,  # (from benchmarks.txt of
                                              # 10.1063/1.1626543) (eV)
         'H_298_H_0_AA_B3LYP': 0.003304 * Hartree,  # (from benchmarks.txt of
                                                    # 10.1063/1.1626543) (eV)
         'H_298_H_0_A': 1.04 / (mol / kcal),  # (from 10.1063/1.473182) (eV)
         'dHf_0_A': 112.53 / (mol / kcal)}  # (from 10.1063/1.473182) (eV)
@@ -57,15 +57,15 @@
         'BPW91': (1.219, -17.9, 'BPW91', 'gga'),
         'B3LYP': (1.204, -3.7, 'BLYP', 'hyb_gga'),
         'B3PW91': (1.197, -5.1, 'PW91', 'hyb_gga'),
         'PBE0': (1.192, -4.3, 'PBE', 'hyb_gga'),
         'PBEH': (1.192, -4.3, 'PBE', 'hyb_gga'),
         'magmom': 2.0,
         # tables.pdf:
-        # http://ftp.aip.org/epaps/journ_chem_phys/E-JCPSA6-119-302348/tables.pdf
+        # https://aip.scitation.org/doi/suppl/10.1063/1.1626543/suppl_file/tables.pdf
         'R_AA_B3LYP': 1.204,  # (from tables.pdf of 10.1063/1.1626543) (Ang)
         'ZPE_AA_B3LYP': 0.003736 * Hartree,  # (from benchmarks.txt of
                                              # 10.1063/1.1626543) (eV)
         'H_298_H_0_AA_B3LYP': 0.003307 * Hartree,
         # (from benchmarks.txt of 10.1063/1.1626543) (eV)
         'H_298_H_0_A': 1.04 / (mol / kcal),  # (from 10.1063/1.473182) (eV)
         'dHf_0_A': 58.99 / (mol / kcal)}  # (from 10.1063/1.473182) (eV)
@@ -81,15 +81,15 @@
         'BPW91': (0.748, 4.0, 'BPW91', 'gga'),
         'B3LYP': (0.742, -0.5, 'BLYP', 'hyb_gga'),
         'B3PW91': (0.744, 2.4, 'PW91', 'hyb_gga'),
         'PBE0': (0.745, 5.3, 'PBE', 'hyb_gga'),
         'PBEH': (0.745, 5.3, 'PBE', 'hyb_gga'),
         'magmom': 1.0,
         # tables.pdf:
-        # http://ftp.aip.org/epaps/journ_chem_phys/E-JCPSA6-119-302348/tables.pdf
+        # https://aip.scitation.org/doi/suppl/10.1063/1.1626543/suppl_file/tables.pdf
         'R_AA_B3LYP': 0.742,  # (from tables.pdf of 10.1063/1.1626543) (Ang)
         'ZPE_AA_B3LYP': 0.010025 * Hartree,  # (from benchmarks.txt of
                                              # 10.1063/1.1626543) (eV)
         'H_298_H_0_AA_B3LYP': 0.003305 * Hartree,  # (from benchmarks.txt of
                                                    # 10.1063/1.1626543) (eV)
         'H_298_H_0_A': 1.01 / (mol / kcal),  # (from 10.1063/1.473182) (eV)
         'dHf_0_A': 51.63 / (mol / kcal)}  # (from 10.1063/1.473182) (eV)
@@ -136,16 +136,16 @@
 
         compound.calc = calc
 
         if data[element][xc][3] == 'hyb_gga':  # only for hybrids
             e_atom = atom.get_potential_energy()
             e_compound = compound.get_potential_energy()
 
-            calc_atom.set(xc=_xc(xc))
-            calc.set(xc=_xc(xc))
+            atom.calc = calc_atom.new(xc=_xc(xc))
+            compound.calc = calc.new(xc=_xc(xc))
 
         e_atom = atom.get_potential_energy()
         e_compound = compound.get_potential_energy()
 
         dHf_0 = (e_compound - 2 * e_atom + data[element]['ZPE_AA_B3LYP'] +
                  2 * data[element]['dHf_0_A'])
         dHf_298 = (dHf_0 + data[element]['H_298_H_0_AA_B3LYP'] -
```

### Comparing `gpaw-22.8.0/gpaw/test/test_Gauss.py` & `gpaw-23.6.0/gpaw/test/test_Gauss.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/test_aeatom.py` & `gpaw-23.6.0/gpaw/test/test_aeatom.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/test_atoms_mismatch.py` & `gpaw-23.6.0/gpaw/test/test_atoms_mismatch.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/test_broadcast_imports.py` & `gpaw-23.6.0/gpaw/test/test_broadcast_imports.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/test_cluster.py` & `gpaw-23.6.0/gpaw/test/test_cluster.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/test_complex.py` & `gpaw-23.6.0/gpaw/test/test_complex.py`

 * *Files 11% similar despite different names*

```diff
@@ -28,10 +28,11 @@
         calc.calculation.converge({'eigenstates': 3.5e-9,
                                    'energy': energy_eps})
         assert calc.calculation.state.ibzwfs.dtype == complex
     else:
         assert calc.wfs.dtype == complex
         assert calc.wfs.kpt_u[0].psit_nG.dtype == complex
 
-        calc.set(convergence={'eigenstates': 3.5e-9, 'energy': energy_eps})
+        convergence = {'eigenstates': 3.5e-9, 'energy': energy_eps}
+        mol.calc = calc.new(convergence=convergence)
     E = mol.get_potential_energy()
     equal(E, Eini, energy_eps * calc.get_number_of_electrons())
```

### Comparing `gpaw-22.8.0/gpaw/test/test_coreeig.py` & `gpaw-23.6.0/gpaw/test/test_coreeig.py`

 * *Files 12% similar despite different names*

```diff
@@ -5,14 +5,15 @@
 from gpaw.test import equal
 from gpaw.utilities.kspot import CoreEigenvalues
 
 pytestmark = pytest.mark.skipif(world.size > 1,
                                 reason='world.size > 1')
 
 
+@pytest.mark.later
 def test_coreeig(in_tmp_dir):
     a = 7.0
     calc = GPAW(h=0.1)
     system = Atoms('Ne', calculator=calc)
     system.center(vacuum=a / 2)
     e0 = system.get_potential_energy()
     calc.write('Ne.gpw')
```

### Comparing `gpaw-22.8.0/gpaw/test/test_coulomb.py` & `gpaw-23.6.0/gpaw/test/test_coulomb.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/test_diagonalizer_backend.py` & `gpaw-23.6.0/gpaw/test/test_diagonalizer_backend.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/test_dipole.py` & `gpaw-23.6.0/gpaw/test/test_dipole.py`

 * *Files 13% similar despite different names*

```diff
@@ -61,59 +61,63 @@
                     h=0.25,
                     xc='oldLDA')
 
     calc1 = GPAW(poissonsolver={'dipolelayer': 'xy'}, **kw())
 
     system1.calc = calc1
     system1.get_potential_energy()
-    v1 = calc1.get_effective_potential(pad=False)
+    v1 = calc1.get_effective_potential()
 
     calc2 = GPAW(**kw())
 
     system2.calc = calc2
     system2.get_potential_energy()
-    v2 = calc2.get_effective_potential(pad=False)
+    v2 = calc2.get_effective_potential()
 
     def get_avg(v):
         nx, ny, nz = v.shape
         vyz = v.sum(axis=0) / nx
         vz = vyz.sum(axis=0) / ny
         return vz, vyz
 
     if rank == 0:
         vz1, vyz1 = get_avg(v1)
         vz2, vyz2 = get_avg(v2)
 
         # Compare values that are not quite at the end of the array
         # (at the end of the array things can "oscillate" a bit)
-        dvz1 = vz1[-3] - vz1[2]
-        dvz2 = vz2[2] - vz2[len(vz2) // 2]
+        dvz1 = vz1[-3] - vz1[3]
+        dvz2 = vz2[3] - vz2[len(vz2) // 2]
         print(dvz1, dvz2)
 
         err1 = abs(dvz1 - dvz2)
 
-        correction = calc1.hamiltonian.poisson.correction
+        try:
+            correction = calc1.hamiltonian.poisson.correction
+        except AttributeError:
+            correction = (calc1.calculation.pot_calc.poisson_solver.
+                          solver.correction)
 
         correction_err = abs(2.0 * correction * Hartree + dvz1)
         print('correction error %s' % correction_err)
         assert correction_err < 3e-5
 
         # Comparison to what the values were when this test was last modified:
         ref_value = 2.07342988218
         err2 = abs(dvz1 - ref_value)
 
         if 0:
-            import pylab as pl
-            pl.imshow(vyz1)
-            pl.figure()
-            pl.imshow(vyz2)
-            pl.figure()
-            pl.plot(vz1)
-            pl.plot(vz2)
-            pl.show()
+            import matplotlib.pyplot as plt
+            plt.imshow(vyz1)
+            plt.figure()
+            plt.imshow(vyz2)
+            plt.figure()
+            plt.plot(vz1)
+            plt.plot(vz2)
+            plt.show()
 
         print('Ref value of previous calculation', ref_value)
         print('Value in this calculation', dvz1)
 
         # fine grid needed to achieve convergence!
         print('Error', err1, err2)
         assert err1 < 4e-3, err1
```

### Comparing `gpaw-22.8.0/gpaw/test/test_ds_beta.py` & `gpaw-23.6.0/gpaw/test/test_ds_beta.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/test_fermisplit.py` & `gpaw-23.6.0/gpaw/test/test_fermisplit.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/test_fixdensity.py` & `gpaw-23.6.0/gpaw/test/test_fixdensity.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/test_fixmom.py` & `gpaw-23.6.0/gpaw/test/test_fixmom.py`

 * *Files 1% similar despite different names*

```diff
@@ -17,9 +17,9 @@
                 mixer=MixerSum(0.1, 3),
                 nbands=11,
                 kpts=(3, 3, 3),
                 convergence=conv,
                 occupations=FermiDirac(0.1, fixmagmom=True))
     bulk.calc = calc
     bulk.get_potential_energy()
-    mom = calc.get_magnetic_moment()
+    mom = bulk.get_magnetic_moment()
     assert mom == pytest.approx(mom0, abs=0.005)
```

### Comparing `gpaw-22.8.0/gpaw/test/test_fixocc.py` & `gpaw-23.6.0/gpaw/test/test_fixocc.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/test_gauss_func.py` & `gpaw-23.6.0/gpaw/test/test_gauss_func.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/test_gauss_wave.py` & `gpaw-23.6.0/gpaw/test/test_gauss_wave.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/test_ibzqpt.py` & `gpaw-23.6.0/gpaw/test/test_ibzqpt.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/test_inducedfield_lrtddft.py` & `gpaw-23.6.0/gpaw/test/test_inducedfield_lrtddft.py`

 * *Files 1% similar despite different names*

```diff
@@ -6,14 +6,15 @@
 from gpaw.inducedfield.inducedfield_lrtddft import LrTDDFTInducedField
 from gpaw.lrtddft import LrTDDFT
 from gpaw.poisson import FDPoissonSolver
 from gpaw.test import equal
 
 
 @pytest.mark.ci
+@pytest.mark.later
 def test_inducedfield_lrtddft(in_tmp_dir):
     do_print_values = False  # Use this for printing the reference values
     poisson_eps = 1e-12
     density_eps = 1e-6
 
     # 0) PoissonSolver
     poissonsolver = FDPoissonSolver(eps=poisson_eps)
```

### Comparing `gpaw-22.8.0/gpaw/test/test_inducedfield_td.py` & `gpaw-23.6.0/gpaw/test/test_inducedfield_td.py`

 * *Files 4% similar despite different names*

```diff
@@ -17,15 +17,15 @@
 
     def equal(x, y, tol):  # noqa
         global i
         print("equal(val%d, %20.12f, tol)" % (i, x))
         i += 1
 
 
-@pytest.mark.skip_for_new_gpaw
+@pytest.mark.later
 @pytest.mark.ci
 def test_inducedfield_td(in_tmp_dir):
     poisson_eps = 1e-12
     density_eps = 1e-6
 
     # PoissonSolver
     poissonsolver = PoissonSolver('fd', eps=poisson_eps)
```

### Comparing `gpaw-22.8.0/gpaw/test/test_initial_occs.py` & `gpaw-23.6.0/gpaw/test/test_initial_occs.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/test_jellium.py` & `gpaw-23.6.0/gpaw/test/test_jellium.py`

 * *Files 5% similar despite different names*

```diff
@@ -3,14 +3,15 @@
 from ase import Atoms
 from ase.units import Bohr, Hartree
 from gpaw.jellium import JelliumSlab
 from gpaw import GPAW, Mixer
 from gpaw.test import equal
 
 
+@pytest.mark.later
 @pytest.mark.libxc
 def test_jellium(in_tmp_dir):
     rs = 5.0 * Bohr  # Wigner-Seitz radius
     h = 0.24          # grid-spacing
     a = 8 * h        # lattice constant
     v = 3 * a        # vacuum
     L = 8 * a       # thickness
```

### Comparing `gpaw-22.8.0/gpaw/test/test_kpt.py` & `gpaw-23.6.0/gpaw/test/test_kpt.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/test_kpt_refine.py` & `gpaw-23.6.0/gpaw/test/test_kpt_refine.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,14 +1,15 @@
-from gpaw import GPAW
-from gpaw import PW
-from gpaw import FermiDirac
+import pytest
 from ase.lattice.hexagonal import Graphene
 from ase.parallel import parprint
 
+from gpaw import GPAW, PW, FermiDirac
 
+
+@pytest.mark.legacy
 def test_kpt_refine():
     system = Graphene(symbol='C',
                       latticeconstant={'a': 2.467710, 'c': 1.0},
                       size=(1, 1, 1))
     system.pbc = (1, 1, 0)
     system.center(axis=2, vacuum=4.0)
```

### Comparing `gpaw-22.8.0/gpaw/test/test_libelpa.py` & `gpaw-23.6.0/gpaw/test/test_libelpa.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/test_mpicomm.py` & `gpaw-23.6.0/gpaw/test/test_mpicomm.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/test_muffintinpot.py` & `gpaw-23.6.0/gpaw/test/test_muffintinpot.py`

 * *Files 11% similar despite different names*

```diff
@@ -5,14 +5,15 @@
 from gpaw.test import equal
 
 from gpaw.utilities.kspot import AllElectronPotential
 pytestmark = pytest.mark.skipif(world.size > 1,
                                 reason='world.size > 1')
 
 
+@pytest.mark.later
 def test_muffintinpot(in_tmp_dir):
     if 1:
         be = Atoms(symbols='Be', positions=[(0, 0, 0)])
         be.center(vacuum=5)
         calc = GPAW(gpts=(64, 64, 64),
                     xc='LDA',
                     nbands=1)  # 0.1 required for accuracy
```

### Comparing `gpaw-22.8.0/gpaw/test/test_multipoletest.py` & `gpaw-23.6.0/gpaw/test/test_multipoletest.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/test_negative_eigerror.py` & `gpaw-23.6.0/gpaw/test/test_negative_eigerror.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/test_occupations.py` & `gpaw-23.6.0/gpaw/test/test_occupations.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/test_overlap.py` & `gpaw-23.6.0/gpaw/test/test_overlap.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,24 +1,26 @@
 import numpy as np
+import pytest
 from ase.build import molecule
 from ase.parallel import parprint, world
 
 from gpaw import GPAW
-from gpaw.test import equal
-from gpaw.cluster import Cluster
 from gpaw.analyse.overlap import Overlap
+from gpaw.cluster import Cluster
 from gpaw.lrtddft import LrTDDFT
+from gpaw.test import equal
 
 """Evaluate the overlap between two independent calculations
 
 Differences are forced by different eigensolvers and differing number
 of Kohn-Sham states.
 """
 
 
+@pytest.mark.later
 def test_overlap(in_tmp_dir):
     h = 0.4
     box = 2
     nbands = 4
     txt = '-'
     txt = None
```

### Comparing `gpaw-22.8.0/gpaw/test/test_potential.py` & `gpaw-23.6.0/gpaw/test/test_potential.py`

 * *Files 14% similar despite different names*

```diff
@@ -4,14 +4,15 @@
 from gpaw import GPAW
 from gpaw.test import equal
 
 pytestmark = pytest.mark.skipif(world.size > 1,
                                 reason='world.size > 1')
 
 
+@pytest.mark.legacy
 def test_potential():
     for mode in ['fd', 'pw']:
         print(mode)
         hydrogen = Atoms('H',
                          cell=(2.5, 3, 3.5),
                          pbc=1,
                          calculator=GPAW(txt=None, mode=mode))
```

### Comparing `gpaw-22.8.0/gpaw/test/test_rattle.py` & `gpaw-23.6.0/gpaw/test/test_rattle.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/test_reuse_wfs_celldisp.py` & `gpaw-23.6.0/gpaw/test/test_reuse_wfs_celldisp.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,18 +1,21 @@
 import numpy as np
+import pytest
+from ase.build import molecule
+
 from gpaw import GPAW, Mixer
 from gpaw.mpi import world
-from ase.build import molecule
 
 # Place one atom next to cell boundary, then check that reuse_wfs
 # works correctly when atom is subsequently displaced across the
 # boundary, i.e., that the kpoint phases of the PAW correction
 # are handled correctly when unprojecting/reprojecting the wavefunctions.
 
 
+@pytest.mark.later
 def test_reuse_wfs_celldisp(in_tmp_dir):
     def check(reuse):
         atoms = molecule('H2')
         atoms.pbc = 1
         atoms.center(vacuum=1.5)
         atoms.positions -= atoms.positions[1]
         dz = 1e-2
```

### Comparing `gpaw-22.8.0/gpaw/test/test_scf_criteria.py` & `gpaw-23.6.0/gpaw/test/test_scf_criteria.py`

 * *Files 14% similar despite different names*

```diff
@@ -25,75 +25,77 @@
         self.iters += 1
         return converged, entry
 
     def reset(self):
         self.iters = 0
 
 
+@pytest.mark.later
 def test_scf_criterion(in_tmp_dir):
     """Tests different ways of setting SCF convergence criteria,
     and that it behaves consistenly with regard to the work function."""
     convergence = {'eigenstates': 1.0,
                    'density': 1.0,
                    'energy': 1.0,
                    'work function': 1.0}
     atoms = Atoms('HF', [(0., 0.5, 0.5),
                          (0., 0.4, -0.4)],
                   cell=(5., 5., 9.),
                   pbc=(True, True, False))
     atoms.center()
-    calc = GPAW(h=0.3,
-                nbands=-1,
-                convergence=convergence,
-                txt=None,
-                poissonsolver={'dipolelayer': 'xy'})
-    atoms.calc = calc
+    atoms.calc = GPAW(h=0.3,
+                      nbands=-1,
+                      convergence=convergence,
+                      txt=None,
+                      poissonsolver={'dipolelayer': 'xy'})
     atoms.get_potential_energy()
-    workfunctions1 = Ha * calc.hamiltonian.get_workfunctions(calc.wfs)
-    calc.write('scf-criterion.gpw')
+    workfunctions1 = Ha * atoms.calc.hamiltonian.get_workfunctions(
+        atoms.calc.wfs)
+    atoms.calc.write('scf-criterion.gpw')
 
     # Flip and use saved calculator; work functions should be opposite.
     atoms = Atoms('HF', [(0., 0.5, -0.5),
                          (0., 0.4, +0.4)],
                   cell=(5., 5., 9.),
                   pbc=(True, True, False))
     atoms.center()
-    calc = GPAW('scf-criterion.gpw', txt=None)  # checks loading
-    atoms.calc = calc
+    atoms.calc = GPAW('scf-criterion.gpw', txt=None)  # checks loading
     atoms.get_potential_energy()
-    workfunctions2 = Ha * calc.hamiltonian.get_workfunctions(calc.wfs)
+    workfunctions2 = Ha * atoms.calc.hamiltonian.get_workfunctions(
+        atoms.calc.wfs)
 
     assert workfunctions1[0] == pytest.approx(workfunctions2[1])
     assert workfunctions1[1] == pytest.approx(workfunctions2[0])
-    assert calc.scf.criteria['work function'].tol == pytest.approx(1.0)
+    assert atoms.calc.scf.criteria['work function'].tol == pytest.approx(1.0)
 
     # Try import syntax, and verify it creates a new instance internally.
     workfunction = WorkFunction(0.5)
     convergence = {'eigenstates': 1.0,
                    'density': 1.0,
                    'energy': 1.0,
                    'work function': workfunction}
-    calc.set(convergence=convergence)
+    atoms.calc = atoms.calc.new(convergence=convergence)
     atoms.get_potential_energy()
-    assert calc.scf.criteria['work function'] is not workfunction
-    assert calc.scf.criteria['work function'].tol == pytest.approx(0.5)
+    assert atoms.calc.scf.criteria['work function'] is not workfunction
+    assert atoms.calc.scf.criteria['work function'].tol == pytest.approx(0.5)
 
     # Switch to H2 for faster calcs.
     for atom in atoms:
         atom.symbol = 'H'
 
     # Change a default.
     convergence = {'energy': Energy(2.0, n_old=4),
                    'density': np.inf,
                    'eigenstates': np.inf}
-    calc.set(convergence=convergence)
+    atoms.calc = atoms.calc.new(convergence=convergence)
     atoms.get_potential_energy()
-    assert calc.scf.criteria['energy'].n_old == 4
+    assert atoms.calc.scf.criteria['energy'].n_old == 4
 
 
+@pytest.mark.later
 def test_scf_custom_criterion(in_tmp_dir):
     """Simulate a user creating their own custom convergence criterion,
     saving the .gpw file, and re-loading it. It will warn the user at two
     points."""
     convergence = {'eigenstates': 1.0,
                    'density': 1.0,
                    'energy': 1.0,
```

### Comparing `gpaw-22.8.0/gpaw/test/test_spectrum.py` & `gpaw-23.6.0/gpaw/test/test_spectrum.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/test_spinorbit_Kr.py` & `gpaw-23.6.0/gpaw/test/test_spinorbit_Kr.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/test_stdout.py` & `gpaw-23.6.0/gpaw/test/test_stdout.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/test_timelimit.py` & `gpaw-23.6.0/gpaw/test/test_timelimit.py`

 * *Files 4% similar despite different names*

```diff
@@ -3,15 +3,15 @@
 
 from gpaw import GPAW, KohnShamConvergenceError
 from gpaw.lcaotddft import LCAOTDDFT
 from gpaw.tddft import TDDFT
 from gpaw.utilities.timelimit import TimeLimiter
 
 
-@pytest.mark.skip_for_new_gpaw
+@pytest.mark.later
 def test_timelimit(in_tmp_dir):
     # Atoms
     atoms = molecule('Na2')
     atoms.center(vacuum=4.0)
 
     # Ground-state calculation that will never converge
     maxiter = 10
```

### Comparing `gpaw-22.8.0/gpaw/test/test_timing.py` & `gpaw-23.6.0/gpaw/test/test_timing.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/test_vdwradii.py` & `gpaw-23.6.0/gpaw/test/test_vdwradii.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/test_watermodel.py` & `gpaw-23.6.0/gpaw/test/test_watermodel.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/too_close_test.py` & `gpaw-23.6.0/gpaw/test/test_too_close.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/utilities/test_eed.py` & `gpaw-23.6.0/gpaw/test/utilities/test_eed.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/utilities/test_elf.py` & `gpaw-23.6.0/gpaw/test/utilities/test_elf.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,19 +1,22 @@
 import numpy as np
+import pytest
 from ase.parallel import parprint
+
 from gpaw import GPAW, restart
 from gpaw.elf import ELF
-from gpaw.test import equal
 from gpaw.mpi import rank
+from gpaw.test import equal
 
 
+@pytest.mark.mgga
 def test_utilities_elf(gpw_files):
     # Real wave functions
     atoms, calc = restart(gpw_files['h2_fd'])
-    
+
     elf = ELF(calc)
     elf.update()
     elf_G = elf.get_electronic_localization_function(gridrefinement=1)
     elf_g = elf.get_electronic_localization_function(gridrefinement=2)
 
     # integrate the H2 bond
     if rank == 0:
```

### Comparing `gpaw-22.8.0/gpaw/test/utilities/test_ewald.py` & `gpaw-23.6.0/gpaw/test/utilities/test_ewald.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/utilities/test_ldos.py` & `gpaw-23.6.0/gpaw/test/utilities/test_ldos.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,14 +1,16 @@
-from ase import Atom, Atoms
+import os
+
 import numpy as np
+from ase import Atom, Atoms
 
+import gpaw.mpi as mpi
 from gpaw import GPAW, FermiDirac, PoissonSolver
-from gpaw.utilities.dos import raw_orbital_LDOS, raw_wignerseitz_LDOS, RawLDOS
 from gpaw.test import equal
-import gpaw.mpi as mpi
+from gpaw.utilities.dos import RawLDOS, raw_orbital_LDOS, raw_wignerseitz_LDOS
 
 
 def test_utilities_ldos(in_tmp_dir):
     comms = [mpi.world.new_communicator(np.array([r]))
              for r in range(mpi.size)]
     comm = comms[mpi.rank]
 
@@ -46,30 +48,32 @@
     e_LiH = LiH.get_potential_energy()
     energies, Li_orbitalweight = raw_orbital_LDOS(calc, a=0, spin=0,
                                                   angular=None)
     energies, H_orbitalweight = raw_orbital_LDOS(calc, a=1, spin=0,
                                                  angular=None)
     energies, Li_wzweight = raw_wignerseitz_LDOS(calc, a=0, spin=0)
     energies, H_wzweight = raw_wignerseitz_LDOS(calc, a=1, spin=0)
-    n_a = calc.get_wigner_seitz_densities(spin=0)
+
+    if not os.environ.get('GPAW_NEW'):
+        n_a = calc.get_wigner_seitz_densities(spin=0)
+        print(n_a)
+        equal(n_a.sum(), 0.0, 1e-5)
+        equal(n_a[1], 0.737, 0.001)
 
     print(sweight, pdfweight)
     print(sweight_spin)
     print(Li_wzweight)
     print(H_wzweight)
-    print(n_a)
 
     equal(sweight[0], 1.0, 0.06)
     equal(pdfweight[0], 0.0, 0.0001)
     equal(sweight_spin[0], 1.14, 0.06)
     assert ((Li_wzweight - [.13, 0.93]).round(2) == 0).all()
     assert ((H_wzweight - [0.87, 0.07]).round(2) == 0).all()
     assert ((Li_wzweight + H_wzweight).round(5) == 1).all()
-    equal(n_a.sum(), 0.0, 1e-5)
-    equal(n_a[1], 0.737, 0.001)
 
     print(Li_orbitalweight)
     print(H_orbitalweight)
     #               HOMO    s   py  pz  px  *s
     Li_orbitalweight[0] -= [.5, .0, .6, .0, .0]
     H_orbitalweight[0] -= [.7, .0, .0, .0, .0]
```

### Comparing `gpaw-22.8.0/gpaw/test/utilities/test_partitioning.py` & `gpaw-23.6.0/gpaw/test/utilities/test_partitioning.py`

 * *Files 2% similar despite different names*

```diff
@@ -2,16 +2,18 @@
 from ase.parallel import parprint
 
 from gpaw import GPAW
 from gpaw.cluster import Cluster
 from gpaw.analyse.hirshfeld import HirshfeldDensity, HirshfeldPartitioning
 from gpaw.analyse.wignerseitz import WignerSeitz
 from gpaw.test import equal
+import pytest
 
 
+@pytest.mark.later
 def test_utilities_partitioning(in_tmp_dir):
     h = 0.4
     gpwname = 'H2O' + str(h) + '.gpw'
 
     def run(lastres=[]):
         results = []
```

### Comparing `gpaw-22.8.0/gpaw/test/utilities/test_simple_stm.py` & `gpaw-23.6.0/gpaw/test/utilities/test_simple_stm.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,15 +1,17 @@
+import pytest
 from ase import Atoms
 
-from gpaw.mpi import size, rank
 from gpaw import GPAW, FermiDirac
 from gpaw.analyse.simple_stm import SimpleStm
+from gpaw.mpi import rank, size
 from gpaw.test import equal
 
 
+@pytest.mark.later
 def test_utilities_simple_stm(in_tmp_dir):
     load = False
     txt = '/dev/null'
     txt = '-'
 
     me = ''
     if size > 1:
```

### Comparing `gpaw-22.8.0/gpaw/test/utilities/test_wannier_ethylene.py` & `gpaw-23.6.0/gpaw/test/utilities/test_wannier_ethylene.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/vdw/test_H_Hirshfeld.py` & `gpaw-23.6.0/gpaw/test/vdw/test_H_Hirshfeld.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,17 +1,19 @@
 """Test Hirshfeld for spin/no spin consistency."""
+import pytest
 from ase import Atom
-from gpaw import GPAW
 from ase.parallel import parprint
+
+from gpaw import GPAW, FermiDirac
 from gpaw.analyse.hirshfeld import HirshfeldPartitioning
-from gpaw import FermiDirac
 from gpaw.cluster import Cluster
 from gpaw.test import equal
 
 
+@pytest.mark.later
 def test_vdw_H_Hirshfeld():
     h = 0.25
     box = 3
 
     atoms = Cluster()
     atoms.append(Atom('H'))
     atoms.minimal_box(box)
```

### Comparing `gpaw-22.8.0/gpaw/test/vdw/test_ar2.py` & `gpaw-23.6.0/gpaw/test/vdw/test_ar2.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/vdw/test_libvdwxc_functionals.py` & `gpaw-23.6.0/gpaw/test/vdw/test_libvdwxc_functionals.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/vdw/test_libvdwxc_h2.py` & `gpaw-23.6.0/gpaw/test/vdw/test_libvdwxc_h2.py`

 * *Files 5% similar despite different names*

```diff
@@ -5,14 +5,15 @@
 from gpaw.xc.libvdwxc import vdw_df
 from gpaw.mpi import world
 
 pytestmark = pytest.mark.skipif(not compiled_with_libvdwxc(),
                                 reason='not compiled_with_libvdwxc()')
 
 
+@pytest.mark.later
 def test_vdw_libvdwxc_h2(in_tmp_dir):
     system = molecule('H2')
     system.center(vacuum=1.0)
     system.pbc = 1
 
     def calculate(**kwargs1):
         kwargs = dict(mode=mode,
```

### Comparing `gpaw-22.8.0/gpaw/test/vdw/test_libvdwxc_mbeef.py` & `gpaw-23.6.0/gpaw/test/vdw/test_libvdwxc_mbeef.py`

 * *Files 19% similar despite different names*

```diff
@@ -8,27 +8,28 @@
 
 from gpaw.test import gen
 
 pytestmark = pytest.mark.skipif(not compiled_with_libvdwxc(),
                                 reason='not compiled_with_libvdwxc()')
 
 
+@pytest.mark.mgga
 def test_vdw_libvdwxc_mbeef():
     setup = gen('Si', xcname='PBEsol')
 
     system = bulk('Si')
     calc = GPAW(mode=PW(200), xc=vdw_mbeef(),
                 kpts=(2, 2, 2),
                 nbands=4,
                 convergence=dict(density=1e-6),
                 mixer=Mixer(1.0),
                 eigensolver=Davidson(4),
                 setups={'Si': setup})
     system.calc = calc
     e = system.get_potential_energy()
-    ref = -60.544411820017906
+    ref = -60.53662105617721
     err = abs(e - ref)
     print('e=%r ref=%r err=%r' % (e, ref, err))
     # It would be reasonable to put 1e-6 as tolerance,
     # but the value changes by 4e-4 depending on libxc version.
     # See https://gitlab.com/gpaw/gpaw/issues/161 .
     assert err < 1e-3, err
```

### Comparing `gpaw-22.8.0/gpaw/test/vdw/test_libvdwxc_spin.py` & `gpaw-23.6.0/gpaw/test/vdw/test_libvdwxc_spin.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/vdw/test_potential.py` & `gpaw-23.6.0/gpaw/test/vdw/test_potential.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/vdw/test_quick_spin.py` & `gpaw-23.6.0/gpaw/test/vdw/test_quick_spin.py`

 * *Files 10% similar despite different names*

```diff
@@ -9,16 +9,18 @@
     a = Atoms('H', cell=(L, L, L), pbc=True)
     calc = GPAW(xc='vdW-DF',
                 occupations=FermiDirac(width=0.001),
                 txt='H.vdW-DF.txt')
     a.calc = calc
     e1 = a.get_potential_energy()
 
-    calc.set(txt='H.vdW-DF.spinpol.txt',
-             spinpol=True,
-             occupations=FermiDirac(width=0.001, fixmagmom=True))
+    calc = GPAW(xc='vdW-DF',
+                txt='H.vdW-DF.spinpol.txt',
+                spinpol=True,
+                occupations=FermiDirac(width=0.001, fixmagmom=True))
+    a.calc = calc
     e2 = a.get_potential_energy()
 
     assert abs(calc.get_eigenvalues(spin=0)[0] -
                calc.get_eigenvalues(spin=1)[0]) < 1e-10
 
     assert abs(e1 - e2) < 2e-6, abs(e1 - e2)
```

### Comparing `gpaw-22.8.0/gpaw/test/vdw/test_ts09.py` & `gpaw-23.6.0/gpaw/test/vdw/test_ts09.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,21 +1,22 @@
-import numpy as np
-
 import ase.io
+import numpy as np
+import pytest
+from ase.build import molecule
 from ase.calculators.vdwcorrection import vdWTkatchenko09prl
 from ase.parallel import barrier, parprint
-from ase.build import molecule
 
 from gpaw import GPAW
 from gpaw.analyse.hirshfeld import HirshfeldPartitioning
 from gpaw.analyse.vdwradii import vdWradii
 from gpaw.cluster import Cluster
 from gpaw.test import equal
 
 
+@pytest.mark.later
 def test_vdw_ts09(in_tmp_dir):
     h = 0.4
     s = Cluster(molecule('LiH'))
     s.minimal_box(3., h=h)
 
     def print_charge_and_check(hp, q=0, label='unpolarized'):
         q_a = np.array(hp.get_charges())
@@ -69,15 +70,15 @@
         equal(q_a, qs_a, 1.e-6)
         equal(E, Es, 1.e-4)
         equal(F_ac, Fs_ac, 1.e-4)
 
     # charged
 
     if 0:
-        cc.set(charge=1)
+        cc = cc.new(charge=1)
         hpp = HirshfeldPartitioning(cc)
         cp = vdWTkatchenko09prl(hpp,
                                 vdWradii(s.get_chemical_symbols(), 'PBE'))
         s.calc = cp
         E = s.get_potential_energy()
 
         print_charge_and_check(hpp, 1, label='+1')
```

### Comparing `gpaw-22.8.0/gpaw/test/xc/test_XC2.py` & `gpaw-23.6.0/gpaw/test/xc/test_XC2.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/xc/test_atomize.py` & `gpaw-23.6.0/gpaw/test/xc/test_atomize.py`

 * *Files 4% similar despite different names*

```diff
@@ -35,21 +35,22 @@
 
     # Hydrogen molecule:
     d = 0.74  # Experimental bond length
     molecule = Atoms([Atom('H', (c - d / 2, c, c)),
                       Atom('H', (c + d / 2, c, c))],
                      cell=(a, a, a), pbc=False)
 
-    calc.set(txt='H2.txt')
-    molecule.calc = calc
+    molecule.calc = calc.new(txt='H2.txt')
     e2 = molecule.get_potential_energy()
-    de2t = calc.get_xc_difference(xc('TPSS'))
-    de2m = calc.get_xc_difference(xc('M06-L'))
-    de2x = calc.get_xc_difference(HybridXC('EXX', stencil=1, finegrid=True))
-    de2xb = calc.get_xc_difference(HybridXC('EXX', stencil=1, finegrid=False))
+    de2t = molecule.calc.get_xc_difference(xc('TPSS'))
+    de2m = molecule.calc.get_xc_difference(xc('M06-L'))
+    de2x = molecule.calc.get_xc_difference(
+        HybridXC('EXX', stencil=1, finegrid=True))
+    de2xb = molecule.calc.get_xc_difference(
+        HybridXC('EXX', stencil=1, finegrid=False))
 
     print('hydrogen atom energy:     %5.2f eV' % e1)
     print('hydrogen molecule energy: %5.2f eV' % e2)
     print('atomization energy:       %5.2f eV' % (2 * e1 - e2))
     print('atomization energy  TPSS: %5.2f eV' %
           (2 * (e1 + de1t) - (e2 + de2t)))
     print('atomization energy  M06-L: %5.2f eV' %
```

### Comparing `gpaw-22.8.0/gpaw/test/xc/test_beef.py` & `gpaw-23.6.0/gpaw/test/xc/test_beef.py`

 * *Files 6% similar despite different names*

```diff
@@ -4,14 +4,15 @@
 from ase.dft.bee import BEEFEnsemble, readbee
 from gpaw import GPAW, Mixer, PW
 from gpaw.test import gen
 from gpaw.mpi import world
 import _gpaw
 
 
+@pytest.mark.mgga
 @pytest.mark.libxc
 @pytest.mark.slow
 def test_beef(in_tmp_dir):
     newlibxc = _gpaw.lxcXCFuncNum('MGGA_X_MBEEF') is not None
 
     gen('Si', xcname='PBEsol')
```

### Comparing `gpaw-22.8.0/gpaw/test/xc/test_degeneracy.py` & `gpaw-23.6.0/gpaw/test/xc/test_degeneracy.py`

 * *Files 11% similar despite different names*

```diff
@@ -14,33 +14,33 @@
                    (-x, -x, x),
                    (x, -x, -x),
                    (-x, x, -x)],
                   cell=(a, a, a),
                   pbc=False)
 
     atoms.positions[:] += a / 2
-    calc = GPAW(h=0.25, nbands=4, convergence={'eigenstates': 7.8e-10})
-    atoms.calc = calc
+    params = dict(h=0.25, nbands=4, convergence={'eigenstates': 7.8e-10})
+    atoms.calc = GPAW(**params)
     energy = atoms.get_potential_energy()
 
     # The three eigenvalues e[1], e[2], and e[3] must be degenerate:
-    e = calc.get_eigenvalues()
+    e = atoms.calc.get_eigenvalues()
     print(e[1] - e[3])
     equal(e[1], e[3], 9.3e-8)
 
     energy_tolerance = 0.002
     equal(energy, -23.631, energy_tolerance)
 
-    gs = calc.gs_adapter()
+    gs = atoms.calc.gs_adapter()
 
     # Calculate non-selfconsistent PBE eigenvalues:
-    epbe0 = e - vxc(gs)[0, 0] + vxc(gs, 'PBE')[0, 0]
+    epbe0 = e[:2] - vxc(gs, n2=2)[0, 0] + vxc(gs, 'PBE', n2=2)[0, 0]
 
     # Calculate selfconsistent PBE eigenvalues:
-    calc.set(xc='PBE')
+    atoms.calc = GPAW(**params, xc='PBE')
     energy = atoms.get_potential_energy()
-    epbe = calc.get_eigenvalues()
+    epbe = atoms.calc.get_eigenvalues()
 
     de = epbe[1] - epbe[0]
     de0 = epbe0[1] - epbe0[0]
     print(de, de0)
     equal(de, de0, 0.001)
```

### Comparing `gpaw-22.8.0/gpaw/test/xc/test_gga_atom.py` & `gpaw-23.6.0/gpaw/test/xc/test_gga_atom.py`

 * *Files 5% similar despite different names*

```diff
@@ -13,15 +13,15 @@
 def test_xc_gga_atom():
     ra.seed(8)
     for name in ['LDA', 'PBE']:
         xc = XC(name)
         s = create_setup('N', xc)
         ni = s.ni
         nao = s.nao
-        wt0_j = s.phit_j
+        wt0_j = s.basis_functions_J
 
         rcut = s.xc_correction.rgd.r_g[-1]
 
         wt_j = []
         for wt0 in wt0_j:
             data = [wt0(r) for r in np.arange(121) * rcut / 100]
             data[-1] = 0.0
```

### Comparing `gpaw-22.8.0/gpaw/test/xc/test_lb94.py` & `gpaw-23.6.0/gpaw/test/xc/test_lb94.py`

 * *Files 2% similar despite different names*

```diff
@@ -49,16 +49,14 @@
         world.barrier()
 
         SS = Atoms(atom, cell=(7, 7, 7), pbc=False)
         SS.center()
         c = GPAW(h=.3, xc='LB94',
                  eigensolver=Davidson(3),
                  mixer=Mixer(0.5, 7, 50.0), nbands=-2, txt=txt)
-        if atom in ['Mg']:
-            c.set(eigensolver='cg')
         c.calculate(SS)
         # find HOMO energy
         eps_n = c.get_eigenvalues(kpt=0, spin=0) / 27.211
         f_n = c.get_occupation_numbers(kpt=0, spin=0)
         for e, f in zip(eps_n, f_n):
             if f < 0.99:
                 break
```

### Comparing `gpaw-22.8.0/gpaw/test/xc/test_lxc_xcatom.py` & `gpaw-23.6.0/gpaw/test/xc/test_lxc_xcatom.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/xc/test_nonselfconsistent.py` & `gpaw-23.6.0/gpaw/test/xc/test_nonselfconsistent.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,36 +1,37 @@
 from ase import Atoms
 from ase.units import Bohr
 from gpaw import GPAW
 from gpaw.test import equal
 
 
-def test_xc_nonselfconsistent(in_tmp_dir):
-    def xc(name):
-        return {'name': name, 'stencil': 1}
+def xc(name):
+    return {'name': name, 'stencil': 1}
+
 
+def test_xc_nonselfconsistent(in_tmp_dir):
     a = 7.5 * Bohr
     n = 16
     atoms = Atoms('He', [(0.0, 0.0, 0.0)], cell=(a, a, a), pbc=True)
-    calc = GPAW(gpts=(n, n, n), nbands=1, xc=xc('PBE'))
-    atoms.calc = calc
+    params = dict(gpts=(n, n, n), nbands=1)
+    atoms.calc = GPAW(**params, xc=xc('PBE'))
     e1 = atoms.get_potential_energy()
-    e1ref = calc.get_reference_energy()
-    de12 = calc.get_xc_difference(xc('revPBE'))
-    calc.set(xc=xc('revPBE'))
+    e1ref = atoms.calc.get_reference_energy()
+    de12 = atoms.calc.get_xc_difference(xc('revPBE'))
+    atoms.calc = GPAW(**params, xc=xc('revPBE'))
     e2 = atoms.get_potential_energy()
-    e2ref = calc.get_reference_energy()
-    de21 = calc.get_xc_difference(xc('PBE'))
+    e2ref = atoms.calc.get_reference_energy()
+    de21 = atoms.calc.get_xc_difference(xc('PBE'))
     print(e1ref + e1 + de12 - (e2ref + e2))
     print(e1ref + e1 - (e2ref + e2 + de21))
     print(de12, de21)
     equal(e1ref + e1 + de12, e2ref + e2, 8e-4)
     equal(e1ref + e1, e2ref + e2 + de21, 3e-3)
 
-    calc.write('revPBE.gpw')
+    atoms.calc.write('revPBE.gpw')
 
     de21b = GPAW('revPBE.gpw').get_xc_difference(xc('PBE'))
     equal(de21, de21b, 9e-8)
 
     energy_tolerance = 0.0005
     equal(e1, -0.07904951, energy_tolerance)
     equal(e2, -0.08147563, energy_tolerance)
```

### Comparing `gpaw-22.8.0/gpaw/test/xc/test_nonselfconsistentLDA.py` & `gpaw-23.6.0/gpaw/test/xc/test_nonselfconsistentLDA.py`

 * *Files 18% similar despite different names*

```diff
@@ -9,15 +9,16 @@
     n = 16
     atoms = Atoms([Atom('He', (0.0, 0.0, 0.0))], cell=(a, a, a), pbc=True)
     calc = GPAW(gpts=(n, n, n), nbands=1, xc='LDA')
     atoms.calc = calc
     e1 = atoms.get_potential_energy()
     e1ref = calc.get_reference_energy()
     de12 = calc.get_xc_difference({'name': 'PBE', 'stencil': 1})
-    calc.set(xc={'name': 'PBE', 'stencil': 1})
+    calc = GPAW(gpts=(n, n, n), nbands=1, xc={'name': 'PBE', 'stencil': 1})
+    atoms.calc = calc
     e2 = atoms.get_potential_energy()
     e2ref = calc.get_reference_energy()
     de21 = calc.get_xc_difference('LDA')
     print(e1ref + e1 + de12, e2ref + e2)
     print(e1ref + e1, e2ref + e2 + de21)
     print(de12, de21)
     equal(e1ref + e1 + de12, e2ref + e2, 0.02)
```

### Comparing `gpaw-22.8.0/gpaw/test/xc/test_pbe_pw91.py` & `gpaw-23.6.0/gpaw/test/xc/test_pbe_pw91.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/xc/test_pplda.py` & `gpaw-23.6.0/gpaw/test/xc/test_pplda.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/xc/test_pygga.py` & `gpaw-23.6.0/gpaw/test/xc/test_pygga.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/xc/test_qna_band.py` & `gpaw-23.6.0/gpaw/test/xc/test_qna_band.py`

 * *Files 21% similar despite different names*

```diff
@@ -1,11 +1,14 @@
-from gpaw import GPAW, PW
+import pytest
 from ase.lattice.compounds import L1_2
 
+from gpaw import GPAW, PW
+
 
+@pytest.mark.later
 def test_xc_qna_band(in_tmp_dir):
     """Cu3Au"""
     ecut = 300
     kpts = (2, 2, 2)
 
     QNA = {'alpha': 2.0,
            'name': 'QNA',
```

### Comparing `gpaw-22.8.0/gpaw/test/xc/test_qna_spinpol.py` & `gpaw-23.6.0/gpaw/test/xc/test_qna_spinpol.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,12 +1,15 @@
-from gpaw import GPAW, PW
+import pytest
 from ase.lattice.cubic import BodyCenteredCubic
+
+from gpaw import GPAW, PW
 from gpaw.test import equal
 
 
+@pytest.mark.later
 def test_xc_qna_spinpol(in_tmp_dir):
     QNA = {'alpha': 2.0,
            'name': 'QNA',
            'orbital_dependent': False,
            'parameters': {'Fe': (0.1485, 0.005)},
            'setup_name': 'PBE',
            'type': 'qna-gga'}
```

### Comparing `gpaw-22.8.0/gpaw/test/xc/test_revPBE.py` & `gpaw-23.6.0/gpaw/test/xc/test_revPBE.py`

 * *Files 19% similar despite different names*

```diff
@@ -4,22 +4,23 @@
 from ase.units import Bohr, Hartree
 
 
 def test_xc_revPBE():
     a = 7.5 * Bohr
     n = 16
     atoms = Atoms('He', [(0.0, 0.0, 0.0)], cell=(a, a, a), pbc=True)
-    calc = GPAW(gpts=(n, n, n), nbands=1, xc={'name': 'PBE', 'stencil': 1},
-                poissonsolver=PoissonSolver('fd'))
-    atoms.calc = calc
+    params = dict(gpts=(n, n, n), nbands=1, xc={'name': 'PBE', 'stencil': 1},
+                  poissonsolver=PoissonSolver('fd'))
+    atoms.calc = GPAW(**params)
     e1 = atoms.get_potential_energy()
-    e1a = calc.get_reference_energy()
-    calc.set(xc={'name': 'revPBE', 'stencil': 1})
+    e1a = atoms.calc.get_reference_energy()
+    params['xc'] = {'name': 'revPBE', 'stencil': 1}
+    atoms.calc = GPAW(**params)
     e2 = atoms.get_potential_energy()
-    e2a = calc.get_reference_energy()
+    e2a = atoms.calc.get_reference_energy()
 
     equal(e1a, -2.893 * Hartree, 8e-3)
     equal(e2a, -2.908 * Hartree, 9e-3)
     equal(e1, e2, 4e-3)
 
     energy_tolerance = 0.0005
     equal(e1, -0.0790449962, energy_tolerance)
```

### Comparing `gpaw-22.8.0/gpaw/test/xc/test_tb09.py` & `gpaw-23.6.0/gpaw/test/xc/test_tb09.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,15 +1,17 @@
 """Test Tran Blaha potential."""
 import pytest
 from ase.dft.bandgap import bandgap
 from ase.build import bulk
 from gpaw import GPAW, PW, Mixer
 
 
+@pytest.mark.later
 @pytest.mark.libxc
+@pytest.mark.mgga
 def test_xc_tb09(in_tmp_dir):
     def xc(name):
         return {'name': name, 'stencil': 1}
 
     k = 8
     atoms = bulk('Si')
     atoms.calc = GPAW(mode=PW(300),
@@ -19,10 +21,10 @@
                       convergence={'bands': -3},
                       txt='si.txt')
     atoms.get_potential_energy()
     gap, (sv, kv, nv), (sc, kc, nc) = bandgap(atoms.calc)
     c = atoms.calc.hamiltonian.xc.c
     print(gap, kv, kc)
     print('c:', c)
-    assert abs(gap - 1.226) < 0.01
-    assert kv == 0 and kc == 24
-    assert abs(c - 1.136) < 0.01
+    assert abs(gap - 1.246) < 0.01
+    assert kv == 0 and kc == 12
+    assert abs(c - 1.135) < 0.01
```

### Comparing `gpaw-22.8.0/gpaw/test/xc/test_xc.py` & `gpaw-23.6.0/gpaw/test/xc/test_xc.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/xc/test_xcatom.py` & `gpaw-23.6.0/gpaw/test/xc/test_xcatom.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/test/xc/tpss_test.py` & `gpaw-23.6.0/gpaw/test/xc/test_tpss.py`

 * *Files 4% similar despite different names*

```diff
@@ -38,15 +38,15 @@
                     parallel=dict(kpt=1),
                     mixer=Mixer(0.5, 5),
                     nbands=-2,
                     poissonsolver=PoissonSolver('fd', relax='GS'),
                     xc='oldPBE',
                     txt=formula + '.txt')
         if len(loa) == 1:
-            calc.set(hund=True)
+            calc = calc.new(hund=True)
         else:
             pos = loa.get_positions()
             pos[1, :] = pos[0, :] + [0.0, 0.0, exp_bonds_dE[formula][0]]
             loa.set_positions(pos)
             loa.center()
         loa.calc = calc
         energy = loa.get_potential_energy()
```

### Comparing `gpaw-22.8.0/gpaw/tetrahedron.py` & `gpaw-23.6.0/gpaw/tetrahedron.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/transformers.py` & `gpaw-23.6.0/gpaw/transformers.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/unfold.py` & `gpaw-23.6.0/gpaw/unfold.py`

 * *Files 1% similar despite different names*

```diff
@@ -34,16 +34,14 @@
             self.pd = self.calc.wfs.pd
         else:
             self.pd = PWDescriptor(ecut=None, gd=self.gd, kd=self.kd,
                                    dtype=complex)
 
         self.acell_cv = self.gd.cell_cv
         self.bcell_cv = 2 * np.pi * self.gd.icell_cv
-        self.vol = self.gd.volume
-        self.BZvol = (2 * np.pi)**3 / self.vol
 
         self.nb = self.calc.get_number_of_bands()
 
         self.v_Kmsn = None
         if spinorbit:
             if mpi.world.rank == 0:
                 print('Calculating spinorbit Corrections')
```

### Comparing `gpaw-22.8.0/gpaw/upf.py` & `gpaw-23.6.0/gpaw/upf.py`

 * *Files 2% similar despite different names*

```diff
@@ -314,15 +314,14 @@
             gcut = self.rgd.r2g(1.0)
             self.pt_jg = [np.zeros(gcut)]  # XXX yet another "null" function
 
         self.rcgauss = 0.0  # XXX .... what is this used for?
         self.ni = sum([2 * l + 1 for l in self.l_j])
 
         self.fingerprint = None  # XXX hexdigest the file?
-        self.HubU = None  # XXX
         self.lq = None  # XXX
 
         if valence_states is None:
             valence_states = data['states']
 
         if valence_states:
             states_lmax = max([state.l for state in valence_states])
@@ -334,18 +333,18 @@
                 f_ln[state.l].append(state.occupation)
                 electroncount += state.occupation
                 # The Cl.pz-hgh.UPF from quantum espresso has only 6
                 # but should have 7 electrons.  Oh well....
             # err = abs(electroncount - self.Nv)
             self.f_j = [state.occupation for state in valence_states]
             self.n_j = [state.n for state in valence_states]
-            self.l_orb_j = [state.l for state in valence_states]
+            self.l_orb_J = [state.l for state in valence_states]
             self.f_ln = f_ln
         else:
-            self.n_j, self.l_orb_j, self.f_j, self.f_ln = \
+            self.n_j, self.l_orb_J, self.f_j, self.f_ln = \
                 figure_out_valence_states(self)
 
         vlocal_unscreened = data['vlocal']
 
         # The UPF representation of HGH setups should be equal to that
         # used with setups='hgh'.  But the UPF files do not contain
         # info on the localization of the compensation charges!  That
```

### Comparing `gpaw-22.8.0/gpaw/utilities/bader.py` & `gpaw-23.6.0/gpaw/utilities/bader.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,39 +1,40 @@
+from __future__ import annotations
+import subprocess
+import sys
 from pathlib import Path
-from typing import Union
 
 import numpy as np
+from ase.io import write
+from ase.units import Bohr
+from gpaw.new.ase_interface import GPAW
 
 
-def read_bader_charges(filename: Union[str, Path] = 'ACF.dat') -> np.ndarray:
+def read_bader_charges(filename: str | Path = 'ACF.dat') -> np.ndarray:
     path = Path(filename)
     charges = []
     with path.open() as fd:
         for line in fd:
             words = line.split()
             if len(words) == 7:
                 charges.append(float(words[4]))
     return np.array(charges)
 
 
-if __name__ == '__main__':
-    import subprocess
-    import sys
-    from ase.io import write
-    from ase.units import Bohr
-    from gpaw import GPAW
-    from gpaw.utilities.ps2ae import PS2AE
-
-    calc = GPAW(sys.argv[1])
-    converter = PS2AE(calc, grid_spacing=0.05)
-    density = converter.get_pseudo_density()
-    ne = density.sum() * converter.dv
-    print(ne, 'electrons')
+def main(gpw_file_name: str):
+    calc = GPAW(gpw_file_name)
+    dens = calc.calculation.densities()
+    n_sR = dens.all_electron_densities(grid_spacing=0.05)
     # NOTE: Ignoring ASE's hint for **kwargs in write() because it is wrong:
     write('density.cube',
           calc.atoms,
-          data=density * Bohr**3)  # type: ignore
+          data=n_sR.data.sum(axis=0) * Bohr**3)  # type: ignore
     subprocess.run('bader -p all_atom density.cube'.split())
-    charges = read_bader_charges()
-    for setup, charge in zip(calc.density.setups, charges):
-        charge -= setup.Nv
-        print(f'{setup.symbol:2} {charge:10.6f}')
+    ne = n_sR.integrate().sum()
+    print(f'{ne:.6f} electrons')
+    charges = calc.atoms.numbers - read_bader_charges()
+    for symbol, charge in zip(calc.atoms.symbols, charges):
+        print(f'{symbol:2} {charge:10.6f} |e|')
+
+
+if __name__ == '__main__':
+    main(sys.argv[1])
```

### Comparing `gpaw-22.8.0/gpaw/utilities/blas.py` & `gpaw-23.6.0/gpaw/utilities/blas.py`

 * *Files 1% similar despite different names*

```diff
@@ -52,18 +52,18 @@
     if opb == 'N':
         b1, b2 = b.shape
     else:
         b2, b1 = b.shape
     assert a2 == b1
     assert c.shape == (a1, b2)
 
+    assert a.dtype == b.dtype == c.dtype
     assert a.strides[1] == c.itemsize or a.size == 0
     assert b.strides[1] == c.itemsize or b.size == 0
     assert c.strides[1] == c.itemsize or c.size == 0
-    assert a.dtype == b.dtype == c.dtype
     if a.dtype == float:
         assert not isinstance(alpha, complex)
         assert not isinstance(beta, complex)
     else:
         assert a.dtype == complex
 
     _gpaw.mmm(alpha, a, opa, b, opb, beta, c)
@@ -99,14 +99,16 @@
     Performs the operation::
 
       y <- alpha * x + y
 
     """
     if x.size == 0:
         return
+    assert x.flags.contiguous
+    assert y.flags.contiguous
     x = x.ravel()
     y = y.ravel()
     if x.dtype == float:
         z = blas.daxpy(x, y, a=alpha)
     else:
         z = blas.zaxpy(x, y, a=alpha)
     assert z is y, (x, y, x.shape, y.shape)
```

### Comparing `gpaw-22.8.0/gpaw/utilities/cg.py` & `gpaw-23.6.0/gpaw/utilities/cg.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/utilities/debug.py` & `gpaw-23.6.0/gpaw/utilities/debug.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/utilities/dipole.py` & `gpaw-23.6.0/gpaw/utilities/dipole.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/utilities/dos.py` & `gpaw-23.6.0/gpaw/utilities/dos.py`

 * *Files 1% similar despite different names*

```diff
@@ -459,16 +459,15 @@
                     'k-point weight: weight']
 
             # minimal and maximal energies
             emin = 1.e32
             emax = -1.e32
             for k in range(wfs.kd.nibzkpts):
                 for s in range(wfs.nspins):
-                    e_n = self.paw.get_eigenvalues(kpt=k, spin=s,
-                                                   broadcast=True)
+                    e_n = self.paw.get_eigenvalues(kpt=k, spin=s)
                     emin = min(e_n.min(), emin)
                     emax = max(e_n.max(), emax)
             emin -= 4 * width
             emax += 4 * width
 
             # Fermi energies
             efermis = self.paw.wfs.fermi_levels
@@ -507,16 +506,15 @@
                 e = emin
                 while e < emax:
                     val = {}
                     for key in ldbe:
                         val[key] = np.zeros((3))
                     for k in range(wfs.kd.nibzkpts):
                         w = wfs.kpt_u[k].weight
-                        e_n = self.paw.get_eigenvalues(kpt=k, spin=s,
-                                                       broadcast=True)
+                        e_n = self.paw.get_eigenvalues(kpt=k, spin=s)
                         for n in range(wfs.bd.nbands):
                             w_i = w * gauss.get(e_n[n] - e)
                             for key in ldbe:
                                 val[key] += w_i * ldbe[key][s, k, n]
 
                     print('%10.5f %2d' % (e + eshift, s), end=' ', file=f)
                     for key in val:
```

### Comparing `gpaw-22.8.0/gpaw/utilities/ekin.py` & `gpaw-23.6.0/gpaw/utilities/ekin.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/utilities/elpa.py` & `gpaw-23.6.0/gpaw/utilities/elpa.py`

 * *Files 13% similar despite different names*

```diff
@@ -90,30 +90,14 @@
         assert self.nev == len(eps)
         self.desc.checkassert(A)
         self.desc.checkassert(S)
         self.desc.checkassert(C)
         _gpaw.pyelpa_general_diagonalize(self._ptr, A, S, C, eps,
                                          is_already_decomposed)
 
-    def hermitian_multiply(self, A, B, C, desca, descb, descc,
-                           uplo_a='X', uplo_c='X'):
-        """Calculate C = A**T * B (real matrices) or C = A**H B (complex)."""
-        ROW = 1
-        COL = 0
-
-        ncb = descb.gshape[COL]
-        nrows_b = descb.shape[ROW]
-        ncols_b = descb.shape[COL]
-        nrows_c = descc.shape[ROW]
-        ncols_c = descc.shape[COL]
-        _gpaw.pyelpa_hermitian_multiply(self._ptr, uplo_a, uplo_c,
-                                        # XXXXXXXXXXX .T.copy()
-                                        ncb, A, B, nrows_b, ncols_b,
-                                        C, nrows_c, ncols_c)
-
     def elpa_set(self, **kwargs):
         for key, value in kwargs.items():
             # print('pyelpa_set {}={}'.format(key, value))
             _gpaw.pyelpa_set(self._ptr, key, value)
             self._parameters[key] = value
 
     def __repr__(self):
```

### Comparing `gpaw-22.8.0/gpaw/utilities/ewald.py` & `gpaw-23.6.0/gpaw/utilities/ewald.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/utilities/extend_grid.py` & `gpaw-23.6.0/gpaw/utilities/extend_grid.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/utilities/extrapolate.py` & `gpaw-23.6.0/gpaw/utilities/extrapolate.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/utilities/gauss.py` & `gpaw-23.6.0/gpaw/utilities/gauss.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/utilities/gl_quadrature.py` & `gpaw-23.6.0/gpaw/utilities/gl_quadrature.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/utilities/gpts.py` & `gpaw-23.6.0/gpaw/utilities/gpts.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/utilities/grid.py` & `gpaw-23.6.0/gpaw/utilities/grid.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/utilities/grid_redistribute.py` & `gpaw-23.6.0/gpaw/utilities/grid_redistribute.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/utilities/hardware.py` & `gpaw-23.6.0/gpaw/utilities/hardware.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/utilities/ibz2bz.py` & `gpaw-23.6.0/gpaw/utilities/ibz2bz.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/utilities/kspot.py` & `gpaw-23.6.0/gpaw/utilities/kspot.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/utilities/memory.py` & `gpaw-23.6.0/gpaw/utilities/memory.py`

 * *Files 1% similar despite different names*

```diff
@@ -18,15 +18,15 @@
     # get pseudo file  /proc/<pid>/status
     try:
         t = open(_proc_status)
         v = t.read()
         t.close()
         # get VmKey line e.g. 'VmRSS:  9999  kB\n ...'
         i = v.index(VmKey)
-    except (IOError, ValueError):
+    except (IOError, ValueError, LookupError):
         return 0.0  # non-Linux?
 
     v = v[i:].split(None, 3)  # whitespace
     if len(v) < 3:
         return 0.0  # invalid format?
     # convert Vm value to bytes
     return float(v[1]) * _scale[v[2]]
```

### Comparing `gpaw-22.8.0/gpaw/utilities/nbrun.py` & `gpaw-23.6.0/gpaw/utilities/nbrun.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/utilities/newrelease.py` & `gpaw-23.6.0/gpaw/utilities/newrelease.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/utilities/partition.py` & `gpaw-23.6.0/gpaw/utilities/partition.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/utilities/progressbar.py` & `gpaw-23.6.0/gpaw/utilities/progressbar.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/utilities/ps2ae.py` & `gpaw-23.6.0/gpaw/utilities/ps2ae.py`

 * *Files 1% similar despite different names*

```diff
@@ -117,15 +117,15 @@
         ae: bool
             Add PAW correction to get an all-electron wave function.
         periodic:
             Return periodic part of wave-function, u(r), instead of
             psi(r)=exp(ikr)u(r).
         """
         u_r = self.calc.get_pseudo_wave_function(n, k, s,
-                                                 pad=True, periodic=True)
+                                                 periodic=True)
         u_R = self.interpolator.interpolate(u_r * Bohr**1.5)
 
         k_c = self.calc.wfs.kd.ibzk_kc[k]
         gamma = np.isclose(k_c, 0.0).all()
 
         if gamma:
             eikr_R = 1.0
```

### Comparing `gpaw-22.8.0/gpaw/utilities/pw.py` & `gpaw-23.6.0/gpaw/utilities/pw.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/utilities/scalapack.py` & `gpaw-23.6.0/gpaw/utilities/scalapack.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/utilities/sic.py` & `gpaw-23.6.0/gpaw/utilities/sic.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/utilities/timelimit.py` & `gpaw-23.6.0/gpaw/utilities/timelimit.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/utilities/timing.py` & `gpaw-23.6.0/gpaw/utilities/timing.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/utilities/tools.py` & `gpaw-23.6.0/gpaw/utilities/tools.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/utilities/urlcheck.py` & `gpaw-23.6.0/gpaw/utilities/urlcheck.py`

 * *Files 22% similar despite different names*

```diff
@@ -3,33 +3,39 @@
 import sys
 from pathlib import Path
 from urllib.error import HTTPError, URLError
 from urllib.request import urlopen, Request
 
 OK = {'https://doi.org/%s',
       'https://arxiv.org/abs/%s',
+      'https://gitlab.com/gpaw/gpaw/-/merge_requests/%s',
+      'https://gitlab.com/gpaw/gpaw/-/issues/%s',
       'https://xkcd.com/%s',
       'https://gitlab.com/ase/ase.git@master',
       'https://gitlab.com/{name}/{name}.git',
+      'https://cmrdb.fysik.dtu.dk/c2db',
       'https://wiki.fysik.dtu.dk/gpaw-files/gpaw-setups-*.tar.gz',
       'https://wiki.fysik.dtu.dk/gpaw-files',
       'https://wiki.fysik.dtu.dk/gpaw-files/',
-      'https://wiki.fysik.dtu.dk/gpaw-files/things/'}
+      'https://wiki.fysik.dtu.dk/gpaw-files/things/',
+      'https://wiki.fysik.dtu.dk/gpaw/devel'}
 
 USERAGENT = 'Mozilla/5.0 (X11; U; Linux i686) Gecko/20071127 Firefox/2.0.0.11'
 
 
 def check(root: Path) -> int:
     """Chech URL's in Python files inside root."""
     errors = 0
     for path in root.glob('**/*.py'):
         for n, line in enumerate(path.read_text().splitlines()):
             for url in re.findall(r'https?://\S+', line):
-                url = url.rstrip(",.')}")
+                url = url.rstrip(""",.'"}):""")
                 if url not in OK and 'html/_downloads' not in str(path):
+                    if '(' in url and ')' not in url:
+                        url += ')'
                     if not check1(path, n, url):
                         errors += 1
     return errors
 
 
 def check1(path: Path, n: int, url: str) -> bool:
     try:
```

### Comparing `gpaw-22.8.0/gpaw/utilities/watermodel.py` & `gpaw-23.6.0/gpaw/utilities/watermodel.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/wannier/edmiston_ruedenberg.py` & `gpaw-23.6.0/gpaw/wannier/edmiston_ruedenberg.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/wannier/functions.py` & `gpaw-23.6.0/gpaw/wannier/functions.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/wannier/overlaps.py` & `gpaw-23.6.0/gpaw/wannier/overlaps.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/wannier/w90.py` & `gpaw-23.6.0/gpaw/wannier/w90.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/wannier90.py` & `gpaw-23.6.0/gpaw/wannier90.py`

 * *Files 2% similar despite different names*

```diff
@@ -372,17 +372,18 @@
             ik2 = int(line[1]) - 1
             if less_memory:
                 u2_nG = wavefunctions(ik2)
             else:
                 u2_nG = u_knG[ik2]
 
             G_c = np.array([int(line[i]) for i in range(2, 5)])
-            bG_c = G_c
-            bG_v = np.dot(bG_c, icell_cv)
+            bG_v = np.dot(G_c, icell_cv)
             u2_nG = u2_nG * np.exp(-1.0j * gemmdot(bG_v, r_g, beta=0.0))
+            bG_c = kpts_kc[ik2] - kpts_kc[ik1] + G_c
+            bG_v = np.dot(bG_c, icell_cv)  # Overwrite bG_v
             M_mm = get_overlap(calc,
                                bands,
                                np.reshape(u1_nG, (len(u1_nG), Ng)),
                                np.reshape(u2_nG, (len(u2_nG), Ng)),
                                P_kani[ik1],
                                P_kani[ik2],
                                dO_aii,
```

### Comparing `gpaw-22.8.0/gpaw/wavefunctions/arrays.py` & `gpaw-23.6.0/gpaw/wavefunctions/arrays.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/wavefunctions/base.py` & `gpaw-23.6.0/gpaw/wavefunctions/base.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,16 +1,13 @@
-from typing import Optional
-
 import numpy as np
 from ase.units import Ha
 
-from gpaw.occupations import OccupationNumberCalculator
 from gpaw.projections import Projections
 from gpaw.utilities import pack, unpack2
-from gpaw.utilities.blas import mmm, axpy
+from gpaw.utilities.blas import axpy, mmm
 from gpaw.utilities.partition import AtomPartition
 
 
 class WaveFunctions:
     """...
 
     setups:
@@ -52,16 +49,16 @@
         self.kptband_comm = kptband_comm
         self.timer = timer
         self.atom_partition = None
 
         self.kpt_qs = kd.create_k_points(self.gd.sdisp_cd, collinear)
         self.kpt_u = [kpt for kpt_s in self.kpt_qs for kpt in kpt_s]
 
-        self.occupations: Optional[OccupationNumberCalculator] = None
-        self.fermi_levels: Optional[np.ndarray] = None
+        self.occupations = None
+        self.fermi_levels = None
 
         self.eigensolver = None
         self.positions_set = False
         self.spos_ac = None
 
         self.set_setups(setups)
```

### Comparing `gpaw-22.8.0/gpaw/wavefunctions/fd.py` & `gpaw-23.6.0/gpaw/wavefunctions/fd.py`

 * *Files 2% similar despite different names*

```diff
@@ -125,14 +125,16 @@
         for kpt in self.kpt_u:
             for f, psit_G in zip(kpt.f_n, kpt.psit_nG):
                 for v in range(3):
                     self.taugrad_v[v](psit_G, dpsit_G, kpt.phase_cd)
                     axpy(0.5 * f, abs(dpsit_G)**2, taut_sG[kpt.s])
 
         self.kptband_comm.sum(taut_sG)
+        for taut_G in taut_sG:
+            self.kd.symmetry.symmetrize(taut_G, self.gd)
         return taut_sG
 
     def apply_mgga_orbital_dependent_hamiltonian(self, kpt, psit_xG,
                                                  Htpsit_xG, dH_asp,
                                                  dedtaut_G):
         a_G = self.gd.empty(dtype=psit_xG.dtype)
         for psit_G, Htpsit_G in zip(psit_xG, Htpsit_xG):
```

### Comparing `gpaw-22.8.0/gpaw/wavefunctions/fdpw.py` & `gpaw-23.6.0/gpaw/wavefunctions/fdpw.py`

 * *Files 1% similar despite different names*

```diff
@@ -41,15 +41,15 @@
     def cut_wfs(self, wfs, spos_ac):
         ni_a = {}
 
         for a in range(len(wfs.setups)):
             setup = wfs.setups[a]
             l_j = [phit.get_angular_momentum_number()
                    for phit in setup.get_partial_waves_for_atomic_orbitals()]
-            # assert l_j == setup.l_j[:len(l_j)]  # Relationship to l_orb_j?
+            # assert l_j == setup.l_j[:len(l_j)]  # Relationship to l_orb_J?
             ni_a[a] = sum(2 * l + 1 for l in l_j)
 
         phit = wfs.get_pseudo_partial_waves()
         phit.set_positions(wfs.spos_ac, wfs.atom_partition)
 
         # XXX See also wavefunctions.lcao.update_phases
         if wfs.dtype == complex:
@@ -280,15 +280,15 @@
         """Initialize wave-functions, density and hamiltonian.
 
         Return (nlcao, nrand) tuple with number of bands intialized from
         LCAO and random numbers, respectively."""
 
         if self.kpt_u[0].psit is None:
             basis_functions = BasisFunctions(self.gd,
-                                             [setup.phit_j
+                                             [setup.basis_functions_J
                                               for setup in self.setups],
                                              self.kd, dtype=self.dtype,
                                              cut=True)
             basis_functions.set_positions(spos_ac)
         else:
             self.initialize_wave_functions_from_restart_file()
```

### Comparing `gpaw-22.8.0/gpaw/wavefunctions/lcao.py` & `gpaw-23.6.0/gpaw/wavefunctions/lcao.py`

 * *Files 2% similar despite different names*

```diff
@@ -113,15 +113,15 @@
             self.atomic_correction_cls = DenseAtomicCorrection
 
         # self.tci = NewTCI(gd.cell_cv, gd.pbc_c, setups, kd.ibzk_qc, kd.gamma)
         with self.timer('TCI: Evaluate splines'):
             self.tciexpansions = TCIExpansions.new_from_setups(setups)
 
         self.basis_functions = BasisFunctions(gd,
-                                              [setup.phit_j
+                                              [setup.basis_functions_J
                                                for setup in setups],
                                               kd,
                                               dtype=dtype,
                                               cut=True)
 
         self.coefficients_read_from_file = False
         self.set_orthonormalized(False)
@@ -392,16 +392,16 @@
 
         Fref_av = np.zeros_like(F_av)
         self.forcecalc = LCAOforces(self.ksl, self.dtype, self.gd,
                                     self.bd, self.kd, self.kpt_u, self.nspins,
                                     self.basis_functions, self.newtci,
                                     self.P_aqMi, self.setups,
                                     self.manytci, hamiltonian,
-                                    self.spos_ac, self.timer,
-                                    Fref_av)
+                                    self, self.spos_ac,
+                                    self.timer, Fref_av)
 
         F_av[:, :] = self.forcecalc.get_forces_sum_GS()
         self.timer.stop('LCAO forces')
 
     def _get_wave_function_array(self, u, n, realspace=True, periodic=False):
         # XXX Taking kpt is better than taking u
         kpt = self.kpt_u[u]
@@ -465,15 +465,15 @@
         self.eigensolver.estimate_memory(mem.subnode('Eigensolver'),
                                          self.dtype)
 
 
 class LCAOforces:
 
     def __init__(self, ksl, dtype, gd, bd, kd, kpt_u, nspins, bfs, newtci,
-                 P_aqMi, setups, manytci, hamiltonian, spos_ac,
+                 P_aqMi, setups, manytci, hamiltonian, wfs, spos_ac,
                  timer, Fref_av):
         """ Object which calculates LCAO forces """
 
         self.ksl = ksl
         self.nao = ksl.nao
         self.mynao = ksl.mynao
         self.dtype = dtype
@@ -487,14 +487,15 @@
         self.nspins = nspins
         self.bfs = bfs
         self.spos_ac = spos_ac
         self.Mstart = ksl.Mstart
         self.Mstop = ksl.Mstop
         self.setups = setups
         self.hamiltonian = hamiltonian
+        self.wfs = wfs
         self.timer = timer
         self.Fref_av = Fref_av
         self.my_atom_indices = bfs.my_atom_indices
         self.atom_indices = bfs.atom_indices
         self.dH_asp = hamiltonian.dH_asp
 
         from gpaw.kohnsham_layouts import BlacsOrbitalLayouts
@@ -517,18 +518,16 @@
         if not self.isblacs:
             F_av = np.zeros_like(self.Fref_av)
             Fkin_av = self.get_kinetic_term()
             Fpot_av = self.get_pot_term()
             Ftheta_av = self.get_den_mat_term()
             Frho_av = self.get_den_mat_paw_term()
             Fatom_av = self.get_atomic_density_term()
-
             F_av += Fkin_av + Fpot_av + Ftheta_av + Frho_av + Fatom_av
-
-        if self.isblacs:
+        else:
             F_av = np.zeros_like(self.Fref_av)
             Fpot_av = self.get_pot_term_blacs()
             Fkin_av, Ftheta_av = self.get_kin_and_den_term_blacs()
             Fatom_av, Frho_av = self.get_at_den_and_den_paw_blacs()
 
             F_av += Fkin_av + Fpot_av + Ftheta_av + Frho_av + Fatom_av
 
@@ -589,16 +588,16 @@
                     ET_MM += self.ksl.get_transposed_density_matrix_delta(
                         d_nn * kpt.eps_n, kpt.C_nM)
             self.timer.stop('Get density matrix')
         else:
             rhoT_uMM = []
             ET_uMM = []
             for kpt in self.kpt_u:
-                H_MM = self.eigensolver.calculate_hamiltonian_matrix(
-                    self.hamiltonian, self, kpt)
+                H_MM = self.wfs.eigensolver.calculate_hamiltonian_matrix(
+                    self.hamiltonian, self.wfs, kpt)
                 tri2full(H_MM)
                 S_MM = kpt.S_MM.copy()
                 tri2full(S_MM)
                 ET_MM = np.linalg.solve(S_MM, gemmdot(H_MM,
                                                       kpt.rho_MM)).T.copy()
                 del S_MM, H_MM
                 rhoT_MM = kpt.rho_MM.T.copy()
@@ -799,14 +798,18 @@
         #           ij
         #
         self.timer.start('Atomic Hamiltonian force')
         Fatom_av = np.zeros_like(Fatom_av)
         for u, kpt in enumerate(self.kpt_u):
             for b in self.my_atom_indices:
                 H_ii = np.asarray(unpack(self.dH_asp[b][kpt.s]), self.dtype)
+                if len(H_ii) == 0:
+                    # gemmdot does not like empty matrices!
+                    # (has been fixed in the new code)
+                    continue
                 HP_iM = gemmdot(H_ii, np.ascontiguousarray(
                                 self.P_aqMi[b][kpt.q].T.conj()))
                 for v in range(3):
                     dPdR_Mi = \
                         self.dPdR_aqvMi[b][kpt.q][v][self.Mstart:self.Mstop]
                     ArhoT_MM = \
                         (gemmdot(dPdR_Mi, HP_iM) * self.rhoT_uMM[u]).real
```

### Comparing `gpaw-22.8.0/gpaw/wavefunctions/mode.py` & `gpaw-23.6.0/gpaw/wavefunctions/mode.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/wavefunctions/pw.py` & `gpaw-23.6.0/gpaw/wavefunctions/pw.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,67 +1,82 @@
+from __future__ import annotations
+
 import numbers
 from math import pi
 
-import numpy as np
-from ase.units import Bohr, Ha
-from ase.utils.timing import timer
-
 import _gpaw
 import gpaw
 import gpaw.fftw as fftw
+import numpy as np
+from ase.units import Bohr, Ha
+from ase.utils.timing import timer
 from gpaw.band_descriptor import BandDescriptor
 from gpaw.blacs import BlacsDescriptor, BlacsGrid, Redistributor
 from gpaw.lfc import BasisFunctions
 from gpaw.matrix_descriptor import MatrixDescriptor
 from gpaw.pw.descriptor import PWDescriptor
 from gpaw.pw.lfc import PWLFC
+from gpaw.typing import Array2D
 from gpaw.utilities import unpack
 from gpaw.utilities.blas import axpy
 from gpaw.utilities.progressbar import ProgressBar
 from gpaw.wavefunctions.arrays import PlaneWaveExpansionWaveFunctions
 from gpaw.wavefunctions.fdpw import FDPWWaveFunctions
 from gpaw.wavefunctions.mode import Mode
 
 
 class PW(Mode):
     name = 'pw'
 
-    def __init__(self, ecut=340, fftwflags=fftw.MEASURE, cell=None,
-                 gammacentered=False,
-                 pulay_stress=None, dedecut=None,
-                 force_complex_dtype=False):
+    def __init__(self,
+                 ecut: float = 340,
+                 *,
+                 fftwflags: int = fftw.MEASURE,
+                 cell: Array2D | None = None,
+                 gammacentered=False,  # Deprecated
+                 pulay_stress: float | None = None,
+                 dedecut: float | str | None = None,
+                 force_complex_dtype: bool = False,
+                 interpolation: str | int = 'fft'):
         """Plane-wave basis mode.
 
+        Only one of ``dedecut`` and ``pulay_stress`` can be used.
+
+        Parameters
+        ==========
         ecut: float
             Plane-wave cutoff in eV.
         gammacentered: bool
             Center the grid of chosen plane waves around the
             gamma point or q/k-vector
-        dedecut: float or None or 'estimate'
+        dedecut:
             Estimate of derivative of total energy with respect to
-            plane-wave cutoff.  Used to calculate pulay_stress.
+            plane-wave cutoff.  Used to calculate the Pulay-stress.
         pulay_stress: float or None
             Pulay-stress correction.
         fftwflags: int
             Flags for making an FFTW plan.  There are 4 possibilities
             (default is MEASURE)::
 
                 from gpaw.fftw import ESTIMATE, MEASURE, PATIENT, EXHAUSTIVE
 
-        cell: 3x3 ndarray
-            Use this unit cell to chose the planewaves.
-
-        Only one of dedecut and pulay_stress can be used.
+        cell: np.ndarray
+            Use this unit cell to chose the plane-waves.
+        interpolation : str or int
+            Interpolation scheme to construct the density on the fine grid.
+            Default is ``'fft'`` and alternatively a stencil (integer) can
+            be given to perform an explicit real-space interpolation.
         """
 
         assert not gammacentered
         self.ecut = ecut / Ha
         # Don't do expensive planning in dry-run mode:
         self.fftwflags = fftwflags if not gpaw.dry_run else fftw.MEASURE
         self.dedecut = dedecut
+        self.interpolation = interpolation
         self.pulay_stress = (None
                              if pulay_stress is None
                              else pulay_stress * Bohr**3 / Ha)
 
         assert pulay_stress is None or dedecut is None
 
         if cell is None:
@@ -101,14 +116,16 @@
 
         if self.cell_cv is not None:
             dct['cell'] = self.cell_cv * Bohr
         if self.pulay_stress is not None:
             dct['pulay_stress'] = self.pulay_stress * Ha / Bohr**3
         if self.dedecut is not None:
             dct['dedecut'] = self.dedecut
+        if self.interpolation != 'fft':
+            dct['interpolation'] = self.interpolation
         return dct
 
 
 class Preconditioner:
     """Preconditioner for KS equation.
 
     From:
@@ -187,15 +204,15 @@
         else:
             return self.pd.empty(n, self.dtype, q)
 
     def integrate(self, a_xg, b_yg=None, global_integral=True):
         return self.pd.integrate(a_xg, b_yg, global_integral)
 
     def bytes_per_wave_function(self):
-        return 16 * self.pd.ngmax
+        return 16 * self.pd.maxmyng
 
     def set_setups(self, setups):
         self.timer.start('PWDescriptor')
         self.pd = PWDescriptor(self.ecut, self.gd, self.dtype, self.kd,
                                self.fftwflags)
         self.timer.stop('PWDescriptor')
 
@@ -321,46 +338,138 @@
             p22 = p2.real**2 + p2.imag**2
             p12 = p1.conj() * p2
             nt_xR[0] += f * (p11 + p22)
             nt_xR[1] += 2 * f * p12.real
             nt_xR[2] += 2 * f * p12.imag
             nt_xR[3] += f * (p11 - p22)
 
+    def add_to_kinetic_energy_density_kpt(self, kpt, psit_xG, taut_xR):
+        N = self.bd.mynbands
+        S = self.gd.comm.size
+        Gpsit_xG = np.empty((S,) + psit_xG.shape[1:], dtype=psit_xG.dtype)
+        taut_R = self.gd.zeros(global_array=True)
+        G_Gv = self.pd.get_reciprocal_vectors(q=kpt.q)
+        comm = self.gd.comm
+
+        for v in range(3):
+            for n1 in range(0, N, S):
+                n2 = min(n1 + S, N)
+                dn = n2 - n1
+                Gpsit_xG[:dn] = 1j * G_Gv[:, v] * psit_xG[n1:n2]
+                Gpsit_G = self.pd.alltoall1(Gpsit_xG[:dn], kpt.q)
+                if Gpsit_G is not None:
+                    f = kpt.f_n[n1 + comm.rank]
+                    a_R = self.pd.ifft(Gpsit_G, kpt.q, local=True, safe=False)
+                    _gpaw.add_to_density(0.5 * f, a_R, taut_R)
+
+        comm.sum(taut_R)
+        taut_R = self.gd.distribute(taut_R)
+        taut_xR[kpt.s] += taut_R
+
+    def add_to_ke_crossterms_kpt(self, kpt, psit_xG, taut_xR):
+        N = self.bd.mynbands
+        S = self.gd.comm.size
+        Gpsit_xG = np.empty((S,) + psit_xG.shape[1:], dtype=psit_xG.dtype)
+        taut_vvR = self.gd.zeros((3, 3), global_array=True)
+        G_Gv = self.pd.get_reciprocal_vectors(q=kpt.q)
+        comm = self.gd.comm
+
+        for n1 in range(0, N, S):
+            n2 = min(n1 + S, N)
+            dn = n2 - n1
+            a_vR = {}
+            for v in range(3):
+                Gpsit_xG[:dn] = 1j * G_Gv[:, v] * psit_xG[n1:n2]
+                Gpsit_G = self.pd.alltoall1(Gpsit_xG[:dn], kpt.q)
+                if Gpsit_G is not None:
+                    f = kpt.f_n[n1 + comm.rank]
+                    a_vR[v] = self.pd.ifft(Gpsit_G, kpt.q,
+                                           local=True, safe=True)
+            if len(a_vR) == 3:
+                f = kpt.f_n[n1 + comm.rank]
+                for v1 in range(3):
+                    for v2 in range(3):
+                        # imaginary parts should cancel
+                        taut_vvR[v1, v2] += f * (a_vR[v1].conj()
+                                                 * a_vR[v2]).real
+            elif len(a_vR) == 0:
+                pass
+            else:
+                raise RuntimeError('Parallelization issue')
+
+        comm.sum(taut_vvR)
+        taut_vvR = self.gd.distribute(taut_vvR)
+        taut_xR[kpt.s, :, :] += taut_vvR
+
     def calculate_kinetic_energy_density(self):
         if self.kpt_u[0].f_n is None:
             return None
 
         taut_sR = self.gd.zeros(self.nspins)
         for kpt in self.kpt_u:
-            G_Gv = self.pd.get_reciprocal_vectors(q=kpt.q)
-            for f, psit_G in zip(kpt.f_n, kpt.psit_nG):
-                for v in range(3):
-                    taut_sR[kpt.s] += 0.5 * f * abs(
-                        self.pd.ifft(1j * G_Gv[:, v] * psit_G, kpt.q))**2
+            self.add_to_kinetic_energy_density_kpt(kpt, kpt.psit_nG, taut_sR)
 
         self.kptband_comm.sum(taut_sR)
+        for taut_R in taut_sR:
+            self.kd.symmetry.symmetrize(taut_R, self.gd)
         return taut_sR
 
+    def calculate_kinetic_energy_density_crossterms(self):
+        if self.kpt_u[0].f_n is None:
+            return None
+
+        taut_svvR = self.gd.zeros((self.nspins, 3, 3))
+        for kpt in self.kpt_u:
+            self.add_to_ke_crossterms_kpt(kpt, kpt.psit_nG, taut_svvR)
+
+        self.kptband_comm.sum(taut_svvR)
+        for taut_R in taut_svvR.reshape(-1, *taut_svvR.shape[-3:]):
+            self.kd.symmetry.symmetrize(taut_R, self.gd)
+        return taut_svvR
+
     def apply_mgga_orbital_dependent_hamiltonian(self, kpt, psit_xG,
                                                  Htpsit_xG, dH_asp,
                                                  dedtaut_R):
+        N = len(psit_xG)
+        S = self.gd.comm.size
+        Q_G = self.pd.Q_qG[kpt.q]
+        Gpsit_xG = np.empty((S,) + psit_xG.shape[1:], dtype=psit_xG.dtype)
+        tmp_xG = np.empty((S,) + psit_xG.shape[1:], dtype=Htpsit_xG.dtype)
         G_Gv = self.pd.get_reciprocal_vectors(q=kpt.q)
-        for psit_G, Htpsit_G in zip(psit_xG, Htpsit_xG):
-            for v in range(3):
-                a_R = self.pd.ifft(1j * G_Gv[:, v] * psit_G, kpt.q)
-                axpy(-0.5, 1j * G_Gv[:, v] *
-                     self.pd.fft(dedtaut_R * a_R, kpt.q),
-                     Htpsit_G)
+
+        dedtaut_R = self.gd.collect(dedtaut_R, broadcast=True)
+
+        for v in range(3):
+            for n1 in range(0, N, S):
+                n2 = min(n1 + S, N)
+                dn = n2 - n1
+                Gpsit_xG[:dn] = 1j * G_Gv[:, v] * psit_xG[n1:n2]
+                tmp_xG[:] = 0
+                Gpsit_G = self.pd.alltoall1(Gpsit_xG[:dn], kpt.q)
+                if Gpsit_G is not None:
+                    a_R = self.pd.ifft(Gpsit_G, kpt.q, local=True, safe=False)
+                    a_R *= dedtaut_R
+                    self.pd.fftplan.execute()
+                    a_R = self.pd.tmp_Q.ravel()[Q_G]
+                else:
+                    a_R = self.pd.tmp_G
+                self.pd.alltoall2(a_R, kpt.q, tmp_xG[:dn])
+                axpy(-0.5, (1j * G_Gv[:, v] * tmp_xG[:dn]).ravel(),
+                     Htpsit_xG[n1:n2].ravel())
 
     def _get_wave_function_array(self, u, n, realspace=True, periodic=False):
         kpt = self.kpt_u[u]
         psit_G = kpt.psit_nG[n]
 
         if realspace:
-            psit_R = self.pd.ifft(psit_G, kpt.q)
+            if psit_G.ndim == 2:
+                psit_R = np.array([self.pd.ifft(psits_G, kpt.q)
+                                   for psits_G in psit_G])
+            else:
+                psit_R = self.pd.ifft(psit_G, kpt.q)
             if self.kd.gamma or periodic:
                 return psit_R
 
             k_c = self.kd.ibzk_kc[kpt.k]
             eikr_R = self.gd.plane_wave(k_c)
             return psit_R * eikr_R
 
@@ -518,14 +627,26 @@
         for G in range(G1, G2):
             x_G = self.pd.zeros(q=q)
             x_G[G] = 1.0
             H_GG[G - G1] += (self.pd.gd.dv / N *
                              self.pd.fft(ham.vt_sG[s] *
                                          self.pd.ifft(x_G, q), q))
 
+        if ham.xc.type == 'MGGA':
+            G_Gv = self.pd.get_reciprocal_vectors(q=q)
+            for G in range(G1, G2):
+                x_G = self.pd.zeros(q=q)
+                x_G[G] = 1.0
+                for v in range(3):
+                    a_R = self.pd.ifft(1j * G_Gv[:, v] * x_G, q)
+                    H_GG[G - G1] += (self.pd.gd.dv / N *
+                                     (-0.5) * 1j * G_Gv[:, v] *
+                                     self.pd.fft(ham.xc.dedtaut_sG[s] *
+                                                 a_R, q))
+
         S_GG.ravel()[G1::npw + 1] = self.pd.gd.dv / N
 
         f_GI = self.pt.expand(q)
         nI = f_GI.shape[1]
         dH_II = np.zeros((nI, nI))
         dS_II = np.zeros((nI, nI))
         I1 = 0
```

### Comparing `gpaw-22.8.0/gpaw/wfd_operators.py` & `gpaw-23.6.0/gpaw/wfd_operators.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/xas.py` & `gpaw-23.6.0/gpaw/xc/gllb/c_response.py`

 * *Files 25% similar despite different names*

```diff
@@ -1,662 +1,686 @@
-import pickle
-from math import log, pi
-
+import warnings
+from math import sqrt, pi
 import numpy as np
-from gpaw.overlap import Overlap
-from ase.units import Hartree
-from gpaw.utilities.cg import CG
-import gpaw.mpi as mpi
-
-
-class XAS:
-    def __init__(self, paw, mode='xas', center=None, spin=0):
-        wfs = paw.wfs
-        self.orthogonal = wfs.gd.orthogonal
-        self.cell_cv = np.array(wfs.gd.cell_cv)
-        assert wfs.world.size == 1  # assert not mpi.parallel
-        # assert wfs.gd.orthogonal
-
-        # to allow spin polarized calclulation
-        nkpts = len(wfs.kd.ibzk_kc)
-
-        # the following lines are to stop the user to make mistakes
-        # if mode is not 'xes' and spin == 1:
-        #     raise RuntimeError(
-        #         'The core hole is always in spin 0: please use spin=0')
-
-        if wfs.nspins == 1:
-            if spin != 0:
-                raise RuntimeError(
-                    'use spin=0 for a spin paired calculation')
-            nocc = wfs.setups.nvalence // 2
-            self.list_kpts = range(nkpts)
-        else:
-            self.list_kpts = []
-
-            if spin != 0 and spin != 1:
-                print('spin', spin)
-                raise RuntimeError(
-                    'use either spin=0 or spin=1')
-
-            # find kpoints with correct spin
-            for i, kpt in enumerate(wfs.kpt_u):
-                if kpt.s == spin:
-                    self.list_kpts.append(i)
-                print(self.list_kpts)
-            assert len(self.list_kpts) == nkpts
-
-            # find number of occupied orbitals, if no fermi smearing
-            nocc = 0.0
-            for i in self.list_kpts:
-                nocc += sum(wfs.kpt_u[i].f_n)
-            nocc = int(nocc + 0.5)
-            print('nocc', nocc)
-
-        # look for the center with the corehole
-        if center is not None:
-            setup = wfs.setups[center]
-            a = center
-        else:
-            for a, setup in enumerate(wfs.setups):
-                if setup.phicorehole_g is not None:
-                    break
-
-        A_ci = setup.A_ci
-
-        # xas, xes or all modes
-        if mode == 'xas':
-            n_start = nocc
-            n_end = wfs.bd.nbands
-            n = wfs.bd.nbands - nocc
-        elif mode == 'xes':
-            n_start = 0
-            n_end = nocc
-            n = nocc
-        elif mode == 'all':
-            n_start = 0
-            n_end = wfs.bd.nbands
-            n = wfs.bd.nbands
-        else:
-            raise RuntimeError(
-                "wrong keyword for 'mode', use 'xas', 'xes' or 'all'")
-
-        self.n = n
-
-        self.eps_n = np.empty(nkpts * n)
-        self.sigma_cn = np.empty((3, nkpts * n), complex)
-        n1 = 0
-        for kpt in wfs.kpt_u:
-            if kpt.s != spin:
-                continue
-
-            n2 = n1 + n
-            self.eps_n[n1:n2] = kpt.eps_n[n_start:n_end] * Hartree
-            P_ni = kpt.P_ani[a][n_start:n_end]
-            a_cn = np.inner(A_ci, P_ni)
-            weight = kpt.weight * wfs.nspins / 2
-            print('weight', weight)
-            print(a_cn.shape, self.sigma_cn.shape)
-            self.sigma_cn[:, n1:n2] = weight**0.5 * a_cn  # .real
-            n1 = n2
-
-        self.symmetry = wfs.kd.symmetry
-
-    def get_spectra(self, fwhm=0.5, E_in=None, linbroad=None,
-                    N=1000, kpoint=None,
-                    proj=None, proj_xyz=True, stick=False):
-        """Calculate spectra.
-
-        Parameters:
-
-        fwhm:
-          the full width half maximum in eV for gaussian broadening
-        linbroad:
-          a list of three numbers, the first fwhm2, the second the value
-          where the linear increase starts and the third the value where
-          the broadening has reached fwhm2. example [0.5, 540, 550]
-        E_in:
-          a list of energy values where the spectrum is to be computed
-          if None the orbital energies will be used to compute the energy
-          range
-        N:
-          the number of bins in the broadened spectrum. If E_in is given N
-          has no effect
-        kpoint:
-          select a specific k-point to calculate spectrum for
-        proj:
-          a list of vectors to project the transition dipole on. Default
-          is None then only x,y,z components are calculated.  a_stick and
-          a_c squares of the transition moments in resp. direction
-        proj_xyz:
-          if True keep projections in x, y and z. a_stck and a_c will have
-          length 3 + len(proj). if False only those projections
-          defined by proj keyword, a_stick and a_c will have length len(proj)
-        stick:
-          if False return broadened spectrum, if True return stick spectrum
-
-        Symmtrization has been moved inside get_spectra because we want to
-        symmtrice squares of transition dipoles."""
-
-        # eps_n = self.eps_n[k_in*self.n: (k_in+1)*self.n -1]
-
-        # proj keyword, check normalization of incoming vectors
-        if proj_xyz:
-            proj_3 = np.array([[1, 0, 0], [0, 1, 0], [0, 0, 1]], float)
-        else:
-            proj_3 = np.array([], float)
-
-        if proj is not None:
-            assert self.orthogonal
-            proj_2 = np.array(proj, float)
-            if len(proj_2.shape) == 1:
-                proj_2 = np.array([proj], float)
-
-            for i, p in enumerate(proj_2):
-                if sum(p ** 2) ** 0.5 != 1.0:
-                    print('proj_2 %s not normalized' % i)
-                    proj_2[i] /= sum(p ** 2) ** 0.5
-
-            proj_tmp = np.zeros((proj_3.shape[0] + proj_2.shape[0], 3), float)
-
-            for i, p in enumerate(proj_3):
-                proj_tmp[i, :] = proj_3[i, :]
-
-            for i, p in enumerate(proj_2):
-                proj_tmp[proj_3.shape[0] + i, :] = proj_2[i, :]
-
-            proj_3 = proj_tmp.copy()
-
-        # now symmetrize
-        sigma2_cn = np.zeros((proj_3.shape[0], self.sigma_cn.shape[1]), float)
-
-        if self.symmetry is not None:
-            for i, p in enumerate(proj_3):
-                for op_cc in self.symmetry.op_scc:
-                    op_vv = np.dot(np.linalg.inv(self.cell_cv),
-                                   np.dot(op_cc, self.cell_cv))
-                    s_tmp = np.dot(p, np.dot(op_vv, self.sigma_cn))
-                    sigma2_cn[i, :] += (s_tmp * np.conjugate(s_tmp)).real
-            sigma2_cn /= len(self.symmetry.op_scc)
-
-        else:
-            for i, p in enumerate(proj_3):
-                s_tmp = np.dot(p, self.sigma_cn)
-                sigma2_cn[i, :] += (s_tmp * np.conjugate(s_tmp)).real
-
-        eps_n = self.eps_n[:]
-
-        if kpoint is not None:
-            eps_start = kpoint * self.n
-            eps_end = (kpoint + 1) * self.n
-        else:
-            eps_start = 0
-            eps_end = len(self.eps_n)
-
-        # return stick spectrum if stick=True
-        if stick:
-            e_stick = eps_n[eps_start:eps_end]
-            a_stick = sigma2_cn[:, eps_start:eps_end]
-
-            return e_stick, a_stick
-
-        # else return broadened spectrum
-        else:
-            if E_in is not None:
-                e = np.array(E_in)
-            else:
-                emin = min(eps_n) - 2 * fwhm
-                emax = max(eps_n) + 2 * fwhm
-                e = emin + np.arange(N + 1) * ((emax - emin) / N)
-
-            a_c = np.zeros((len(sigma2_cn), len(e)))
-
-            if linbroad is None:
-                # constant broadening fwhm
-                alpha = 4 * log(2) / fwhm**2
-
-                for n, eps in enumerate(eps_n[eps_start:eps_end]):
-                    x = -alpha * (e - eps)**2
-                    x = np.clip(x, -100.0, 100.0)
-                    a_c += np.outer(sigma2_cn[:, n + eps_start],
-                                    (alpha / pi)**0.5 * np.exp(x))
-            else:
 
-                # constant broadening fwhm until linbroad[1] and a
-                # constant broadening over linbroad[2] with fwhm2=
-                # linbroad[0]
-                fwhm2 = linbroad[0]
-                lin_e1 = linbroad[1]
-                lin_e2 = linbroad[2]
-                print('fwhm', fwhm, fwhm2, lin_e1, lin_e2)
-                for n, eps in enumerate(eps_n):
-                    if eps < lin_e1:
-                        alpha = 4 * log(2) / fwhm**2
-                    elif eps <= lin_e2:
-                        fwhm_lin = (fwhm + (eps - lin_e1) *
-                                    (fwhm2 - fwhm) / (lin_e2 - lin_e1))
-                        alpha = 4 * log(2) / fwhm_lin**2
-                    elif eps >= lin_e2:
-                        alpha = 4 * log(2) / fwhm2**2
-
-                    x = -alpha * (e - eps)**2
-                    x = np.clip(x, -100.0, 100.0)
-                    a_c += np.outer(sigma2_cn[:, n],
-                                    (alpha / pi)**0.5 * np.exp(x))
-
-            return e, a_c
-
-
-class RecursionMethod:
-    """This class implements the Haydock recursion method. """
-
-    def __init__(self, paw=None, filename=None,
-                 tol=1e-10, maxiter=100, proj=None,
-                 proj_xyz=True):
-
-        if paw is not None:
-            wfs = paw.wfs
-            assert wfs.gd.orthogonal
-
-            self.wfs = wfs
-            self.hamiltonian = paw.hamiltonian
-            self.nkpts = len(wfs.kd.ibzk_kc) * wfs.nspins
-            self.nmykpts = len(wfs.kpt_u)
-
-            self.k1 = wfs.kd.comm.rank * self.nmykpts
-            self.k2 = self.k1 + self.nmykpts
-
-            print('k1', self.k1, 'k2', self.k2)
-
-            # put spin and weight index in the columns corresponding
-            # to this processors k-points
-            self.spin_k = np.zeros(self.nkpts, int)
-            self.weight_k = np.zeros(self.nkpts)
-
-            for n, i in enumerate(range(self.k1, self.k2)):
-                self.spin_k[i] = wfs.kpt_u[n].s
-                self.weight_k[i] = wfs.kpt_u[n].weight
-
-            self.op_scc = None
-            if wfs.kd.symmetry is not None:
-                self.op_scc = wfs.kd.symmetry.op_scc
-        else:
-            self.k1 = 0
-            self.k2 = None
-            self.wfs = None
-            wfs = None
-
-        self.tol = tol
-        self.maxiter = maxiter
-
-        if filename is not None:
-            self.read(filename)
-            if wfs is not None:
-                self.allocate_tmp_arrays()
-        else:
-            self.initialize_start_vector(proj=proj, proj_xyz=proj_xyz)
-
-    def read(self, filename):
-        with open(filename, 'rb') as fd:
-            data = pickle.load(fd)
-        self.nkpts = data['nkpts']
-        if 'swaps' in data:
-            # This is an old file:
-            self.op_scc = np.array([np.identity(3, int)[list(swap)]
-                                    for swap in data['swaps']])
-        else:
-            self.op_scc = data['symmetry operations']
-        self.weight_k = data['weight_k']
-        self.spin_k = data['spin_k']
-        self.dim = data['dim']
-        k1, k2 = self.k1, self.k2
-        if k2 is None:
-            k2 = self.nkpts
-        a_kci, b_kci = data['ab']
-        self.a_uci = a_kci[k1:k2].copy()
-        self.b_uci = b_kci[k1:k2].copy()
-
-        if self.wfs is not None and 'arrays' in data:
-            print('reading arrays')
-            w_kcG, wold_kcG, y_kcG = data['arrays']
-            i = [slice(k1, k2), slice(0, self.dim)] + self.wfs.gd.get_slice()
-            self.w_ucG = w_kcG[i].copy()
-            self.wold_ucG = wold_kcG[i].copy()
-            self.y_ucG = y_kcG[i].copy()
-
-    def write(self, filename, mode=''):
-        assert self.wfs is not None
-        kpt_comm = self.wfs.kd.comm
-        gd = self.wfs.gd
-
-        if gd.comm.rank == 0:
-            if kpt_comm.rank == 0:
-                nmyu, dim, ni = self.a_uci.shape
-                a_kci = np.empty((kpt_comm.size, nmyu, dim, ni),
-                                 self.wfs.dtype)
-                b_kci = np.empty((kpt_comm.size, nmyu, dim, ni),
-                                 self.wfs.dtype)
-
-                kpt_comm.gather(self.a_uci, 0, a_kci)
-                kpt_comm.gather(self.b_uci, 0, b_kci)
-                kpt_comm.sum(self.spin_k, 0)
-                kpt_comm.sum(self.weight_k, 0)
-
-                a_kci.shape = (self.nkpts, dim, ni)
-                b_kci.shape = (self.nkpts, dim, ni)
-                data = {'ab': (a_kci, b_kci),
-                        'nkpts': self.nkpts,
-                        'symmetry operations': self.op_scc,
-                        'weight_k': self.weight_k,
-                        'spin_k': self.spin_k,
-                        'dim': dim}
-            else:
-                kpt_comm.gather(self.a_uci, 0)
-                kpt_comm.gather(self.b_uci, 0)
-                kpt_comm.sum(self.spin_k, 0)
-                kpt_comm.sum(self.weight_k, 0)
-
-        if mode == 'all':
-            w0_ucG = gd.collect(self.w_ucG)
-            wold0_ucG = gd.collect(self.wold_ucG)
-            y0_ucG = gd.collect(self.y_ucG)
-            if gd.comm.rank == 0:
-                if kpt_comm.rank == 0:
-                    w_kcG = gd.empty((self.nkpts, dim), self.wfs.dtype,
-                                     global_array=True)
-                    wold_kcG = gd.empty((self.nkpts, dim), self.wfs.dtype,
-                                        global_array=True)
-                    y_kcG = gd.empty((self.nkpts, dim), self.wfs.dtype,
-                                     global_array=True)
-                    kpt_comm.gather(w0_ucG, 0, w_kcG)
-                    kpt_comm.gather(wold0_ucG, 0, wold_kcG)
-                    kpt_comm.gather(y0_ucG, 0, y_kcG)
-                    data['arrays'] = (w_kcG, wold_kcG, y_kcG)
+from ase.units import Ha
+from gpaw import BadParallelization
+from gpaw.mpi import world
+from gpaw.density import redistribute_array, redistribute_atomic_matrices
+from gpaw.sphere.lebedev import weight_n
+from gpaw.utilities import pack, pack_atomic_matrices, unpack_atomic_matrices
+from gpaw.xc.gllb import safe_sqr
+from gpaw.xc.gllb.contribution import Contribution
+
+# XXX Work in process
+debug = False
+
+
+def d(*args):
+    if debug:
+        print(args)
+
+
+class ResponsePotential:
+    """Container for response potential"""
+    def __init__(self, response, vt_sG, vt_sg, D_asp, Dresp_asp):
+        self.response = response
+        self.vt_sG = vt_sG
+        self.vt_sg = vt_sg
+        self.D_asp = D_asp
+        self.Dresp_asp = Dresp_asp
+
+    def redistribute(self, new_response):
+        old_response = self.response
+        new_wfs = new_response.wfs
+        new_density = new_response.density
+        self.vt_sG = redistribute_array(self.vt_sG,
+                                        old_response.density.gd,
+                                        new_density.gd,
+                                        new_wfs.nspins,
+                                        new_wfs.kptband_comm)
+        if self.vt_sg is not None:
+            self.vt_sg = redistribute_array(self.vt_sg,
+                                            old_response.density.finegd,
+                                            new_density.finegd,
+                                            new_wfs.nspins,
+                                            new_wfs.kptband_comm)
+
+        def redist_asp(D_asp):
+            return redistribute_atomic_matrices(D_asp,
+                                                new_density.gd,
+                                                new_wfs.nspins,
+                                                new_density.setups,
+                                                new_density.atom_partition,
+                                                new_wfs.kptband_comm)
+
+        self.D_asp = redist_asp(self.D_asp)
+        self.Dresp_asp = redist_asp(self.Dresp_asp)
+        self.response = new_response
+
+
+class C_Response(Contribution):
+    """Response contribution for GLLB functionals.
+
+    Parameters
+    ----------
+    weight
+        Weight of the contribution
+    coefficients
+        Coefficient calculator object
+    metallic
+        If True, then Fermi level is used as the reference
+        energy for coefficients instead of the HOMO energy.
+        This is necessary to get sensible results in metallic systems.
+    damp
+        Small value to damp divisions by zero
+    """
+    def __init__(self,
+                 weight: float,
+                 coefficients, *,
+                 metallic: bool = False,
+                 damp: float = 1e-10):
+        Contribution.__init__(self, weight)
+        d('In c_Response __init__', self)
+        self.coefficients = coefficients
+        self.vt_sg = None
+        self.vt_sG = None
+        self.D_asp = None
+        self.Dresp_asp = None
+        self.Ddist_asp = None
+        self.Drespdist_asp = None
+        self.damp = damp
+        self.fix_potential = False
+        self.metallic = metallic
+
+        # For logging reference energy
+        self.eref_s = None
+        self.eref_source_s = None
+
+    def set_damp(self, damp):
+        self.damp = damp
+
+    def get_name(self):
+        return 'RESPONSE'
+
+    def get_desc(self):
+        desc = []
+        if self.metallic:
+            desc += ['metallic']
+        desc += [self.coefficients.get_description()]
+        return ', '.join(desc)
+
+    def initialize(self, density, hamiltonian, wfs):
+        Contribution.initialize(self, density, hamiltonian, wfs)
+        self.coefficients.initialize(wfs)
+        if self.Dresp_asp is None:
+            assert self.density.D_asp is None
+        # XXX With the deprecated `fixdensity=True` option this
+        # initialize() function is called both before AND after read()!
+        # Thus, the second call of initialize() would discard the read
+        # potential unless we check if it was already allocated.
+        # Remove this if statement once `fixdensity=True` option has
+        # been removed from the calculator.
+        if self.vt_sg is None:
+            self.vt_sG = self.gd.empty(self.nspins)
+            self.vt_sg = self.finegd.empty(self.nspins)
+
+    def initialize_1d(self, ae):
+        Contribution.initialize_1d(self, ae)
+        self.coefficients.initialize_1d(ae)
+
+    def initialize_from_other_response(self, response):
+        pot = ResponsePotential(response,
+                                response.vt_sG,
+                                response.vt_sg,
+                                response.D_asp,
+                                response.Dresp_asp)
+        pot.redistribute(self)
+        self.vt_sG = pot.vt_sG
+        self.vt_sg = pot.vt_sg
+        self.D_asp = pot.D_asp
+        self.Dresp_asp = pot.Dresp_asp
+        self.Ddist_asp = self.distribute_D_asp(pot.D_asp)
+        self.Drespdist_asp = self.distribute_D_asp(pot.Dresp_asp)
+        self.eref_s = response.eref_s
+        self.eref_source_s = response.eref_source_s
+
+    # Calcualte the GLLB potential and energy 1d
+    def add_xc_potential_and_energy_1d(self, v_g):
+        w_i = self.coefficients.get_coefficients_1d()
+        u2_j = safe_sqr(self.ae.u_j)
+        v_g += self.weight * np.dot(w_i, u2_j) / (
+            np.dot(self.ae.f_j, u2_j) + self.damp)
+        return 0.0  # Response part does not contribute to energy
+
+    def update_potentials(self):
+        d('In update response potential')
+        if self.fix_potential:
+            # Skip the evaluation of the potential so that
+            # the existing potential is used. This is relevant for
+            # band structure calculation so that the potential
+            # does not get updated with the other k-point sampling.
+            return
+
+        if self.wfs.kpt_u[0].eps_n is None:
+            # This skips the evaluation of the potential so that
+            # the existing one is used.
+            # This happens typically after reading when occupations
+            # haven't been calculated yet and the potential read earlier
+            # is used.
+            return
+
+        # Calculate reference energy
+        self.eref_s = []
+        self.eref_source_s = []
+        if self.metallic:
+            # Use Fermi level as reference levels
+            fermilevel = self.wfs.fermi_level
+            assert isinstance(fermilevel, float), \
+                'GLLBSCM supports only a single Fermi level'
+            for s in range(self.wfs.nspins):
+                self.eref_source_s.append('Fermi level')
+                self.eref_s.append(fermilevel)
+        else:
+            # Find homo and lumo levels for each spin
+            for s in range(self.wfs.nspins):
+                homo, lumo = self.wfs.get_homo_lumo(s)
+                # Check that homo and lumo are reasonable
+                if homo > lumo:
+                    # HOMO higher than LUMO; set Fermi level as reference
+                    fermilevel = self.wfs.fermi_level
+                    self.eref_source_s.append('Fermi level')
+                    self.eref_s.append(fermilevel)
                 else:
-                    kpt_comm.gather(w0_ucG, 0)
-                    kpt_comm.gather(wold0_ucG, 0)
-                    kpt_comm.gather(y0_ucG, 0)
-
-        if self.wfs.world.rank == 0:
-            with open(filename, 'wb') as fd:
-                pickle.dump(data, fd)
-
-    def allocate_tmp_arrays(self):
-
-        self.tmp1_cG = self.wfs.gd.zeros(self.dim, self.wfs.dtype)
-        self.tmp2_cG = self.wfs.gd.zeros(self.dim, self.wfs.dtype)
-        self.z_cG = self.wfs.gd.zeros(self.dim, self.wfs.dtype)
-
-    def initialize_start_vector(self, proj=None, proj_xyz=True):
-        # proj is one list of vectors [[e1_x,e1_y,e1_z],[e2_x,e2_y,e2_z]]
-        # ( or [ex,ey,ez] if only one projection )
-        # that the spectrum will be projected on
-        # default is to only calculate the averaged spectrum
-        # if proj_xyz is True, keep projection in x,y,z, if False
-        # only calculate the projections in proj
-
-        # Create initial wave function:
-        nmykpts = self.nmykpts
-
-        for a, setup in enumerate(self.wfs.setups):
-            if setup.phicorehole_g is not None:
-                break
-        A_ci = setup.A_ci
-
-        #
-        # proj keyword
-        #
-
-        # check normalization of incoming vectors
-        if proj is not None:
-            proj_2 = np.array(proj, float)
-            if len(proj_2.shape) == 1:
-                proj_2 = np.array([proj], float)
-
-            for i, p in enumerate(proj_2):
-                if sum(p ** 2) ** 0.5 != 1.0:
-                    print('proj_2 %s not normalized' % i)
-                    proj_2[i] /= sum(p ** 2) ** 0.5
-
-            proj_tmp = []
-            for p in proj_2:
-                proj_tmp.append(np.dot(p, A_ci))
-            proj_tmp = np.array(proj_tmp, float)
-
-            # if proj_xyz is True, append projections to A_ci
-            if proj_xyz:
-                A_ci_tmp = np.zeros((3 + proj_2.shape[0], A_ci.shape[1]))
-                A_ci_tmp[0:3, :] = A_ci
-                A_ci_tmp[3:, :] = proj_tmp
+                    self.eref_source_s.append('HOMO')
+                    self.eref_s.append(homo)
 
-            # otherwise, replace A_ci by projections
-            else:
-                A_ci_tmp = np.zeros((proj_2.shape[0], A_ci.shape[1]))
-                A_ci_tmp = proj_tmp
-            A_ci = A_ci_tmp
-
-        self.dim = len(A_ci)
-
-        self.allocate_tmp_arrays()
-
-        self.w_ucG = self.wfs.gd.zeros((nmykpts, self.dim), self.wfs.dtype)
-        self.wold_ucG = self.wfs.gd.zeros((nmykpts, self.dim), self.wfs.dtype)
-        self.y_ucG = self.wfs.gd.zeros((nmykpts, self.dim), self.wfs.dtype)
-
-        self.a_uci = np.zeros((nmykpts, self.dim, 0), self.wfs.dtype)
-        self.b_uci = np.zeros((nmykpts, self.dim, 0), self.wfs.dtype)
-
-        A_aci = self.wfs.pt.dict(3, zero=True)
-        if a in A_aci:
-            A_aci[a] = A_ci.astype(self.wfs.dtype)
-        for u in range(nmykpts):
-            self.wfs.pt.add(self.w_ucG[u], A_aci, u)
-
-    def run(self, nsteps, inverse_overlap='exact'):
-
-        if inverse_overlap == 'exact':
-            self.solver = self.solve
-        elif inverse_overlap == 'approximate':
-            self.solver = self.solve2
-        elif inverse_overlap == 'noinverse':
-            self.solver = self.solve3
-        else:
-            raise RuntimeError("Error, inverse_solver must be either 'exact' "
-                               "'approximate' or 'noinverse'")
+        w_kn = self.coefficients.get_coefficients(self.wfs.kpt_u,
+                                                  eref_s=self.eref_s)
+        f_kn = [kpt.f_n for kpt in self.wfs.kpt_u]
+        if w_kn is not None:
+            self.vt_sG[:] = 0.0
+            nt_sG = self.gd.zeros(self.nspins)
+
+            for kpt, w_n in zip(self.wfs.kpt_u, w_kn):
+                self.wfs.add_to_density_from_k_point_with_occupation(
+                    self.vt_sG, kpt, w_n)
+                self.wfs.add_to_density_from_k_point(nt_sG, kpt)
+
+            self.wfs.kptband_comm.sum(nt_sG)
+            self.wfs.kptband_comm.sum(self.vt_sG)
+
+            if self.wfs.kd.symmetry:
+                for nt_G, vt_G in zip(nt_sG, self.vt_sG):
+                    self.wfs.kd.symmetry.symmetrize(nt_G, self.gd)
+                    self.wfs.kd.symmetry.symmetrize(vt_G, self.gd)
+
+            d('response update D_asp', world.rank, self.Dresp_asp.keys(),
+              self.D_asp.keys())
+            self.wfs.calculate_atomic_density_matrices_with_occupation(
+                self.Dresp_asp, w_kn)
+            self.Drespdist_asp = self.distribute_D_asp(self.Dresp_asp)
+            d('response update Drespdist_asp', world.rank,
+              self.Dresp_asp.keys(), self.D_asp.keys())
+            self.wfs.calculate_atomic_density_matrices_with_occupation(
+                self.D_asp, f_kn)
+            self.Ddist_asp = self.distribute_D_asp(self.D_asp)
+
+            self.vt_sG /= nt_sG + self.damp
+
+        self.density.distribute_and_interpolate(self.vt_sG, self.vt_sg)
+
+    def calculate(self, e_g, n_sg, v_sg):
+        self.update_potentials()
+        v_sg += self.weight * self.vt_sg
+
+    def distribute_D_asp(self, D_asp):
+        return self.density.atomdist.to_work(D_asp)
+
+    def calculate_energy_and_derivatives(self, setup, D_sp, H_sp, a,
+                                         addcoredensity=True):
+        # Get the XC-correction instance
+        c = setup.xc_correction
+        ncresp_g = setup.extra_xc_data['core_response'] / self.nspins
+        if not addcoredensity:
+            ncresp_g[:] = 0.0
+
+        for D_p, dEdD_p, Dresp_p in zip(self.Ddist_asp[a], H_sp,
+                                        self.Drespdist_asp[a]):
+            D_Lq = np.dot(c.B_pqL.T, D_p)
+            n_Lg = np.dot(D_Lq, c.n_qg)  # Construct density
+            if addcoredensity:
+                n_Lg[0] += c.nc_g * sqrt(4 * pi) / self.nspins
+            nt_Lg = np.dot(
+                D_Lq, c.nt_qg
+            )  # Construct smooth density (_without smooth core density_)
+
+            Dresp_Lq = np.dot(c.B_pqL.T, Dresp_p)
+            nresp_Lg = np.dot(Dresp_Lq, c.n_qg)  # Construct 'response density'
+            nrespt_Lg = np.dot(
+                Dresp_Lq, c.nt_qg
+            )  # Construct smooth 'response density' (w/o smooth core)
+
+            for w, Y_L in zip(weight_n, c.Y_nL):
+                nt_g = np.dot(Y_L, nt_Lg)
+                nrespt_g = np.dot(Y_L, nrespt_Lg)
+                x_g = nrespt_g / (nt_g + self.damp)
+                dEdD_p -= self.weight * w * np.dot(
+                    np.dot(c.B_pqL, Y_L), np.dot(c.nt_qg, x_g * c.rgd.dv_g))
+
+                n_g = np.dot(Y_L, n_Lg)
+                nresp_g = np.dot(Y_L, nresp_Lg)
+                x_g = (nresp_g + ncresp_g) / (n_g + self.damp)
+
+                dEdD_p += self.weight * w * np.dot(
+                    np.dot(c.B_pqL, Y_L), np.dot(c.n_qg, x_g * c.rgd.dv_g))
+
+        return 0.0
+
+    def integrate_sphere(self, a, Dresp_sp, D_sp, Dwf_p, spin=0):
+        c = self.wfs.setups[a].xc_correction
+        Dresp_p, D_p = Dresp_sp[spin], D_sp[spin]
+        D_Lq = np.dot(c.B_pqL.T, D_p)
+        n_Lg = np.dot(D_Lq, c.n_qg)  # Construct density
+        n_Lg[0] += c.nc_g * sqrt(4 * pi) / len(D_sp)
+        nt_Lg = np.dot(D_Lq, c.nt_qg
+                       )  # Construct smooth density (without smooth core)
+        Dresp_Lq = np.dot(c.B_pqL.T, Dresp_p)  # Construct response
+        nresp_Lg = np.dot(Dresp_Lq, c.n_qg)  # Construct 'response density'
+        nrespt_Lg = np.dot(
+            Dresp_Lq, c.nt_qg
+        )  # Construct smooth 'response density' (w/o smooth core)
+        Dwf_Lq = np.dot(c.B_pqL.T, Dwf_p)  # Construct lumo wf
+        nwf_Lg = np.dot(Dwf_Lq, c.n_qg)
+        nwft_Lg = np.dot(Dwf_Lq, c.nt_qg)
+        E = 0.0
+        for w, Y_L in zip(weight_n, c.Y_nL):
+            v = np.dot(Y_L, nwft_Lg) * np.dot(Y_L, nrespt_Lg) / (
+                np.dot(Y_L, nt_Lg) + self.damp)
+            E -= self.weight * w * np.dot(v, c.rgd.dv_g)
+            v = np.dot(Y_L, nwf_Lg) * np.dot(Y_L, nresp_Lg) / (
+                np.dot(Y_L, n_Lg) + self.damp)
+            E += self.weight * w * np.dot(v, c.rgd.dv_g)
+        return E
+
+    def add_smooth_xc_potential_and_energy_1d(self, vt_g):
+        w_ln = self.coefficients.get_coefficients_1d(smooth=True)
+        v_g = np.zeros(self.ae.N)
+        n_g = np.zeros(self.ae.N)
+        for w_n, f_n, u_n in zip(w_ln, self.ae.f_ln,
+                                 self.ae.s_ln):  # For each angular momentum
+            u2_n = safe_sqr(u_n)
+            v_g += np.dot(w_n, u2_n)
+            n_g += np.dot(f_n, u2_n)
+
+        vt_g += self.weight * v_g / (n_g + self.damp)
+        return 0.0  # Response part does not contribute to energy
+
+    def calculate_delta_xc(self, homolumo=None):
+        warnings.warn(
+            'The function calculate_delta_xc() is deprecated. '
+            'Please use calculate_discontinuity_potential() instead. '
+            'See documentation on calculating band gap with GLLBSC.',
+            DeprecationWarning)
+
+        if homolumo is None:
+            # Calculate band gap
+
+            # This always happens, so we don't warn.
+            # We should perhaps print it as an ordinary message,
+            # but we do not have a file here to which to print.
+            # import warnings
+            # warnings.warn('Calculating KS-gap directly from the k-points, '
+            #               'can be inaccurate.')
+            homolumo = self.wfs.get_homo_lumo()
+        homo, lumo = homolumo
+        dxc_pot = self.calculate_discontinuity_potential(homo * Ha, lumo * Ha)
+        self.Dxc_vt_sG = dxc_pot.vt_sG
+        self.Dxc_D_asp = dxc_pot.D_asp
+        self.Dxc_Dresp_asp = dxc_pot.Dresp_asp
 
-        self.overlap = Overlap()
+    def calculate_discontinuity_potential(self, homo, lumo):
+        r"""Calculate the derivative discontinuity potential.
 
-        ni = self.a_uci.shape[2]
-        a_uci = np.empty((self.nmykpts, self.dim, ni + nsteps), self.wfs.dtype)
-        b_uci = np.empty((self.nmykpts, self.dim, ni + nsteps), self.wfs.dtype)
-        a_uci[:, :, :ni] = self.a_uci
-        b_uci[:, :, :ni] = self.b_uci
-        self.a_uci = a_uci
-        self.b_uci = b_uci
-
-        for u in range(self.nmykpts):
-            for i in range(nsteps):
-                self.step(u, ni + i)
-
-    def step(self, u, i):
-        print(u, i)
-        integrate = self.wfs.gd.integrate
-        w_cG = self.w_ucG[u]
-        y_cG = self.y_ucG[u]
-        wold_cG = self.wold_ucG[u]
-        z_cG = self.z_cG
-
-        self.solver(w_cG, self.z_cG, u)
-        I_c = np.reshape(integrate(np.conjugate(z_cG) * w_cG)**-0.5,
-                         (self.dim, 1, 1, 1))
-        z_cG *= I_c
-        w_cG *= I_c
+        This function calculates $`\Delta_{xc}(r)`$ as given by
+        Eq. (24) of https://doi.org/10.1103/PhysRevB.82.115106
 
-        if i != 0:
-            b_c = 1.0 / I_c
-        else:
-            b_c = np.reshape(np.zeros(self.dim), (self.dim, 1, 1, 1))
+        Parameters:
 
-        self.hamiltonian.apply(z_cG, y_cG, self.wfs, self.wfs.kpt_u[u])
-        a_c = np.reshape(integrate(np.conjugate(z_cG) * y_cG),
-                         (self.dim, 1, 1, 1))
-        wnew_cG = (y_cG - a_c * w_cG - b_c * wold_cG)
-        wold_cG[:] = w_cG
-        w_cG[:] = wnew_cG
-        self.a_uci[u, :, i] = a_c[:, 0, 0, 0]
-        self.b_uci[u, :, i] = b_c[:, 0, 0, 0]
-
-    def continued_fraction(self, e, k, c, i, imax):
-        a_i = self.a_uci[k, c]
-        b_i = self.b_uci[k, c]
-        if i == imax - 2:
-            return self.terminator(a_i[i], b_i[i], e)
-        return 1.0 / (a_i[i] - e -
-                      b_i[i + 1]**2 *
-                      self.continued_fraction(e, k, c, i + 1, imax))
-
-    def get_spectra(self, eps_s, delta=0.1, imax=None, kpoint=None, fwhm=None,
-                    linbroad=None, spin=0):
-        assert not mpi.parallel
-
-        # the following lines are to stop the user to make mistakes
-        # if spin == 1:
-        #     raise RuntimeError(
-        #         'The core hole is always in spin 0: please use spin=0')
-
-        n = len(eps_s)
-
-        sigma_cn = np.zeros((self.dim, n))
-        if imax is None:
-            imax = self.a_uci.shape[2]
-        eps_n = (eps_s + delta * 1.0j) / Hartree
-
-        # if a certain k-point is chosen
-        if kpoint is not None:
-            for c in range(self.dim):
-                sigma_cn[c] += self.continued_fraction(eps_n, kpoint, c,
-                                                       0, imax).imag
-        else:
-            for k in range(self.nkpts):
-                print('kpoint', k, 'spin_k', self.spin_k[k], spin,
-                      'weight', self.weight_k[k])
-                if self.spin_k[k] == spin:
-                    weight = self.weight_k[k]
-                    for c in range(self.dim):
-                        sigma_cn[c] += weight * self.continued_fraction(
-                            eps_n, k, c, 0, imax).imag
-
-        if self.op_scc is not None:
-            sigma0_cn = sigma_cn
-            sigma_cn = np.zeros((self.dim, n))
-            for op_cc in self.op_scc:
-                sigma_cn += np.dot(op_cc**2, sigma0_cn)
-            sigma_cn /= len(self.op_scc)
-
-        # gaussian broadening
-        if fwhm is not None:
-            sigma_tmp = np.zeros(sigma_cn.shape)
-
-            # constant broadening fwhm
-            if linbroad is None:
-                alpha = 4 * log(2) / fwhm**2
-                for n, eps in enumerate(eps_s):
-                    x = -alpha * (eps_s - eps)**2
-                    x = np.clip(x, -100.0, 100.0)
-                    sigma_tmp += np.outer(sigma_cn[:, n],
-                                          (alpha / pi)**0.5 * np.exp(x))
+        homo:
+            homo energy (or energies in spin-polarized case) in eV
+        lumo:
+            lumo energy (or energies in spin-polarized case) in eV
 
-            else:
-                # constant broadening fwhm until linbroad[1] and a
-                # constant broadening over linbroad[2] with fwhm2=
-                # linbroad[0]
-                fwhm2 = linbroad[0]
-                lin_e1 = linbroad[1]
-                lin_e2 = linbroad[2]
-                for n, eps in enumerate(eps_s):
-                    if eps < lin_e1:
-                        alpha = 4 * log(2) / fwhm**2
-                    elif eps <= lin_e2:
-                        fwhm_lin = (fwhm + (eps - lin_e1) *
-                                    (fwhm2 - fwhm) / (lin_e2 - lin_e1))
-                        alpha = 4 * log(2) / fwhm_lin**2
-                    elif eps >= lin_e2:
-                        alpha = 4 * log(2) / fwhm2**2
-
-                    x = -alpha * (eps_s - eps)**2
-                    x = np.clip(x, -100.0, 100.0)
-                    sigma_tmp += np.outer(sigma_cn[:, n],
-                                          (alpha / pi)**0.5 * np.exp(x))
-            sigma_cn = sigma_tmp
-
-        return sigma_cn
-
-    def solve(self, w_cG, z_cG, u):
-        # exact inverse overlap
-        self.overlap.apply_inverse(w_cG, self.tmp1_cG, self.wfs,
-                                   self.wfs.kpt_u[u])
-        self.u = u
-        CG(self, z_cG, self.tmp1_cG,
-           tolerance=self.tol, maxiter=self.maxiter)
-
-    def solve2(self, w_cG, z_cG, u):
-        # approximate inverse overlap
-        self.overlap.apply_inverse(w_cG, z_cG, self.wfs, self.wfs.kpt_u[u])
-
-        self.u = u
-
-    def solve3(self, w_cG, z_cG, u):
-        # no inverse overlap
-        z_cG[:] = w_cG
-        self.u = u
-
-    def sum(self, a):
-        self.wfs.gd.comm.sum(a)
-        return a
+        Returns:
 
-    def __call__(self, in_cG, out_cG):
-        """Function that is called by CG. It returns S~-1Sx_in in x_out
+        dxc_pot: Discontinuity potential
         """
+        if self.nspins == 2:
+            eref_s = np.asarray(homo)
+            eref_lumo_s = np.asarray(lumo)
+        else:
+            eref_s = np.asarray([homo])
+            eref_lumo_s = np.asarray([lumo])
+        assert len(eref_s) == len(eref_lumo_s) == self.nspins
+        eref_s /= Ha
+        eref_lumo_s /= Ha
+
+        dxc_Dresp_asp = self.empty_atomic_matrix()
+        dxc_D_asp = self.empty_atomic_matrix()
+        for a in self.density.D_asp:
+            ni = self.wfs.setups[a].ni
+            dxc_Dresp_asp[a] = np.zeros((self.nspins, ni * (ni + 1) // 2))
+            dxc_D_asp[a] = np.zeros((self.nspins, ni * (ni + 1) // 2))
+
+        # Calculate new response potential with LUMO reference
+        w_kn = self.coefficients.get_coefficients_for_lumo_perturbation(
+            self.wfs.kpt_u, eref_s=eref_s, eref_lumo_s=eref_lumo_s)
+        f_kn = [kpt.f_n for kpt in self.wfs.kpt_u]
+
+        dxc_vt_sG = self.gd.zeros(self.nspins)
+        nt_sG = self.gd.zeros(self.nspins)
+        for kpt, w_n in zip(self.wfs.kpt_u, w_kn):
+            self.wfs.add_to_density_from_k_point_with_occupation(dxc_vt_sG,
+                                                                 kpt, w_n)
+            self.wfs.add_to_density_from_k_point(nt_sG, kpt)
+
+        self.wfs.kptband_comm.sum(nt_sG)
+        self.wfs.kptband_comm.sum(dxc_vt_sG)
+
+        if self.wfs.kd.symmetry:
+            for nt_G, dxc_vt_G in zip(nt_sG, dxc_vt_sG):
+                self.wfs.kd.symmetry.symmetrize(nt_G, self.gd)
+                self.wfs.kd.symmetry.symmetrize(dxc_vt_G, self.gd)
+
+        dxc_vt_sG /= nt_sG + self.damp
+
+        self.wfs.calculate_atomic_density_matrices_with_occupation(
+            dxc_Dresp_asp, w_kn)
+        self.wfs.calculate_atomic_density_matrices_with_occupation(
+            dxc_D_asp, f_kn)
+        dxc_pot = ResponsePotential(self, dxc_vt_sG, None,
+                                    dxc_D_asp, dxc_Dresp_asp)
+        return dxc_pot
+
+    def calculate_delta_xc_perturbation(self):
+        warnings.warn(
+            'The function calculate_delta_xc_perturbation() is deprecated. '
+            'Please use calculate_discontinuity() instead. '
+            'See documentation on calculating band gap with GLLBSC.',
+            DeprecationWarning)
+        dxc_pot = ResponsePotential(self, self.Dxc_vt_sG, None, self.Dxc_D_asp,
+                                    self.Dxc_Dresp_asp)
+        if self.nspins != 1:
+            ret = []
+            for spin in range(self.nspins):
+                ret.append(self.calculate_discontinuity(dxc_pot, spin=spin))
+            return ret
+        return self.calculate_discontinuity(dxc_pot)
+
+    def calculate_delta_xc_perturbation_spin(self, s=0):
+        warnings.warn(
+            'The function calculate_delta_xc_perturbation_spin() is '
+            'deprecated. Please use calculate_discontinuity_spin() instead. '
+            'See documentation on calculating band gap with GLLBSC.',
+            DeprecationWarning)
+        dxc_pot = ResponsePotential(self, self.Dxc_vt_sG, None, self.Dxc_D_asp,
+                                    self.Dxc_Dresp_asp)
+        return self.calculate_discontinuity(dxc_pot, spin=s)
+
+    def calculate_discontinuity(self,
+                                dxc_pot: ResponsePotential,
+                                spin: int = None):
+        r"""Calculate the derivative discontinuity.
+
+        This function evaluates the perturbation theory expression
+        for the derivative discontinuity value as given by
+        Eq. (25) of https://doi.org/10.1103/PhysRevB.82.115106
 
-        kpt = self.wfs.kpt_u[self.u]
-        self.overlap.apply(in_cG, self.tmp2_cG, self.wfs, kpt)
-        self.overlap.apply_inverse(self.tmp2_cG, out_cG, self.wfs, kpt)
-
-    def terminator(self, a, b, e):
-        """ Analytic formula to terminate the continued fraction from
-        [R Haydock, V Heine, and M J Kelly,
-        J Phys. C: Solid State Physics, Vol 8, (1975), 2591-2605]
-        """
+        Parameters:
 
-        return 0.5 * (e - a - ((e - a)**2 - 4 * b**2)**0.5 / b**2)
+        dxc_pot:
+            Discontinuity potential.
+        spin:
+            Spin value.
+
+        Returns:
+
+        KSgap:
+            Kohn-Sham gap in eV
+        dxc:
+            Derivative discontinuity in eV
+        """
+        if spin is None:
+            if self.nspins != 1:
+                raise ValueError('Specify spin for the discontinuity.')
+            spin = 0
+
+        # Redistribute discontinuity potential
+        if dxc_pot.response is not self:
+            dxc_pot.redistribute(self)
+
+        homo, lumo = self.wfs.get_homo_lumo(spin)
+        KSgap = lumo - homo
+
+        # Find the lumo-orbital of this spin
+        if self.wfs.bd.comm.size != 1:
+            raise BadParallelization(
+                'Band parallelization is not supported by '
+                'calculate_discontinuity().')
+        eps_n = self.wfs.kpt_qs[0][spin].eps_n
+        lumo_n = (eps_n < self.wfs.fermi_level).sum()
+
+        # Calculate the expectation value for all k points, and keep
+        # the smallest energy value
+        nt_G = self.gd.empty()
+        min_energy = np.inf
+        for u, kpt in enumerate(self.wfs.kpt_u):
+            if kpt.s == spin:
+                nt_G[:] = 0.0
+                self.wfs.add_orbital_density(nt_G, kpt, lumo_n)
+                E = 0.0
+                for a in dxc_pot.D_asp:
+                    D_sp = dxc_pot.D_asp[a]
+                    Dresp_sp = dxc_pot.Dresp_asp[a]
+                    P_ni = kpt.P_ani[a]
+                    Dwf_p = pack(np.outer(P_ni[lumo_n].T.conj(),
+                                          P_ni[lumo_n]).real)
+                    E += self.integrate_sphere(a, Dresp_sp, D_sp, Dwf_p,
+                                               spin=spin)
+                E = self.gd.comm.sum(E)
+                E += self.gd.integrate(nt_G * dxc_pot.vt_sG[spin])
+                E += kpt.eps_n[lumo_n] - lumo
+                min_energy = min(min_energy, E)
+
+        # Take the smallest value over all distributed k points
+        dxc = self.wfs.kd.comm.min(min_energy)
+        return KSgap * Ha, dxc * Ha
+
+    def calculate_discontinuity_from_average(self,
+                                             dxc_pot: ResponsePotential,
+                                             spin: int,
+                                             testing: bool = False):
+        msg = ('This function estimates discontinuity by calculating '
+               'the average of the discontinuity potential. '
+               'Use only for testing and debugging.')
+        if not testing:
+            raise RuntimeError(msg)
+        else:
+            warnings.warn(msg)
+        assert self.wfs.world.size == 1
+
+        # Calculate average of lumo reference response potential
+        dxc = np.average(dxc_pot.vt_sG[spin])
+        return dxc * Ha
+
+    def initialize_from_atomic_orbitals(self, basis_functions):
+        # Initialize 'response-density' and density-matrices
+        # print('Initializing from atomic orbitals')
+        self.Dresp_asp = self.empty_atomic_matrix()
+        setups = self.wfs.setups
+
+        for a in self.density.D_asp.keys():
+            ni = setups[a].ni
+            self.Dresp_asp[a] = np.zeros((self.nspins, ni * (ni + 1) // 2))
+
+        self.D_asp = self.empty_atomic_matrix()
+        f_asi = {}
+        w_asi = {}
+
+        for a in basis_functions.atom_indices:
+            if setups[a].type == 'ghost':
+                w_j = [0.0]
+            else:
+                w_j = setups[a].extra_xc_data['w_j']
 
-    def duplicate_coefficients(self, nsteps, ntimes):
-        n1 = self.a_uci.shape[0]
-        n2 = self.a_uci.shape[1]
-        ni = self.a_uci.shape[2]
-        type_code = self.a_uci.dtype.name  # typecode()
-        a_uci = np.empty((n1, n2, ni + nsteps * ntimes), type_code)
-        b_uci = np.empty((n1, n2, ni + nsteps * ntimes), type_code)
-        a_uci[:, :, :ni] = self.a_uci
-        b_uci[:, :, :ni] = self.b_uci
-
-        ni1 = ni
-        ni2 = ni + nsteps
-        for i in range(ntimes):
-            a_uci[:, :, ni1: ni2] = a_uci[:, :, ni - nsteps:ni]
-            b_uci[:, :, ni1: ni2] = b_uci[:, :, ni - nsteps:ni]
-            ni1 += nsteps
-            ni2 += nsteps
-        self.a_uci = a_uci
-        self.b_uci = b_uci
-
-
-def write_spectrum(a, b, filename):
-    f = open(filename, 'w')
-    print(f, a.shape, b.shape)
-
-    for i in range(a.shape[0]):
-        print('%g' % a[i], b[0, i] + b[1, i] + b[2, i], end=' ', file=f)
-        for b2 in b:
-            print('%g' % b2[i], end=' ', file=f)
-        print(file=f)
-    f.close()
+            # Basis function coefficients based of response weights
+            w_si = setups[a].calculate_initial_occupation_numbers(
+                0, False,
+                charge=0,
+                nspins=self.nspins,
+                f_j=w_j)
+            # Basis function coefficients based on density
+            f_si = setups[a].calculate_initial_occupation_numbers(
+                0, False,
+                charge=0,
+                nspins=self.nspins)
+
+            if a in basis_functions.my_atom_indices:
+                self.Dresp_asp[a] = setups[a].initialize_density_matrix(w_si)
+                self.D_asp[a] = setups[a].initialize_density_matrix(f_si)
+
+            f_asi[a] = f_si
+            w_asi[a] = w_si
+
+        self.Drespdist_asp = self.distribute_D_asp(self.Dresp_asp)
+        self.Ddist_asp = self.distribute_D_asp(self.D_asp)
+        nt_sG = self.gd.zeros(self.nspins)
+        basis_functions.add_to_density(nt_sG, f_asi)
+        self.vt_sG = self.gd.zeros(self.nspins)
+        basis_functions.add_to_density(self.vt_sG, w_asi)
+        # Update vt_sG to correspond atomic response potential. This will be
+        # used until occupations and eigenvalues are available.
+        self.vt_sG /= nt_sG + self.damp
+        self.vt_sg = self.finegd.zeros(self.nspins)
+        self.density.distribute_and_interpolate(self.vt_sG, self.vt_sg)
+
+    def get_extra_setup_data(self, extra_data):
+        ae = self.ae
+        njcore = ae.njcore
+        w_ln = self.coefficients.get_coefficients_1d(smooth=True)
+        w_j = []
+        for w_n in w_ln:
+            for w in w_n:
+                w_j.append(w)
+        extra_data['w_j'] = w_j
+
+        w_j = self.coefficients.get_coefficients_1d()
+        x_g = np.dot(w_j[:njcore], safe_sqr(ae.u_j[:njcore]))
+        x_g[1:] /= ae.r[1:] ** 2 * 4 * np.pi
+        x_g[0] = x_g[1]
+        extra_data['core_response'] = x_g
+
+        # For debugging purposes
+        w_j = self.coefficients.get_coefficients_1d()
+        u2_j = safe_sqr(self.ae.u_j)
+        v_g = self.weight * np.dot(w_j, u2_j) / (
+            np.dot(self.ae.f_j, u2_j) + self.damp)
+        v_g[0] = v_g[1]
+        extra_data['all_electron_response'] = v_g
+
+        # Calculate Hardness of spherical atom, for debugging purposes
+        l = [np.where(f < 1e-3, e, 1000)
+             for f, e in zip(self.ae.f_j, self.ae.e_j)]
+        h = [np.where(f > 1e-3, e, -1000)
+             for f, e in zip(self.ae.f_j, self.ae.e_j)]
+        lumo_e = min(l)
+        homo_e = max(h)
+        if lumo_e < 999:  # If there is unoccpied orbital
+            w_j = self.coefficients.get_coefficients_1d_for_lumo_perturbation()
+            v_g = self.weight * np.dot(w_j, u2_j) / (
+                np.dot(self.ae.f_j, u2_j) + self.damp)
+            e2 = [e + np.dot(u2 * v_g, self.ae.dr)
+                  for u2, e in zip(u2_j, self.ae.e_j)]
+            lumo_2 = min([np.where(f < 1e-3, e, 1000)
+                          for f, e in zip(self.ae.f_j, e2)])
+            # print('New lumo eigenvalue:', lumo_2 * 27.2107)
+            self.hardness = lumo_2 - homo_e
+            # print('Hardness predicted: %10.3f eV' %
+            #       (self.hardness * 27.2107))
+
+    def write(self, writer):
+        """Writes response specific data."""
+        wfs = self.wfs
+        kpt_comm = wfs.kd.comm
+        gd = wfs.gd
+
+        # Write the pseudodensity on the coarse grid:
+        shape = (wfs.nspins,) + tuple(gd.get_size_of_global_array())
+        writer.add_array('gllb_pseudo_response_potential', shape)
+        if kpt_comm.rank == 0:
+            for vt_G in self.vt_sG:
+                writer.fill(gd.collect(vt_G) * Ha)
+
+        def pack(X0_asp):
+            X_asp = wfs.setups.empty_atomic_matrix(
+                wfs.nspins, wfs.atom_partition)
+            # XXX some of the provided X0_asp contain strangely duplicated
+            # elements.  Take only the minimal set:
+            for a in X_asp:
+                X_asp[a][:] = X0_asp[a]
+            return pack_atomic_matrices(X_asp)
+
+        writer.write(gllb_atomic_density_matrices=pack(self.D_asp))
+        writer.write(gllb_atomic_response_matrices=pack(self.Dresp_asp))
+
+        writer.write(eref_s=self.eref_s)
+        writer.write(eref_source_s=self.eref_source_s)
+
+    def empty_atomic_matrix(self):
+        assert self.wfs.atom_partition is self.density.atom_partition
+        return self.wfs.setups.empty_atomic_matrix(self.wfs.nspins,
+                                                   self.wfs.atom_partition)
+
+    def read(self, reader):
+        r = reader.hamiltonian.xc
+        wfs = self.wfs
+
+        d('Reading vt_sG')
+        self.gd.distribute(r.gllb_pseudo_response_potential / reader.ha,
+                           self.vt_sG)
+        self.density.distribute_and_interpolate(self.vt_sG, self.vt_sg)
+
+        def unpack(D_sP):
+            return unpack_atomic_matrices(D_sP, wfs.setups)
+
+        # Read atomic density matrices and non-local part of hamiltonian:
+        D_asp = unpack(r.gllb_atomic_density_matrices)
+        Dresp_asp = unpack(r.gllb_atomic_response_matrices)
+
+        # All density matrices are loaded to all cores
+        # First distribute them to match density.D_asp
+        self.D_asp = self.empty_atomic_matrix()
+        self.Dresp_asp = self.empty_atomic_matrix()
+        for a in self.density.D_asp:
+            self.D_asp[a][:] = D_asp[a]
+            self.Dresp_asp[a][:] = Dresp_asp[a]
+        assert len(self.Dresp_asp) == len(self.density.D_asp)
+
+        # Further distributes the density matricies for xc-corrections
+        self.Ddist_asp = self.distribute_D_asp(self.D_asp)
+        self.Drespdist_asp = self.distribute_D_asp(self.Dresp_asp)
+
+        if 'eref_s' in r:
+            self.eref_s = r.eref_s
+            self.eref_source_s = r.eref_source_s
+
+    def heeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeelp(self, olddens):
+        # XXX This function should be removed once the deprecated
+        # `fixdensity=True` option is removed.
+        from gpaw.density import redistribute_array
+        self.vt_sg = redistribute_array(self.vt_sg,
+                                        olddens.finegd, self.finegd,
+                                        self.wfs.nspins, self.wfs.kptband_comm)
+        self.vt_sG = redistribute_array(self.vt_sG,
+                                        olddens.gd, self.gd,
+                                        self.wfs.nspins, self.wfs.kptband_comm)
```

### Comparing `gpaw-22.8.0/gpaw/xc/__init__.py` & `gpaw-23.6.0/gpaw/xc/__init__.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,12 +1,13 @@
 from gpaw.xc.libxc import LibXC
 from gpaw.xc.lda import LDA
 from gpaw.xc.gga import GGA
 from gpaw.xc.mgga import MGGA
 from gpaw.xc.noncollinear import NonCollinearLDAKernel
+from gpaw import libraries
 
 
 def xc_string_to_dict(string):
     """Convert XC specification string to dictionary.
 
     'name:key1=value1:...' -> {'name': <name>, key1: value1, ...}."""
     tokens = string.split(':')
@@ -98,14 +99,15 @@
         elif name == 'TB09':
             from gpaw.xc.tb09 import TB09
             return TB09(**kwargs)
         elif name.endswith('PZ-SIC'):
             from gpaw.xc.sic import SIC
             return SIC(xc=name[:-7], **kwargs)
         elif name in {'TPSS', 'revTPSS', 'M06-L'}:
+            assert libraries['libxc'], 'Please compile with libxc'
             from gpaw.xc.kernel import XCKernel
             kernel = XCKernel(name)
         elif name in {'LDA', 'PBE', 'revPBE', 'RPBE', 'PW91'}:
             from gpaw.xc.kernel import XCKernel
             kernel = XCKernel(name)
         elif name.startswith('old'):
             from gpaw.xc.kernel import XCKernel
```

### Comparing `gpaw-22.8.0/gpaw/xc/bee.py` & `gpaw-23.6.0/gpaw/xc/bee.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/xc/functional.py` & `gpaw-23.6.0/gpaw/xc/functional.py`

 * *Files 2% similar despite different names*

```diff
@@ -104,10 +104,14 @@
         pass
 
     def get_kinetic_energy_correction(self):
         return self.ekin
 
     def add_forces(self, F_av):
         pass
+    
+    def stress_tensor_contribution(self, n_sg):
+        raise NotImplementedError('Calculation of stress tensor is not ' +
+                                  f'implemented for {self.name}')
 
     def calculate_spherical(self, rgd, n_sg, v_sg, e_g=None):
         raise NotImplementedError
```

### Comparing `gpaw-22.8.0/gpaw/xc/gga.py` & `gpaw-23.6.0/gpaw/xc/gga.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/xc/gllb/c_gllbscr.py` & `gpaw-23.6.0/gpaw/xc/gllb/c_gllbscr.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/xc/gllb/c_xc.py` & `gpaw-23.6.0/gpaw/xc/gllb/c_xc.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/xc/gllb/coefficients.py` & `gpaw-23.6.0/gpaw/xc/gllb/coefficients.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/xc/gllb/contribution.py` & `gpaw-23.6.0/gpaw/xc/gllb/contribution.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/xc/gllb/nonlocalfunctional.py` & `gpaw-23.6.0/gpaw/xc/gllb/nonlocalfunctional.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/xc/gllb/nonlocalfunctionalfactory.py` & `gpaw-23.6.0/gpaw/xc/gllb/nonlocalfunctionalfactory.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/xc/hybrid.py` & `gpaw-23.6.0/gpaw/xc/hybrid.py`

 * *Files 0% similar despite different names*

```diff
@@ -147,15 +147,15 @@
             RSF mixing parameter
         excitation: string:
             Apply operator for improved virtual orbitals
             to unocc states? Possible modes:
                 singlet: excitations to singlets
                 triplet: excitations to triplets
                 average: average between singlets and tripletts
-                see f.e. http://dx.doi.org/10.1021/acs.jctc.8b00238
+                see f.e. https://doi.org/10.1021/acs.jctc.8b00238
         excited: number
             Band to excite from - counted from HOMO downwards
 
         """
         self.finegrid = finegrid
         self.unocc = unocc
         self.excitation = excitation
```

### Comparing `gpaw-22.8.0/gpaw/xc/kernel.py` & `gpaw-23.6.0/gpaw/xc/kernel.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/xc/lb94.py` & `gpaw-23.6.0/gpaw/xc/lb94.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/xc/lda.py` & `gpaw-23.6.0/gpaw/xc/lda.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/xc/libvdwxc.py` & `gpaw-23.6.0/gpaw/xc/libvdwxc.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/xc/libxc.py` & `gpaw-23.6.0/gpaw/xc/libxc.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/xc/mgga.py` & `gpaw-23.6.0/gpaw/xc/mgga.py`

 * *Files 14% similar despite different names*

```diff
@@ -15,14 +15,15 @@
     orbital_dependent = True
 
     def __init__(self, kernel, stencil=2):
         """Meta GGA functional."""
         XCFunctional.__init__(self, kernel.name, kernel.type)
         self.kernel = kernel
         self.stencil = stencil
+        self.fixed_ke = False
 
     def set_grid_descriptor(self, gd):
         self.grad_v = get_gradient_ops(gd, self.stencil)
         XCFunctional.set_grid_descriptor(self, gd)
 
     def get_setup_name(self):
         return 'PBE'
@@ -34,32 +35,66 @@
                 .format(self.name, self.stencil))
 
     def initialize(self, density, hamiltonian, wfs):
         self.wfs = wfs
         self.tauct = density.get_pseudo_core_kinetic_energy_density_lfc()
         self.tauct_G = None
         self.dedtaut_sG = None
-        self.restrict_and_collect = hamiltonian.restrict_and_collect
-        self.distribute_and_interpolate = density.distribute_and_interpolate
+        if ((not hasattr(hamiltonian, 'xc_redistributor'))
+                or (hamiltonian.xc_redistributor is None)):
+            self.restrict_and_collect = hamiltonian.restrict_and_collect
+            self.distribute_and_interpolate = \
+                density.distribute_and_interpolate
+        else:
+            def _distribute_and_interpolate(in_xR, out_xR=None):
+                tmp_xR = density.interpolate(in_xR)
+                if hamiltonian.xc_redistributor.enabled:
+                    out_xR = hamiltonian.xc_redistributor.distribute(tmp_xR,
+                                                                     out_xR)
+                elif out_xR is None:
+                    out_xR = tmp_xR
+                else:
+                    out_xR[:] = tmp_xR
+                return out_xR
+
+            def _restrict_and_collect(in_xR, out_xR=None):
+                if hamiltonian.xc_redistributor.enabled:
+                    in_xR = hamiltonian.xc_redistributor.collect(in_xR)
+                return hamiltonian.restrict(in_xR, out_xR)
+            self.restrict_and_collect = _restrict_and_collect
+            self.distribute_and_interpolate = _distribute_and_interpolate
 
     def set_positions(self, spos_ac):
         self.tauct.set_positions(spos_ac, self.wfs.atom_partition)
         if self.tauct_G is None:
             self.tauct_G = self.wfs.gd.empty()
         self.tauct_G[:] = 0.0
         self.tauct.add(self.tauct_G)
 
     def calculate_impl(self, gd, n_sg, v_sg, e_g):
         sigma_xg, dedsigma_xg, gradn_svg = gga_vars(gd, self.grad_v, n_sg)
         self.process_mgga(e_g, n_sg, v_sg, sigma_xg, dedsigma_xg)
         add_gradient_correction(self.grad_v, gradn_svg, sigma_xg,
                                 dedsigma_xg, v_sg)
 
+    def fix_kinetic_energy_density(self, taut_sG):
+        self.fixed_ke = True
+        self._taut_gradv_init = False
+        self._fixed_taut_sG = taut_sG.copy()
+
     def process_mgga(self, e_g, nt_sg, v_sg, sigma_xg, dedsigma_xg):
-        taut_sG = self.wfs.calculate_kinetic_energy_density()
+        if self.fixed_ke:
+            taut_sG = self._fixed_taut_sG
+            if not self._taut_gradv_init:
+                self._taut_gradv_init = True
+                # ensure initialization for calculation potential
+                self.wfs.calculate_kinetic_energy_density()
+        else:
+            taut_sG = self.wfs.calculate_kinetic_energy_density()
+
         if taut_sG is None:
             taut_sG = self.wfs.gd.zeros(len(nt_sg))
 
         if 0:  # taut_sG is None:
             # Below code disabled because it produces garbage in at least
             # some cases.
             #
@@ -94,14 +129,72 @@
         self.ekin = 0.0
         for s in range(self.wfs.nspins):
             self.restrict_and_collect(dedtaut_sg[s], self.dedtaut_sG[s])
             self.ekin -= self.wfs.gd.integrate(
                 self.dedtaut_sG[s] * (taut_sG[s] -
                                       self.tauct_G / self.wfs.nspins))
 
+    def stress_tensor_contribution(self, n_sg):
+        sigma_xg, dedsigma_xg, gradn_svg = gga_vars(self.gd, self.grad_v, n_sg)
+        taut_sG = self.wfs.calculate_kinetic_energy_density()
+        if taut_sG is None:
+            taut_sG = self.wfs.gd.zeros(len(n_sg))
+        taut_sg = np.empty_like(n_sg)
+        for taut_G, taut_g in zip(taut_sG, taut_sg):
+            taut_G += 1.0 / self.wfs.nspins * self.tauct_G
+            self.distribute_and_interpolate(taut_G, taut_g)
+
+        nspins = len(n_sg)
+        dedtaut_sg = np.empty_like(n_sg)
+        v_sg = self.gd.zeros(nspins)
+        e_g = self.gd.empty()
+        self.kernel.calculate(e_g, n_sg, v_sg, sigma_xg, dedsigma_xg,
+                              taut_sg, dedtaut_sg)
+
+        def integrate(a1_g, a2_g=None):
+            return self.gd.integrate(a1_g, a2_g, global_integral=False)
+
+        P = integrate(e_g)
+        for v_g, n_g in zip(v_sg, n_sg):
+            P -= integrate(v_g, n_g)
+        for sigma_g, dedsigma_g in zip(sigma_xg, dedsigma_xg):
+            P -= 2 * integrate(sigma_g, dedsigma_g)
+        for taut_g, dedtaut_g in zip(taut_sg, dedtaut_sg):
+            P -= integrate(taut_g, dedtaut_g)
+
+        tau_svvG = self.wfs.calculate_kinetic_energy_density_crossterms()
+
+        stress_vv = P * np.eye(3)
+        for v1 in range(3):
+            for v2 in range(3):
+                stress_vv[v1, v2] -= integrate(gradn_svg[0, v1] *
+                                               gradn_svg[0, v2],
+                                               dedsigma_xg[0]) * 2
+                if nspins == 2:
+                    stress_vv[v1, v2] -= integrate(gradn_svg[0, v1] *
+                                                   gradn_svg[1, v2],
+                                                   dedsigma_xg[1]) * 2
+                    stress_vv[v1, v2] -= integrate(gradn_svg[1, v1] *
+                                                   gradn_svg[1, v2],
+                                                   dedsigma_xg[2]) * 2
+        tau_cross_g = self.gd.empty()
+        for s in range(nspins):
+            for v1 in range(3):
+                for v2 in range(3):
+                    self.distribute_and_interpolate(
+                        tau_svvG[s, v1, v2], tau_cross_g)
+                    stress_vv[v1, v2] -= integrate(tau_cross_g, dedtaut_sg[s])
+
+        self.dedtaut_sG = self.wfs.gd.empty(self.wfs.nspins)
+        for s in range(self.wfs.nspins):
+            self.restrict_and_collect(dedtaut_sg[s], self.dedtaut_sG[s])
+
+        self.gd.comm.sum(stress_vv)
+        return stress_vv
+
     def apply_orbital_dependent_hamiltonian(self, kpt, psit_xG,
                                             Htpsit_xG, dH_asp=None):
         self.wfs.apply_mgga_orbital_dependent_hamiltonian(
             kpt, psit_xG,
             Htpsit_xG, dH_asp,
             self.dedtaut_sG[kpt.s])
 
@@ -110,15 +203,15 @@
         assert not hasattr(self, 'D_sp')
         self.D_sp = D_sp
         self.n = 0
         self.ae = True
         self.xcc = setup.xc_correction
         self.dEdD_sp = dEdD_sp
 
-        if self.xcc.tau_npg is None:
+        if self.xcc is not None and self.xcc.tau_npg is None:
             self.xcc.tau_npg, self.xcc.taut_npg = self.initialize_kinetic(
                 self.xcc)
 
         rcalc = self.create_mgga_radial_calculator()
         expansion = GGARadialExpansion(rcalc)
         # The damn thing uses too many 'self' variables to define a clean
         # integrator object.
```

### Comparing `gpaw-22.8.0/gpaw/xc/noncollinear.py` & `gpaw-23.6.0/gpaw/xc/noncollinear.py`

 * *Files 17% similar despite different names*

```diff
@@ -60,14 +60,17 @@
         M = len(S_MM)
         S2_MM = np.zeros((2 * M, 2 * M), complex)
         H2_MM = np.zeros((2 * M, 2 * M), complex)
 
         S2_MM[:M, :M] = S_MM
         S2_MM[M:, M:] = S_MM
 
+        # We are ignoring x and y here.
+        # See gpaw.new.lcao.hamiltonian.NonCollinearHamiltonianMatrixCalculator
+        # for the correct way!
         H2_MM[:M, :M] = H_xMM[0] + H_xMM[3]
         H2_MM[M:, M:] = H_xMM[0] - H_xMM[3]
 
         kpt.eps_n = np.empty(2 * wfs.bd.mynbands)
 
         diagonalization_string = repr(self.diagonalizer)
         wfs.timer.start(diagonalization_string)
```

### Comparing `gpaw-22.8.0/gpaw/xc/parametrizedxc.py` & `gpaw-23.6.0/gpaw/xc/parametrizedxc.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/xc/pawcorrection.py` & `gpaw-23.6.0/gpaw/xc/pawcorrection.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/xc/qna.py` & `gpaw-23.6.0/gpaw/xc/qna.py`

 * *Files 1% similar despite different names*

```diff
@@ -192,14 +192,15 @@
     def get_setup_name(self):
         return self.qna_setup_name
 
     def get_description(self):
         return 'QNA Parameters: ' + str(self.parameters)
 
     def add_forces(self, F_av):
+        assert self.gd.comm.size == 1, 'Domain decomposition is not supported'
         mu_g = self.gd.zeros()
         beta_g = self.gd.zeros()
         denominator = self.gd.zeros()
         mu_a = {}
         beta_a = {}
         eye_a = {}
         for atom in self.atoms:
```

### Comparing `gpaw-22.8.0/gpaw/xc/ri/__init__.py` & `gpaw-23.6.0/gpaw/xc/ri/__init__.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/xc/ri/ribasis.py` & `gpaw-23.6.0/gpaw/xc/ri/ribasis.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/xc/ri/spherical_hse_kernel.py` & `gpaw-23.6.0/gpaw/xc/ri/spherical_hse_kernel.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/xc/rpa.py` & `gpaw-23.6.0/gpaw/xc/rpa.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,23 +1,26 @@
+from __future__ import annotations
 import functools
 import os
 from time import ctime
 
 import numpy as np
 from ase.units import Hartree
-from ase.utils import IOContext
-from ase.utils.timing import Timer, timer
 from scipy.special import p_roots
 
 import gpaw.mpi as mpi
-from gpaw import GPAW
-from gpaw.response.chi0 import Chi0
-from gpaw.response.kernels import get_coulomb_kernel
-from gpaw.response.wstc import WignerSeitzTruncatedCoulomb
-from gpaw.response.groundstate import ResponseGroundStateAdapter
+from gpaw.response import timer
+from gpaw.response.chi0 import Chi0Calculator
+from gpaw.response.coulomb_kernels import CoulombKernel
+from gpaw.response.frequencies import FrequencyDescriptor
+from gpaw.response.pair import get_gs_and_context, PairDensityCalculator
+
+
+def default_ecut_extrapolation(ecut, extrapolate):
+    return ecut * (1 + 0.5 * np.arange(extrapolate))**(-2 / 3)
 
 
 def rpa(filename, ecut=200.0, blocks=1, extrapolate=4):
     """Calculate RPA energy.
 
     filename: str
         Name of restart-file.
@@ -29,387 +32,433 @@
         Number of cutoff energies to use for extrapolation.
     """
     name, ext = filename.rsplit('.', 1)
     assert ext == 'gpw'
     from gpaw.xc.rpa import RPACorrelation
     rpa = RPACorrelation(name, name + '-rpa.dat',
                          nblocks=blocks,
+                         ecut=default_ecut_extrapolation(ecut, extrapolate),
                          txt=name + '-rpa.txt')
-    rpa.calculate(ecut=ecut * (1 + 0.5 * np.arange(extrapolate))**(-2 / 3))
-
-
-class RPACorrelation:
-    def __init__(self, calc, xc='RPA', filename=None,
-                 skip_gamma=False, qsym=True, nlambda=None,
-                 nfrequencies=16, frequency_max=800.0, frequency_scale=2.0,
-                 frequencies=None, weights=None, truncation=None,
-                 world=mpi.world, nblocks=1, txt='-'):
-        """Creates the RPACorrelation object
-
-        calc: str or calculator object
-            The string should refer to the .gpw file contaning KS orbitals
-        xc: str
-            Exchange-correlation kernel. This is only different from RPA when
-            this object is constructed from a different module - e.g. fxc.py
-        filename: str
-            txt output
-        skip_gamme: bool
-            If True, skip q = [0,0,0] from the calculation
-        qsym: bool
-            Use symmetry to reduce q-points
-        nlambda: int
-            Number of lambda points. Only used for numerical coupling
-            constant integration involved when called from fxc.py
-        nfrequencies: int
-            Number of frequency points used in the Gauss-Legendre integration
-        frequency_max: float
-            Largest frequency point in Gauss-Legendre integration
-        frequency_scale: float
-            Determines density of frequency points at low frequencies. A slight
-            increase to e.g. 2.5 or 3.0 improves convergence wth respect to
-            frequency points for metals
-        frequencies: list
-            List of frequancies for user-specified frequency integration
-        weights: list
-            list of weights (integration measure) for a user specified
-            frequency grid. Must be specified and have the same length as
-            frequencies if frequencies is not None
-        truncation: str
-            Coulomb truncation scheme. Can be either wigner-seitz,
-            2D, 1D, or 0D
-        world: communicator
-        nblocks: int
-            Number of parallelization blocks. Frequency parallelization
-            can be specified by setting nblocks=nfrequencies and is useful
-            for memory consuming calculations
-        txt: str
-            txt file for saving and loading contributions to the correlation
-            energy from different q-points
-        """
-
-        self.iocontext = IOContext()
-        if isinstance(calc, str):
-            calc = GPAW(calc, txt=None, communicator=mpi.serial_comm)
-        self.calc = calc
-        self.gs = ResponseGroundStateAdapter(calc)
+    rpa.calculate()
 
-        self.fd = self.iocontext.openfile(txt, world)
 
-        self.timer = Timer()
-
-        if frequencies is None:
-            frequencies, weights = get_gauss_legendre_points(nfrequencies,
-                                                             frequency_max,
-                                                             frequency_scale)
-            user_spec = False
-        else:
-            assert weights is not None
-            user_spec = True
+class GCut:
+    def __init__(self, cut_G):
+        self._cut_G = cut_G
+
+    @property
+    def nG(self):
+        return len(self._cut_G)
+
+    def spin_cut(self, array_GG, ns):
+        # Strange special case for spin-repeated arrays.
+        # Maybe we can get rid of this.
+        if self._cut_G is None:
+            return array_GG
+
+        cut_sG = np.tile(self._cut_G, ns)
+        cut_sG[self.nG:] += len(array_GG) // ns
+        array_GG = array_GG.take(cut_sG, 0).take(cut_sG, 1)
+        return array_GG
+
+    def cut(self, array, axes=(0,)):
+        if self._cut_G is None:
+            return array
+
+        for axis in axes:
+            array = array.take(self._cut_G, axis)
+        return array
+
+
+def initialize_q_points(kd, qsym):
+    bzq_qc = kd.get_bz_q_points(first=True)
+
+    if not qsym:
+        ibzq_qc = bzq_qc
+        weight_q = np.ones(len(bzq_qc)) / len(bzq_qc)
+    else:
+        U_scc = kd.symmetry.op_scc
+        ibzq_qc = kd.get_ibz_q_points(bzq_qc, U_scc)[0]
+        weight_q = kd.q_weights
+    return bzq_qc, ibzq_qc, weight_q
+
+
+class RPACalculator:
+    def __init__(self, gs, *, context, filename=None,
+                 ecut,
+                 skip_gamma=False, qsym=True,
+                 frequencies, weights, truncation=None,
+                 nblocks=1, calculate_q=None):
+        self.gs = gs
+        self.context = context
 
         self.omega_w = frequencies / Hartree
         self.weight_w = weights / Hartree
 
-        if nblocks > 1:
-            assert len(self.omega_w) % nblocks == 0
+        # TODO: We should avoid this requirement.
+        assert len(self.omega_w) % nblocks == 0
 
         self.nblocks = nblocks
-        self.world = world
 
-        self.truncation = truncation
+        self.coulomb = CoulombKernel(truncation, gs)
         self.skip_gamma = skip_gamma
-        self.ibzq_qc = None
-        self.weight_q = None
-        self.initialize_q_points(qsym)
 
-        # Energies for all q-vetors and cutoff energies:
-        self.energy_qi = []
+        # We should actually have a kpoint descriptor for the qpoints.
+        # We are badly failing at making use of the existing tools by reducing
+        # the qpoints to dumb arrays.
+        self.bzq_qc, self.ibzq_qc, self.weight_q = initialize_q_points(
+            gs.kd, qsym)
 
         self.filename = filename
 
-        self.print_initialization(xc, frequency_scale, nlambda, user_spec)
-
-    def __del__(self):
-        self.iocontext.close()
+        if calculate_q is None:
+            calculate_q = self.calculate_q_rpa
+        self.calculate_q = calculate_q
 
-    def initialize_q_points(self, qsym):
-        kd = self.gs.kd
-        self.bzq_qc = kd.get_bz_q_points(first=True)
+        if isinstance(ecut, (float, int)):
+            ecut = default_ecut_extrapolation(ecut, extrapolate=6)
+        self.ecut_i = np.asarray(np.sort(ecut)) / Hartree
 
-        if not qsym:
-            self.ibzq_qc = self.bzq_qc
-            self.weight_q = np.ones(len(self.bzq_qc)) / len(self.bzq_qc)
-        else:
-            U_scc = kd.symmetry.op_scc
-            self.ibzq_qc = kd.get_ibz_q_points(self.bzq_qc, U_scc)[0]
-            self.weight_q = kd.q_weights
+    def read(self, ecut_i, filename):
+        with open(filename) as fd:
+            lines = fd.readlines()[1:]
 
-    def read(self):
-        lines = open(self.filename).readlines()[1:]
         n = 0
-        self.energy_qi = []
-        nq = len(lines) // len(self.ecut_i)
+        energy_qi = []
+        nq = len(lines) // len(ecut_i)
         for q_c in self.ibzq_qc[:nq]:
-            self.energy_qi.append([])
-            for ecut in self.ecut_i:
-                q1, q2, q3, ec, energy = [float(x)
-                                          for x in lines[n].split()]
-                self.energy_qi[-1].append(energy / Hartree)
+            energy_qi.append([])
+            for ecut in ecut_i:
+                current_inputs = np.array([*q_c, ecut * Hartree])
+                numbers_from_file = [float(x) for x in lines[n].split()]
+                previous_inputs = numbers_from_file[:-1]
+
+                if not np.allclose(current_inputs, previous_inputs):
+                    # Energies are not reusable since input parameters
+                    # have changed
+                    return []
+
+                energy = numbers_from_file[-1]
+                energy_qi[-1].append(energy / Hartree)
                 n += 1
 
-                if (abs(q_c - (q1, q2, q3)).max() > 1e-4 or
-                    abs(int(ecut * Hartree) - ec) > 0):
-                    self.energy_qi = []
-                    return
-
-        print('Read %d q-points from file: %s' % (nq, self.filename),
-              file=self.fd)
-        print(file=self.fd)
-
-    def write(self):
-        if self.world.rank == 0 and self.filename:
-            fd = open(self.filename, 'w')
-            print('#%9s %10s %10s %8s %12s' %
-                  ('q1', 'q2', 'q3', 'E_cut', 'E_c(q)'), file=fd)
-            for energy_i, q_c in zip(self.energy_qi, self.ibzq_qc):
-                for energy, ecut in zip(energy_i, self.ecut_i):
-                    print('%10.4f %10.4f %10.4f %8d   %r' %
-                          (tuple(q_c) + (ecut * Hartree, energy * Hartree)),
-                          file=fd)
+        return energy_qi
+
+    def energies_to_string(self, energy_qi, ecut_i):
+        lines = []
+        app = lines.append
+        app('q1 q2 q3 E_cut E_c(q)')
+        for energy_i, q_c in zip(energy_qi, self.ibzq_qc):
+            for energy, ecut in zip(energy_i, ecut_i):
+                tokens = [repr(num) for num in
+                          (*q_c, ecut * Hartree, energy * Hartree)]
+                app(' '.join(tokens))
+
+    def write(self, energy_qi, ecut_i):
+        txt = self.energies_to_string(energy_qi, ecut_i)
+        if self.context.comm.rank == 0 and self.filename:
+            with open(self.filename, 'w') as fd:
+                print(txt, file=fd)
 
-    def calculate(self, ecut, nbands=None, spin=False):
+    def calculate(self, *, nbands=None, spin=False):
         """Calculate RPA correlation energy for one or several cutoffs.
 
         ecut: float or list of floats
             Plane-wave cutoff(s) in eV.
         nbands: int
             Number of bands (defaults to number of plane-waves).
         spin: bool
             Separate spin in response function.
             (Only needed for beyond RPA methods that inherit this function).
         """
 
-        p = functools.partial(print, file=self.fd)
+        p = functools.partial(self.context.print, flush=False)
 
-        if isinstance(ecut, (float, int)):
-            ecut = ecut * (1 + 0.5 * np.arange(6))**(-2 / 3)
-        self.ecut_i = np.asarray(np.sort(ecut)) / Hartree
-        ecutmax = max(self.ecut_i)
+        ecut_i = self.ecut_i
+        ecutmax = max(ecut_i)
 
         if nbands is None:
             p('Response function bands : Equal to number of plane waves')
         else:
             p('Response function bands : %s' % nbands)
         p('Plane wave cutoffs (eV) :', end='')
-        for e in self.ecut_i:
+        for e in ecut_i:
             p(' {0:.3f}'.format(e * Hartree), end='')
         p()
-        if self.truncation is not None:
-            p('Using %s Coulomb truncation' % self.truncation)
-        p()
+        p(self.coulomb.description())
+        self.context.print('')
 
         if self.filename and os.path.isfile(self.filename):
-            self.read()
-            self.world.barrier()
-
-        chi0calc = Chi0(
-            self.calc, frequencies=1j * Hartree * self.omega_w,
-            eta=0.0, intraband=False, hilbert=False,
-            txt='chi0.txt', timer=self.timer, world=self.world,
-            nblocks=self.nblocks,
-            ecut=ecutmax * Hartree)
+            energy_qi = self.read(ecut_i, self.filename)
+            self.context.print(
+                'Read %d q-points from file: %s\n' % (len(energy_qi)))
+
+            self.context.comm.barrier()
+
+        wd = FrequencyDescriptor(1j * self.omega_w)
+
+        pair = PairDensityCalculator(
+            self.gs,
+            context=self.context.with_txt('chi0.txt'),
+            nblocks=self.nblocks)
+
+        chi0calc = Chi0Calculator(wd=wd,
+                                  pair=pair,
+                                  eta=0.0,
+                                  intraband=False,
+                                  hilbert=False,
+                                  ecut=ecutmax * Hartree)
 
         self.blockcomm = chi0calc.blockcomm
 
-        gs = self.gs
-
-        if self.truncation == 'wigner-seitz':
-            self.wstc = WignerSeitzTruncatedCoulomb(gs.gd.cell_cv,
-                                                    gs.kd.N_c, self.fd)
-        else:
-            self.wstc = None
+        energy_qi = []
+        nq = len(energy_qi)
 
-        nq = len(self.energy_qi)
-
-        self.timer.start('RPA')
+        self.context.timer.start('RPA')
 
         for q_c in self.ibzq_qc[nq:]:
             if np.allclose(q_c, 0.0) and self.skip_gamma:
-                self.energy_qi.append(len(self.ecut_i) * [0.0])
-                self.write()
+                energy_qi.append(len(ecut_i) * [0.0])
+                self.write(energy_qi, ecut_i)
                 p('Not calculating E_c(q) at Gamma')
                 p()
                 continue
 
-            chi0_s = [chi0calc.create_chi0(q_c, extend_head=False)]
+            chi0_s = [chi0calc.create_chi0(q_c)]
             if spin:
-                chi0_s.append(chi0calc.create_chi0(q_c, extend_head=False))
+                chi0_s.append(chi0calc.create_chi0(q_c))
 
-            pd = chi0_s[0].pd
-            nG = pd.ngmax
+            qpd = chi0_s[0].qpd
+            nG = qpd.ngmax
 
             # First not completely filled band:
             m1 = chi0calc.nocc1
-            p('# %s  -  %s' % (len(self.energy_qi), ctime().split()[-2]))
+            p('# %s  -  %s' % (len(energy_qi), ctime().split()[-2]))
             p('q = [%1.3f %1.3f %1.3f]' % tuple(q_c))
 
             energy_i = []
-            for ecut in self.ecut_i:
+            for ecut in ecut_i:
                 if ecut == ecutmax:
                     # Nothing to cut away:
-                    cut_G = None
+                    gcut = GCut(None)
                     m2 = nbands or nG
                 else:
-                    cut_G = np.arange(nG)[pd.G2_qG[0] <= 2 * ecut]
-                    m2 = len(cut_G)
+                    gcut = GCut(np.arange(nG)[qpd.G2_qG[0] <= 2 * ecut])
+                    m2 = gcut.nG
 
-                p('E_cut = %d eV / Bands = %d:' % (ecut * Hartree, m2))
-                self.fd.flush()
+                p('E_cut = %d eV / Bands = %d:' % (ecut * Hartree, m2),
+                  end='\n', flush=True)
 
-                energy = self.calculate_q(chi0calc,
-                                          chi0_s,
-                                          m1, m2, cut_G)
+                energy = self.calculate_q(chi0calc, chi0_s, m1, m2, gcut)
 
                 energy_i.append(energy)
                 m1 = m2
 
                 a = 1 / chi0calc.kncomm.size
                 if ecut < ecutmax and a != 1.0:
                     # Chi0 will be summed again over chicomm, so we divide
                     # by its size:
                     for chi0 in chi0_s:
-                        chi0.chi0_wGG *= a
+                        chi0.chi0_WgG[:] *= a
                     # if chi0_swxvG is not None:
                     #     chi0_swxvG *= a
                     #     chi0_swvv *= a
 
-            self.energy_qi.append(energy_i)
-            self.write()
+            energy_qi.append(energy_i)
+            self.write(energy_qi, ecut_i)
             p()
 
-        e_i = np.dot(self.weight_q, np.array(self.energy_qi))
+        e_i = np.dot(self.weight_q, np.array(energy_qi))
         p('==========================================================')
         p()
         p('Total correlation energy:')
-        for e_cut, e in zip(self.ecut_i, e_i):
+        for e_cut, e in zip(ecut_i, e_i):
             p('%6.0f:   %6.4f eV' % (e_cut * Hartree, e * Hartree))
         p()
 
-        self.energy_qi = []  # important if another calculation is performed
-
         if len(e_i) > 1:
-            self.extrapolate(e_i)
+            self.extrapolate(e_i, ecut_i)
 
         p('Calculation completed at: ', ctime())
         p()
 
-        self.timer.stop('RPA')
-        self.timer.write(self.fd)
-        self.fd.flush()
+        self.context.timer.stop('RPA')
+        self.context.write_timer()
 
         return e_i * Hartree
 
     @timer('chi0(q)')
-    def calculate_q(self, chi0calc, chi0_s,
-                    m1, m2, cut_G):
+    def calculate_q_rpa(self, chi0calc, chi0_s,
+                        m1, m2, gcut):
         chi0 = chi0_s[0]
         chi0calc.update_chi0(chi0,
                              m1, m2, spins='all')
 
-        print('E_c(q) = ', end='', file=self.fd)
+        self.context.print('E_c(q) = ', end='', flush=False)
 
-        chi0_wGG = chi0.redistribute()
+        chi0_wGG = chi0.copy_array_with_distribution('wGG')
 
         kd = self.gs.kd
-        if not chi0.pd.kd.gamma:
-            e = self.calculate_energy(chi0.pd, chi0_wGG, cut_G)
-            print('%.3f eV' % (e * Hartree), file=self.fd)
-            self.fd.flush()
+        if not chi0.qpd.kd.gamma:
+            e = self.calculate_energy_rpa(chi0.qpd, chi0_wGG, gcut)
+            self.context.print('%.3f eV' % (e * Hartree))
         else:
-            from ase.dft import monkhorst_pack
-            # XXXX again a redundant implementation of the thing
-            # now in gpaw.response.gamma_int !
-            N = 4
-            N_c = np.array([N, N, N])
-            if self.truncation is not None:
-                N_c[kd.N_c == 1] = 1
-            q_qc = monkhorst_pack(N_c) / kd.N_c
-            q_qc *= 1.0e-6
-            U_scc = kd.symmetry.op_scc
-            q_qc = kd.get_ibz_q_points(q_qc, U_scc)[0]
-            weight_q = kd.q_weights
-            q_qv = 2 * np.pi * np.dot(q_qc, chi0.pd.gd.icell_cv)
-
-            nw = len(self.omega_w)
-            mynw = nw // self.nblocks
-            w1 = self.blockcomm.rank * mynw
-            w2 = w1 + mynw
-            a_qw = np.sum(np.dot(chi0.chi0_wvv[w1:w2], q_qv.T) * q_qv.T,
-                          axis=1).T
-            a0_qwG = np.dot(q_qv, chi0.chi0_wxvG[w1:w2, 0])
-            a1_qwG = np.dot(q_qv, chi0.chi0_wxvG[w1:w2, 1])
+            from gpaw.response.gamma_int import GammaIntegrator
+            from gpaw.response.pw_parallelization import Blocks1D
+
+            wblocks = Blocks1D(self.blockcomm, len(self.omega_w))
+            gamma_int = GammaIntegrator(
+                truncation=self.coulomb.truncation,
+                kd=kd,
+                qpd=chi0.qpd,
+                chi0_wvv=chi0.chi0_Wvv[wblocks.myslice],
+                chi0_wxvG=chi0.chi0_WxvG[wblocks.myslice])
 
             e = 0
-            for iq in range(len(q_qv)):
-                chi0_wGG[:, 0] = a0_qwG[iq]
-                chi0_wGG[:, :, 0] = a1_qwG[iq]
-                chi0_wGG[:, 0, 0] = a_qw[iq]
-                ev = self.calculate_energy(chi0.pd, chi0_wGG, cut_G,
-                                           q_v=q_qv[iq])
-                e += ev * weight_q[iq]
-            print('%.3f eV' % (e * Hartree), file=self.fd)
-            self.fd.flush()
+            for iqf in range(len(gamma_int.qf_qv)):
+                for iw in range(wblocks.nlocal):
+                    gamma_int.set_appendages(chi0_wGG[iw], iw, iqf)
+                ev = self.calculate_energy_rpa(chi0.qpd, chi0_wGG, gcut,
+                                               q_v=gamma_int.qf_qv[iqf])
+                e += ev * gamma_int.weight_q
+            self.context.print('%.3f eV' % (e * Hartree))
 
         return e
 
     @timer('Energy')
-    def calculate_energy(self, pd, chi0_wGG, cut_G, q_v=None):
+    def calculate_energy_rpa(self, qpd, chi0_wGG, gcut, q_v=None):
         """Evaluate correlation energy from chi0."""
 
-        sqrV_G = get_coulomb_kernel(pd, self.gs.kd.N_c, q_v=q_v,
-                                    truncation=self.truncation,
-                                    wstc=self.wstc)**0.5
-        if cut_G is not None:
-            sqrV_G = sqrV_G[cut_G]
-        nG = len(sqrV_G)
+        sqrtV_G = gcut.cut(self.coulomb.sqrtV(qpd, q_v))
+
+        nG = len(sqrtV_G)
 
         e_w = []
         for chi0_GG in chi0_wGG:
-            if cut_G is not None:
-                chi0_GG = chi0_GG.take(cut_G, 0).take(cut_G, 1)
+            chi0_GG = gcut.cut(chi0_GG, [0, 1])
 
-            e_GG = np.eye(nG) - chi0_GG * sqrV_G * sqrV_G[:, np.newaxis]
+            e_GG = np.eye(nG) - chi0_GG * sqrtV_G * sqrtV_G[:, np.newaxis]
             e = np.log(np.linalg.det(e_GG)) + nG - np.trace(e_GG)
             e_w.append(e.real)
 
+        self.E_w, energy = self.gather_energies(e_w)
+        return energy
+
+    def gather_energies(self, e_w):
         E_w = np.zeros_like(self.omega_w)
+        # XXX This requires all cores to the same number of w doesn't it?
         self.blockcomm.all_gather(np.array(e_w), E_w)
-        energy = np.dot(E_w, self.weight_w) / (2 * np.pi)
-        self.E_w = E_w
-        return energy
+        energy = E_w @ self.weight_w / (2 * np.pi)
+        return E_w, energy
 
-    def extrapolate(self, e_i):
-        print('Extrapolated energies:', file=self.fd)
+    def extrapolate(self, e_i, ecut_i):
+        self.context.print('Extrapolated energies:', flush=False)
         ex_i = []
         for i in range(len(e_i) - 1):
             e1, e2 = e_i[i:i + 2]
-            x1, x2 = self.ecut_i[i:i + 2]**-1.5
+            x1, x2 = ecut_i[i:i + 2]**-1.5
             ex = (e1 * x2 - e2 * x1) / (x2 - x1)
             ex_i.append(ex)
 
-            print('  %4.0f -%4.0f:  %5.3f eV' % (self.ecut_i[i] * Hartree,
-                                                 self.ecut_i[i + 1] * Hartree,
-                                                 ex * Hartree),
-                  file=self.fd)
-        print(file=self.fd)
-        self.fd.flush()
+            self.context.print('  %4.0f -%4.0f:  %5.3f eV' %
+                               (ecut_i[i] * Hartree, ecut_i[i + 1]
+                                * Hartree, ex * Hartree), flush=False)
+        self.context.print('')
 
         return e_i * Hartree
 
+
+def get_gauss_legendre_points(nw=16, frequency_max=800.0, frequency_scale=2.0):
+    y_w, weights_w = p_roots(nw)
+    y_w = y_w.real
+    ys = 0.5 - 0.5 * y_w
+    ys = ys[::-1]
+    w = (-np.log(1 - ys))**frequency_scale
+    w *= frequency_max / w[-1]
+    alpha = (-np.log(1 - ys[-1]))**frequency_scale / frequency_max
+    transform = (-np.log(1 - ys))**(frequency_scale - 1) \
+        / (1 - ys) * frequency_scale / alpha
+    return w, weights_w * transform / 2
+
+
+class RPACorrelation(RPACalculator):
+    def __init__(self, calc, xc='RPA',
+                 nlambda=None,
+                 nfrequencies=16, frequency_max=800.0, frequency_scale=2.0,
+                 frequencies=None, weights=None,
+                 world=mpi.world,
+                 txt='-',
+                 truncation: str | None = None,
+                 **kwargs):
+        """Creates the RPACorrelation object
+
+        calc: str or calculator object
+            The string should refer to the .gpw file contaning KS orbitals
+        xc: str
+            Exchange-correlation kernel. This is only different from RPA when
+            this object is constructed from a different module - e.g. fxc.py
+        filename: str
+            txt output
+        skip_gamme: bool
+            If True, skip q = [0,0,0] from the calculation
+        qsym: bool
+            Use symmetry to reduce q-points
+        nlambda: int
+            Number of lambda points. Only used for numerical coupling
+            constant integration involved when called from fxc.py
+        nfrequencies: int
+            Number of frequency points used in the Gauss-Legendre integration
+        frequency_max: float
+            Largest frequency point in Gauss-Legendre integration
+        frequency_scale: float
+            Determines density of frequency points at low frequencies. A slight
+            increase to e.g. 2.5 or 3.0 improves convergence wth respect to
+            frequency points for metals
+        frequencies: list
+            List of frequancies for user-specified frequency integration
+        weights: list
+            list of weights (integration measure) for a user specified
+            frequency grid. Must be specified and have the same length as
+            frequencies if frequencies is not None
+        truncation: str or None
+            Coulomb truncation scheme. Can be None, '0D' or '2D'.  If None
+            and the system is a molecule then '0D' will be used.
+        world: communicator
+        nblocks: int
+            Number of parallelization blocks. Frequency parallelization
+            can be specified by setting nblocks=nfrequencies and is useful
+            for memory consuming calculations
+        txt: str
+            txt file for saving and loading contributions to the correlation
+            energy from different q-points
+        """
+        gs, context = get_gs_and_context(calc=calc, txt=txt, world=world,
+                                         timer=None)
+
+        if frequencies is None:
+            frequencies, weights = get_gauss_legendre_points(nfrequencies,
+                                                             frequency_max,
+                                                             frequency_scale)
+            user_spec = False
+        else:
+            assert weights is not None
+            user_spec = True
+
+        if truncation is None and not gs.pbc.any():
+            truncation = '0D'
+
+        super().__init__(gs=gs, context=context,
+                         frequencies=frequencies, weights=weights,
+                         truncation=truncation,
+                         **kwargs)
+
+        self.print_initialization(xc, frequency_scale, nlambda, user_spec)
+
     def print_initialization(self, xc, frequency_scale, nlambda, user_spec):
-        p = functools.partial(print, file=self.fd)
+        p = functools.partial(self.context.print, flush=False)
         p('----------------------------------------------------------')
         p('Non-self-consistent %s correlation energy' % xc)
         p('----------------------------------------------------------')
         p('Started at:  ', ctime())
         p()
         p('Atoms                          :',
           self.gs.atoms.get_chemical_formula(mode='hill'))
@@ -443,46 +492,12 @@
             p('    Highest frequency point at %5.1f eV and B=%1.1f' %
               (self.omega_w[-1] * Hartree, frequency_scale))
         else:
             p('    User specified frequency integration with',
               len(self.omega_w), 'frequency points')
         p()
         p('Parallelization')
-        p('    Total number of CPUs          : % s' % self.world.size)
+        p('    Total number of CPUs          : % s' % self.context.comm.size)
         p('    G-vector decomposition        : % s' % self.nblocks)
         p('    K-point/band decomposition    : % s' %
-          (self.world.size // self.nblocks))
-        p()
-
-
-def get_gauss_legendre_points(nw=16, frequency_max=800.0, frequency_scale=2.0):
-    y_w, weights_w = p_roots(nw)
-    y_w = y_w.real
-    ys = 0.5 - 0.5 * y_w
-    ys = ys[::-1]
-    w = (-np.log(1 - ys))**frequency_scale
-    w *= frequency_max / w[-1]
-    alpha = (-np.log(1 - ys[-1]))**frequency_scale / frequency_max
-    transform = (-np.log(1 - ys))**(frequency_scale - 1) \
-        / (1 - ys) * frequency_scale / alpha
-    return w, weights_w * transform / 2
-
-
-class CLICommand:
-    """Run RPA-correlation calculation."""
-
-    @staticmethod
-    def add_arguments(parser):
-        add = parser.add_argument
-        add('gpw', metavar='gpw-file')
-        add('-e', '--cut-off', type=float, default=100, metavar='ECUT',
-            help='Plane-wave cut off energy (eV) for polarization function.')
-        add('-b', '--blocks', type=int, default=1, metavar='N',
-            help='Split polarization matrix in N blocks.')
-
-    @staticmethod
-    def run(args):
-        assert args.gpw.endswith('.gpw')
-        rpa = RPACorrelation(args.gpw,
-                             txt=args.gpw[:-3] + 'rpa.txt',
-                             nblocks=args.blocks)
-        rpa.calculate([args.cut_off])
+          (self.context.comm.size // self.nblocks))
+        self.context.print('')
```

### Comparing `gpaw-22.8.0/gpaw/xc/sic.py` & `gpaw-23.6.0/gpaw/xc/sic.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/xc/tb09.py` & `gpaw-23.6.0/gpaw/xc/tb09.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/xc/tools.py` & `gpaw-23.6.0/gpaw/xc/tools.py`

 * *Files 25% similar despite different names*

```diff
@@ -1,17 +1,20 @@
 import numpy as np
-from ase.units import Hartree
+from ase.units import Ha
 
 from gpaw.xc import XC
 from gpaw.utilities import unpack
 
 
-def vxc(gs, xc=None, coredensity=True):
+def vxc(gs, xc=None, coredensity=True, n1=0, n2=0):
     """Calculate XC-contribution to eigenvalues."""
 
+    if n2 <= 0:
+        n2 += gs.bd.nbands
+
     ham = gs.hamiltonian
     dens = gs.density
 
     if xc is None:
         xc = ham.xc
     elif isinstance(xc, str):
         xc = XC(xc)
@@ -31,34 +34,45 @@
     if thisisatest:
         vxct_sG[:] = 1
 
     # ... and PAW corrections:
     dvxc_asii = {}
     for a, D_sp in dens.D_asp.items():
         dvxc_sp = np.zeros_like(D_sp)
-        xc.calculate_paw_correction(gs.setups[a], D_sp, dvxc_sp, a=a,
+
+        pawdata = gs.pawdatasets[a]
+        if pawdata.hubbard_u is not None:
+            _, dHU_sp = pawdata.hubbard_u.calculate(pawdata, D_sp)
+            dvxc_sp += dHU_sp
+        xc.calculate_paw_correction(pawdata, D_sp, dvxc_sp, a=a,
                                     addcoredensity=coredensity)
+
         dvxc_asii[a] = [unpack(dvxc_p) for dvxc_p in dvxc_sp]
         if thisisatest:
-            dvxc_asii[a] = [gs.setups[a].dO_ii]
+            dvxc_asii[a] = [pawdata.dO_ii]
 
     vxc_un = np.empty((gs.kd.mynk * gs.nspins, gs.bd.mynbands))
     for u, vxc_n in enumerate(vxc_un):
         kpt = gs.kpt_u[u]
         vxct_G = vxct_sG[kpt.s]
         for n in range(gs.bd.mynbands):
-            psit_G = gs.get_wave_function_array(u, n)
-            vxc_n[n] = gs.gd.integrate((psit_G * psit_G.conj()).real,
-                                       vxct_G, global_integral=False)
+            if n1 <= n + gs.bd.beg < n2:
+                psit_G = gs.get_wave_function_array(u, n)
+                vxc_n[n] = gs.gd.integrate((psit_G * psit_G.conj()).real,
+                                           vxct_G, global_integral=False)
 
         for a, dvxc_sii in dvxc_asii.items():
-            P_ni = kpt.P_ani[a]
-            vxc_n += (np.dot(P_ni, dvxc_sii[kpt.s]) *
-                      P_ni.conj()).sum(1).real
+            m1 = max(n1, gs.bd.beg) - gs.bd.beg
+            m2 = min(n2, gs.bd.end) - gs.bd.beg
+            if m1 < m2:
+                P_ni = kpt.P_ani[a][m1:m2]
+                vxc_n[m1:m2] += ((P_ni @ dvxc_sii[kpt.s]) *
+                                 P_ni.conj()).sum(1).real
 
     gs.gd.comm.sum(vxc_un)
     vxc_skn = gs.kd.collect(vxc_un, broadcast=True)
 
     if xc.orbital_dependent:
         vxc_skn += xc.exx_skn
 
-    return gs.bd.collect(vxc_skn.T.copy(), broadcast=True).T * Hartree
+    vxc_skn = gs.bd.collect(vxc_skn.T.copy(), broadcast=True).T
+    return vxc_skn[:, :, n1:n2] * Ha
```

### Comparing `gpaw-22.8.0/gpaw/xc/vdw.py` & `gpaw-23.6.0/gpaw/xc/vdw.py`

 * *Files 0% similar despite different names*

```diff
@@ -573,16 +573,15 @@
             self.j_k = None
 
     def construct_cubic_splines(self):
         """Construc interpolating splines for q0.
 
         The recipe is from
 
-          http://en.wikipedia.org/wiki/Spline_(mathematics)
-        """
+          http://en.wikipedia.org/wiki/Spline_(mathematics) """
 
         n = self.Nalpha
         lambd = self.lambd
         q1 = self.q0cut * (lambd - 1) / (lambd**(n - 1) - 1)
         q = q1 * (lambd**np.arange(n) - 1) / (lambd - 1)
 
         if self.verbose:
```

### Comparing `gpaw-22.8.0/gpaw/yml.py` & `gpaw-23.6.0/gpaw/yml.py`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/gpaw/zero_field_splitting.py` & `gpaw-23.6.0/gpaw/zero_field_splitting.py`

 * *Files 2% similar despite different names*

```diff
@@ -83,17 +83,17 @@
     def from_calc(calc: GPAW, spin: int, n1: int, n2: int) -> 'WaveFunctions':
         """Create WaveFunctions object GPAW calculation."""
         kpt = calc.wfs.kpt_qs[0][spin]
         gd = calc.wfs.gd.new_descriptor(pbc_c=np.ones(3, bool),
                                         comm=serial_comm)
         psit_nR = gd.empty(n2 - n1)
         for band, psit_R in enumerate(psit_nR):
-            psit_R[:] = calc.get_pseudo_wave_function(band + n1,
-                                                      spin=spin,
-                                                      pad=True) * Bohr**1.5
+            psit_R[:] = calc.get_pseudo_wave_function(
+                band + n1,
+                spin=spin) * Bohr**1.5
 
         return WaveFunctions(psit_nR,
                              kpt.projections.as_dict_on_master(n1, n2),
                              spin,
                              calc.setups,
                              gd=gd)
 
@@ -115,15 +115,15 @@
     """Compute dipole coupling."""
     pd = wf1.pd
     setups = wf1.setups
     N2 = len(wf2)
 
     G_G = pd.G2_qG[0]**0.5
     G_G[0] = 1.0
-    G_Gv = pd.get_reciprocal_vectors() / G_G[:, np.newaxis]
+    G_Gv = pd.get_reciprocal_vectors(add_q=False) / G_G[:, np.newaxis]
 
     n_sG = pd.zeros(2)
     for n_G, wf in zip(n_sG, [wf1, wf2]):
         D_aii = {}
         Q_aL = {}
         for a, P_ni in wf.P_ani.items():
             D_ii = np.einsum('ni, nj -> ij', P_ni, P_ni)
```

### Comparing `gpaw-22.8.0/gpaw.egg-info/PKG-INFO` & `gpaw-23.6.0/gpaw.egg-info/PKG-INFO`

 * *Files 20% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: gpaw
-Version: 22.8.0
+Version: 23.6.0
 Summary: GPAW: DFT and beyond within the projector-augmented wave method
 Home-page: https://wiki.fysik.dtu.dk/gpaw
 Maintainer: GPAW-community
 Maintainer-email: gpaw-users@listserv.fysik.dtu.dk
 License: GPLv3+
 Platform: unix
 Classifier: Development Status :: 6 - Mature
@@ -12,16 +12,16 @@
 Classifier: Operating System :: OS Independent
 Classifier: Programming Language :: Python :: 3
 Classifier: Programming Language :: Python :: 3.7
 Classifier: Programming Language :: Python :: 3.8
 Classifier: Programming Language :: Python :: 3.9
 Classifier: Programming Language :: Python :: 3.10
 Classifier: Topic :: Scientific/Engineering :: Physics
-Provides-Extra: devel
 Provides-Extra: docs
+Provides-Extra: devel
 License-File: LICENSE
 
 .. image:: https://badge.fury.io/py/gpaw.svg
     :target: https://pypi.org/project/gpaw/
 
 Coverage_
 
@@ -36,24 +36,28 @@
 Webpage: http://wiki.fysik.dtu.dk/gpaw
 
 
 Requirements
 ------------
 
 * Python_ 3.7 or later
-* ASE_ (atomic simulation environment)
-* NumPy_ (base N-dimensional array package)
-* SciPy_ (library for scientific computing)
-* LibXC
-* BLAS
-
-Optional (highly recommended):
+* ASE_
+* NumPy_
+* SciPy_
+* LibXC_
+* A C compiler
+* A BLAS_ library
+
+Optional (highly recommended for increased performance):
+
+* A MPI_ library (required for parallel calculations)
+* BLACS_ and ScaLAPACK_ libraries
+* FFTW_
 
-* MPI
-* ScaLAPACK
+See `Release notes <releasenotes_>`_ for version requirements.
 
 
 Installation
 ------------
 
 Do this::
 
@@ -118,15 +122,20 @@
 look at the GPAW exercises_ and tutorials_.
 
 
 .. _Python: http://www.python.org/
 .. _ASE: http://wiki.fysik.dtu.dk/ase
 .. _NumPy: http://docs.scipy.org/doc/numpy/reference/
 .. _SciPy: http://docs.scipy.org/doc/scipy/reference/
+.. _LibXC: http://www.tddft.org/programs/libxc/
+.. _MPI: http://www.mpi-forum.org/
+.. _BLAS: http://www.netlib.org/blas/
+.. _FFTW: http://www.fftw.org/
+.. _BLACS: http://www.netlib.org/blacs/
+.. _ScaLAPACK: http://www.netlib.org/scalapack/
 .. _gpaw-users: https://listserv.fysik.dtu.dk/mailman/listinfo/gpaw-users
 .. _Matrix: https://matrix.io/#/#gpaw:matrix.org
 .. _gitlab-issues: https://gitlab.com/gpaw/gpaw/issues
 .. _exercises: https://wiki.fysik.dtu.dk/gpaw/exercises/exercises.html
 .. _tutorials: https://wiki.fysik.dtu.dk/gpaw/tutorials/tutorials.html
 .. _Coverage: https://wiki.fysik.dtu.dk/gpaw/htmlcov/index.html
-
-
+.. _releasenotes: https://wiki.fysik.dtu.dk/gpaw/releasenotes.html
```

### Comparing `gpaw-22.8.0/gpaw.egg-info/SOURCES.txt` & `gpaw-23.6.0/gpaw.egg-info/SOURCES.txt`

 * *Files 3% similar despite different names*

```diff
@@ -3,29 +3,32 @@
 LICENSE
 MANIFEST.in
 README.rst
 config.py
 setup.cfg
 setup.py
 siteconfig_example.py
-c/_gpaw.c
+c/_gpaw.h
+c/_gpaw_so.c
+c/array.h
 c/bc.c
 c/bc.h
 c/blacs.c
 c/blas.c
 c/constraints.c
 c/elpa.c
 c/extensions.h
 c/f2c.h
 c/fd_preconditioner.c
 c/fftw.c
 c/lcao.c
 c/lfc.c
 c/lfc.h
 c/lfc2.c
+c/main.c
 c/mpi.c
 c/mympi.h
 c/operators.c
 c/operators.h
 c/plane_wave.c
 c/plt.c
 c/point_charges.c
@@ -129,14 +132,16 @@
 gpaw/pair_overlap.py
 gpaw/poisson.py
 gpaw/poisson_extravacuum.py
 gpaw/poisson_moment.py
 gpaw/preconditioner.py
 gpaw/projections.py
 gpaw/pseudopotential.py
+gpaw/py.typed
+gpaw/quiz.py
 gpaw/rotation.py
 gpaw/scf.py
 gpaw/setup.py
 gpaw/setup_data.py
 gpaw/spherical_harmonics.py
 gpaw/spinorbit.py
 gpaw/spline.py
@@ -242,48 +247,66 @@
 gpaw/eigensolvers/cg.py
 gpaw/eigensolvers/davidson.py
 gpaw/eigensolvers/diagonalizerbackend.py
 gpaw/eigensolvers/direct.py
 gpaw/eigensolvers/eigensolver.py
 gpaw/eigensolvers/rmmdiis.py
 gpaw/elph/__init__.py
+gpaw/elph/displacements.py
 gpaw/elph/electronphonon.py
+gpaw/elph/filter.py
+gpaw/elph/gmatrix.py
+gpaw/elph/raman_calculator.py
+gpaw/elph/raman_data.py
+gpaw/elph/supercell.py
 gpaw/fdtd/__init__.py
 gpaw/fdtd/poisson_fdtd.py
 gpaw/fdtd/polarizable_material.py
 gpaw/fdtd/potential_couplers.py
+gpaw/gpu/__init__.py
+gpaw/gpu/kernels.py
+gpaw/gpu/mpi.py
+gpaw/gpu/cpupy/__init__.py
+gpaw/gpu/cpupy/cublas.py
+gpaw/gpu/cpupy/fft.py
+gpaw/gpu/cpupy/linalg.py
+gpaw/gpu/cpupyx/__init__.py
+gpaw/gpu/cpupyx/fft.py
+gpaw/gpu/cpupyx/scipy.py
 gpaw/hybrids/__init__.py
 gpaw/hybrids/coulomb.py
 gpaw/hybrids/eigenvalues.py
 gpaw/hybrids/energy.py
 gpaw/hybrids/forces.py
 gpaw/hybrids/kpts.py
 gpaw/hybrids/paw.py
 gpaw/hybrids/scf.py
 gpaw/hybrids/symmetry.py
 gpaw/hybrids/wrapper.py
+gpaw/hybrids/wstc.py
 gpaw/inducedfield/__init__.py
 gpaw/inducedfield/inducedfield_base.py
 gpaw/inducedfield/inducedfield_fdtd.py
 gpaw/inducedfield/inducedfield_lrtddft.py
 gpaw/inducedfield/inducedfield_tddft.py
 gpaw/io/__init__.py
 gpaw/io/fmf.py
 gpaw/io/logger.py
 gpaw/io/old.py
 gpaw/io/tar.py
 gpaw/lcao/__init__.py
 gpaw/lcao/analyse_basis.py
 gpaw/lcao/atomic_correction.py
 gpaw/lcao/bsse.py
+gpaw/lcao/dipoletransition.py
 gpaw/lcao/eigensolver.py
 gpaw/lcao/el_ph.py
 gpaw/lcao/generate_extended.py
 gpaw/lcao/generate_ngto_augmented.py
-gpaw/lcao/newoverlap.py
+gpaw/lcao/local_orbitals.py
 gpaw/lcao/overlap.py
 gpaw/lcao/projected_wannier.py
 gpaw/lcao/pwf2.py
 gpaw/lcao/scissors.py
 gpaw/lcao/tci.py
 gpaw/lcao/tightbinding.py
 gpaw/lcao/tools.py
@@ -353,23 +376,25 @@
 gpaw/new/xc.py
 gpaw/new/fd/__init__.py
 gpaw/new/fd/builder.py
 gpaw/new/fd/pot_calc.py
 gpaw/new/lcao/__init__.py
 gpaw/new/lcao/builder.py
 gpaw/new/lcao/eigensolver.py
+gpaw/new/lcao/forces.py
 gpaw/new/lcao/hamiltonian.py
 gpaw/new/lcao/hybrids.py
 gpaw/new/lcao/wave_functions.py
 gpaw/new/pw/__init__.py
 gpaw/new/pw/builder.py
 gpaw/new/pw/fulldiag.py
 gpaw/new/pw/hamiltonian.py
 gpaw/new/pw/poisson.py
 gpaw/new/pw/pot_calc.py
+gpaw/new/pw/stress.py
 gpaw/new/pwfd/__init__.py
 gpaw/new/pwfd/builder.py
 gpaw/new/pwfd/davidson.py
 gpaw/new/pwfd/wave_functions.py
 gpaw/new/tb/__init__.py
 gpaw/new/tb/builder.py
 gpaw/nlopt/__init__.py
@@ -393,66 +418,70 @@
 gpaw/pw/__init__.py
 gpaw/pw/density.py
 gpaw/pw/descriptor.py
 gpaw/pw/hamiltonian.py
 gpaw/pw/lfc.py
 gpaw/pw/poisson.py
 gpaw/raman/__init__.py
-gpaw/raman/dipoletransition.py
-gpaw/raman/elph.py
 gpaw/raman/raman.py
 gpaw/response/__init__.py
 gpaw/response/bse.py
 gpaw/response/chi0.py
 gpaw/response/chi0_data.py
 gpaw/response/chiks.py
 gpaw/response/context.py
+gpaw/response/coulomb_kernels.py
+gpaw/response/density_kernels.py
 gpaw/response/df.py
+gpaw/response/drude.py
+gpaw/response/dyson.py
 gpaw/response/frequencies.py
-gpaw/response/fxc.py
-gpaw/response/fxckernel_calc.py
+gpaw/response/fxc_kernels.py
 gpaw/response/g0w0.py
+gpaw/response/g0w0_kernels.py
 gpaw/response/gamma_int.py
+gpaw/response/goldstone.py
 gpaw/response/groundstate.py
 gpaw/response/gw_bands.py
-gpaw/response/gwqeh.py
 gpaw/response/heisenberg.py
 gpaw/response/hilbert.py
+gpaw/response/ibz2bz.py
 gpaw/response/integrators.py
-gpaw/response/kernels.py
-gpaw/response/kslrf.py
+gpaw/response/jdos.py
 gpaw/response/kspair.py
-gpaw/response/kxc.py
-gpaw/response/math_func.py
+gpaw/response/localft.py
+gpaw/response/matrix_elements.py
 gpaw/response/mft.py
 gpaw/response/pair.py
+gpaw/response/pair_functions.py
+gpaw/response/pair_integrator.py
+gpaw/response/pair_transitions.py
 gpaw/response/paw.py
 gpaw/response/pw_parallelization.py
 gpaw/response/q0_correction.py
 gpaw/response/qeh.py
+gpaw/response/screened_interaction.py
 gpaw/response/site_kernels.py
 gpaw/response/susceptibility.py
 gpaw/response/symmetry.py
-gpaw/response/symmetry_ops.py
 gpaw/response/temp.py
-gpaw/response/tms.py
 gpaw/response/tool.py
 gpaw/response/wgg.py
-gpaw/response/wstc.py
 gpaw/solvation/__init__.py
 gpaw/solvation/calculator.py
 gpaw/solvation/cavity.py
 gpaw/solvation/dielectric.py
 gpaw/solvation/gridmem.py
 gpaw/solvation/hamiltonian.py
 gpaw/solvation/interactions.py
 gpaw/solvation/poisson.py
 gpaw/solvation/sjm.py
 gpaw/sphere/__init__.py
 gpaw/sphere/lebedev.py
+gpaw/sphere/rshe.py
 gpaw/tddft/__init__.py
 gpaw/tddft/abc.py
 gpaw/tddft/ehrenfest.py
 gpaw/tddft/folding.py
 gpaw/tddft/laser.py
 gpaw/tddft/propagators.py
 gpaw/tddft/spectrum.py
@@ -462,41 +491,43 @@
 gpaw/tddft/solvers/__init__.py
 gpaw/tddft/solvers/base.py
 gpaw/tddft/solvers/bicgstab.py
 gpaw/tddft/solvers/cscg.py
 gpaw/test/__init__.py
 gpaw/test/conftest.py
 gpaw/test/crontab.py
-gpaw/test/dipole_me_test.py
-gpaw/test/dipole_test.py
-gpaw/test/fermilevel_test.py
 gpaw/test/fuzz.py
-gpaw/test/fuzz_test.py
 gpaw/test/test_AA_enthalpy.py
 gpaw/test/test_Gauss.py
+gpaw/test/test_ae.py
 gpaw/test/test_aeatom.py
 gpaw/test/test_aedensity.py
 gpaw/test/test_atomic_el_pot.py
 gpaw/test/test_atoms_mismatch.py
 gpaw/test/test_atoms_too_close.py
 gpaw/test/test_broadcast_imports.py
 gpaw/test/test_broydenmixer.py
 gpaw/test/test_cluster.py
 gpaw/test/test_complete.py
 gpaw/test/test_complex.py
 gpaw/test/test_coreeig.py
 gpaw/test/test_coulomb.py
 gpaw/test/test_diagonalizer_backend.py
 gpaw/test/test_dipole.py
+gpaw/test/test_dipole_me.py
+gpaw/test/test_dipole_new.py
 gpaw/test/test_ds_beta.py
+gpaw/test/test_fermilevel.py
 gpaw/test/test_fermisplit.py
 gpaw/test/test_fixdensity.py
+gpaw/test/test_fixdensity_mgga.py
 gpaw/test/test_fixmom.py
 gpaw/test/test_fixocc.py
 gpaw/test/test_force_as_stop.py
+gpaw/test/test_fuzz.py
 gpaw/test/test_gauss_func.py
 gpaw/test/test_gauss_wave.py
 gpaw/test/test_ibzqpt.py
 gpaw/test/test_inducedfield_lrtddft.py
 gpaw/test/test_inducedfield_td.py
 gpaw/test/test_initial_occs.py
 gpaw/test/test_jellium.py
@@ -504,29 +535,31 @@
 gpaw/test/test_kpt_refine.py
 gpaw/test/test_libelpa.py
 gpaw/test/test_mpicomm.py
 gpaw/test/test_muffintinpot.py
 gpaw/test/test_multipoleH2O.py
 gpaw/test/test_multipoletest.py
 gpaw/test/test_negative_eigerror.py
+gpaw/test/test_new_calculator.py
 gpaw/test/test_occupations.py
 gpaw/test/test_overlap.py
 gpaw/test/test_potential.py
 gpaw/test/test_rattle.py
 gpaw/test/test_reuse_wfs.py
 gpaw/test/test_reuse_wfs_celldisp.py
 gpaw/test/test_scf_criteria.py
 gpaw/test/test_spectrum.py
+gpaw/test/test_spherical_harmonics.py
 gpaw/test/test_spinorbit_Kr.py
 gpaw/test/test_stdout.py
 gpaw/test/test_timelimit.py
 gpaw/test/test_timing.py
+gpaw/test/test_too_close.py
 gpaw/test/test_vdwradii.py
 gpaw/test/test_watermodel.py
-gpaw/test/too_close_test.py
 gpaw/test/ase_features/__init__.py
 gpaw/test/ase_features/autoneb.py
 gpaw/test/ase_features/test_ase3k.py
 gpaw/test/ase_features/test_ase3k_version.py
 gpaw/test/big/__init__.py
 gpaw/test/big/dcdft/__init__.py
 gpaw/test/big/dcdft/analyse.py
@@ -543,35 +576,44 @@
 gpaw/test/big/g2_1/pbe_gpaw_nrel_plot.py
 gpaw/test/big/g2_1/submit.agts.py
 gpaw/test/big/hsk/__init__.py
 gpaw/test/big/hsk/hsk.py
 gpaw/test/big/kpb/check.py
 gpaw/test/big/kpb/molecules.py
 gpaw/test/big/kpb/submit.agts.py
-gpaw/test/big/scf/__init__.py
-gpaw/test/big/scf/analyse.py
 gpaw/test/big/setups/__init__.py
+gpaw/test/big/test_systems/__init__.py
+gpaw/test/big/test_systems/agts.py
+gpaw/test/big/test_systems/create.py
 gpaw/test/corehole/__init__.py
 gpaw/test/corehole/si_nonortho.py
 gpaw/test/corehole/test_h2o.py
 gpaw/test/corehole/test_h2o_dks.py
 gpaw/test/corehole/test_h2o_recursion.py
+gpaw/test/corehole/test_li2.py
 gpaw/test/corehole/test_si.py
 gpaw/test/dscf/__init__.py
 gpaw/test/dscf/dscf_forces.py
 gpaw/test/dscf/test_dscf_lcao.py
 gpaw/test/eigen/__init__.py
 gpaw/test/eigen/test_blocked_rmm_diis.py
 gpaw/test/eigen/test_cg.py
 gpaw/test/eigen/test_cg2.py
 gpaw/test/eigen/test_davidson.py
 gpaw/test/eigen/test_keep_htpsit.py
 gpaw/test/elph/__init__.py
+gpaw/test/elph/conftest.py
+gpaw/test/elph/test_displacements.py
 gpaw/test/elph/test_electronphonon.py
 gpaw/test/elph/test_elph_li.py
+gpaw/test/elph/test_gmatrix.py
+gpaw/test/elph/test_gradient.py
+gpaw/test/elph/test_ramancalculator.py
+gpaw/test/elph/test_resonant_term.py
+gpaw/test/elph/test_supercell.py
 gpaw/test/ext_potential/__init__.py
 gpaw/test/ext_potential/stark_shift.py
 gpaw/test/ext_potential/test_b_field.py
 gpaw/test/ext_potential/test_collection.py
 gpaw/test/ext_potential/test_constant_e_field.py
 gpaw/test/ext_potential/test_external.py
 gpaw/test/ext_potential/test_external_pw.py
@@ -607,15 +649,15 @@
 gpaw/test/fileio/test_parallel.py
 gpaw/test/fileio/test_read_old_gpw.py
 gpaw/test/fileio/test_refine.py
 gpaw/test/fileio/test_restart.py
 gpaw/test/fileio/test_restart_density.py
 gpaw/test/fileio/test_wfs_auto.py
 gpaw/test/fileio/test_wfs_io.py
-gpaw/test/fileio/yaml_test.py
+gpaw/test/fileio/test_yaml.py
 gpaw/test/generic/__init__.py
 gpaw/test/generic/colinear.py
 gpaw/test/generic/test_2Al.py
 gpaw/test/generic/test_8Si.py
 gpaw/test/generic/test_Cl_minus.py
 gpaw/test/generic/test_Cu.py
 gpaw/test/generic/test_H_force.py
@@ -628,30 +670,38 @@
 gpaw/test/generic/test_mixer.py
 gpaw/test/generic/test_move_across_cell.py
 gpaw/test/generic/test_proton.py
 gpaw/test/generic/test_relax.py
 gpaw/test/generic/test_si.py
 gpaw/test/generic/test_si_primitive.py
 gpaw/test/gllb/__init__.py
-gpaw/test/gllb/gllbghost_test.py
 gpaw/test/gllb/test_atomic.py
 gpaw/test/gllb/test_diamond.py
+gpaw/test/gllb/test_gllbghost.py
 gpaw/test/gllb/test_metallic.py
 gpaw/test/gllb/test_ne.py
 gpaw/test/gllb/test_ne_disc.py
 gpaw/test/gllb/test_restart_eigenvalues.py
 gpaw/test/gllb/test_spin.py
 gpaw/test/gllb/test_variants.py
+gpaw/test/gpu/__init__.py
+gpaw/test/gpu/test_cpupy.py
+gpaw/test/gpu/test_matrix.py
+gpaw/test/gpu/test_mpi.py
+gpaw/test/gpu/test_precondition.py
+gpaw/test/gpu/test_pw.py
 gpaw/test/lcao/__init__.py
 gpaw/test/lcao/restart.py
 gpaw/test/lcao/test_analyse_basis.py
 gpaw/test/lcao/test_atomic_corrections.py
 gpaw/test/lcao/test_bsse.py
 gpaw/test/lcao/test_bulk.py
 gpaw/test/lcao/test_density.py
+gpaw/test/lcao/test_dipole_transition.py
+gpaw/test/lcao/test_dipole_transition2.py
 gpaw/test/lcao/test_dos.py
 gpaw/test/lcao/test_fd2lcao_restart.py
 gpaw/test/lcao/test_fftmixer.py
 gpaw/test/lcao/test_force.py
 gpaw/test/lcao/test_generate_ngto.py
 gpaw/test/lcao/test_gllb_si.py
 gpaw/test/lcao/test_h2o.py
@@ -660,14 +710,15 @@
 gpaw/test/lcao/test_lcao_complicated.py
 gpaw/test/lcao/test_lcao_elpa.py
 gpaw/test/lcao/test_lcao_elpa_kpts.py
 gpaw/test/lcao/test_lcao_hamiltonian.py
 gpaw/test/lcao/test_lcao_parallel.py
 gpaw/test/lcao/test_lcao_parallel_kpt.py
 gpaw/test/lcao/test_lcao_projections.py
+gpaw/test/lcao/test_local_orbitals.py
 gpaw/test/lcao/test_pair_and_coulomb.py
 gpaw/test/lcao/test_scissors.py
 gpaw/test/lcaotddft/__init__.py
 gpaw/test/lcaotddft/demo_tddft.py
 gpaw/test/lcaotddft/test_circular_dichroism.py
 gpaw/test/lcaotddft/test_fxc_is_xc.py
 gpaw/test/lcaotddft/test_fxc_rpa.py
@@ -711,40 +762,42 @@
 gpaw/test/lrtddft/test_pes.py
 gpaw/test/lrtddft/test_placzek_profeta_albrecht.py
 gpaw/test/lrtddft/test_rraman.py
 gpaw/test/lrtddft/test_select.py
 gpaw/test/lrtddft2/__init__.py
 gpaw/test/lrtddft2/test_Al2.py
 gpaw/test/lrtddft2/test_H2O-lcao.py
+gpaw/test/lrtddft2/test_parameters.py
 gpaw/test/maths/__init__.py
 gpaw/test/maths/test_fftw.py
 gpaw/test/maths/test_fsbt.py
 gpaw/test/mgga/__init__.py
 gpaw/test/mgga/test_mgga_restart.py
 gpaw/test/mgga/test_mgga_sc.py
 gpaw/test/mgga/test_nsc_MGGA.py
+gpaw/test/mgga/test_symm.py
 gpaw/test/mom/__init__.py
 gpaw/test/mom/test_mom_fd_energy.py
 gpaw/test/mom/test_mom_lcao_forces.py
 gpaw/test/mom/test_mom_lcao_smearing.py
 gpaw/test/noncollinear/__init__.py
-gpaw/test/noncollinear/o2_test.py
-gpaw/test/noncollinear/rad_pot_test.py
-gpaw/test/noncollinear/soc_test.py
+gpaw/test/noncollinear/test_o2.py
+gpaw/test/noncollinear/test_rad_pot.py
+gpaw/test/noncollinear/test_soc.py
 gpaw/test/ofdft/__init__.py
 gpaw/test/ofdft/test_ofdft.py
 gpaw/test/ofdft/test_ofdft_pbc.py
 gpaw/test/ofdft/test_ofdft_scale.py
 gpaw/test/parallel/__init__.py
-gpaw/test/parallel/davidson_scalapack_test.py
 gpaw/test/parallel/scalapack_pdlasrt_hang.py
 gpaw/test/parallel/test_arraydict_redist.py
 gpaw/test/parallel/test_augment_grid.py
 gpaw/test/parallel/test_blacsdist.py
 gpaw/test/parallel/test_compare.py
+gpaw/test/parallel/test_davidson_scalapack.py
 gpaw/test/parallel/test_diamond_gllb.py
 gpaw/test/parallel/test_fd_parallel.py
 gpaw/test/parallel/test_fd_parallel_kpt.py
 gpaw/test/parallel/test_kptpar.py
 gpaw/test/parallel/test_mpi.py
 gpaw/test/parallel/test_parallel_eigh.py
 gpaw/test/parallel/test_pblas.py
@@ -781,94 +834,106 @@
 gpaw/test/pw/__init__.py
 gpaw/test/pw/test_augment_grids.py
 gpaw/test/pw/test_bulk.py
 gpaw/test/pw/test_davidson_pw.py
 gpaw/test/pw/test_direct.py
 gpaw/test/pw/test_electrostatic_potential.py
 gpaw/test/pw/test_expert_diag.py
+gpaw/test/pw/test_fe_stress_mgga.py
 gpaw/test/pw/test_fftmixer.py
 gpaw/test/pw/test_fulldiag.py
+gpaw/test/pw/test_fulldiag_mgga.py
 gpaw/test/pw/test_fulldiagk.py
 gpaw/test/pw/test_h.py
 gpaw/test/pw/test_interpol.py
 gpaw/test/pw/test_lfc.py
 gpaw/test/pw/test_moleculecg.py
 gpaw/test/pw/test_par_strategies.py
 gpaw/test/pw/test_reallfc.py
 gpaw/test/pw/test_si_stress.py
+gpaw/test/pw/test_si_stress_mgga.py
 gpaw/test/pw/test_slab.py
 gpaw/test/pw/test_smallanglecell.py
 gpaw/test/pw/test_stresstest.py
 gpaw/test/radial/__init__.py
 gpaw/test/radial/test_integral4.py
 gpaw/test/radial/test_lebedev.py
 gpaw/test/radial/test_two_phi_plw_integrals.py
 gpaw/test/radial/test_ylexpand.py
 gpaw/test/radial/test_yukawa_radial.py
 gpaw/test/ralda/__init__.py
-gpaw/test/ralda/ralda_H2_test.py
-gpaw/test/ralda/ralda_He_test.py
-gpaw/test/ralda/ralda_Ni_test.py
-gpaw/test/raman/__init__.py
-gpaw/test/raman/test_dipole_transition.py
-gpaw/test/raman/test_dipole_transition2.py
-gpaw/test/raman/test_elph_matrix.py
+gpaw/test/ralda/test_pbe_deriv.py
+gpaw/test/ralda/test_ralda_H2.py
+gpaw/test/ralda/test_ralda_He.py
+gpaw/test/ralda/test_ralda_Ni.py
 gpaw/test/response/__init__.py
 gpaw/test/response/hyd_chain_response.py
+gpaw/test/response/test_Na_EELS_RPA_tetra_point_comparison.py
+gpaw/test/response/test_WGG_GaAs.py
 gpaw/test/response/test_afm_hchain_sf_gssALDA.py
 gpaw/test/response/test_aluminum_EELS_ALDA.py
 gpaw/test/response/test_aluminum_EELS_RPA.py
 gpaw/test/response/test_au02_absorption.py
 gpaw/test/response/test_bse_MoS2_cut.py
 gpaw/test/response/test_bse_aluminum.py
 gpaw/test/response/test_bse_silicon.py
 gpaw/test/response/test_chi0.py
-gpaw/test/response/test_chi0_extend_head.py
-gpaw/test/response/test_chi0_intraband_test.py
+gpaw/test/response/test_chi0_update.py
 gpaw/test/response/test_chiks.py
+gpaw/test/response/test_cobalt_sf_gssALDA.py
 gpaw/test/response/test_diamond_absorption.py
 gpaw/test/response/test_graphene.py
 gpaw/test/response/test_graphene_EELS.py
 gpaw/test/response/test_gw_MoS2_cut.py
 gpaw/test/response/test_gw_hBN_extrapolate.py
 gpaw/test/response/test_gw_ppa.py
 gpaw/test/response/test_gw_restart_file.py
 gpaw/test/response/test_gw_si.py
+gpaw/test/response/test_gw_spinpol.py
 gpaw/test/response/test_gw_too.py
 gpaw/test/response/test_gw_vertex.py
 gpaw/test/response/test_heisenberg.py
+gpaw/test/response/test_hubbard.py
+gpaw/test/response/test_ibz2bz.py
 gpaw/test/response/test_iron_sf_ALDA.py
 gpaw/test/response/test_iron_sf_gssALDA.py
+gpaw/test/response/test_jdos.py
+gpaw/test/response/test_localft.py
 gpaw/test/response/test_mft.py
 gpaw/test/response/test_na_plasmon.py
 gpaw/test/response/test_na_plasmons.py
 gpaw/test/response/test_na_plasmons_tetrahedron.py
-gpaw/test/response/test_pair.py
-gpaw/test/response/test_paw_ft.py
+gpaw/test/response/test_nicl2_sf_gssALDA.py
+gpaw/test/response/test_parallel_kptpair_extraction.py
+gpaw/test/response/test_parallelization.py
 gpaw/test/response/test_pdens_tool.py
 gpaw/test/response/test_qeh.py
-gpaw/test/response/test_silicon_chi_RPA.py
+gpaw/test/response/test_response_band_cutoff.py
+gpaw/test/response/test_silicon_chi.py
 gpaw/test/response/test_site_kernels.py
+gpaw/test/response/test_test_chi0_intraband.py
 gpaw/test/response/test_test_unit_sphere_area.py
+gpaw/test/response/test_tetra_point_smoothing.py
 gpaw/test/response/test_two-aluminum_chi_RPA.py
+gpaw/test/response/test_two_phi_integrals.py
 gpaw/test/response/test_wgg_factorization.py
 gpaw/test/rpa/__init__.py
 gpaw/test/rpa/rpa_C6_He.py
 gpaw/test/rpa/test_rpa_energy_N2.py
 gpaw/test/rpa/test_rpa_energy_Na.py
 gpaw/test/rpa/test_rpa_energy_Ni.py
 gpaw/test/rpa/test_rpa_energy_Si.py
 gpaw/test/rsf_yukawa/__init__.py
 gpaw/test/rsf_yukawa/test_lrtddft_short.py
 gpaw/test/rsf_yukawa/test_rsf_general.py
 gpaw/test/rsf_yukawa/test_rsf_ivo_sing_mg.py
 gpaw/test/setups/__init__.py
-gpaw/test/setups/setup_basis_spec_test.py
 gpaw/test/setups/test_derivative_integrals.py
 gpaw/test/setups/test_generator2.py
+gpaw/test/setups/test_setup_basis_spec.py
 gpaw/test/sic/__init__.py
 gpaw/test/sic/test_nscfsic.py
 gpaw/test/sic/test_scfsic_h2.py
 gpaw/test/solvation/__init__.py
 gpaw/test/solvation/test_adm12.py
 gpaw/test/solvation/test_forces.py
 gpaw/test/solvation/test_forces_symmetry.py
@@ -893,14 +958,15 @@
 gpaw/test/spin/test_spinpol.py
 gpaw/test/symmetry/__init__.py
 gpaw/test/symmetry/test_check.py
 gpaw/test/symmetry/test_fractional_translations.py
 gpaw/test/symmetry/test_fractional_translations_big.py
 gpaw/test/symmetry/test_fractional_translations_med.py
 gpaw/test/symmetry/test_kpoint_mapping.py
+gpaw/test/symmetry/test_symmetrize_wGG.py
 gpaw/test/symmetry/test_symmetry.py
 gpaw/test/symmetry/test_symmetry2.py
 gpaw/test/symmetry/test_symmetry_ft.py
 gpaw/test/symmetry/test_usesymm.py
 gpaw/test/symmetry/test_usesymm2.py
 gpaw/test/tddft/__init__.py
 gpaw/test/tddft/test_be_nltd_ip.py
@@ -944,17 +1010,17 @@
 gpaw/test/xc/test_qna_band.py
 gpaw/test/xc/test_qna_force.py
 gpaw/test/xc/test_qna_spinpol.py
 gpaw/test/xc/test_qna_stress.py
 gpaw/test/xc/test_revPBE.py
 gpaw/test/xc/test_revPBE_Li.py
 gpaw/test/xc/test_tb09.py
+gpaw/test/xc/test_tpss.py
 gpaw/test/xc/test_xc.py
 gpaw/test/xc/test_xcatom.py
-gpaw/test/xc/tpss_test.py
 gpaw/utilities/__init__.py
 gpaw/utilities/bader.py
 gpaw/utilities/blas.py
 gpaw/utilities/cg.py
 gpaw/utilities/debug.py
 gpaw/utilities/dipole.py
 gpaw/utilities/dos.py
@@ -999,17 +1065,17 @@
 gpaw/wavefunctions/fd.py
 gpaw/wavefunctions/fdpw.py
 gpaw/wavefunctions/lcao.py
 gpaw/wavefunctions/mode.py
 gpaw/wavefunctions/pw.py
 gpaw/xc/__init__.py
 gpaw/xc/bee.py
-gpaw/xc/exx.py
 gpaw/xc/functional.py
 gpaw/xc/fxc.py
+gpaw/xc/fxc_kernels.py
 gpaw/xc/gga.py
 gpaw/xc/hybrid.py
 gpaw/xc/kernel.py
 gpaw/xc/lb94.py
 gpaw/xc/lda.py
 gpaw/xc/libvdwxc.py
 gpaw/xc/libxc.py
```

### Comparing `gpaw-22.8.0/siteconfig_example.py` & `gpaw-23.6.0/siteconfig_example.py`

 * *Files 15% similar despite different names*

```diff
@@ -15,39 +15,33 @@
 * extra_compile_args
   Arguments forwarded directly to compiler
 * runtime_library_dirs
   Runtime library search directories: -Wl,-rpath=<dir1> -Wl,-rpath=<dir2> ...
 * extra_objects
 * define_macros
 
-The following lists work like above, but are only linked when compiling
-the parallel interpreter:
-
-* mpi_libraries
-* mpi_library_dirs
-* mpi_include_dirs
-* mpi_runtime_library_dirs
-* mpi_define_macros
-
 To override use the form:
 
     libraries = ['somelib', 'otherlib']
 
 To append use the form
 
     libraries += ['somelib', 'otherlib']
 """
 
 # flake8: noqa
 
 # compiler = 'gcc'
-# mpicompiler = 'mpicc'
-# mpilinker = 'mpicc'
 # platform_id = ''
 
+# MPI:
+mpi = True
+if mpi:
+    compiler = 'mpicc'
+
 # FFTW3:
 fftw = True
 if fftw:
     libraries += ['fftw3']
 
 # ScaLAPACK (version 2.0.1+ required):
 scalapack = True
@@ -56,15 +50,15 @@
 
 # Use Elpa (requires ScaLAPACK and Elpa API 20171201):
 if 0:
     elpa = True
     elpadir = '/home/user/elpa'
     libraries += ['elpa']
     library_dirs += ['{}/lib'.format(elpadir)]
-    extra_link_args += ['-Wl,-rpath={}/lib'.format(elpadir)]
+    runtime_library_dirs += ['{}/lib'.format(elpadir)]
     include_dirs += ['{}/include/elpa-xxxx.xx.xxx'.format(elpadir)]
 
 # LibXC:
 # In order to link libxc installed in a non-standard location
 # (e.g.: configure --prefix=/home/user/libxc-2.0.1-1), use:
 
 # - static linking:
@@ -77,20 +71,23 @@
 
 # - dynamic linking (requires rpath or setting LD_LIBRARY_PATH at runtime):
 if 0:
     xc = '/home/user/libxc-4.0.4/'
     include_dirs += [xc + 'include']
     library_dirs += [xc + 'lib']
     # You can use rpath to avoid changing LD_LIBRARY_PATH:
-    extra_link_args += ['-Wl,-rpath={xc}/lib'.format(xc=xc)]
+    runtime_library_dirs += [xc + 'lib']
     if 'xc' not in libraries:
         libraries.append('xc')
 
+# Enable this, if your MPI doesn't support MPI_INPLACE
+if 0:
+    undef_macros.append('GPAW_MPI_INPLACE')
 
 # libvdwxc:
 if 0:
     libvdwxc = True
     path = '/home/user/libvdwxc'
-    extra_link_args += ['-Wl,-rpath=%s/lib' % path]
-    library_dirs += ['%s/lib' % path]
     include_dirs += ['%s/include' % path]
+    library_dirs += ['%s/lib' % path]
+    runtime_library_dirs += ['%s/lib' % path]
     libraries += ['vdwxc']
```

### Comparing `gpaw-22.8.0/tools/gpaw-plot-parallel-timings` & `gpaw-23.6.0/tools/gpaw-plot-parallel-timings`

 * *Files identical despite different names*

### Comparing `gpaw-22.8.0/tools/gpaw-runscript` & `gpaw-23.6.0/tools/gpaw-runscript`

 * *Files identical despite different names*

