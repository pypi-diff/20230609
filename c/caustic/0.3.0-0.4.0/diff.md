# Comparing `tmp/caustic-0.3.0-py3-none-any.whl.zip` & `tmp/caustic-0.4.0-py2.py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,38 +1,38 @@
-Zip file size: 43493 bytes, number of entries: 36
--rw-rw-r--  2.0 unx        0 b- defN 23-Jan-31 22:20 caustic/__init__.py
--rw-rw-r--  2.0 unx      496 b- defN 23-Apr-14 19:49 caustic/constants.py
--rw-rw-r--  2.0 unx     8554 b- defN 23-May-29 15:35 caustic/cosmology.py
--rw-rw-r--  2.0 unx     3536 b- defN 23-May-29 15:35 caustic/fwd_raytrace.py
--rw-rw-r--  2.0 unx      154 b- defN 23-May-30 17:36 caustic/packed.py
--rw-rw-r--  2.0 unx     3392 b- defN 23-May-29 15:35 caustic/parameter.py
--rw-rw-r--  2.0 unx    21182 b- defN 23-May-30 17:36 caustic/parametrized.py
--rw-rw-r--  2.0 unx      631 b- defN 23-May-30 17:36 caustic/simulator.py
--rw-rw-r--  2.0 unx    11755 b- defN 23-May-29 15:35 caustic/utils.py
--rw-rw-r--  2.0 unx       80 b- defN 23-Feb-16 16:45 caustic/data/__init__.py
--rw-rw-r--  2.0 unx     1563 b- defN 23-Feb-16 16:45 caustic/data/hdf5dataset.py
--rw-rw-r--  2.0 unx      683 b- defN 23-Feb-16 16:45 caustic/data/illustris_kappa.py
--rw-rw-r--  2.0 unx      675 b- defN 23-Feb-16 16:45 caustic/data/probes.py
--rw-rw-r--  2.0 unx      248 b- defN 23-Feb-16 16:45 caustic/lenses/__init__.py
--rw-rw-r--  2.0 unx    13591 b- defN 23-May-30 17:36 caustic/lenses/base.py
--rw-rw-r--  2.0 unx     7271 b- defN 23-May-29 15:35 caustic/lenses/epl.py
--rw-rw-r--  2.0 unx     3634 b- defN 23-May-29 15:35 caustic/lenses/external_shear.py
--rw-rw-r--  2.0 unx    13160 b- defN 23-May-11 17:09 caustic/lenses/kappa_grid.py
--rw-rw-r--  2.0 unx     5613 b- defN 23-May-29 15:35 caustic/lenses/multiplane.py
--rw-rw-r--  2.0 unx    10688 b- defN 23-May-29 15:35 caustic/lenses/nfw.py
--rw-rw-r--  2.0 unx     4008 b- defN 23-May-29 15:35 caustic/lenses/point.py
--rw-rw-r--  2.0 unx     7035 b- defN 23-May-29 15:35 caustic/lenses/pseudo_jaffe.py
--rw-rw-r--  2.0 unx     4395 b- defN 23-May-29 15:35 caustic/lenses/sie.py
--rw-rw-r--  2.0 unx     3209 b- defN 23-May-29 15:35 caustic/lenses/singleplane.py
--rw-rw-r--  2.0 unx     3489 b- defN 23-May-29 15:35 caustic/lenses/sis.py
--rw-rw-r--  2.0 unx     2674 b- defN 23-May-30 17:36 caustic/lenses/utils.py
--rw-rw-r--  2.0 unx       89 b- defN 23-Apr-14 19:49 caustic/sources/__init__.py
--rw-rw-r--  2.0 unx     2006 b- defN 23-May-29 15:35 caustic/sources/base.py
--rw-rw-r--  2.0 unx     3162 b- defN 23-May-29 15:35 caustic/sources/pixelated.py
--rw-rw-r--  2.0 unx      792 b- defN 23-Apr-14 19:49 caustic/sources/probes.py
--rw-rw-r--  2.0 unx     4948 b- defN 23-May-29 15:35 caustic/sources/sersic.py
--rw-rw-r--  2.0 unx     1076 b- defN 23-May-30 17:43 caustic-0.3.0.dist-info/LICENSE
--rw-rw-r--  2.0 unx     3393 b- defN 23-May-30 17:43 caustic-0.3.0.dist-info/METADATA
--rw-rw-r--  2.0 unx       92 b- defN 23-May-30 17:43 caustic-0.3.0.dist-info/WHEEL
--rw-rw-r--  2.0 unx        8 b- defN 23-May-30 17:43 caustic-0.3.0.dist-info/top_level.txt
--rw-rw-r--  2.0 unx     2878 b- defN 23-May-30 17:43 caustic-0.3.0.dist-info/RECORD
-36 files, 150160 bytes uncompressed, 38947 bytes compressed:  74.1%
+Zip file size: 44602 bytes, number of entries: 36
+-rw-rw-r--  2.0 unx      246 b- defN 23-Jun-09 14:54 caustic/__init__.py
+-rw-rw-r--  2.0 unx      598 b- defN 23-Jun-09 14:53 caustic/constants.py
+-rw-rw-r--  2.0 unx     8952 b- defN 23-Jun-09 14:53 caustic/cosmology.py
+-rw-rw-r--  2.0 unx     3685 b- defN 23-Jun-09 14:53 caustic/forward_raytrace.py
+-rw-rw-r--  2.0 unx      155 b- defN 23-Jun-09 14:53 caustic/packed.py
+-rw-rw-r--  2.0 unx     3380 b- defN 23-Jun-09 14:53 caustic/parameter.py
+-rw-rw-r--  2.0 unx    21171 b- defN 23-Jun-09 14:53 caustic/parametrized.py
+-rw-rw-r--  2.0 unx      619 b- defN 23-Jun-09 14:53 caustic/simulator.py
+-rw-rw-r--  2.0 unx    11725 b- defN 23-Jun-09 14:53 caustic/utils.py
+-rw-rw-r--  2.0 unx       80 b- defN 23-Jun-09 14:53 caustic/data/__init__.py
+-rw-rw-r--  2.0 unx     1563 b- defN 23-Jun-09 14:53 caustic/data/hdf5dataset.py
+-rw-rw-r--  2.0 unx      683 b- defN 23-Jun-09 14:53 caustic/data/illustris_kappa.py
+-rw-rw-r--  2.0 unx      675 b- defN 23-Jun-09 14:53 caustic/data/probes.py
+-rw-rw-r--  2.0 unx      259 b- defN 23-Jun-09 14:53 caustic/lenses/__init__.py
+-rw-rw-r--  2.0 unx    16265 b- defN 23-Jun-09 14:53 caustic/lenses/base.py
+-rw-rw-r--  2.0 unx     7239 b- defN 23-Jun-09 14:53 caustic/lenses/epl.py
+-rw-rw-r--  2.0 unx     3617 b- defN 23-Jun-09 14:53 caustic/lenses/external_shear.py
+-rw-rw-r--  2.0 unx     5481 b- defN 23-Jun-09 14:53 caustic/lenses/multiplane.py
+-rw-rw-r--  2.0 unx    10539 b- defN 23-Jun-09 14:53 caustic/lenses/nfw.py
+-rw-rw-r--  2.0 unx    14235 b- defN 23-Jun-09 14:53 caustic/lenses/pixelated_convergence.py
+-rw-rw-r--  2.0 unx     3951 b- defN 23-Jun-09 14:53 caustic/lenses/point.py
+-rw-rw-r--  2.0 unx     7521 b- defN 23-Jun-09 14:53 caustic/lenses/pseudo_jaffe.py
+-rw-rw-r--  2.0 unx     4488 b- defN 23-Jun-09 14:53 caustic/lenses/sie.py
+-rw-rw-r--  2.0 unx     3365 b- defN 23-Jun-09 14:53 caustic/lenses/singleplane.py
+-rw-rw-r--  2.0 unx     3434 b- defN 23-Jun-09 14:53 caustic/lenses/sis.py
+-rw-rw-r--  2.0 unx     2458 b- defN 23-Jun-09 14:53 caustic/lenses/utils.py
+-rw-rw-r--  2.0 unx       89 b- defN 23-Jun-09 14:53 caustic/sources/__init__.py
+-rw-rw-r--  2.0 unx     2000 b- defN 23-Jun-09 14:53 caustic/sources/base.py
+-rw-rw-r--  2.0 unx     3253 b- defN 23-Jun-09 14:53 caustic/sources/pixelated.py
+-rw-rw-r--  2.0 unx      792 b- defN 23-Jun-09 14:53 caustic/sources/probes.py
+-rw-rw-r--  2.0 unx     4876 b- defN 23-Jun-09 14:53 caustic/sources/sersic.py
+-rw-rw-r--  2.0 unx     1076 b- defN 23-Jun-09 14:55 caustic-0.4.0.dist-info/LICENSE
+-rw-rw-r--  2.0 unx     3393 b- defN 23-Jun-09 14:55 caustic-0.4.0.dist-info/METADATA
+-rw-rw-r--  2.0 unx      110 b- defN 23-Jun-09 14:55 caustic-0.4.0.dist-info/WHEEL
+-rw-rw-r--  2.0 unx        8 b- defN 23-Jun-09 14:55 caustic-0.4.0.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx     2896 b- defN 23-Jun-09 14:55 caustic-0.4.0.dist-info/RECORD
+36 files, 154877 bytes uncompressed, 40026 bytes compressed:  74.2%
```

## zipnote {}

```diff
@@ -3,15 +3,15 @@
 
 Filename: caustic/constants.py
 Comment: 
 
 Filename: caustic/cosmology.py
 Comment: 
 
-Filename: caustic/fwd_raytrace.py
+Filename: caustic/forward_raytrace.py
 Comment: 
 
 Filename: caustic/packed.py
 Comment: 
 
 Filename: caustic/parameter.py
 Comment: 
@@ -45,23 +45,23 @@
 
 Filename: caustic/lenses/epl.py
 Comment: 
 
 Filename: caustic/lenses/external_shear.py
 Comment: 
 
-Filename: caustic/lenses/kappa_grid.py
-Comment: 
-
 Filename: caustic/lenses/multiplane.py
 Comment: 
 
 Filename: caustic/lenses/nfw.py
 Comment: 
 
+Filename: caustic/lenses/pixelated_convergence.py
+Comment: 
+
 Filename: caustic/lenses/point.py
 Comment: 
 
 Filename: caustic/lenses/pseudo_jaffe.py
 Comment: 
 
 Filename: caustic/lenses/sie.py
@@ -87,23 +87,23 @@
 
 Filename: caustic/sources/probes.py
 Comment: 
 
 Filename: caustic/sources/sersic.py
 Comment: 
 
-Filename: caustic-0.3.0.dist-info/LICENSE
+Filename: caustic-0.4.0.dist-info/LICENSE
 Comment: 
 
-Filename: caustic-0.3.0.dist-info/METADATA
+Filename: caustic-0.4.0.dist-info/METADATA
 Comment: 
 
-Filename: caustic-0.3.0.dist-info/WHEEL
+Filename: caustic-0.4.0.dist-info/WHEEL
 Comment: 
 
-Filename: caustic-0.3.0.dist-info/top_level.txt
+Filename: caustic-0.4.0.dist-info/top_level.txt
 Comment: 
 
-Filename: caustic-0.3.0.dist-info/RECORD
+Filename: caustic-0.4.0.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## caustic/__init__.py

```diff
@@ -0,0 +1,16 @@
+00000000: 5f5f 7665 7273 696f 6e5f 5f20 3d20 2730  __version__ = '0
+00000010: 2e34 2e30 270a 0a66 726f 6d20 2e63 6f6e  .4.0'..from .con
+00000020: 7374 616e 7473 2069 6d70 6f72 7420 2a0a  stants import *.
+00000030: 6672 6f6d 202e 6c65 6e73 6573 2069 6d70  from .lenses imp
+00000040: 6f72 7420 2a0a 6672 6f6d 202e 636f 736d  ort *.from .cosm
+00000050: 6f6c 6f67 7920 696d 706f 7274 202a 0a66  ology import *.f
+00000060: 726f 6d20 2e66 6f72 7761 7264 5f72 6179  rom .forward_ray
+00000070: 7472 6163 6520 696d 706f 7274 202a 0a66  trace import *.f
+00000080: 726f 6d20 2e70 6163 6b65 6420 696d 706f  rom .packed impo
+00000090: 7274 202a 0a66 726f 6d20 2e70 6172 616d  rt *.from .param
+000000a0: 6574 7269 7a65 6420 696d 706f 7274 202a  etrized import *
+000000b0: 0a66 726f 6d20 2e73 696d 756c 6174 6f72  .from .simulator
+000000c0: 2069 6d70 6f72 7420 2a0a 6672 6f6d 202e   import *.from .
+000000d0: 736f 7572 6365 7320 696d 706f 7274 202a  sources import *
+000000e0: 0a66 726f 6d20 2e75 7469 6c73 2069 6d70  .from .utils imp
+000000f0: 6f72 7420 2a0a                           ort *.
```

## caustic/constants.py

```diff
@@ -1,12 +1,14 @@
 from math import pi
 
 from astropy.constants.codata2018 import G as _G_astropy
 from astropy.constants.codata2018 import c as _c_astropy
 
-rad_to_arcsec = 180 / pi * 60**2
+__all__ = ("rad_to_arcsec", "arcsec_to_rad", "c_km_s", "G", "G_over_c2", "c_Mpc_s", "km_to_Mpc")
+
+rad_to_arcsec = 180 / pi * 60 ** 2
 arcsec_to_rad = 1 / rad_to_arcsec
 c_km_s = float(_c_astropy.to("km/s").value)
 G = float(_G_astropy.to("pc * km^2 / (s^2 * solMass)").value)
-G_over_c2 = float((_G_astropy / _c_astropy**2).to("Mpc/solMass").value)  # type: ignore
+G_over_c2 = float((_G_astropy / _c_astropy ** 2).to("Mpc/solMass").value)  # type: ignore
 c_Mpc_s = float(_c_astropy.to("Mpc/s").value)
 km_to_Mpc = 3.2407792896664e-20  # TODO: use astropy
```

## caustic/cosmology.py

```diff
@@ -9,42 +9,42 @@
 
 from .utils import interp1d
 from .constants import G_over_c2, c_Mpc_s, km_to_Mpc
 from .parametrized import Parametrized
 
 __all__ = (
     "h0_default",
-    "rho_cr_0_default",
+    "critical_density_0_default",
     "Om0_default",
     "Cosmology",
     "FlatLambdaCDM",
 )
 
 h0_default = float(default_cosmology.get().h)
-rho_cr_0_default = float(
+critical_density_0_default = float(
     default_cosmology.get().critical_density(0).to("solMass/Mpc^3").value
 )
 Om0_default = float(default_cosmology.get().Om0)
 
 # Set up interpolator to speed up comoving distance calculations in Lambda-CDM
 # cosmologies. Construct with float64 precision.
-_comoving_dist_helper_x_grid = 10 ** torch.linspace(-3, 1, 500, dtype=torch.float64)
-_comoving_dist_helper_y_grid = torch.as_tensor(
-    _comoving_dist_helper_x_grid
-    * hyp2f1(1 / 3, 1 / 2, 4 / 3, -(_comoving_dist_helper_x_grid**3)),
+_comoving_distance_helper_x_grid = 10 ** torch.linspace(-3, 1, 500, dtype=torch.float64)
+_comoving_distance_helper_y_grid = torch.as_tensor(
+    _comoving_distance_helper_x_grid
+    * hyp2f1(1 / 3, 1 / 2, 4 / 3, -(_comoving_distance_helper_x_grid ** 3)),
     dtype=torch.float64,
 )
 
 
 class Cosmology(Parametrized):
     """
     Abstract base class for cosmological models.
 
-    This class provides an interface for cosmological computations used in lensing 
-    such as comoving distance and critical surface density. 
+    This class provides an interface for cosmological computations used in lensing
+    such as comoving distance and critical surface density.
 
     Units:
         - Distance: Mpc
         - Mass: solar mass
 
     Attributes:
         name (str): Name of the cosmological model.
@@ -56,215 +56,218 @@
 
         Args:
             name (str): Name of the cosmological model.
         """
         super().__init__(name)
 
     @abstractmethod
-    def rho_cr(self, z: Tensor, x: Optional[dict[str, Any]] = None) -> Tensor:
+    def critical_density(self, z: Tensor, params: Optional["Packed"] = None) -> Tensor:
         """
         Compute the critical density at redshift z.
 
         Args:
             z (Tensor): The redshifts.
-            x (Optional[dict[str, Any]]): Additional parameters for the computation.
+            params (Packed, optional): Dynamic parameter container for the computation.
 
         Returns:
             Tensor: The critical density at each redshift.
         """
         ...
 
     @abstractmethod
-    def comoving_dist(self, z: Tensor, x: Optional[dict[str, Any]] = None) -> Tensor:
+    def comoving_distance(self, z: Tensor, params: Optional["Packed"] = None) -> Tensor:
         """
         Compute the comoving distance to redshift z.
 
         Args:
             z (Tensor): The redshifts.
-            x (Optional[dict[str, Any]]): Additional parameters for the computation.
+            params (Packed, optional): Dynamic parameter container for the computation.
 
         Returns:
             Tensor: The comoving distance to each redshift.
         """
         ...
 
-    def comoving_dist_z1z2(
-        self, z1: Tensor, z2: Tensor, x: Optional[dict[str, Any]] = None) -> Tensor:
+    def comoving_distance_z1z2(
+        self, z1: Tensor, z2: Tensor, params: Optional["Packed"] = None
+    ) -> Tensor:
         """
         Compute the comoving distance between two redshifts.
 
         Args:
             z1 (Tensor): The starting redshifts.
             z2 (Tensor): The ending redshifts.
-            x (Optional[dict[str, Any]]): Additional parameters for the computation.
+            params (Packed, optional): Dynamic parameter container for the computation.
 
         Returns:
             Tensor: The comoving distance between each pair of redshifts.
         """
-        return self.comoving_dist(z2, x) - self.comoving_dist(z1, x)
+        return self.comoving_distance(z2, params) - self.comoving_distance(z1, params)
 
-    def angular_diameter_dist(
-        self, z: Tensor, x: Optional[dict[str, Any]] = None) -> Tensor:
+    def angular_diameter_distance(self, z: Tensor, params: Optional["Packed"] = None) -> Tensor:
         """
         Compute the angular diameter distance to redshift z.
 
         Args:
             z (Tensor): The redshifts.
-            x (Optional[dict[str, Any]]): Additional parameters for the computation.
+            params (Packed, optional): Dynamic parameter container for the computation.
 
         Returns:
             Tensor: The angular diameter distance to each redshift.
         """
-        return self.comoving_dist(z, x) / (1 + z)
+        return self.comoving_distance(z, params) / (1 + z)
 
-    def angular_diameter_dist_z1z2(
-        self, z1: Tensor, z2: Tensor, x: Optional[dict[str, Any]] = None) -> Tensor:
+    def angular_diameter_distance_z1z2(
+        self, z1: Tensor, z2: Tensor, params: Optional["Packed"] = None
+    ) -> Tensor:
         """
         Compute the angular diameter distance between two redshifts.
 
         Args:
             z1 (Tensor): The starting redshifts.
             z2 (Tensor): The ending redshifts.
-            x (Optional[dict[str, Any]]): Additional parameters for the computation.
+            params (Packed, optional): Dynamic parameter container for the computation.
 
         Returns:
             Tensor: The angular diameter distance between each pair of redshifts.
         """
-        return self.comoving_dist_z1z2(z1, z2, x) / (1 + z2)
+        return self.comoving_distance_z1z2(z1, z2, params) / (1 + z2)
 
-    def time_delay_dist(
-        self, z_l: Tensor, z_s: Tensor, x: Optional[dict[str, Any]] = None) -> Tensor:
+    def time_delay_distance(
+        self, z_l: Tensor, z_s: Tensor, params: Optional["Packed"] = None
+    ) -> Tensor:
         """
         Compute the time delay distance between lens and source planes.
 
         Args:
             z_l (Tensor): The lens redshifts.
             z_s (Tensor): The source redshifts.
-            x (Optional[dict[str, Any]]): Additional parameters for the computation.
+            params (Packed, optional): Dynamic parameter container for the computation.
 
         Returns:
             Tensor: The time delay distance for each pair of lens and source redshifts.
         """
-        d_l = self.angular_diameter_dist(z_l, x)
-        d_s = self.angular_diameter_dist(z_s, x)
-        d_ls = self.angular_diameter_dist_z1z2(z_l, z_s, x)
+        d_l = self.angular_diameter_distance(z_l, params)
+        d_s = self.angular_diameter_distance(z_s, params)
+        d_ls = self.angular_diameter_distance_z1z2(z_l, z_s, params)
         return (1 + z_l) * d_l * d_s / d_ls
 
-    def Sigma_cr(
-        self, z_l: Tensor, z_s: Tensor, x: Optional[dict[str, Any]] = None) -> Tensor:
+    def critical_surface_density(
+        self, z_l: Tensor, z_s: Tensor, params: Optional["Packed"] = None
+    ) -> Tensor:
         """
         Compute the critical surface density between lens and source planes.
 
         Args:
             z_l (Tensor): The lens redshifts.
             z_s (Tensor): The source redshifts.
-            x (Optional[dict[str, Any]]): Additional parameters for the computation.
+            params (Packed, optional): Dynamic parameter container for the computation.
 
         Returns:
             Tensor: The critical surface density for each pair of lens and source redshifts.
         """
-        d_l = self.angular_diameter_dist(z_l, x)
-        d_s = self.angular_diameter_dist(z_s, x)
-        d_ls = self.angular_diameter_dist_z1z2(z_l, z_s, x)
+        d_l = self.angular_diameter_distance(z_l, params)
+        d_s = self.angular_diameter_distance(z_s, params)
+        d_ls = self.angular_diameter_distance_z1z2(z_l, z_s, params)
         return d_s / d_l / d_ls / (4 * pi * G_over_c2)
 
 
 class FlatLambdaCDM(Cosmology):
     """
     Subclass of Cosmology representing a Flat Lambda Cold Dark Matter (LCDM) cosmology with no radiation.
     """
-    
+
     def __init__(
         self,
         name: str,
         h0: Optional[Tensor] = torch.tensor(h0_default),
-        rho_cr_0: Optional[Tensor] = torch.tensor(rho_cr_0_default),
+        critical_density_0: Optional[Tensor] = torch.tensor(critical_density_0_default),
         Om0: Optional[Tensor] = torch.tensor(Om0_default),
     ):
         """
         Initialize a new instance of the FlatLambdaCDM class.
 
         Args:
             name (str): Name of the cosmology.
-            h0 (Optional[Tensor]): Hubble constant. Default is h0_default.
-            rho_cr_0 (Optional[Tensor]): Critical density at z=0. Default is rho_cr_0_default.
+            h0 (Optional[Tensor]): Hubble constant over 100. Default is h0_default.
+            critical_density_0 (Optional[Tensor]): Critical density at z=0. Default is critical_density_0_default.
             Om0 (Optional[Tensor]): Matter density parameter at z=0. Default is Om0_default.
         """
         super().__init__(name)
 
         self.add_param("h0", h0)
-        self.add_param("rho_cr_0", rho_cr_0)
+        self.add_param("critical_density_0", critical_density_0)
         self.add_param("Om0", Om0)
 
-        self._comoving_dist_helper_x_grid = _comoving_dist_helper_x_grid.to(
+        self._comoving_distance_helper_x_grid = _comoving_distance_helper_x_grid.to(
             dtype=torch.float32
         )
-        self._comoving_dist_helper_y_grid = _comoving_dist_helper_y_grid.to(
+        self._comoving_distance_helper_y_grid = _comoving_distance_helper_y_grid.to(
             dtype=torch.float32
         )
 
-    def dist_hubble(self, h0):
+    def hubble_distance(self, h0):
         """
         Calculate the Hubble distance.
 
         Args:
             h0 (Tensor): Hubble constant.
 
         Returns:
             Tensor: Hubble distance.
         """
         return c_Mpc_s / (100 * km_to_Mpc) / h0
 
-    def rho_cr(self, z: Tensor, x: Optional[dict[str, Any]] = None) -> torch.Tensor:
+    def critical_density(self, z: Tensor, params: Optional["Packed"] = None) -> torch.Tensor:
         """
         Calculate the critical density at redshift z.
 
         Args:
             z (Tensor): Redshift.
-            x (Optional[dict[str, Any]]): Additional parameters for the computation.
+            params (Packed, optional): Dynamic parameter container for the computation.
 
         Returns:
             torch.Tensor: Critical density at redshift z.
         """
-        _, rho_cr_0, Om0 = self.unpack(x)
+        _, critical_density_0, Om0 = self.unpack(params)
         Ode0 = 1 - Om0
-        return rho_cr_0 * (Om0 * (1 + z) ** 3 + Ode0)
+        return critical_density_0 * (Om0 * (1 + z) ** 3 + Ode0)
 
-    def _comoving_dist_helper(self, x: Tensor) -> Tensor:
+    def _comoving_distance_helper(self, x: Tensor, params: Optional["Packed"]) -> Tensor:
         """
         Helper method for computing comoving distances.
 
         Args:
             x (Tensor): Input tensor.
 
         Returns:
             Tensor: Computed comoving distances.
         """
         return interp1d(
-            self._comoving_dist_helper_x_grid,
-            self._comoving_dist_helper_y_grid,
+            self._comoving_distance_helper_x_grid,
+            self._comoving_distance_helper_y_grid,
             torch.atleast_1d(x),
         ).reshape(x.shape)
 
-    def comoving_dist(self, z: Tensor, x: Optional[dict[str, Any]] = None) -> Tensor:
+    def comoving_distance(self, z: Tensor, params: Optional["Packed"] = None) -> Tensor:
         """
         Calculate the comoving distance to redshift z.
 
         Args:
             z (Tensor): Redshift.
-            x (Optional[dict[str, Any]]): Additional parameters for the computation.
+            params (Packed, optional): Dynamic parameter container for the computation.
 
         Returns:
             Tensor: Comoving distance to redshift z.
         """
-        h0, _, Om0 = self.unpack(x)
+        h0, _, Om0 = self.unpack(params)
 
         Ode0 = 1 - Om0
         ratio = (Om0 / Ode0) ** (1 / 3)
         return (
-            self.dist_hubble(h0)
+            self.hubble_distance(h0)
             * (
-                self._comoving_dist_helper((1 + z) * ratio)
-                - self._comoving_dist_helper(ratio)
+                self._comoving_distance_helper((1 + z) * ratio, params)
+                - self._comoving_distance_helper(ratio, params)
             )
             / (Om0 ** (1 / 3) * Ode0 ** (1 / 6))
         )
```

## caustic/packed.py

```diff
@@ -1,8 +1,9 @@
 from collections import OrderedDict
 
+
 class Packed(OrderedDict):
     """
     Dummy wrapper for `x` so other functions can check its type.
     """
 
     ...
```

## caustic/parameter.py

```diff
@@ -12,25 +12,25 @@
 
     A static parameter has a fixed value, while a dynamic parameter must be passed in each time it's required.
 
     Attributes:
         value (Optional[Tensor]): The value of the parameter.
         shape (tuple[int, ...]): The shape of the parameter.
     """
-    
+
     def __init__(
         self, value: Optional[Tensor] = None, shape: Optional[tuple[int, ...]] = ()
     ):
         """
         Initializes an instance of the Parameter class.
 
         Args:
             value (Optional[Tensor], optional): The value of the parameter. Defaults to None.
             shape (Optional[tuple[int, ...]], optional): The shape of the parameter. Defaults to an empty tuple.
-        
+
         Raises:
             ValueError: If both value and shape are None, or if shape is provided and doesn't match the shape of the value.
         """
         # Must assign one of value or shape
         self._value = value
         if value is None:
             if shape is None:
```

## caustic/parametrized.py

```diff
@@ -14,22 +14,22 @@
 
 class Parametrized:
     """
     Represents a class with Param and Parametrized attributes, typically used to construct parts of a simulator
     that have parameters which need to be tracked during MCMC sampling.
 
     This class can contain Params, Parametrized, tensor buffers or normal attributes as its attributes.
-    It provides functionalities to manage these attributes, ensuring that an attribute of one type isn't rebound 
+    It provides functionalities to manage these attributes, ensuring that an attribute of one type isn't rebound
     to be of a different type.
 
     TODO
     - Attributes can be Params, Parametrized, tensor buffers or just normal attributes.
     - Need to make sure an attribute of one of those types isn't rebound to be of a different type.
     - params: generator returning all the params, with names of parent Parametrized concatenated as key.
-    
+
     Attributes:
         name (str): The name of the Parametrized object.
         parents (list[Parametrized]): List of parent Parametrized objects.
         params (OrderedDict[str, Parameter]): Dictionary of parameters.
         descendants (OrderedDict[str, Parametrized]): Dictionary of descendant Parametrized objects.
         dynamic_size (int): Size of dynamic parameters.
         n_dynamic (int): Number of dynamic parameters.
@@ -265,15 +265,15 @@
         ],
     ) -> Packed:
         """
         Converts a list or tensor into a dict that can subsequently be unpacked
         into arguments to this component and its descendants.
 
         Args:
-            x (Union[list[Tensor], dict[str, Union[list[Tensor], Tensor, dict[str, Tensor]]], Tensor): 
+            x (Union[list[Tensor], dict[str, Union[list[Tensor], Tensor, dict[str, Tensor]]], Tensor):
                 The input to be packed. Can be a list of tensors, a dictionary of tensors, or a single tensor.
 
         Returns:
             Packed: The packed input.
 
         Raises:
             ValueError: If the input is not a list, dictionary, or tensor.
@@ -340,24 +340,24 @@
         self, x: Optional[dict[str, Union[list[Tensor], dict[str, Tensor], Tensor]]]
     ) -> list[Tensor]:
         """
         Unpacks a dict of kwargs, list of args or flattened vector of args to retrieve
         this object's static and dynamic parameters.
 
         Args:
-            x (Optional[dict[str, Union[list[Tensor], dict[str, Tensor], Tensor]]]): 
+            x (Optional[dict[str, Union[list[Tensor], dict[str, Tensor], Tensor]]]):
                 The packed object to be unpacked.
 
         Returns:
             list[Tensor]: Unpacked static and dynamic parameters of the object.
 
         Raises:
             ValueError: If the input is not a dict, list, tuple or tensor.
             ValueError: If a static parameter is passed dynamically.
-            ValueError: If the argument type is invalid. It must be a dict containing key {self.name} 
+            ValueError: If the argument type is invalid. It must be a dict containing key {self.name}
                 and value containing args as list or flattened tensor, or kwargs.
         """
         my_x = defaultdict(list) if x is None else x[self.name]
         if isinstance(my_x, dict):
             # Parse dynamic kwargs
             args = []
             for name, p in self._params.items():
@@ -554,15 +554,16 @@
                 if parent.name not in self._descendants and parent.name != self.name:
                     continue
                 add_component(parent, dot)
                 dot.edge(parent.name, desc.name)
                 add_params(desc, dot)
 
         return dot
-    
+
+
 # class ParametrizedList(Parametrized):
 #     """
 #     TODO
 #         - Many operations require being able to remove descendants from the DAG.
 #     """
 #
 #     def __init__(self, name: str, items: Iterable[Parametrized] = []):
```

## caustic/simulator.py

```diff
@@ -1,18 +1,20 @@
-from .parameterized import Parametrized
+from . import Parametrized
+
+__all__ = ("Simulator",)
 
-__all__ = ("Simulator", )
 
 class Simulator(Parametrized):
     """A caustic simulator using Parametrized framework.
 
     Defines a simulator class which is a callable function that
     operates on the Parametrized framework. Users define the `forward`
     method which takes as its first argument an object which can be
     packed, all other args and kwargs are simply passed to the forward
     method.
 
     See `Parametrized` for details on how to add/access parameters.
 
     """
+
     def __call__(self, *args, **kwargs):
         return self.forward(self.pack(args[0]), *args[1:], **kwargs)
```

## caustic/utils.py

```diff
@@ -75,15 +75,15 @@
         x (Tensor): Tensor containing the x-coordinates.
         y (Tensor): Tensor containing the y-coordinates.
         q (Tensor): Tensor containing the elliptical parameters.
 
     Returns:
         Tuple[Tensor, Tensor]: Tuple containing the x and y coordinates in elliptical form.
     """
-    return x * q.sqrt(), y / q.sqrt()
+    return x, y / q
 
 
 def get_meshgrid(
     resolution, nx, ny, device=None, dtype=torch.float32
 ) -> Tuple[Tensor, Tensor]:
     """
     Generates a 2D meshgrid based on the provided resolution and dimensions.
@@ -142,50 +142,50 @@
     """
     out = torch.zeros_like(x)
     where = x != 0
     out[where] = x[where].log()
     return out
 
 
-
 def _h_poly(t):
     """Helper function to compute the 'h' polynomial matrix used in the
     cubic spline.
-    
+
     Args:
         t (Tensor): A 1D tensor representing the normalized x values.
-    
+
     Returns:
         Tensor: A 2D tensor of size (4, len(t)) representing the 'h' polynomial matrix.
 
     """
 
     tt = t[None, :] ** (torch.arange(4, device=t.device)[:, None])
     A = torch.tensor(
         [[1, 0, -3, 2], [0, 1, -2, 1], [0, 0, 3, -2], [0, 0, -1, 1]],
         dtype=t.dtype,
         device=t.device,
     )
     return A @ tt
 
+
 def interp1d(x: Tensor, y: Tensor, xs: Tensor, extend: str = "extrapolate") -> Tensor:
     """Compute the 1D cubic spline interpolation for the given data points
     using PyTorch.
 
     Args:
         x (Tensor): A 1D tensor representing the x-coordinates of the known data points.
         y (Tensor): A 1D tensor representing the y-coordinates of the known data points.
         xs (Tensor): A 1D tensor representing the x-coordinates of the positions where
                      the cubic spline function should be evaluated.
         extend (str, optional): The method for handling extrapolation, either "const", "extrapolate", or "linear".
                                 Default is "extrapolate".
                                 "const": Use the value of the last known data point for extrapolation.
                                 "linear": Use linear extrapolation based on the last two known data points.
                                 "extrapolate": Use cubic extrapolation of data.
-    
+
     Returns:
         Tensor: A 1D tensor representing the interpolated values at the specified positions (xs).
 
     """
     m = (y[1:] - y[:-1]) / (x[1:] - x[:-1])
     m = torch.cat([m[[0]], (m[1:] + m[:-1]) / 2, m[[-1]]])
     idxs = torch.searchsorted(x[:-1], xs) - 1
@@ -200,23 +200,24 @@
     if extend == "const":
         ret[xs > x[-1]] = y[-1]
     elif extend == "linear":
         indices = xs > x[-1]
         ret[indices] = y[-1] + (xs[indices] - x[-1]) * (y[-1] - y[-2]) / (x[-1] - x[-2])
     return ret
 
+
 def interp2d(
     im: Tensor,
     x: Tensor,
     y: Tensor,
     method: str = "linear",
     padding_mode: str = "zeros",
 ) -> Tensor:
     """
-    Interpolates a 2D image at specified coordinates. 
+    Interpolates a 2D image at specified coordinates.
     Similar to `torch.nn.functional.grid_sample` with `align_corners=False`.
 
     Args:
         im (Tensor): A 2D tensor representing the image.
         x (Tensor): A 0D or 1D tensor of x coordinates at which to interpolate.
         y (Tensor): A 0D or 1D tensor of y coordinates at which to interpolate.
         method (str, optional): Interpolation method. Either 'nearest' or 'linear'. Defaults to 'linear'.
```

## caustic/lenses/__init__.py

```diff
@@ -1,11 +1,11 @@
 from .base import *
 from .epl import *
 from .external_shear import *
-from .kappa_grid import *
+from .pixelated_convergence import *
 from .multiplane import *
 from .nfw import *
 from .point import *
 from .pseudo_jaffe import *
 from .sie import *
 from .sis import *
 from .utils import *
```

## caustic/lenses/base.py

```diff
@@ -1,10 +1,11 @@
 from abc import abstractmethod
 from typing import Any, Optional
 from functools import partial
+import warnings
 
 import torch
 from torch import Tensor
 
 from ..constants import arcsec_to_rad, c_Mpc_s
 from ..cosmology import Cosmology
 from ..parametrized import Parametrized
@@ -28,100 +29,142 @@
         Args:
             name (str): The name of the lens model.
             cosmology (Cosmology): An instance of a Cosmology class that describes the cosmological parameters of the model.
         """
         super().__init__(name)
         self.cosmology = cosmology
 
-    @abstractmethod
-    def alpha(
-        self, thx: Tensor, thy: Tensor, z_s: Tensor, x: Optional[dict[str, Any]] = None
+    def reduced_deflection_angle(
+        self, x: Tensor, y: Tensor, z_s: Tensor, params: Optional["Packed"] = None
     ) -> tuple[Tensor, Tensor]:
         """
-        Computes the reduced deflection angle at given coordinates [arcsec].
+        ThickLens objects do not have a reduced deflection angle since the distance D_ls is undefined
+        
+        Args:
+            x (Tensor): Tensor of x coordinates in the lens plane.
+            y (Tensor): Tensor of y coordinates in the lens plane.
+            z_s (Tensor): Tensor of source redshifts.
+            params (Packed, optional): Dynamic parameter container for the lens model. Defaults to None.
+
+        Raises:
+            NotImplementedError
+        """
+        warnings.warn("ThickLens objects do not have a reduced deflection angle since they have no unique lens redshift. The distance D_{ls} is undefined in the equation $\alpha_{reduced} = \frac{D_{ls}}{D_s}\alpha_{physical}$. See `effective_reduced_deflection_angle`. Now using effective_reduced_deflection_angle, please switch functions to remove this warning")
+        return self.effective_reduced_deflection_angle(x, y, z_s, params)
 
+    def effective_reduced_deflection_angle(
+        self, x: Tensor, y: Tensor, z_s: Tensor, params: Optional["Packed"] = None
+    ) -> tuple[Tensor, Tensor]:
+        """ThickLens objects do not have a reduced deflection angle since the
+        distance D_ls is undefined. Instead we define an effective
+        reduced deflection angle by simply assuming the relation
+        $\alpha = \theta - \beta$ holds, where $\alpha$ is the
+        effective reduced deflection angle, $\theta$ are the observed
+        angular coordinates, and $\beta$ are the angular coordinates
+        to the source plane.
+        
         Args:
-            thx (Tensor): Tensor of x coordinates in the lens plane.
-            thy (Tensor): Tensor of y coordinates in the lens plane.
+            x (Tensor): Tensor of x coordinates in the lens plane.
+            y (Tensor): Tensor of y coordinates in the lens plane.
             z_s (Tensor): Tensor of source redshifts.
-            x (Optional[dict[str, Any]], optional): Additional parameters for the lens model. Defaults to None.
+            params (Packed, optional): Dynamic parameter container for the lens model. Defaults to None.
+
+        """
+        bx, by = self.raytrace(x, y, z_s, params)
+        return x - bx, y - by
+    
+    def physical_deflection_angle(
+        self, x: Tensor, y: Tensor, z_s: Tensor, params: Optional["Packed"] = None
+    ) -> tuple[Tensor, Tensor]:
+        """Physical deflection angles are computed with respect to a lensing
+        plane. ThickLens objects have no unique definition of a lens
+        plane and so cannot compute a physical_deflection_angle
+
+        Args:
+            x (Tensor): Tensor of x coordinates in the lens plane.
+            y (Tensor): Tensor of y coordinates in the lens plane.
+            z_s (Tensor): Tensor of source redshifts.
+            params (Packed, optional): Dynamic parameter container for the lens model. Defaults to None.
 
         Returns:
             tuple[Tensor, Tensor]: Tuple of Tensors representing the x and y components of the deflection angle, respectively.
+
         """
-        ...
+        raise NotImplementedError("Physical deflection angles are computed with respect to a lensing plane. ThickLens objects have no unique definition of a lens plane and so cannot compute a physical_deflection_angle")
 
+    @abstractmethod
     def raytrace(
-        self, thx: Tensor, thy: Tensor, z_s: Tensor, x: Optional[dict[str, Any]] = None
+        self, x: Tensor, y: Tensor, z_s: Tensor, params: Optional["Packed"] = None
     ) -> tuple[Tensor, Tensor]:
-        """
-        Performs ray tracing by computing the deflection angle and subtracting it from the initial coordinates.
+        """Performs ray tracing by computing the angular position on the
+        source plance associated with a given input observed angular
+        coordinate x,y.
 
         Args:
-            thx (Tensor): Tensor of x coordinates in the lens plane.
-            thy (Tensor): Tensor of y coordinates in the lens plane.
+            x (Tensor): Tensor of x coordinates in the lens plane.
+            y (Tensor): Tensor of y coordinates in the lens plane.
             z_s (Tensor): Tensor of source redshifts.
-            x (Optional[dict[str, Any]], optional): Additional parameters for the lens model. Defaults to None.
+            params (Packed, optional): Dynamic parameter container for the lens model. Defaults to None.
 
         Returns:
             tuple[Tensor, Tensor]: Tuple of Tensors representing the x and y coordinates of the ray-traced light rays, respectively.
+
         """
-        ax, ay = self.alpha(thx, thy, z_s, x)
-        return thx - ax, thy - ay
+        ...
 
     @abstractmethod
-    def Sigma(
-        self, thx: Tensor, thy: Tensor, z_s: Tensor, x: Optional[dict[str, Any]] = None
+    def surface_density(
+        self, x: Tensor, y: Tensor, z_s: Tensor, params: Optional["Packed"] = None
     ) -> Tensor:
         """
         Computes the projected mass density at given coordinates.
 
         Args:
-            thx (Tensor): Tensor of x coordinates in the lens plane.
-            thy (Tensor): Tensor of y coordinates in the lens plane.
+            x (Tensor): Tensor of x coordinates in the lens plane.
+            y (Tensor): Tensor of y coordinates in the lens plane.
             z_s (Tensor): Tensor of source redshifts.
-            x (Optional[dict[str, Any]], optional): Additional parameters for the lens model. Defaults to None.
+            params (Packed, optional): Dynamic parameter container for the lens model. Defaults to None.
 
         Returns:
             Tensor: The projected mass density at the given coordinates in units of solar masses per square Megaparsec.
         """
         ...
 
     @abstractmethod
     def time_delay(
-        self, thx: Tensor, thy: Tensor, z_s: Tensor, x: Optional[dict[str, Any]] = None
+        self, x: Tensor, y: Tensor, z_s: Tensor, params: Optional["Packed"] = None
     ) -> Tensor:
         """
         Computes the gravitational time delay at given coordinates.
 
         Args:
-            thx (Tensor): Tensor of x coordinates in the lens plane.
-            thy (Tensor): Tensor of y coordinates in the lens plane.
+            x (Tensor): Tensor of x coordinates in the lens plane.
+            y (Tensor): Tensor of y coordinates in the lens plane.
             z_s (Tensor): Tensor ofsource redshifts.
-        x (Optional[dict[str, Any]], optional): Additional parameters for the lens model. Defaults to None.
+            params (Packed, optional): Dynamic parameter container for the lens model. Defaults to None.
 
         Returns:
             Tensor: The gravitational time delay at the given coordinates.
         """
         ...
 
-    def magnification(self, thx: Tensor, thy: Tensor, z_s: Tensor, x) -> Tensor:
+    def magnification(self, x: Tensor, y: Tensor, z_s: Tensor, params: Optional["Packed"] = None) -> Tensor:
         """
         Computes the gravitational lensing magnification at given coordinates.
     
         Args:
-            thx (Tensor): Tensor of x coordinates in the lens plane.
-            thy (Tensor): Tensor of y coordinates in the lens plane.
+            x (Tensor): Tensor of x coordinates in the lens plane.
+            y (Tensor): Tensor of y coordinates in the lens plane.
             z_s (Tensor): Tensor of source redshifts.
-            x (Optional[dict[str, Any]], optional): Additional parameters for the lens model. Defaults to None.
+            params (Packed, optional): Dynamic parameter container for the lens model. Defaults to None.
     
         Returns:
             Tensor: The gravitational lensing magnification at the given coordinates.
         """
-        return get_magnification(partial(self.raytrace, x = x), thx, thy, z_s)
+        return get_magnification(partial(self.raytrace, params = params), x, y, z_s)
 
 class ThinLens(Parametrized):
     """Base class for thin gravitational lenses.
 
     This class provides an interface for thin gravitational lenses,
     i.e., lenses that can be modeled using the thin lens
     approximation.  The class provides methods to compute several
@@ -137,194 +180,194 @@
 
     def __init__(self, name: str, cosmology: Cosmology, z_l: Optional[Tensor] = None):
         super().__init__(name)
         self.cosmology = cosmology
         self.add_param("z_l", z_l)
 
     @abstractmethod
-    def alpha(
-        self, thx: Tensor, thy: Tensor, z_s: Tensor, x: Optional[dict[str, Any]] = None
+    def reduced_deflection_angle(
+        self, x: Tensor, y: Tensor, z_s: Tensor, params: Optional["Packed"] = None
     ) -> tuple[Tensor, Tensor]:
         """
         Computes the reduced deflection angle of the lens at given coordinates [arcsec].
 
         Args:
-            thx (Tensor): Tensor of x coordinates in the lens plane.
-            thy (Tensor): Tensor of y coordinates in the lens plane.
+            x (Tensor): Tensor of x coordinates in the lens plane.
+            y (Tensor): Tensor of y coordinates in the lens plane.
             z_s (Tensor): Tensor of source redshifts.
-            x (Optional[dict[str, Any]], optional): Additional parameters for the lens model. Defaults to None.
+            params (Packed, optional): Dynamic parameter container for the lens model. Defaults to None.
 
         Returns:
             tuple[Tensor, Tensor]: Reduced deflection angle in x and y directions.
         """
         ...
 
-    def alpha_hat(
-        self, thx: Tensor, thy: Tensor, z_s: Tensor, x: Optional[dict[str, Any]] = None
+    def physical_deflection_angle(
+        self, x: Tensor, y: Tensor, z_s: Tensor, params: Optional["Packed"] = None
     ) -> tuple[Tensor, Tensor]:
         """
         Computes the physical deflection angle immediately after passing through this lens's plane.
 
         Args:
-            thx (Tensor): Tensor of x coordinates in the lens plane.
-            thy (Tensor): Tensor of y coordinates in the lens plane.
+            x (Tensor): Tensor of x coordinates in the lens plane.
+            y (Tensor): Tensor of y coordinates in the lens plane.
             z_s (Tensor): Tensor of source redshifts.
-            x (Optional[dict[str, Any]], optional): Additional parameters for the lens model. Defaults to None.
+            params (Packed, optional): Dynamic parameter container for the lens model. Defaults to None.
 
         Returns:
             tuple[Tensor, Tensor]: Physical deflection angle in x and y directions in arcseconds.
         """
-        z_l = self.unpack(x)[0]
+        z_l = self.unpack(params)[0]
 
-        d_s = self.cosmology.angular_diameter_dist(z_s, x)
-        d_ls = self.cosmology.angular_diameter_dist_z1z2(z_l, z_s, x)
-        alpha_x, alpha_y = self.alpha(thx, thy, z_s, x)
-        return (d_s / d_ls) * alpha_x, (d_s / d_ls) * alpha_y
+        d_s = self.cosmology.angular_diameter_distance(z_s, params)
+        d_ls = self.cosmology.angular_diameter_distance_z1z2(z_l, z_s, params)
+        deflection_angle_x, deflection_angle_y = self.reduced_deflection_angle(x, y, z_s, params)
+        return (d_s / d_ls) * deflection_angle_x, (d_s / d_ls) * deflection_angle_y
 
     @abstractmethod
-    def kappa(
-        self, thx: Tensor, thy: Tensor, z_s: Tensor, x: Optional[dict[str, Any]] = None
+    def convergence(
+        self, x: Tensor, y: Tensor, z_s: Tensor, params: Optional["Packed"] = None
     ) -> Tensor:
         """
         Computes the convergence of the lens at given coordinates.
 
         Args:
-            thx (Tensor): Tensor of x coordinates in the lens plane.
-            thy (Tensor): Tensor of y coordinates in the lens plane.
+            x (Tensor): Tensor of x coordinates in the lens plane.
+            y (Tensor): Tensor of y coordinates in the lens plane.
             z_s (Tensor): Tensor of source redshifts.
-            x (Optional[dict[str, Any]], optional): Additional parameters for the lens model. Defaults to None.
+            params (Packed, optional): Dynamic parameter container for the lens model. Defaults to None.
 
         Returns:
             Tensor: Convergence at the given coordinates.
         """
         ...
 
     @abstractmethod
-    def Psi(
-        self, thx: Tensor, thy: Tensor, z_s: Tensor, x: Optional[dict[str, Any]] = None
+    def potential(
+        self, x: Tensor, y: Tensor, z_s: Tensor, params: Optional["Packed"] = None
     ) -> Tensor:
         """
         Computes the gravitational lensing potential at given coordinates.
 
         Args:
-            thx (Tensor): Tensor of x coordinates in the lens plane.
-            thy (Tensor): Tensor of y coordinates in the lens plane.
+            x (Tensor): Tensor of x coordinates in the lens plane.
+            y (Tensor): Tensor of y coordinates in the lens plane.
             z_s (Tensor): Tensor of source redshifts.
-            x (Optional[dict[str, Any]], optional): Additional parameters for the lens model. Defaults to None.
+            params (Packed, optional): Dynamic parameter container for the lens model. Defaults to None.
 
         Returns: Tensor: Gravitational lensing potential at the given coordinates in arcsec^2.
         """
         ...
 
-    def Sigma(
-        self, thx: Tensor, thy: Tensor, z_s: Tensor, x: Optional[dict[str, Any]] = None
+    def surface_density(
+        self, x: Tensor, y: Tensor, z_s: Tensor, params: Optional["Packed"] = None
     ) -> Tensor:
         """
         Computes the surface mass density of the lens at given coordinates.
 
         Args:
-            thx (Tensor): Tensor of x coordinates in the lens plane.
-            thy (Tensor): Tensor of y coordinates in the lens plane.
+            x (Tensor): Tensor of x coordinates in the lens plane.
+            y (Tensor): Tensor of y coordinates in the lens plane.
             z_s (Tensor): Tensor of source redshifts.
-            x (Optional[dict[str, Any]], optional): Additional parameters for the lens model. Defaults to None.
+            params (Packed, optional): Dynamic parameter container for the lens model. Defaults to None.
 
         Returns:
             Tensor: Surface mass density at the given coordinates in solar masses per Mpc^2.
         """
         # Superclass params come before subclass ones
-        z_l = self.unpack(x)[0]
+        z_l = self.unpack(params)[0]
 
-        Sigma_cr = self.cosmology.Sigma_cr(z_l, z_s, x)
-        return self.kappa(thx, thy, z_s, x) * Sigma_cr
+        critical_surface_density = self.cosmology.critical_surface_density(z_l, z_s, params)
+        return self.convergence(x, y, z_s, params) * critical_surface_density
 
     def raytrace(
-        self, thx: Tensor, thy: Tensor, z_s: Tensor, x: Optional[dict[str, Any]] = None
+        self, x: Tensor, y: Tensor, z_s: Tensor, params: Optional["Packed"] = None
     ) -> tuple[Tensor, Tensor]:
         """
         Perform a ray-tracing operation by subtracting the deflection angles from the input coordinates.
 
         Args:
-            thx (Tensor): Tensor of x coordinates in the lens plane.
-            thy (Tensor): Tensor of y coordinates in the lens plane.
+            x (Tensor): Tensor of x coordinates in the lens plane.
+            y (Tensor): Tensor of y coordinates in the lens plane.
             z_s (Tensor): Tensor of source redshifts.
-            x (Optional[dict[str, Any]], optional): Additional parameters for the lens model. Defaults to None.
+            params (Packed, optional): Dynamic parameter container for the lens model. Defaults to None.
 
         Returns:
             tuple[Tensor, Tensor]: Ray-traced coordinates in the x and y directions.
         """
-        ax, ay = self.alpha(thx, thy, z_s, x)
-        return thx - ax, thy - ay
+        ax, ay = self.reduced_deflection_angle(x, y, z_s, params)
+        return x - ax, y - ay
 
     def time_delay(
-        self, thx: Tensor, thy: Tensor, z_s: Tensor, x: Optional[dict[str, Any]] = None
+        self, x: Tensor, y: Tensor, z_s: Tensor, params: Optional["Packed"] = None
     ):
         """
         Compute the gravitational time delay for light passing through the lens at given coordinates.
 
         Args:
-            thx (Tensor): Tensor of x coordinates in the lens plane.
-            thy (Tensor): Tensor of y coordinates in the lens plane.
+            x (Tensor): Tensor of x coordinates in the lens plane.
+            y (Tensor): Tensor of y coordinates in the lens plane.
             z_s (Tensor): Tensor of source redshifts.
-            x (Optional[dict[str, Any]], optional): Additional parameters for the lens model. Defaults to None.
+            params (Packed, optional): Dynamic parameter container for the lens model. Defaults to None.
 
         Returns:
             Tensor: Time delay at the given coordinates.
         """
-        z_l = self.unpack(x)[0]
+        z_l = self.unpack(params)[0]
 
-        d_l = self.cosmology.angular_diameter_dist(z_l, x)
-        d_s = self.cosmology.angular_diameter_dist(z_s, x)
-        d_ls = self.cosmology.angular_diameter_dist_z1z2(z_l, z_s, x)
-        ax, ay = self.alpha(thx, thy, z_s, x)
-        Psi = self.Psi(thx, thy, z_s, x)
+        d_l = self.cosmology.angular_diameter_distance(z_l, params)
+        d_s = self.cosmology.angular_diameter_distance(z_s, params)
+        d_ls = self.cosmology.angular_diameter_distance_z1z2(z_l, z_s, params)
+        ax, ay = self.reduced_deflection_angle(x, y, z_s, params)
+        potential = self.potential(x, y, z_s, params)
         factor = (1 + z_l) / c_Mpc_s * d_s * d_l / d_ls
-        fp = 0.5 * d_ls**2 / d_s**2 * (ax**2 + ay**2) - Psi
+        fp = 0.5 * d_ls**2 / d_s**2 * (ax**2 + ay**2) - potential
         return factor * fp * arcsec_to_rad**2
 
     def _lensing_jacobian_fft_method(
-        self, thx: Tensor, thy: Tensor, z_s: Tensor, x: Optional[dict[str, Any]] = None
+        self, x: Tensor, y: Tensor, z_s: Tensor, params: Optional["Packed"] = None
     ) -> Tensor:
         """
         Compute the lensing Jacobian using the Fast Fourier Transform method.
 
         Args:
-            thx (Tensor): Tensor of x coordinates in the lens plane.
-            thy (Tensor): Tensor of y coordinates in the lens plane.
+            x (Tensor): Tensor of x coordinates in the lens plane.
+            y (Tensor): Tensor of y coordinates in the lens plane.
             z_s (Tensor): Tensor of source redshifts.
-            x (Optional[dict[str, Any]], optional): Additional parameters for the lens model. Defaults to None.
+            params (Packed, optional): Dynamic parameter container for the lens model. Defaults to None.
 
         Returns:
             Tensor: Lensing Jacobian at the given coordinates.
         """
-        psi = self.Psi(thx, thy, z_s, x)
-        # quick dirty work to get kx and ky. Assumes thx and thy come from meshgrid... TODO Might want to get k differently
-        n = thx.shape[-1]
-        d = torch.abs(thx[0, 0] - thx[0, 1])
+        potential = self.potential(x, y, z_s, params)
+        # quick dirty work to get kx and ky. Assumes x and y come from meshgrid... TODO Might want to get k differently
+        n = x.shape[-1]
+        d = torch.abs(x[0, 0] - x[0, 1])
         k = torch.fft.fftfreq(2 * n, d=d)
         kx, ky = torch.meshgrid([k, k], indexing="xy")
         # Now we compute second derivatives in Fourier space, then inverse Fourier transform and unpad
         pad = 2 * n
-        psi_tilde = torch.fft.fft(psi, (pad, pad))
-        psi_xx = torch.abs(torch.fft.ifft2(-(kx**2) * psi_tilde))[..., :n, :n]
-        psi_yy = torch.abs(torch.fft.ifft2(-(ky**2) * psi_tilde))[..., :n, :n]
-        psi_xy = torch.abs(torch.fft.ifft2(-kx * ky * psi_tilde))[..., :n, :n]
+        potential_tilde = torch.fft.fft(potential, (pad, pad))
+        potential_xx = torch.abs(torch.fft.ifft2(-(kx**2) * potential_tilde))[..., :n, :n]
+        potential_yy = torch.abs(torch.fft.ifft2(-(ky**2) * potential_tilde))[..., :n, :n]
+        potential_xy = torch.abs(torch.fft.ifft2(-kx * ky * potential_tilde))[..., :n, :n]
         j1 = torch.stack(
-            [1 - psi_xx, -psi_xy], dim=-1
+            [1 - potential_xx, -potential_xy], dim=-1
         )  # Equation 2.33 from Meneghetti lensing lectures
-        j2 = torch.stack([-psi_xy, 1 - psi_yy], dim=-1)
+        j2 = torch.stack([-potential_xy, 1 - potential_yy], dim=-1)
         jacobian = torch.stack([j1, j2], dim=-1)
         return jacobian
 
-    def magnification(self, thx: Tensor, thy: Tensor, z_s: Tensor, x) -> Tensor:
+    def magnification(self, x: Tensor, y: Tensor, z_s: Tensor, params: Optional["Packed"] = None) -> Tensor:
         """
         Compute the gravitational magnification at the given coordinates.
 
         Args:
-            thx (Tensor): Tensor of x coordinates in the lens plane.
-            thy (Tensor): Tensor of y coordinates in the lens plane.
+            x (Tensor): Tensor of x coordinates in the lens plane.
+            y (Tensor): Tensor of y coordinates in the lens plane.
             z_s (Tensor): Tensor of source redshifts.
-            x (Optional[dict[str, Any]], optional): Additional parameters for the lens model. Defaults to None.
+            params (Packed, optional): Dynamic parameter container for the lens model. Defaults to None.
 
         Returns:
             Tensor: Gravitational magnification at the given coordinates.
         """
-        return get_magnification(partial(self.raytrace, x = x), thx, thy, z_s)
+        return get_magnification(partial(self.raytrace, params = params), x, y, z_s)
```

## caustic/lenses/epl.py

```diff
@@ -19,85 +19,85 @@
 
     Attributes:
         n_iter (int): Number of iterations for the iterative solver.
         s (float): Softening length for the elliptical power-law profile.
     
     Parameters:
         z_l (Tensor, optional): This is the redshift of the lens. In the context of gravitational lensing, the lens is the galaxy or other mass distribution that is bending the light from a more distant source.
-        thx0 and thy0 (Tensors, optional): These are the coordinates of the lens center in the lens plane. The lens plane is the plane perpendicular to the line of sight in which the deflection of light by the lens is considered.
+        x0 and y0 (Tensors, optional): These are the coordinates of the lens center in the lens plane. The lens plane is the plane perpendicular to the line of sight in which the deflection of light by the lens is considered.
         q (Tensor, optional): This is the axis ratio of the lens, i.e., the ratio of the minor axis to the major axis of the elliptical lens.
         phi (Tensor, optional): This is the orientation of the lens on the sky, typically given as an angle measured counter-clockwise from some reference direction.
         b (Tensor, optional): This is the scale length of the lens, which sets the overall scale of the lensing effect. In some contexts, this is referred to as the Einstein radius.
         t (Tensor, optional): This is the power-law slope parameter of the lens model. In the context of the EPL model, t is equivalent to the gamma parameter minus one, where gamma is the power-law index of the radial mass distribution of the lens.
 
     """
 
     def __init__(
         self,
         name: str,
         cosmology: Cosmology,
         z_l: Optional[Tensor] = None,
-        thx0: Optional[Tensor] = None,
-        thy0: Optional[Tensor] = None,
+        x0: Optional[Tensor] = None,
+        y0: Optional[Tensor] = None,
         q: Optional[Tensor] = None,
         phi: Optional[Tensor] = None,
         b: Optional[Tensor] = None,
         t: Optional[Tensor] = None,
         s: float = 0.0,
         n_iter: int = 18,
     ):
         """
         Initialize an EPL lens model.
 
         Args:
             name (str): Name of the lens model.
             cosmology (Cosmology): Cosmology object that provides cosmological distance calculations.
             z_l (Optional[Tensor]): Redshift of the lens. If not provided, it is considered as a free parameter.
-            thx0 (Optional[Tensor]): X coordinate of the lens center. If not provided, it is considered as a free parameter.
-            thy0 (Optional[Tensor]): Y coordinate of the lens center. If not provided, it is considered as a free parameter.
+            x0 (Optional[Tensor]): X coordinate of the lens center. If not provided, it is considered as a free parameter.
+            y0 (Optional[Tensor]): Y coordinate of the lens center. If not provided, it is considered as a free parameter.
             q (Optional[Tensor]): Axis ratio of the lens. If not provided, it is considered as a free parameter.
             phi (Optional[Tensor]): Position angle of the lens. If not provided, it is considered as a free parameter.
             b (Optional[Tensor]): Scale length of the lens. If not provided, it is considered as a free parameter.
             t (Optional[Tensor]): Power law slope (`gamma-1`) of the lens. If not provided, it is considered as a free parameter.
             s (float): Softening length for the elliptical power-law profile.
             n_iter (int): Number of iterations for the iterative solver.
         """
         super().__init__(name, cosmology, z_l)
 
-        self.add_param("thx0", thx0)
-        self.add_param("thy0", thy0)
+        self.add_param("x0", x0)
+        self.add_param("y0", y0)
         self.add_param("q", q)
         self.add_param("phi", phi)
         self.add_param("b", b)
         self.add_param("t", t)
         self.s = s
 
         self.n_iter = n_iter
 
-    def alpha(
-        self, thx: Tensor, thy: Tensor, z_s: Tensor, x: Optional[dict[str, Any]] = None
+    def reduced_deflection_angle(
+        self, x: Tensor, y: Tensor, z_s: Tensor, params: Optional["Packed"] = None
     ) -> tuple[Tensor, Tensor]:
         """
         Compute the reduced deflection angles of the lens.
 
         Args:
-            thx (Tensor): X coordinates in the lens plane.
-            thy (Tensor): Y coordinates in the lens plane.
+            x (Tensor): X coordinates in the lens plane.
+            y (Tensor): Y coordinates in the lens plane.
             z_s (Tensor): Source redshifts.
-            x (Optional[dict[str, Any]]): Additional parameters for the lens model.
+            params (Packed, optional): Dynamic parameter container for the lens model.
 
         Returns:
             tuple[Tensor, Tensor]: Reduced deflection angles in the x and y directions.
         """
-        z_l, thx0, thy0, q, phi, b, t = self.unpack(x)
+        z_l, x0, y0, q, phi, b, t = self.unpack(params)
 
-        thx, thy = translate_rotate(thx, thy, thx0, thy0, phi)
+        x, y = translate_rotate(x, y, x0, y0, phi)
 
         # follow Tessore et al 2015 (eq. 5)
-        z = q * thx + thy * 1j
+        z = q * x + y * 1j
         r = torch.abs(z)
 
         # Tessore et al 2015 (eq. 23)
         r_omega = self._r_omega(z, t, q)
         alpha_c = 2.0 / (1.0 + q) * (b / r) ** t * r_omega
 
         alpha_real = torch.nan_to_num(alpha_c.real, posinf=10**10, neginf=-(10**10))
@@ -127,49 +127,49 @@
         for i in range(1, self.n_iter):
             factor = (2.0 * i - (2.0 - t)) / (2.0 * i + (2.0 - t))
             omega_i = -f * factor * phi * omega_i
             part_sum = part_sum + omega_i
 
         return part_sum
 
-    def Psi(
-        self, thx: Tensor, thy: Tensor, z_s: Tensor, x: Optional[dict[str, Any]] = None
+    def potential(
+        self, x: Tensor, y: Tensor, z_s: Tensor, params: Optional["Packed"] = None
     ):
         """
         Compute the lensing potential of the lens.
 
         Args:
-            thx (Tensor): X coordinates in the lens plane.
-            thy (Tensor): Y coordinates in the lens plane.
+            x (Tensor): X coordinates in the lens plane.
+            y (Tensor): Y coordinates in the lens plane.
             z_s (Tensor): Source redshifts.
-            x (Optional[dict[str, Any]]): Additional parameters for the lens model.
+            params (Packed, optional): Dynamic parameter container for the lens model.
 
         Returns:
             Tensor: The lensing potential.
         """
-        z_l, thx0, thy0, q, phi, b, t = self.unpack(x)
+        z_l, x0, y0, q, phi, b, t = self.unpack(params)
 
-        ax, ay = self.alpha(thx, thy, z_s, x)
+        ax, ay = self.reduced_deflection_angle(x, y, z_s, params)
         ax, ay = derotate(ax, ay, -phi)
-        thx, thy = translate_rotate(thx, thy, thx0, thy0, phi)
-        return (thx * ax + thy * ay) / (2 - t)
+        x, y = translate_rotate(x, y, x0, y0, phi)
+        return (x * ax + y * ay) / (2 - t)
 
-    def kappa(
-        self, thx: Tensor, thy: Tensor, z_s: Tensor, x: Optional[dict[str, Any]] = None
+    def convergence(
+        self, x: Tensor, y: Tensor, z_s: Tensor, params: Optional["Packed"] = None
     ):
         """
         Compute the convergence of the lens, which describes the local density of the lens.
 
         Args:
-            thx (Tensor): X coordinates in the lens plane.
-            thy (Tensor): Y coordinates in the lens plane.
+            x (Tensor): X coordinates in the lens plane.
+            y (Tensor): Y coordinates in the lens plane.
             z_s (Tensor): Source redshifts.
-            x (Optional[dict[str, Any]]): Additional parameters for the lens model.
+            params (Packed, optional): Dynamic parameter container for the lens model.
 
         Returns:
             Tensor: The convergence of the lens.
         """
-        z_l, thx0, thy0, q, phi, b, t = self.unpack(x)
+        z_l, x0, y0, q, phi, b, t = self.unpack(params)
 
-        thx, thy = translate_rotate(thx, thy, thx0, thy0, phi)
-        psi = (q**2 * (thx**2 + self.s**2) + thy**2).sqrt()
+        x, y = translate_rotate(x, y, x0, y0, phi)
+        psi = (q**2 * (x**2 + self.s**2) + y**2).sqrt()
         return (2 - t) / 2 * (b / psi) ** t
```

## caustic/lenses/external_shear.py

```diff
@@ -13,92 +13,92 @@
     """
     Represents an external shear effect in a gravitational lensing system.
 
     Attributes:
         name (str): Identifier for the lens instance.
         cosmology (Cosmology): The cosmological model used for lensing calculations.
         z_l (Optional[Tensor]): The redshift of the lens.
-        thx0, thy0 (Optional[Tensor]): Coordinates of the shear center in the lens plane.
+        x0, y0 (Optional[Tensor]): Coordinates of the shear center in the lens plane.
         gamma_1, gamma_2 (Optional[Tensor]): Shear components.
 
     Note: The shear components gamma_1 and gamma_2 represent an external shear, a gravitational 
     distortion that can be caused by nearby structures outside of the main lens galaxy. 
     """
     def __init__(
         self,
         name: str,
         cosmology: Cosmology,
         z_l: Optional[Tensor] = None,
-        thx0: Optional[Tensor] = None,
-        thy0: Optional[Tensor] = None,
+        x0: Optional[Tensor] = None,
+        y0: Optional[Tensor] = None,
         gamma_1: Optional[Tensor] = None,
         gamma_2: Optional[Tensor] = None,
     ):
         
         super().__init__(name, cosmology, z_l)
 
-        self.add_param("thx0", thx0)
-        self.add_param("thy0", thy0)
+        self.add_param("x0", x0)
+        self.add_param("y0", y0)
         self.add_param("gamma_1", gamma_1)
         self.add_param("gamma_2", gamma_2)
 
-    def alpha(
-        self, thx: Tensor, thy: Tensor, z_s: Tensor, x: Optional[dict[str, Any]] = None
+    def reduced_deflection_angle(
+        self, x: Tensor, y: Tensor, z_s: Tensor, params: Optional["Packed"] = None
     ) -> tuple[Tensor, Tensor]:
         """
         Calculates the reduced deflection angle.
 
         Args:
-            thx (Tensor): x-coordinates in the lens plane.
-            thy (Tensor): y-coordinates in the lens plane.
+            x (Tensor): x-coordinates in the lens plane.
+            y (Tensor): y-coordinates in the lens plane.
             z_s (Tensor): Redshifts of the sources.
-            x (Optional[dict[str, Any]]): Additional parameters.
+            params (Packed, optional): Dynamic parameter container.
 
         Returns:
             tuple[Tensor, Tensor]: The reduced deflection angles in the x and y directions.
         """
-        z_l, thx0, thy0, gamma_1, gamma_2 = self.unpack(x)
+        z_l, x0, y0, gamma_1, gamma_2 = self.unpack(params)
 
-        thx, thy = translate_rotate(thx, thy, thx0, thy0)
+        x, y = translate_rotate(x, y, x0, y0)
         # Meneghetti eq 3.83
-        a1 = thx * gamma_1 + thy * gamma_2
-        a2 = thx * gamma_2 - thy * gamma_1
+        a1 = x * gamma_1 + y * gamma_2
+        a2 = x * gamma_2 - y * gamma_1
         return a1, a2  # I'm not sure but I think no derotation necessary
 
-    def Psi(
-        self, thx: Tensor, thy: Tensor, z_s: Tensor, x: Optional[dict[str, Any]] = None
+    def potential(
+        self, x: Tensor, y: Tensor, z_s: Tensor, params: Optional["Packed"] = None
     ) -> Tensor:
         """
         Calculates the lensing potential.
 
         Args:
-            thx (Tensor): x-coordinates in the lens plane.
-            thy (Tensor): y-coordinates in the lens plane.
+            x (Tensor): x-coordinates in the lens plane.
+            y (Tensor): y-coordinates in the lens plane.
             z_s (Tensor): Redshifts of the sources.
-            x (Optional[dict[str, Any]]): Additional parameters.
+            params (Packed, optional): Dynamic parameter container.
 
         Returns:
             Tensor: The lensing potential.
         """
-        z_l, thx0, thy0, gamma_1, gamma_2 = self.unpack(x)
+        z_l, x0, y0, gamma_1, gamma_2 = self.unpack(params)
 
-        ax, ay = self.alpha(thx, thy, z_s, x)
-        thx, thy = translate_rotate(thx, thy, thx0, thy0)
-        return 0.5 * (thx * ax + thy * ay)
+        ax, ay = self.reduced_deflection_angle(x, y, z_s, params)
+        x, y = translate_rotate(x, y, x0, y0)
+        return 0.5 * (x * ax + y * ay)
 
-    def kappa(
-        self, thx: Tensor, thy: Tensor, z_s: Tensor, x: Optional[dict[str, Any]] = None
+    def convergence(
+        self, x: Tensor, y: Tensor, z_s: Tensor, params: Optional["Packed"] = None
     ) -> Tensor:
         """
         The convergence is undefined for an external shear.
 
         Args:
-            thx (Tensor): x-coordinates in the lens plane.
-            thy (Tensor): y-coordinates in the lens plane.
+            x (Tensor): x-coordinates in the lens plane.
+            y (Tensor): y-coordinates in the lens plane.
             z_s (Tensor): Redshifts of the sources.
-            x (Optional[dict[str, Any]]): Additional parameters.
+            params (Packed, optional): Dynamic parameter container.
 
         Raises:
             NotImplementedError: This method is not implemented as the convergence is not defined 
             for an external shear.
         """
         raise NotImplementedError("convergence undefined for external shear")
```

## caustic/lenses/multiplane.py

```diff
@@ -3,18 +3,18 @@
 
 import torch
 from torch import Tensor
 
 from ..cosmology import Cosmology
 from .base import ThickLens, ThinLens
 
-__all__ = ("MultiplaneLens",)
+__all__ = ("Multiplane",)
 
 
-class MultiplaneLens(ThickLens):
+class Multiplane(ThickLens):
     """
     Class for handling gravitational lensing with multiple lens planes.
 
     Attributes:
         lenses (list[ThinLens]): List of thin lenses.
 
     Args:
@@ -24,73 +24,71 @@
     """
     def __init__(self, name: str, cosmology: Cosmology, lenses: list[ThinLens]):
         super().__init__(name, cosmology)
         self.lenses = lenses
         for lens in lenses:
             self.add_parametrized(lens)
 
-    def get_z_ls(self, x: Optional[dict[str, Any]]) -> list[Tensor]:
+    def get_z_ls(self, params: Optional["Packed"]) -> list[Tensor]:
         """
         Get the redshifts of each lens in the multiplane.
 
         Args:
-            x (Optional[dict[str, Any]]): Additional parameters.
+            params (Packed, optional): Dynamic parameter container.
 
         Returns:
             List[Tensor]: Redshifts of the lenses.
         """
         # Relies on z_l being the first element to be unpacked, which should always
         # be the case for a ThinLens
-        return [lens.unpack(x)[0] for lens in self.lenses]
+        return [lens.unpack(params)[0] for lens in self.lenses]
 
     def raytrace(
-        self, thx: Tensor, thy: Tensor, z_s: Tensor, x: Optional[dict[str, Any]] = None
+        self, x: Tensor, y: Tensor, z_s: Tensor, params: Optional["Packed"] = None
     ) -> tuple[Tensor, Tensor]:
-        """
-        Calculate the reduced deflection angle [arcsec].
+        """Calculate the angular source positions corresponding to the
+        observer positions x,y. See Margarita et al. 2013 for the
+        formalism from the GLAMER -II code:
+        https://ui.adsabs.harvard.edu/abs/2014MNRAS.445.1954P/abstract
 
         Args:
-            thx (Tensor): x-coordinates in the lens plane.
-            thy (Tensor): y-coordinates in the lens plane.
+            x (Tensor): angular x-coordinates from the observer perspective.
+            y (Tensor): angular y-coordinates from the observer perspective.
             z_s (Tensor): Redshifts of the sources.
-            x (Optional[dict[str, Any]]): Additional parameters.
+            params (Packed, optional): Dynamic parameter container.
 
         Returns:
             tuple[Tensor, Tensor]: The reduced deflection angle.
+
         """
         zero = torch.tensor(0.0, dtype=z_s.dtype, device=z_s.device)
-
         # argsort redshifts
-        z_ls = self.get_z_ls(x)
+        z_ls = self.get_z_ls(params)
         idxs = [i for i, _ in sorted(enumerate(z_ls), key=itemgetter(1))]
-        D_0_s = self.cosmology.comoving_dist(z_s)
+        D_0_s = self.cosmology.comoving_distance(z_s, params)
         X_im1 = 0.0
         Y_im1 = 0.0
-        X_i = None
-        Y_i = None
+        X_i = self.cosmology.comoving_distance(z_ls[0], params) * x 
+        Y_i = self.cosmology.comoving_distance(z_ls[0], params) * y 
         X_ip1 = None
         Y_ip1 = None
 
         for i in idxs:
             z_im1 = zero if i == 0 else z_ls[i - 1]
             z_i = z_ls[i]
             z_ip1 = z_s if i == len(z_ls) - 1 else z_ls[i + 1]
 
-            D_im1_i = self.cosmology.comoving_dist_z1z2(z_im1, z_i)
-            D_i_ip1 = self.cosmology.comoving_dist_z1z2(z_i, z_ip1)
-            D_0_i = self.cosmology.comoving_dist(z_i)
-            D_i_s = self.cosmology.comoving_dist_z1z2(z_i, z_s)
+            D_im1_i = self.cosmology.comoving_distance_z1z2(z_im1, z_i, params)
+            D_i_ip1 = self.cosmology.comoving_distance_z1z2(z_i, z_ip1, params)
+            D_0_i = self.cosmology.comoving_distance(z_i, params)
+            D_i_s = self.cosmology.comoving_distance_z1z2(z_i, z_s, params)
             D_ratio = D_0_s / D_i_s
 
-            # Collect current alphas
-            X_i = D_0_i * thx if X_i is None else X_i
-            Y_i = D_0_i * thy if Y_i is None else Y_i
-
             # Get alphas at next plane
-            ax, ay = self.lenses[i].alpha(X_i / D_0_i, Y_i / D_0_i, z_ip1, x)
+            ax, ay = self.lenses[i].reduced_deflection_angle(X_i / D_0_i, Y_i / D_0_i, z_ip1, params)
             X_ip1 = (
                 (D_i_ip1 / D_im1_i + 1) * X_i
                 - (D_i_ip1 / D_im1_i) * X_im1
                 - D_i_ip1 * D_ratio * ax
             )
             Y_ip1 = (
                 (D_i_ip1 / D_im1_i + 1) * Y_i
@@ -102,68 +100,56 @@
             X_im1 = X_i
             Y_im1 = Y_i
             X_i = X_ip1
             Y_i = Y_ip1
 
         # Handle edge case of lenses = []
         if X_ip1 is None or Y_ip1 is None:
-            return thx, thy
+            return x, y
         else:
             return X_ip1 / D_0_s, Y_ip1 / D_0_s
-
-    def alpha(
-        self, thx: Tensor, thy: Tensor, z_s: Tensor, x: Optional[dict[str, Any]] = None
+        
+    def effective_reduced_deflection_angle(
+        self, x: Tensor, y: Tensor, z_s: Tensor, params: Optional["Packed"] = None
     ) -> tuple[Tensor, Tensor]:
-        """
-        Calculate the reduced deflection angle [arcsec].
-
-        Args:
-            thx (Tensor): x-coordinates in the lens plane.
-            thy (Tensor): y-coordinates in the lens plane.
-            z_s (Tensor): Redshifts of the sources.
-            x (Optional[dict[str, Any]]): Additional parameters.
-
-        Returns:
-            tuple[Tensor, Tensor]: The reduced deflection angle.
-        """
-        bx, by = self.raytrace(thx, thy, z_s, x)
-        return thx - bx, thy - by
+        bx, by = self.raytrace(x, y, z_s, params)
+        return x - bx, y - by
 
-    def Sigma(
-        self, thx: Tensor, thy: Tensor, z_s: Tensor, x: Optional[dict[str, Any]] = None
+    def surface_density(
+        self, x: Tensor, y: Tensor, z_s: Tensor, params: Optional["Packed"] = None
     ) -> Tensor:
         """
         Calculate the projected mass density.
 
         Args:
-            thx (Tensor): x-coordinates in the lens plane.
-            thy (Tensor): y-coordinates in the lens plane.
+            x (Tensor): x-coordinates in the lens plane.
+            y (Tensor): y-coordinates in the lens plane.
             z_s (Tensor): Redshifts of the sources.
-            x (Optional[dict[str, Any]]): Additional parameters.
+            params (Packed, optional): Dynamic parameter container.
 
         Returns:
             Tensor: Projected mass density [solMass / Mpc^2].
 
         Raises:
             NotImplementedError: This method is not yet implemented.
         """
         # TODO: rescale mass densities of each lens and sum
         raise NotImplementedError()
 
     def time_delay(
-        self, thx: Tensor, thy: Tensor, z_s: Tensor, x: Optional[dict[str, Any]] = None
+        self, x: Tensor, y: Tensor, z_s: Tensor, params: Optional["Packed"] = None
     ) -> Tensor:
         """
         Compute the time delay of light caused by the lensing.
 
         Args:
-            thx (Tensor): x-coordinates in the lens plane.
-            thy (Tensor): y-coordinates in the lens plane.
+            x (Tensor): x-coordinates in the lens plane.
+            y (Tensor): y-coordinates in the lens plane.
             z_s (Tensor): Redshifts of the sources.
-            x (Optional[dict[str, Any]]): Additional parameters.
+            params (Packed, optional): Dynamic parameter container.
 
         Returns:
             Tensor: Time delay caused by the lensing.
 
         Raises:
             NotImplementedError: This method is not yet implemented.
         """
```

## caustic/lenses/nfw.py

```diff
@@ -18,127 +18,127 @@
     """
     NFW lens class. This class models a lens using the Navarro-Frenk-White (NFW) profile.
     The NFW profile is a spatial density profile of dark matter halo that arises in 
     cosmological simulations.
 
     Attributes:
         z_l (Optional[Tensor]): Redshift of the lens. Default is None.
-        thx0 (Optional[Tensor]): x-coordinate of the lens center in the lens plane. 
+        x0 (Optional[Tensor]): x-coordinate of the lens center in the lens plane. 
             Default is None.
-        thy0 (Optional[Tensor]): y-coordinate of the lens center in the lens plane. 
+        y0 (Optional[Tensor]): y-coordinate of the lens center in the lens plane. 
             Default is None.
         m (Optional[Tensor]): Mass of the lens. Default is None.
         c (Optional[Tensor]): Concentration parameter of the lens. Default is None.
         s (float): Softening parameter to avoid singularities at the center of the lens. 
             Default is 0.0.
 
     Methods:
-        get_r_s: Returns the scale radius of the lens.
-        get_rho_s: Returns the scale density of the lens.
-        get_kappa_s: Returns the dimensionless surface mass density of the lens.
+        get_scale_radius: Returns the scale radius of the lens.
+        get_scale_density: Returns the scale density of the lens.
+        get_convergence_s: Returns the dimensionless surface mass density of the lens.
         _f: Helper method for computing deflection angles.
         _g: Helper method for computing lensing potential.
         _h: Helper method for computing reduced deflection angles.
-        alpha_hat: Computes the reduced deflection angle.
-        alpha: Computes the deflection angle.
-        kappa: Computes the convergence (dimensionless surface mass density).
-        Psi: Computes the lensing potential.
+        deflection_angle_hat: Computes the reduced deflection angle.
+        deflection_angle: Computes the deflection angle.
+        convergence: Computes the convergence (dimensionless surface mass density).
+        potential: Computes the lensing potential.
     """
     def __init__(
         self,
         name: str,
         cosmology: Cosmology,
         z_l: Optional[Tensor] = None,
-        thx0: Optional[Tensor] = None,
-        thy0: Optional[Tensor] = None,
+        x0: Optional[Tensor] = None,
+        y0: Optional[Tensor] = None,
         m: Optional[Tensor] = None,
         c: Optional[Tensor] = None,
         s: float = 0.0,
     ):
         """
         Initialize an instance of the NFW lens class.
 
         Args:
             name (str): Name of the lens instance.
             cosmology (Cosmology): An instance of the Cosmology class which contains 
                 information about the cosmological model and parameters.
             z_l (Optional[Tensor]): Redshift of the lens. Default is None.
-            thx0 (Optional[Tensor]): x-coordinate of the lens center in the lens plane. 
+            x0 (Optional[Tensor]): x-coordinate of the lens center in the lens plane. 
                 Default is None.
-            thy0 (Optional[Tensor]): y-coordinate of the lens center in the lens plane. 
+            y0 (Optional[Tensor]): y-coordinate of the lens center in the lens plane. 
                 Default is None.
             m (Optional[Tensor]): Mass of the lens. Default is None.
             c (Optional[Tensor]): Concentration parameter of the lens. Default is None.
             s (float): Softening parameter to avoid singularities at the center of the lens. 
                 Default is 0.0.
         """
         super().__init__(name, cosmology, z_l)
 
-        self.add_param("thx0", thx0)
-        self.add_param("thy0", thy0)
+        self.add_param("x0", x0)
+        self.add_param("y0", y0)
         self.add_param("m", m)
         self.add_param("c", c)
         self.s = s
 
-    def get_r_s(self, z_l, m, c, x) -> Tensor:
+    def get_scale_radius(self, z_l, m, c, params: Optional["Packed"]) -> Tensor:
         """
         Calculate the scale radius of the lens.
 
         Args:
             z_l (Tensor): Redshift of the lens.
             m (Tensor): Mass of the lens.
             c (Tensor): Concentration parameter of the lens.
-            x (dict): Additional parameters.
+            x (dict): Dynamic parameter container.
 
         Returns:
             Tensor: The scale radius of the lens in Mpc.
         """
-        rho_cr = self.cosmology.rho_cr(z_l, x)
-        r_delta = (3 * m / (4 * pi * DELTA * rho_cr)) ** (1 / 3)
+        critical_density = self.cosmology.critical_density(z_l, params)
+        r_delta = (3 * m / (4 * pi * DELTA * critical_density)) ** (1 / 3)
         return 1 / c * r_delta
 
-    def get_rho_s(self, z_l, c, x) -> Tensor:
+    def get_scale_density(self, z_l, c, params: Optional["Packed"]) -> Tensor:
         """
         Calculate the scale density of the lens.
 
         Args:
             z_l (Tensor): Redshift of the lens.
             c (Tensor): Concentration parameter of the lens.
-            x (dict): Additional parameters.
+            params (Packed, optional): Dynamic parameter container.
 
         Returns:
             Tensor: The scale density of the lens in solar masses per Mpc cubed.
         """
         return (
             DELTA
             / 3
-            * self.cosmology.rho_cr(z_l, x)
+            * self.cosmology.critical_density(z_l, params)
             * c**3
             / ((1 + c).log() - c / (1 + c))
         )
 
-    def get_kappa_s(self, z_l, z_s, m, c, x) -> Tensor:
+    def get_convergence_s(self, z_l, z_s, m, c, params) -> Tensor:
         """
         Calculate the dimensionless surface mass density of the lens.
 
         Args:
             z_l (Tensor): Redshift of the lens.
             z_s (Tensor): Redshift of the source.
             m (Tensor): Mass of the lens.
             c (Tensor): Concentration parameter of the lens.
-            x (dict): Additional parameters.
+            params (Packed, optional): Dynamic parameter container.
 
         Returns:
             Tensor: The dimensionless surface mass density of the lens.
         """
-        Sigma_cr = self.cosmology.Sigma_cr(z_l, z_s)
-        return self.get_rho_s(z_l, c, x) * self.get_r_s(z_l, m, c, x) / Sigma_cr
+        critical_surface_density = self.cosmology.critical_surface_density(z_l, z_s, params)
+        return self.get_scale_density(z_l, c, params) * self.get_scale_radius(z_l, m, c, params) / critical_surface_density
 
-    @classmethod
-    def _f(cls, x: Tensor) -> Tensor:
+    @staticmethod
+    def _f(x: Tensor) -> Tensor:
         """
         Helper method for computing deflection angles.
 
         Args:
             x (Tensor): The scaled radius (xi / xi_0).
 
         Returns:
@@ -151,16 +151,16 @@
             torch.where(
                 x < 1,
                 1 - 2 / (1 - x**2).sqrt() * ((1 - x) / (1 + x)).sqrt().arctanh(),
                 0.0,
             ),
         )
 
-    @classmethod
-    def _g(cls, x: Tensor) -> Tensor:
+    @staticmethod
+    def _g(x: Tensor) -> Tensor:
         """
         Helper method for computing lensing potential.
 
         Args:
             x (Tensor): The scaled radius (xi / xi_0).
 
         Returns:
@@ -171,16 +171,16 @@
         term_2 = torch.where(
             x > 1,
             (1 / x).arccos() ** 2,
             torch.where(x < 1, -(1 / x).arccosh() ** 2, 0.0),
         )
         return term_1 + term_2
 
-    @classmethod
-    def _h(cls, x: Tensor) -> Tensor:
+    @staticmethod
+    def _h(x: Tensor) -> Tensor:
         """
         Helper method for computing reduced deflection angles.
 
         Args:
             x (Tensor): The scaled radius (xi / xi_0).
 
         Returns:
@@ -194,119 +194,99 @@
                 x < 1,
                 term_1 + (1 / x).arccosh() * 1 / (1 - x**2).sqrt(),
                 1.0 + torch.tensor(1 / 2).log(),
             ),
         )
         return term_2
 
-    def alpha_hat(
-        self, thx: Tensor, thy: Tensor, z_s: Tensor, x: Optional[dict[str, Any]] = None
+    def reduced_deflection_angle(
+        self, x: Tensor, y: Tensor, z_s: Tensor, params: Optional["Packed"] = None
     ) -> tuple[Tensor, Tensor]:
         """
         Compute the reduced deflection angle.
 
         Args:
-            thx (Tensor): x-coordinates in the lens plane.
-            thy (Tensor): y-coordinates in the lens plane.
+            x (Tensor): x-coordinates in the lens plane.
+            y (Tensor): y-coordinates in the lens plane.
             z_s (Tensor): Redshifts of the sources.
-            x (Optional[dict[str, Any]]): Additional parameters.
+            params (Packed, optional): Dynamic parameter container.
 
         Returns:
             tuple[Tensor, Tensor]: The reduced deflection angles in the x and y directions.
         """
-        z_l, thx0, thy0, m, c = self.unpack(x)
+        z_l, x0, y0, m, c = self.unpack(params)
 
-        thx, thy = translate_rotate(thx, thy, thx0, thy0)
-        th = (thx**2 + thy**2).sqrt() + self.s
-        d_l = self.cosmology.angular_diameter_dist(z_l)
-        r_s = self.get_r_s(z_l, m, c, x)
+        x, y = translate_rotate(x, y, x0, y0)
+        th = (x**2 + y**2).sqrt() + self.s
+        d_l = self.cosmology.angular_diameter_distance(z_l, params)
+        scale_radius = self.get_scale_radius(z_l, m, c, params)
         xi = d_l * th * arcsec_to_rad
-        r = xi / r_s
+        r = xi / scale_radius
 
-        alpha = (
+        deflection_angle = (
             16
             * pi
             * G_over_c2
-            * self.get_rho_s(z_l, c, x)
-            * r_s**3
+            * self.get_scale_density(z_l, c, params)
+            * scale_radius**3
             * self._h(r)
             * rad_to_arcsec
             / xi
         )
 
-        ax = alpha * thx / th
-        ay = alpha * thy / th
-        return ax, ay
+        ax = deflection_angle * x / th
+        ay = deflection_angle * y / th
+        d_s = self.cosmology.angular_diameter_distance(z_s, params)
+        d_ls = self.cosmology.angular_diameter_distance_z1z2(z_l, z_s, params)
+        return ax * d_ls / d_s, ay * d_ls / d_s
 
-    def alpha(
-        self, thx: Tensor, thy: Tensor, z_s: Tensor, x: Optional[dict[str, Any]] = None
-    ) -> tuple[Tensor, Tensor]:
-        """
-        Compute the deflection angle.
-
-        Args:
-            thx (Tensor): x-coordinates in the lens plane.
-            thy (Tensor): y-coordinates in the lens plane.
-            z_s (Tensor): Redshifts of the sources.
-            x (Optional[dict[str, Any]]): Additional parameters.
-
-        Returns:
-            tuple[Tensor, Tensor]: The deflection angles in the x and y directions.
-        """
-        z_l = self.unpack(x)[0]
-
-        d_s = self.cosmology.angular_diameter_dist(z_s, x)
-        d_ls = self.cosmology.angular_diameter_dist_z1z2(z_l, z_s, x)
-        ahx, ahy = self.alpha_hat(thx, thy, z_s, x)
-        return d_ls / d_s * ahx, d_ls / d_s * ahy
-
-    def kappa(
-        self, thx: Tensor, thy: Tensor, z_s: Tensor, x: Optional[dict[str, Any]] = None
+    def convergence(
+        self, x: Tensor, y: Tensor, z_s: Tensor, params: Optional["Packed"] = None
     ) -> Tensor:
         """
         Compute the convergence (dimensionless surface mass density).
 
         Args:
-            thx (Tensor): x-coordinates in the lens plane.
-            thy (Tensor): y-coordinates in the lens plane.
+            x (Tensor): x-coordinates in the lens plane.
+            y (Tensor): y-coordinates in the lens plane.
             z_s (Tensor): Redshifts of the sources.
-            x (Optional[dict[str, Any]]): Additional parameters.
+            params (Packed, optional): Dynamic parameter container.
 
         Returns:
             Tensor: The convergence (dimensionless surface mass density).
         """
-        z_l, thx0, thy0, m, c = self.unpack(x)
-
-        thx, thy = translate_rotate(thx, thy, thx0, thy0)
-        th = (thx**2 + thy**2).sqrt() + self.s
-        d_l = self.cosmology.angular_diameter_dist(z_l, x)
-        r_s = self.get_r_s(z_l, m, c, x)
+        z_l, x0, y0, m, c = self.unpack(params)
+        
+        x, y = translate_rotate(x, y, x0, y0)
+        th = (x**2 + y**2).sqrt() + self.s
+        d_l = self.cosmology.angular_diameter_distance(z_l, params)
+        scale_radius = self.get_scale_radius(z_l, m, c, params)
         xi = d_l * th * arcsec_to_rad
-        r = xi / r_s  # xi / xi_0
-        kappa_s = self.get_kappa_s(z_l, z_s, m, c, x)
-        return 2 * kappa_s * self._f(r) / (r**2 - 1)
+        r = xi / scale_radius  # xi / xi_0
+        convergence_s = self.get_convergence_s(z_l, z_s, m, c, params)
+        return 2 * convergence_s * self._f(r) / (r**2 - 1)
 
-    def Psi(
-        self, thx: Tensor, thy: Tensor, z_s: Tensor, x: Optional[dict[str, Any]] = None
+    def potential(
+        self, x: Tensor, y: Tensor, z_s: Tensor, params: Optional["Packed"] = None
     ) -> Tensor:
         """
         Compute the lensing potential.
 
         Args:
-            thx (Tensor): x-coordinates in the lens plane.
-            thy (Tensor): y-coordinates in the lens plane.
+            x (Tensor): x-coordinates in the lens plane.
+            y (Tensor): y-coordinates in the lens plane.
             z_s (Tensor): Redshifts of the sources.
-            x (Optional[dict[str, Any]]): Additional parameters.
+            params (Packed, optional): Dynamic parameter container.
 
         Returns:
             Tensor: The lensing potential.
         """
-        z_l, thx0, thy0, m, c = self.unpack(x)
+        z_l, x0, y0, m, c = self.unpack(params)
 
-        thx, thy = translate_rotate(thx, thy, thx0, thy0)
-        th = (thx**2 + thy**2).sqrt() + self.s
-        d_l = self.cosmology.angular_diameter_dist(z_l, x)
-        r_s = self.get_r_s(z_l, m, c, x)
+        x, y = translate_rotate(x, y, x0, y0)
+        th = (x**2 + y**2).sqrt() + self.s
+        d_l = self.cosmology.angular_diameter_distance(z_l, params)
+        scale_radius = self.get_scale_radius(z_l, m, c, params)
         xi = d_l * th * arcsec_to_rad
-        r = xi / r_s  # xi / xi_0
-        kappa_s = self.get_kappa_s(z_l, z_s, m, c, x)
-        return 2 * kappa_s * self._g(r) * r_s**2 / (d_l**2 * arcsec_to_rad**2)
+        r = xi / scale_radius  # xi / xi_0
+        convergence_s = self.get_convergence_s(z_l, z_s, m, c, params)
+        return 2 * convergence_s * self._g(r) * scale_radius**2 / (d_l**2 * arcsec_to_rad**2)
```

## caustic/lenses/point.py

```diff
@@ -5,113 +5,112 @@
 
 from ..cosmology import Cosmology
 from ..utils import translate_rotate
 from .base import ThinLens
 
 __all__ = ("Point",)
 
-
 class Point(ThinLens):
     """
     Class representing a point mass lens in strong gravitational lensing.
 
     Attributes:
         name (str): The name of the point lens.
         cosmology (Cosmology): The cosmology used for calculations.
         z_l (Optional[Tensor]): Redshift of the lens.
-        thx0 (Optional[Tensor]): x-coordinate of the center of the lens.
-        thy0 (Optional[Tensor]): y-coordinate of the center of the lens.
+        x0 (Optional[Tensor]): x-coordinate of the center of the lens.
+        y0 (Optional[Tensor]): y-coordinate of the center of the lens.
         th_ein (Optional[Tensor]): Einstein radius of the lens.
         s (float): Softening parameter to prevent numerical instabilities.
     """
     def __init__(
         self,
         name: str,
         cosmology: Cosmology,
         z_l: Optional[Tensor] = None,
-        thx0: Optional[Tensor] = None,
-        thy0: Optional[Tensor] = None,
+        x0: Optional[Tensor] = None,
+        y0: Optional[Tensor] = None,
         th_ein: Optional[Tensor] = None,
         s: float = 0.0,
     ):
         """
         Initialize the Point class.
 
         Args:
             name (str): The name of the point lens.
             cosmology (Cosmology): The cosmology used for calculations.
             z_l (Optional[Tensor]): Redshift of the lens.
-            thx0 (Optional[Tensor]): x-coordinate of the center of the lens.
-            thy0 (Optional[Tensor]): y-coordinate of the center of the lens.
+            x0 (Optional[Tensor]): x-coordinate of the center of the lens.
+            y0 (Optional[Tensor]): y-coordinate of the center of the lens.
             th_ein (Optional[Tensor]): Einstein radius of the lens.
             s (float): Softening parameter to prevent numerical instabilities.
         """
         super().__init__(name, cosmology, z_l)
 
-        self.add_param("thx0", thx0)
-        self.add_param("thy0", thy0)
+        self.add_param("x0", x0)
+        self.add_param("y0", y0)
         self.add_param("th_ein", th_ein)
         self.s = s
 
-    def alpha(
-        self, thx: Tensor, thy: Tensor, z_s: Tensor, x: Optional[dict[str, Any]] = None
+    def reduced_deflection_angle(
+        self, x: Tensor, y: Tensor, z_s: Tensor, params: Optional["Packed"] = None
     ) -> tuple[Tensor, Tensor]:
         """
         Compute the deflection angles.
 
         Args:
-            thx (Tensor): x-coordinates in the lens plane.
-            thy (Tensor): y-coordinates in the lens plane.
+            x (Tensor): x-coordinates in the lens plane.
+            y (Tensor): y-coordinates in the lens plane.
             z_s (Tensor): Redshifts of the sources.
-            x (Optional[dict[str, Any]]): Additional parameters.
+            params (Packed, optional): Dynamic parameter container.
 
         Returns:
             tuple[Tensor, Tensor]: The deflection angles in the x and y directions.
         """
-        z_l, thx0, thy0, th_ein = self.unpack(x)
+        z_l, x0, y0, th_ein = self.unpack(params)
 
-        thx, thy = translate_rotate(thx, thy, thx0, thy0)
-        th = (thx**2 + thy**2).sqrt() + self.s
-        ax = thx / th**2 * th_ein**2
-        ay = thy / th**2 * th_ein**2
+        x, y = translate_rotate(x, y, x0, y0)
+        th = (x**2 + y**2).sqrt() + self.s
+        ax = x / th**2 * th_ein**2
+        ay = y / th**2 * th_ein**2
         return ax, ay
 
-    def Psi(
-        self, thx: Tensor, thy: Tensor, z_s: Tensor, x: Optional[dict[str, Any]] = None
+    def potential(
+        self, x: Tensor, y: Tensor, z_s: Tensor, params: Optional["Packed"] = None
     ) -> Tensor:
         """
         Compute the lensing potential.
 
         Args:
-            thx (Tensor): x-coordinates in the lens plane.
-            thy (Tensor): y-coordinates in the lens plane.
+            x (Tensor): x-coordinates in the lens plane.
+            y (Tensor): y-coordinates in the lens plane.
             z_s (Tensor): Redshifts of the sources.
-            x (Optional[dict[str, Any]]): Additional parameters.
+            params (Packed, optional): Dynamic parameter container.
 
         Returns:
             Tensor: The lensing potential.
         """
-        z_l, thx0, thy0, th_ein = self.unpack(x)
+        z_l, x0, y0, th_ein = self.unpack(params)
 
-        thx, thy = translate_rotate(thx, thy, thx0, thy0)
-        th = (thx**2 + thy**2).sqrt() + self.s
+        x, y = translate_rotate(x, y, x0, y0)
+        th = (x**2 + y**2).sqrt() + self.s
         return th_ein**2 * th.log()
 
-    def kappa(
-        self, thx: Tensor, thy: Tensor, z_s: Tensor, x: Optional[dict[str, Any]] = None
+    def convergence(
+        self, x: Tensor, y: Tensor, z_s: Tensor, params: Optional["Packed"] = None
     ) -> Tensor:
         """
         Compute the convergence (dimensionless surface mass density).
 
         Args:
-            thx (Tensor): x-coordinates in the lens plane.
-            thy (Tensor): y-coordinates in the lens plane.
+            x (Tensor): x-coordinates in the lens plane.
+            y (Tensor): y-coordinates in the lens plane.
             z_s (Tensor): Redshifts of the sources.
-            x (Optional[dict[str, Any]]): Additional parameters.
+            params (Packed, optional): Dynamic parameter container.
 
         Returns:
             Tensor: The convergence (dimensionless surface mass density).
         """
-        z_l, thx0, thy0, th_ein = self.unpack(x)
+        z_l, x0, y0, th_ein = self.unpack(params)
 
-        thx, thy = translate_rotate(thx, thy, thx0, thy0)
-        return torch.where((thx == 0) & (thy == 0), torch.inf, 0.0)
+        x, y = translate_rotate(x, y, x0, y0)
+        return torch.where((x == 0) & (y == 0), torch.inf, 0.0)
```

## caustic/lenses/pseudo_jaffe.py

```diff
@@ -17,191 +17,191 @@
     based on `Eliasdottir et al 2007 <https://arxiv.org/abs/0710.5636>`_ and 
     the `lenstronomy` source code.
 
     Attributes:
         name (str): The name of the Pseudo Jaffe lens.
         cosmology (Cosmology): The cosmology used for calculations.
         z_l (Optional[Tensor]): Redshift of the lens.
-        thx0 (Optional[Tensor]): x-coordinate of the center of the lens.
-        thy0 (Optional[Tensor]): y-coordinate of the center of the lens.
-        kappa_0 (Optional[Tensor]): Central convergence of the lens.
-        th_core (Optional[Tensor]): Core radius of the lens.
-        th_s (Optional[Tensor]): Scaling radius of the lens.
+        x0 (Optional[Tensor]): x-coordinate of the center of the lens.
+        y0 (Optional[Tensor]): y-coordinate of the center of the lens.
+        convergence_0 (Optional[Tensor]): Central convergence of the lens.
+        core_radius (Optional[Tensor]): Core radius of the lens.
+        scale_radius (Optional[Tensor]): Scaling radius of the lens.
         s (float): Softening parameter to prevent numerical instabilities.
     """
 
     def __init__(
         self,
         name: str,
         cosmology: Cosmology,
         z_l: Optional[Tensor] = None,
-        thx0: Optional[Tensor] = None,
-        thy0: Optional[Tensor] = None,
-        kappa_0: Optional[Tensor] = None,
-        th_core: Optional[Tensor] = None,
-        th_s: Optional[Tensor] = None,
+        x0: Optional[Tensor] = None,
+        y0: Optional[Tensor] = None,
+        convergence_0: Optional[Tensor] = None,
+        core_radius: Optional[Tensor] = None,
+        scale_radius: Optional[Tensor] = None,
         s: float = 0.0,
     ):
         """
         Initialize the PseudoJaffe class.
 
         Args:
             name (str): The name of the Pseudo Jaffe lens.
             cosmology (Cosmology): The cosmology used for calculations.
             z_l (Optional[Tensor]): Redshift of the lens.
-            thx0 (Optional[Tensor]): x-coordinate of the center of the lens.
-            thy0 (Optional[Tensor]): y-coordinate of the center of the lens.
-            kappa_0 (Optional[Tensor]): Central convergence of the lens.
-            th_core (Optional[Tensor]): Core radius of the lens.
-            th_s (Optional[Tensor]): Scaling radius of the lens.
+            x0 (Optional[Tensor]): x-coordinate of the center of the lens.
+            y0 (Optional[Tensor]): y-coordinate of the center of the lens.
+            convergence_0 (Optional[Tensor]): Central convergence of the lens.
+            core_radius (Optional[Tensor]): Core radius of the lens.
+            scale_radius (Optional[Tensor]): Scaling radius of the lens.
             s (float): Softening parameter to prevent numerical instabilities.
         """
         super().__init__(name, cosmology, z_l)
 
-        self.add_param("thx0", thx0)
-        self.add_param("thy0", thy0)
-        self.add_param("kappa_0", kappa_0)
-        self.add_param("th_core", th_core)
-        self.add_param("th_s", th_s)
+        self.add_param("x0", x0)
+        self.add_param("y0", y0)
+        self.add_param("convergence_0", convergence_0)
+        self.add_param("core_radius", core_radius)
+        self.add_param("scale_radius", scale_radius)
         self.s = s
 
-    def mass_enclosed_2d(self, th, z_s, x: Optional[dict[str, Any]] = None):
+    def mass_enclosed_2d(self, theta, z_s, params: Optional["Packed"] = None):
         """
         Calculate the mass enclosed within a two-dimensional radius.
 
         Args:
-            th (Tensor): Radius at which to calculate enclosed mass.
+            theta (Tensor): Radius at which to calculate enclosed mass.
             z_s (Tensor): Source redshift.
-            x (Optional[dict[str, Any]]): Additional parameters.
+            params (Packed, optional): Dynamic parameter container.
 
         Returns:
             Tensor: The mass enclosed within the given radius.
         """
-        z_l, thx0, thy0, kappa_0, th_core, th_s = self.unpack(x)
+        z_l, x0, y0, convergence_0, core_radius, scale_radius = self.unpack(params)
 
-        th = th + self.s
-        Sigma_0 = kappa_0 * self.cosmology.Sigma_cr(z_l, z_s, x)
+        theta = theta + self.s
+        surface_density_0 = convergence_0 * self.cosmology.critical_surface_density(z_l, z_s, params)
         return (
             2
             * pi
-            * Sigma_0
-            * th_core
-            * th_s
-            / (th_s - th_core)
+            * surface_density_0
+            * core_radius
+            * scale_radius
+            / (scale_radius - core_radius)
             * (
-                (th_core**2 + th**2).sqrt()
-                - th_core
-                - (th_s**2 + th**2).sqrt()
-                + th_s
+                (core_radius**2 + theta**2).sqrt()
+                - core_radius
+                - (scale_radius**2 + theta**2).sqrt()
+                + scale_radius
             )
         )
 
     @staticmethod
-    def kappa_0(
+    def convergence_0(
         z_l,
         z_s,
         rho_0,
-        th_core,
-        th_s,
+        core_radius,
+        scale_radius,
         cosmology: Cosmology,
-        x: Optional[dict[str, Any]] = None,
+        params: Optional["Packed"] = None,
     ):
         """
         Compute the central convergence.
 
         Args:
             z_l (Tensor): Lens redshift.
             z_s (Tensor): Source redshift.
             rho_0 (Tensor): Central mass density.
-            th_core (Tensor): Core radius of the lens.
-            th_s (Tensor): Scaling radius of the lens.
+            core_radius (Tensor): Core radius of the lens.
+            scale_radius (Tensor): Scaling radius of the lens.
             cosmology (Cosmology): The cosmology used for calculations.
-            x (Optional[dict[str, Any]]): Additional parameters.
+            params (Packed, optional): Dynamic parameter container.
 
         Returns:
             Tensor: The central convergence.
         """
         return (
             pi
             * rho_0
-            * th_core
-            * th_s
-            / (th_core + th_s)
-            / cosmology.Sigma_cr(z_l, z_s, x)
+            * core_radius
+            * scale_radius
+            / (core_radius + scale_radius)
+            / cosmology.critical_surface_density(z_l, z_s, params)
         )
 
-    def alpha(
-        self, thx: Tensor, thy: Tensor, z_s: Tensor, x: Optional[dict[str, Any]] = None
+    def reduced_deflection_angle(
+        self, x: Tensor, y: Tensor, z_s: Tensor, params: Optional["Packed"] = None
     ) -> tuple[Tensor, Tensor]:
         """ Calculate the deflection angle.
 
         Args:
-            thx (Tensor): x-coordinate of the lens.
-            thy (Tensor): y-coordinate of the lens.
+            x (Tensor): x-coordinate of the lens.
+            y (Tensor): y-coordinate of the lens.
             z_s (Tensor): Source redshift.
-            x (Optional[dict[str, Any]]): Additional parameters.
+            params (Packed, optional): Dynamic parameter container.
     
         Returns:
             Tuple[Tensor, Tensor]: The deflection angle in the x and y directions.
         """
-        z_l, thx0, thy0, kappa_0, th_core, th_s = self.unpack(x)
+        z_l, x0, y0, convergence_0, core_radius, scale_radius = self.unpack(params)
 
-        thx, thy = translate_rotate(thx, thy, thx0, thy0)
-        th = (thx**2 + thy**2).sqrt() + self.s
-        f = th / th_core / (1 + (1 + (th / th_core) ** 2).sqrt()) - th / th_s / (
-            1 + (1 + (th / th_s) ** 2).sqrt()
+        x, y = translate_rotate(x, y, x0, y0)
+        R = (x**2 + y**2).sqrt() + self.s
+        f = R / core_radius / (1 + (1 + (R / core_radius) ** 2).sqrt()) - R / scale_radius / (
+            1 + (1 + (R / scale_radius) ** 2).sqrt()
         )
-        alpha = 2 * kappa_0 * th_core * th_s / (th_s - th_core) * f
-        ax = alpha * thx / th
-        ay = alpha * thy / th
+        alpha = 2 * convergence_0 * core_radius * scale_radius / (scale_radius - core_radius) * f
+        ax = alpha * x / R
+        ay = alpha * y / R
         return ax, ay
 
-    def Psi(
-        self, thx: Tensor, thy: Tensor, z_s: Tensor, x: Optional[dict[str, Any]] = None
+    def potential(
+        self, x: Tensor, y: Tensor, z_s: Tensor, params: Optional["Packed"] = None
     ) -> Tensor:
         """
         Compute the lensing potential. This calculation is based on equation A18.
     
         Args:
-            thx (Tensor): x-coordinate of the lens.
-            thy (Tensor): y-coordinate of the lens.
+            x (Tensor): x-coordinate of the lens.
+            y (Tensor): y-coordinate of the lens.
             z_s (Tensor): Source redshift.
-            x (Optional[dict[str, Any]]): Additional parameters.
+            params (Packed, optional): Dynamic parameter container.
     
         Returns:
             Tensor: The lensing potential.
         """
-        z_l, thx0, thy0, kappa_0, th_core, th_s = self.unpack(x)
+        z_l, x0, y0, convergence_0, core_radius, scale_radius = self.unpack(params)
 
-        thx, thy = translate_rotate(thx, thy, thx0, thy0)
-        th = (thx**2 + thy**2).sqrt() + self.s
-        coeff = -2 * kappa_0 * th_core * th_s / (th_s - th_core)
+        x, y = translate_rotate(x, y, x0, y0)
+        R_squared = x**2 + y**2 + self.s
+        coeff = -2 * convergence_0 * core_radius * scale_radius / (scale_radius - core_radius)
         return coeff * (
-            (th_s**2 + th**2).sqrt()
-            - (th_core**2 + th**2).sqrt()
-            + th_core * (th_core + (th_core**2 + th**2).sqrt()).log()
-            - th_s * (th_s + (th_s**2 + th**2).sqrt()).log()
+            (scale_radius**2 + R_squared).sqrt()
+            - (core_radius**2 + R_squared).sqrt()
+            + core_radius * (core_radius + (core_radius**2 + R_squared).sqrt()).log()
+            - scale_radius * (scale_radius + (scale_radius**2 + R_squared).sqrt()).log()
         )
 
-    def kappa(
-        self, thx: Tensor, thy: Tensor, z_s: Tensor, x: Optional[dict[str, Any]] = None
+    def convergence(
+        self, x: Tensor, y: Tensor, z_s: Tensor, params: Optional["Packed"] = None
     ) -> Tensor:
         """
         Calculate the projected mass density, based on equation A6.
     
         Args:
-            thx (Tensor): x-coordinate of the lens.
-            thy (Tensor): y-coordinate of the lens.
+            x (Tensor): x-coordinate of the lens.
+            y (Tensor): y-coordinate of the lens.
             z_s (Tensor): Source redshift.
-            x (Optional[dict[str, Any]]): Additional parameters.
+            params (Packed, optional): Dynamic parameter container.
     
         Returns:
             Tensor: The projected mass density.
         """
-        z_l, thx0, thy0, kappa_0, th_core, th_s = self.unpack(x)
+        z_l, x0, y0, convergence_0, core_radius, scale_radius = self.unpack(params)
 
-        thx, thy = translate_rotate(thx, thy, thx0, thy0)
-        th = (thx**2 + thy**2).sqrt() + self.s
-        coeff = kappa_0 * th_core * th_s / (th_s - th_core)
+        x, y = translate_rotate(x, y, x0, y0)
+        R_squared = x**2 + y**2 + self.s
+        coeff = convergence_0 * core_radius * scale_radius / (scale_radius - core_radius)
         return coeff * (
-            1 / (th_core**2 + th**2).sqrt() - 1 / (th_s**2 + th**2).sqrt()
+            1 / (core_radius**2 + R_squared).sqrt() - 1 / (scale_radius**2 + R_squared).sqrt()
         )
```

## caustic/lenses/sie.py

```diff
@@ -14,120 +14,124 @@
     A class representing a Singular Isothermal Ellipsoid (SIE) strong gravitational lens model. 
     This model is based on Keeton 2001, which can be found at https://arxiv.org/abs/astro-ph/0102341.
     
     Attributes:
         name (str): The name of the lens.
         cosmology (Cosmology): An instance of the Cosmology class.
         z_l (Tensor, optional): The redshift of the lens.
-        thx0 (Tensor, optional): The x-coordinate of the lens center.
-        thy0 (Tensor, optional): The y-coordinate of the lens center.
+        x0 (Tensor, optional): The x-coordinate of the lens center.
+        y0 (Tensor, optional): The y-coordinate of the lens center.
         q (Tensor, optional): The axis ratio of the lens.
-        phi (Tensor, optional): The orientation angle of the lens.
+        phi (Tensor, optional): The orientation angle of the lens (position angle).
         b (Tensor, optional): The Einstein radius of the lens.
         s (float): The core radius of the lens (defaults to 0.0).
     """
 
     def __init__(
         self,
         name: str,
         cosmology: Cosmology,
         z_l: Optional[Tensor] = None,
-        thx0: Optional[Tensor] = None,
-        thy0: Optional[Tensor] = None,
-        q: Optional[Tensor] = None,
+        x0: Optional[Tensor] = None,
+        y0: Optional[Tensor] = None,
+        q: Optional[Tensor] = None,# TODO change to true axis ratio
         phi: Optional[Tensor] = None,
         b: Optional[Tensor] = None,
         s: float = 0.0,
     ):
         """
         Initialize the SIE lens model.
         """
         super().__init__(name, cosmology, z_l)
 
-        self.add_param("thx0", thx0)
-        self.add_param("thy0", thy0)
+        self.add_param("x0", x0)
+        self.add_param("y0", y0)
         self.add_param("q", q)
         self.add_param("phi", phi)
         self.add_param("b", b)
         self.s = s
 
-    def _get_psi(self, x, y, q):
+    def _get_potential(self, x, y, q):
         """
         Compute the radial coordinate in the lens plane.
 
         Args:
             x (Tensor): The x-coordinate in the lens plane.
             y (Tensor): The y-coordinate in the lens plane.
             q (Tensor): The axis ratio of the lens.
 
         Returns:
             Tensor: The radial coordinate in the lens plane.
         """
         return (q**2 * (x**2 + self.s**2) + y**2).sqrt()
 
-    def alpha(
-        self, thx: Tensor, thy: Tensor, z_s: Tensor, x: Optional[dict[str, Any]] = None
+    def reduced_deflection_angle(
+        self,
+            x: Tensor,
+            y: Tensor,
+            z_s: Tensor,
+            params: Optional["Packed"] = None
     ) -> tuple[Tensor, Tensor]:
         """
-        Calculate the deflection angle.
+        Calculate the physical deflection angle.
 
         Args:
-            thx (Tensor): The x-coordinate of the lens.
-            thy (Tensor): The y-coordinate of the lens.
+            x (Tensor): The x-coordinate of the lens.
+            y (Tensor): The y-coordinate of the lens.
             z_s (Tensor): The source redshift.
-            x (Optional[dict[str, Any]]): Additional parameters.
+            params (Packed, optional): Dynamic parameter container.
 
         Returns:
             Tuple[Tensor, Tensor]: The deflection angle in the x and y directions.
         """
-        z_l, thx0, thy0, q, phi, b = self.unpack(x)
+        z_l, x0, y0, q, phi, b = self.unpack(params)
 
-        thx, thy = translate_rotate(thx, thy, thx0, thy0, phi)
-        psi = self._get_psi(thx, thy, q)
+        x, y = translate_rotate(x, y, x0, y0, phi)
+        psi = self._get_potential(x, y, q)
         f = (1 - q**2).sqrt()
-        ax = b * q.sqrt() / f * (f * thx / (psi + self.s)).atan()
-        ay = b * q.sqrt() / f * (f * thy / (psi + q**2 * self.s)).atanh()
+        ax = b * q.sqrt() / f * (f * x / (psi + self.s)).atan()
+        ay = b * q.sqrt() / f * (f * y / (psi + q**2 * self.s)).atanh()
 
         return derotate(ax, ay, phi)
 
-    def Psi(
-        self, thx: Tensor, thy: Tensor, z_s: Tensor, x: Optional[dict[str, Any]] = None
+    def potential( 
+        self, x: Tensor, y: Tensor, z_s: Tensor, params: Optional["Packed"] = None
     ) -> Tensor:
         """
         Compute the lensing potential.
 
         Args:
-            thx (Tensor): The x-coordinate of the lens.
-            thy (Tensor): The y-coordinate of the lens.
+            x (Tensor): The x-coordinate of the lens.
+            y (Tensor): The y-coordinate of the lens.
             z_s (Tensor): The source redshift.
-            x (Optional[dict[str, Any]]): Additional parameters.
+            params (Packed, optional): Dynamic parameter container.
 
         Returns:
             Tensor: The lensing potential.
         """
-        z_l, thx0, thy0, q, phi, b = self.unpack(x)
+        z_l, x0, y0, q, phi, b = self.unpack(params)
 
-        ax, ay = self.alpha(thx, thy, z_s, x)
+        ax, ay = self.reduced_deflection_angle(x, y, z_s, params)
         ax, ay = derotate(ax, ay, -phi)
-        thx, thy = translate_rotate(thx, thy, thx0, thy0, phi)
-        return thx * ax + thy * ay
+        x, y = translate_rotate(x, y, x0, y0, phi)
+        return x * ax + y * ay
 
-    def kappa(
-        self, thx: Tensor, thy: Tensor, z_s: Tensor, x: Optional[dict[str, Any]] = None
+    def convergence(
+        self, x: Tensor, y: Tensor, z_s: Tensor, params: Optional["Packed"] = None
     ) -> Tensor:
         """
         Calculate the projected mass density.
 
         Args:
-            thx (Tensor): The x-coordinate of the lens.
-            thy (Tensor): The y-coordinate of the lens.
+            x (Tensor): The x-coordinate of the lens.
+            y (Tensor): The y-coordinate of the lens.
             z_s (Tensor): The source redshift.
-            x (Optional[dict[str, Any]]): Additional parameters.
+            params (Packed, optional): Dynamic parameter container.
 
         Returns:
             Tensor: The projected mass.
         """
-        z_l, thx0, thy0, q, phi, b = self.unpack(x)
+        z_l, x0, y0, q, phi, b = self.unpack(params)
 
-        thx, thy = translate_rotate(thx, thy, thx0, thy0, phi)
-        psi = self._get_psi(thx, thy, q)
+        x, y = translate_rotate(x, y, x0, y0, phi)
+        psi = self._get_potential(x, y, q)
         return 0.5 * q.sqrt() * b / psi
```

## caustic/lenses/singleplane.py

```diff
@@ -24,72 +24,73 @@
         """
         Initialize the SinglePlane lens model.
         """
         super().__init__(name, cosmology)
         self.lenses = lenses
         for lens in lenses:
             self.add_parametrized(lens)
+        # TODO: assert all z_l are the same?
 
-    def alpha(
-        self, thx: Tensor, thy: Tensor, z_s: Tensor, x: Optional[dict[str, Any]] = None
+    def reduced_deflection_angle(
+        self, x: Tensor, y: Tensor, z_s: Tensor, params: Optional["Packed"] = None
     ) -> tuple[Tensor, Tensor]:
         """
         Calculate the total deflection angle by summing the deflection angles of all individual lenses.
 
         Args:
-            thx (Tensor): The x-coordinate of the lens.
-            thy (Tensor): The y-coordinate of the lens.
+            x (Tensor): The x-coordinate of the lens.
+            y (Tensor): The y-coordinate of the lens.
             z_s (Tensor): The source redshift.
-            x (Optional[dict[str, Any]]): Additional parameters.
+            params (Packed, optional): Dynamic parameter container.
 
         Returns:
             Tuple[Tensor, Tensor]: The total deflection angle in the x and y directions.
         """
-        ax = torch.zeros_like(thx)
-        ay = torch.zeros_like(thx)
+        ax = torch.zeros_like(x)
+        ay = torch.zeros_like(x)
         for lens in self.lenses:
-            ax_cur, ay_cur = lens.alpha(thx, thy, z_s, x)
+            ax_cur, ay_cur = lens.reduced_deflection_angle(x, y, z_s, params)
             ax = ax + ax_cur
             ay = ay + ay_cur
         return ax, ay
 
-    def kappa(
-        self, thx: Tensor, thy: Tensor, z_s: Tensor, x: Optional[dict[str, Any]] = None
+    def convergence(
+        self, x: Tensor, y: Tensor, z_s: Tensor, params: Optional["Packed"] = None
     ) -> Tensor:
         """
         Calculate the total projected mass density by summing the mass densities of all individual lenses.
 
         Args:
-            thx (Tensor): The x-coordinate of the lens.
-            thy (Tensor): The y-coordinate of the lens.
+            x (Tensor): The x-coordinate of the lens.
+            y (Tensor): The y-coordinate of the lens.
             z_s (Tensor): The source redshift.
-            x (Optional[dict[str, Any]]): Additional parameters.
+            params (Packed, optional): Dynamic parameter container.
 
         Returns:
             Tensor: The total projected mass density.
         """
-        kappa = torch.zeros_like(thx)
+        convergence = torch.zeros_like(x)
         for lens in self.lenses:
-            kappa_cur = lens.kappa(thx, thy, z_s, x)
-            kappa = kappa + kappa_cur
-        return kappa
+            convergence_cur = lens.convergence(x, y, z_s, params)
+            convergence = convergence + convergence_cur
+        return convergence
 
-    def Psi(
-        self, thx: Tensor, thy: Tensor, z_s: Tensor, x: Optional[dict[str, Any]] = None
+    def potential(
+        self, x: Tensor, y: Tensor, z_s: Tensor, params: Optional["Packed"] = None
     ) -> Tensor:
         """
         Compute the total lensing potential by summing the lensing potentials of all individual lenses.
 
         Args:
-            thx (Tensor): The x-coordinate of the lens.
-            thy (Tensor): The y-coordinate of the lens.
+            x (Tensor): The x-coordinate of the lens.
+            y (Tensor): The y-coordinate of the lens.
             z_s (Tensor): The source redshift.
-            x (Optional[dict[str, Any]]): Additional parameters.
+            params (Packed, optional): Dynamic parameter container.
 
         Returns:
             Tensor: The total lensing potential.
         """
-        Psi = torch.zeros_like(thx)
+        potential = torch.zeros_like(x)
         for lens in self.lenses:
-            Psi_cur = lens.Psi(thx, thy, z_s, x)
-            Psi = Psi + Psi_cur
-        return Psi
+            potential_cur = lens.potential(x, y, z_s, params)
+            potential = potential + potential_cur
+        return potential
```

## caustic/lenses/sis.py

```diff
@@ -15,96 +15,96 @@
     A class representing the Singular Isothermal Sphere (SIS) model. 
     This model inherits from the base `ThinLens` class.
 
     Attributes:
         name (str): The name of the SIS lens.
         cosmology (Cosmology): An instance of the Cosmology class.
         z_l (Optional[Tensor]): The lens redshift.
-        thx0 (Optional[Tensor]): The x-coordinate of the lens center.
-        thy0 (Optional[Tensor]): The y-coordinate of the lens center.
+        x0 (Optional[Tensor]): The x-coordinate of the lens center.
+        y0 (Optional[Tensor]): The y-coordinate of the lens center.
         th_ein (Optional[Tensor]): The Einstein radius of the lens.
         s (float): A smoothing factor, default is 0.0.
     """
     def __init__(
         self,
         name: str,
         cosmology: Cosmology,
         z_l: Optional[Tensor] = None,
-        thx0: Optional[Tensor] = None,
-        thy0: Optional[Tensor] = None,
+        x0: Optional[Tensor] = None,
+        y0: Optional[Tensor] = None,
         th_ein: Optional[Tensor] = None,
         s: float = 0.0,
     ):
         """
         Initialize the SIS lens model.
         """
         super().__init__(name, cosmology, z_l)
 
-        self.add_param("thx0", thx0)
-        self.add_param("thy0", thy0)
+        self.add_param("x0", x0)
+        self.add_param("y0", y0)
         self.add_param("th_ein", th_ein)
         self.s = s
 
-    def alpha(
-        self, thx: Tensor, thy: Tensor, z_s: Tensor, x: Optional[dict[str, Any]] = None
+    def reduced_deflection_angle(
+        self, x: Tensor, y: Tensor, z_s: Tensor, params: Optional["Packed"] = None
     ) -> tuple[Tensor, Tensor]:
         """
         Calculate the deflection angle of the SIS lens.
 
         Args:
-            thx (Tensor): The x-coordinate of the lens.
-            thy (Tensor): The y-coordinate of the lens.
+            x (Tensor): The x-coordinate of the lens.
+            y (Tensor): The y-coordinate of the lens.
             z_s (Tensor): The source redshift.
-            x (Optional[dict[str, Any]]): Additional parameters.
+            params (Packed, optional): Dynamic parameter container.
 
         Returns:
             Tuple[Tensor, Tensor]: The deflection angle in the x and y directions.
         """
-        z_l, thx0, thy0, th_ein = self.unpack(x)
+        z_l, x0, y0, th_ein = self.unpack(params)
 
-        thx, thy = translate_rotate(thx, thy, thx0, thy0)
-        th = (thx**2 + thy**2).sqrt() + self.s
-        ax = th_ein * thx / th
-        ay = th_ein * thy / th
+        x, y = translate_rotate(x, y, x0, y0)
+        R = (x**2 + y**2).sqrt() + self.s
+        ax = th_ein * x / R
+        ay = th_ein * y / R
         return ax, ay
 
-    def Psi(
-        self, thx: Tensor, thy: Tensor, z_s: Tensor, x: Optional[dict[str, Any]] = None
+    def potential(
+        self, x: Tensor, y: Tensor, z_s: Tensor, params: Optional["Packed"] = None
     ) -> Tensor:
         """
         Compute the lensing potential of the SIS lens.
 
         Args:
-            thx (Tensor): The x-coordinate of the lens.
-            thy (Tensor): The y-coordinate of the lens.
+            x (Tensor): The x-coordinate of the lens.
+            y (Tensor): The y-coordinate of the lens.
             z_s (Tensor): The source redshift.
-            x (Optional[dict[str, Any]]): Additional parameters.
+            params (Packed, optional): Dynamic parameter container.
 
         Returns:
             Tensor: The lensing potential.
         """
-        z_l, thx0, thy0, th_ein = self.unpack(x)
+        z_l, x0, y0, th_ein = self.unpack(params)
 
-        thx, thy = translate_rotate(thx, thy, thx0, thy0)
-        th = (thx**2 + thy**2).sqrt() + self.s
+        x, y = translate_rotate(x, y, x0, y0)
+        th = (x**2 + y**2).sqrt() + self.s
         return th_ein * th
 
-    def kappa(
-        self, thx: Tensor, thy: Tensor, z_s: Tensor, x: Optional[dict[str, Any]] = None
+    def convergence(
+        self, x: Tensor, y: Tensor, z_s: Tensor, params: Optional["Packed"] = None
     ) -> Tensor:
         """
         Calculate the projected mass density of the SIS lens.
 
         Args:
-            thx (Tensor): The x-coordinate of the lens.
-            thy (Tensor): The y-coordinate of the lens.
+            x (Tensor): The x-coordinate of the lens.
+            y (Tensor): The y-coordinate of the lens.
             z_s (Tensor): The source redshift.
-            x (Optional[dict[str, Any]]): Additional parameters.
+            params (Packed, optional): Dynamic parameter container.
 
         Returns:
             Tensor: The projected mass density.
         """
-        z_l, thx0, thy0, th_ein = self.unpack(x)
+        z_l, x0, y0, th_ein = self.unpack(params)
 
-        thx, thy = translate_rotate(thx, thy, thx0, thy0)
-        th = (thx**2 + thy**2).sqrt() + self.s
+        x, y = translate_rotate(x, y, x0, y0)
+        th = (x**2 + y**2).sqrt() + self.s
         return 0.5 * th_ein / th
```

## caustic/lenses/utils.py

```diff
@@ -5,66 +5,63 @@
 
 from ..utils import vmap_n
 
 __all__ = ("get_pix_jacobian", "get_pix_magnification", "get_magnification")
 
 
 def get_pix_jacobian(
-    raytrace, thx, thy, z_s
+    raytrace, x, y, z_s
 ) -> Tuple[Tuple[Tensor, Tensor], Tuple[Tensor, Tensor]]:
     """Computes the Jacobian matrix of the partial derivatives of the
     image position with respect to the source position
     (:math:`\\partial \beta / \\partial \theta`).  This is done at a
     single point on the lensing plane.
 
     Args:
         raytrace: A function that maps the lensing plane coordinates to the source plane coordinates.
-        thx (Tensor): The x-coordinate on the lensing plane.
-        thy (Tensor): The y-coordinate on the lensing plane.
+        x (Tensor): The x-coordinate on the lensing plane.
+        y (Tensor): The y-coordinate on the lensing plane.
         z_s (Tensor): The redshift of the source.
-        x: Additional parameters for the raytrace function.
 
     Returns:
         The Jacobian matrix of the image position with respect to the source position at the given point.
 
     """
-    jac = torch.func.jacfwd(raytrace, (0, 1))(thx, thy, z_s)  # type: ignore
+    jac = torch.func.jacfwd(raytrace, (0, 1))(x, y, z_s)  # type: ignore
     return jac
 
 
-def get_pix_magnification(raytrace, thx, thy, z_s) -> Tensor:
+def get_pix_magnification(raytrace, x, y, z_s) -> Tensor:
     """
     Computes the magnification at a single point on the lensing plane. The magnification is derived from the determinant
     of the Jacobian matrix of the image position with respect to the source position.
 
     Args:
         raytrace: A function that maps the lensing plane coordinates to the source plane coordinates.
-        thx (Tensor): The x-coordinate on the lensing plane.
-        thy (Tensor): The y-coordinate on the lensing plane.
+        x (Tensor): The x-coordinate on the lensing plane.
+        y (Tensor): The y-coordinate on the lensing plane.
         z_s (Tensor): The redshift of the source.
-        x: Additional parameters for the raytrace function.
 
     Returns:
         The magnification at the given point on the lensing plane.
     """
-    jac = get_pix_jacobian(raytrace, thx, thy, z_s)
+    jac = get_pix_jacobian(raytrace, x, y, z_s)
     return 1 / (jac[0][0] * jac[1][1] - jac[0][1] * jac[1][0]).abs()
 
 
-def get_magnification(raytrace, thx, thy, z_s) -> Tensor:
+def get_magnification(raytrace, x, y, z_s) -> Tensor:
     """
     Computes the magnification over a grid on the lensing plane. This is done by calling `get_pix_magnification` 
     for each point on the grid.
 
     Args:
         raytrace: A function that maps the lensing plane coordinates to the source plane coordinates.
-        thx (Tensor): The x-coordinates on the lensing plane.
-        thy (Tensor): The y-coordinates on the lensing plane.
+        x (Tensor): The x-coordinates on the lensing plane.
+        y (Tensor): The y-coordinates on the lensing plane.
         z_s (Tensor): The redshift of the source.
-        x: Additional parameters for the raytrace function.
 
     Returns:
         A tensor representing the magnification at each point on the grid.
     """
     return vmap_n(get_pix_magnification, 2, (None, 0, 0, None))(
-        raytrace, thx, thy, z_s
+        raytrace, x, y, z_s
     )
```

## caustic/sources/base.py

```diff
@@ -16,28 +16,28 @@
     be optimized or manipulated.
     
     The class introduces one abstract method, `brightness`, that must be implemented in any concrete 
     subclass. This method calculates the brightness of the source at given coordinates.
     """
     @abstractmethod
     def brightness(
-        self, thx: Tensor, thy: Tensor, x: Optional[dict[str, Any]] = None
+        self, x: Tensor, y: Tensor, params: Optional["Packed"] = None
     ) -> Tensor:
         """
         Abstract method that calculates the brightness of the source at the given coordinates. 
         This method is expected to be implemented in any class that derives from Source.
         
         Args:
-            thx (Tensor): The x-coordinate(s) at which to calculate the source brightness. 
+            x (Tensor): The x-coordinate(s) at which to calculate the source brightness. 
                 This could be a single value or a tensor of values.
                 
-            thy (Tensor): The y-coordinate(s) at which to calculate the source brightness. 
+            y (Tensor): The y-coordinate(s) at which to calculate the source brightness. 
                 This could be a single value or a tensor of values.
                 
-            x (Optional[dict[str, Any]]): Additional parameters that might be required to calculate 
+            params (Packed, optional): Dynamic parameter container that might be required to calculate 
                 the brightness. The exact contents will depend on the specific implementation in derived classes. 
 
         Returns:
             Tensor: The brightness of the source at the given coordinate(s). The exact form of the output 
             will depend on the specific implementation in the derived class.
             
         Note:
```

## caustic/sources/pixelated.py

```diff
@@ -1,73 +1,73 @@
 from typing import Optional
 
 from torch import Tensor
 
 from ..utils import interp2d
 from .base import Source
 
-__all__ = ("ImageSource",)
+__all__ = ("Pixelated",)
 
 
-class ImageSource(Source):
+class Pixelated(Source):
     """
-    `ImageSource` is a subclass of the abstract class `Source`. It represents a source in a strong 
+    `Pixelated` is a subclass of the abstract class `Source`. It represents a source in a strong 
     gravitational lensing system where the source is an image.
     
     This class provides a concrete implementation of the `brightness` method required by the `Source` 
     superclass. In this implementation, brightness is determined by interpolating values from the 
     provided source image.
 
     Attributes:
-        thx0 (Optional[Tensor]): The x-coordinate of the source image's center. 
-        thy0 (Optional[Tensor]): The y-coordinate of the source image's center.
+        x0 (Optional[Tensor]): The x-coordinate of the source image's center. 
+        y0 (Optional[Tensor]): The y-coordinate of the source image's center.
         image (Optional[Tensor]): The source image from which brightness values will be interpolated.
-        scale (Optional[Tensor]): The scale of the source image in the lens plane.
+        pixelscale (Optional[Tensor]): The pixelscale of the source image in the lens plane in units of arcsec/pixel.
         image_shape (Optional[tuple[int, ...]]): The shape of the source image.
     """
     def __init__(
         self,
         name: str,
-        thx0: Optional[Tensor] = None,
-        thy0: Optional[Tensor] = None,
-        image: Optional[Tensor] = None,
-        scale: Optional[Tensor] = None,
+        x0: Optional[Tensor] = None,
+        y0: Optional[Tensor] = None,
+        image: Optional[Tensor] = None, 
+        pixelscale: Optional[Tensor] = None,
         image_shape: Optional[tuple[int, ...]] = None,
     ):
         """
-        Constructs the `ImageSource` object with the given parameters. 
+        Constructs the `Pixelated` object with the given parameters. 
 
         Args:
             name (str): The name of the source.
-            thx0 (Optional[Tensor]): The x-coordinate of the source image's center.
-            thy0 (Optional[Tensor]): The y-coordinate of the source image's center.
+            x0 (Optional[Tensor]): The x-coordinate of the source image's center.
+            y0 (Optional[Tensor]): The y-coordinate of the source image's center.
             image (Optional[Tensor]): The source image from which brightness values will be interpolated.
-            scale (Optional[Tensor]): The scale of the source image in the lens plane.
+            pixelscale (Optional[Tensor]): The pixelscale of the source image in the lens plane in units of arcsec/pixel.
             image_shape (Optional[tuple[int, ...]]): The shape of the source image.
         """
         super().__init__(name)
-        self.add_param("thx0", thx0)
-        self.add_param("thy0", thy0)
+        self.add_param("x0", x0)
+        self.add_param("y0", y0)
         self.add_param("image", image, image_shape)
-        self.add_param("scale", scale)
+        self.add_param("pixelscale", pixelscale)
 
-    def brightness(self, thx, thy, x):
+    def brightness(self, x, y, params: Optional["Packed"]):
         """
-        Implements the `brightness` method for `ImageSource`. The brightness at a given point is 
+        Implements the `brightness` method for `Pixelated`. The brightness at a given point is 
         determined by interpolating values from the source image.
 
         Args:
-            thx (Tensor): The x-coordinate(s) at which to calculate the source brightness. 
+            x (Tensor): The x-coordinate(s) at which to calculate the source brightness. 
                 This could be a single value or a tensor of values.
-            thy (Tensor): The y-coordinate(s) at which to calculate the source brightness. 
+            y (Tensor): The y-coordinate(s) at which to calculate the source brightness. 
                 This could be a single value or a tensor of values.
-            x (dict): A dictionary containing additional parameters that might be required to 
+            P (Optional[Packed]): A dictionary containing additional parameters that might be required to 
                 calculate the brightness. 
 
         Returns:
             Tensor: The brightness of the source at the given coordinate(s). The brightness is 
             determined by interpolating values from the source image.
         """
-        thx0, thy0, image, scale = self.unpack(x)
+        x0, y0, image, pixelscale = self.unpack(params)
         return interp2d(
-            image, (thx - thx0).view(-1) / scale, (thy - thy0).view(-1) / scale
-        ).reshape(thx.shape)
+            image, (x - x0).view(-1) / pixelscale, (y - y0).view(-1) / pixelscale
+        ).reshape(x.shape)
```

## caustic/sources/sersic.py

```diff
@@ -14,95 +14,95 @@
     `Sersic` is a subclass of the abstract class `Source`. It represents a source in a strong 
     gravitational lensing system that follows a Sersic profile, a mathematical function that describes 
     how the intensity I of a galaxy varies with distance r from its center.
     
     The Sersic profile is often used to describe elliptical galaxies and spiral galaxies' bulges.
 
     Attributes:
-        thx0 (Optional[Tensor]): The x-coordinate of the Sersic source's center. 
-        thy0 (Optional[Tensor]): The y-coordinate of the Sersic source's center.
+        x0 (Optional[Tensor]): The x-coordinate of the Sersic source's center. 
+        y0 (Optional[Tensor]): The y-coordinate of the Sersic source's center.
         q (Optional[Tensor]): The axis ratio of the Sersic source.
-        phi (Optional[Tensor]): The orientation of the Sersic source.
+        phi (Optional[Tensor]): The orientation of the Sersic source (position angle).
         index (Optional[Tensor]): The Sersic index, which describes the degree of concentration of the source.
-        th_e (Optional[Tensor]): The scale length of the Sersic source.
-        I_e (Optional[Tensor]): The intensity at the effective radius.
+        Re (Optional[Tensor]): The scale length of the Sersic source.
+        Ie (Optional[Tensor]): The intensity at the effective radius.
         s (float): A small constant for numerical stability.
         lenstronomy_k_mode (bool): A flag indicating whether to use lenstronomy to compute the value of k.
     """
     def __init__(
         self,
         name: str,
-        thx0: Optional[Tensor] = None,
-        thy0: Optional[Tensor] = None,
+        x0: Optional[Tensor] = None,
+        y0: Optional[Tensor] = None,
         q: Optional[Tensor] = None,
         phi: Optional[Tensor] = None,
-        index: Optional[Tensor] = None,
-        th_e: Optional[Tensor] = None,
-        I_e: Optional[Tensor] = None,
+        n: Optional[Tensor] = None,
+        Re: Optional[Tensor] = None,
+        Ie: Optional[Tensor] = None,
         s: float = 0.0,
         use_lenstronomy_k=False,
     ):
         """
         Constructs the `Sersic` object with the given parameters. 
 
         Args:
             name (str): The name of the source.
-            thx0 (Optional[Tensor]): The x-coordinate of the Sersic source's center.
-            thy0 (Optional[Tensor]): The y-coordinate of the Sersic source's center.
+            x0 (Optional[Tensor]): The x-coordinate of the Sersic source's center.
+            y0 (Optional[Tensor]): The y-coordinate of the Sersic source's center.
             q (Optional[Tensor]): The axis ratio of the Sersic source.
             phi (Optional[Tensor]): The orientation of the Sersic source.
-            index (Optional[Tensor]): The Sersic index, which describes the degree of concentration of the source.
-            th_e (Optional[Tensor]): The scale length of the Sersic source.
-            I_e (Optional[Tensor]): The intensity at the effective radius.
+            n (Optional[Tensor]): The Sersic index, which describes the degree of concentration of the source.
+            Re (Optional[Tensor]): The scale length of the Sersic source.
+            Ie (Optional[Tensor]): The intensity at the effective radius.
             s (float): A small constant for numerical stability.
             use_lenstronomy_k (bool): A flag indicating whether to use lenstronomy to compute the value of k.
         """
         super().__init__(name)
-        self.add_param("thx0", thx0)
-        self.add_param("thy0", thy0)
+        self.add_param("x0", x0)
+        self.add_param("y0", y0)
         self.add_param("q", q)
         self.add_param("phi", phi)
-        self.add_param("index", index)
-        self.add_param("th_e", th_e)
-        self.add_param("I_e", I_e)
+        self.add_param("n", n)
+        self.add_param("Re", Re)
+        self.add_param("Ie", Ie)
         self.s = s
 
         self.lenstronomy_k_mode = use_lenstronomy_k
 
-    def brightness(self, thx, thy, x):
+    def brightness(self, x, y, params: Optional["Packed"] = None):
         """
         Implements the `brightness` method for `Sersic`. The brightness at a given point is 
         determined by the Sersic profile formula.
 
         Args:
-            thx (Tensor): The x-coordinate(s) at which to calculate the source brightness. 
+            x (Tensor): The x-coordinate(s) at which to calculate the source brightness. 
                 This could be a single value or a tensor of values.
-            thy (Tensor): The y-coordinate(s) at which to calculate the source brightness. 
+            y (Tensor): The y-coordinate(s) at which to calculate the source brightness. 
                 This could be a single value or a tensor of values.
-            x (dict[str, Any]): A dictionary containing additional parameters.
+            params (Packed, optional): Dynamic parameter container.
 
         Returns:
-            Tensor: The brightness of the source at the given point(s). The output tensor has the same shape as `thx` and `thy`.
+            Tensor: The brightness of the source at the given point(s). The output tensor has the same shape as `x` and `y`.
 
         Notes:
-            The Sersic profile is defined as: I(r) = I_e * exp(-k * ((r / r_e)^(1/n) - 1)), 
-            where I_e is the intensity at the effective radius r_e, n is the Sersic index 
+            The Sersic profile is defined as: I(r) = Ie * exp(-k * ((r / r_e)^(1/n) - 1)), 
+            where Ie is the intensity at the effective radius r_e, n is the Sersic index 
             that describes the concentration of the source, and k is a parameter that 
             depends on n. In this implementation, we use elliptical coordinates ex and ey, 
             and the transformation from Cartesian coordinates is handled by `to_elliptical`.
             The value of k can be calculated in two ways, controlled by `lenstronomy_k_mode`. 
             If `lenstronomy_k_mode` is True, we use the approximation from Lenstronomy, 
             otherwise, we use the approximation from Ciotti & Bertin (1999).
         """
-        thx0, thy0, q, phi, index, th_e, I_e = self.unpack(x)
+        x0, y0, q, phi, n, Re, Ie = self.unpack(params)
 
-        thx, thy = translate_rotate(thx, thy, thx0, thy0, phi)
-        ex, ey = to_elliptical(thx, thy, q)
+        x, y = translate_rotate(x, y, x0, y0, phi)
+        ex, ey = to_elliptical(x, y, q)
         e = (ex**2 + ey**2).sqrt() + self.s
 
         if self.lenstronomy_k_mode:
-            k = 1.9992 * index - 0.3271
+            k = 1.9992 * n - 0.3271
         else:
-            k = 2 * index - 1 / 3 + 4 / 405 / index + 46 / 25515 / index**2
+            k = 2 * n - 1 / 3 + 4 / 405 / n + 46 / 25515 / n**2
 
-        exponent = -k * ((e / th_e) ** (1 / index) - 1)
-        return I_e * exponent.exp()
+        exponent = -k * ((e / Re) ** (1 / n) - 1)
+        return Ie * exponent.exp()
```

## Comparing `caustic/fwd_raytrace.py` & `caustic/forward_raytrace.py`

 * *Files 20% similar despite different names*

```diff
@@ -2,78 +2,83 @@
 
 import torch
 from levmarq_torch import minimize_levmarq
 from torch import Tensor
 
 from .utils import get_cluster_means
 
+__all__ = ("forward_raytrace", )
 
-def fwd_raytrace(
+def forward_raytrace(
     beta_x: Tensor,
     beta_y: Tensor,
     get_beta_hat: Callable[[Tensor, Tensor], Tuple[Tensor, Tensor]],
     n_images: int,
-    thx_range: Tuple[float, float],
-    thy_range: Tuple[float, float],
+    thetax_range: Tuple[float, float],
+    thetay_range: Tuple[float, float],
     n_guesses: int = 15,
-    lam: float = 1e-2,
+    LM_damping: float = 1e-2,
     max_iters_guesses: int = 50,
     max_iters_final: int = 50,
 ) -> Tensor:
     """
-    Implements a forward ray tracing algorithm for a strong gravitational lensing system. 
+    Implements a forward ray tracing algorithm for a strong gravitational lensing system.
 
     Args:
         beta_x (Tensor): The x coordinates of the source positions in the source plane.
         beta_y (Tensor): The y coordinates of the source positions in the source plane.
-        get_beta_hat (Callable[[Tensor, Tensor], Tuple[Tensor, Tensor]]): A function that returns 
+        get_beta_hat (Callable[[Tensor, Tensor], Tuple[Tensor, Tensor]]): A function that returns
             the predicted source positions given the lensed image positions.
         n_images (int): The number of images to produce.
-        thx_range (Tuple[float, float]): The range of x coordinates in the lens plane to consider for initial guesses.
-        thy_range (Tuple[float, float]): The range of y coordinates in the lens plane to consider for initial guesses.
+        thetax_range (Tuple[float, float]): The range of x coordinates in the lens plane to consider for initial guesses.
+        thetay_range (Tuple[float, float]): The range of y coordinates in the lens plane to consider for initial guesses.
         n_guesses (int, optional): The number of initial guesses for the lensed image positions. Default is 15.
-        lam (float, optional): The damping parameter for the Levenberg-Marquardt optimization. Default is 1e-2.
+        LM_damping (float, optional): The damping parameter for the Levenberg-Marquardt optimization. Default is 1e-2.
         max_iters_guesses (int, optional): The maximum number of iterations for the optimization of initial guesses. Default is 50.
         max_iters_final (int, optional): The maximum number of iterations for the final optimization. Default is 50.
 
     Returns:
         Tensor: The optimized lensed image positions in the lens plane.
-    
-    This function first generates a set of initial guesses for the lensed image positions. 
-    These guesses are then optimized using the Levenberg-Marquardt algorithm to match the 
-    observed source positions. If the optimization fails for any of the initial guesses, 
+
+    This function first generates a set of initial guesses for the lensed image positions.
+    These guesses are then optimized using the Levenberg-Marquardt algorithm to match the
+    observed source positions. If the optimization fails for any of the initial guesses,
     new guesses are generated and the process is repeated until a successful optimization is achieved.
 
-    Once the initial optimization is complete, the results are pared down to the desired number 
-    of images using a clustering algorithm, and a final round of optimization is performed. 
+    Once the initial optimization is complete, the results are pared down to the desired number
+    of images using a clustering algorithm, and a final round of optimization is performed.
     The function returns the final optimized lensed image positions.
 
-    Note: If the number of images is greater than the number of observed source positions, 
+    Note: If the number of images is greater than the number of observed source positions,
     the function may not be able to find a solution.
     """
 
     bxy = torch.stack((beta_x, beta_y))
-    thxy_min = torch.tensor((thx_range[0], thy_range[0]))
-    thxy_max = torch.tensor((thx_range[1], thy_range[1]))
-    fov = thxy_max - thxy_min
+    thetaxy_min = torch.tensor((thetax_range[0], thetay_range[0]))
+    thetaxy_max = torch.tensor((thetax_range[1], thetay_range[1]))
+    fov = thetaxy_max - thetaxy_min
 
     while True:
-        thxy_0s = fov[None, :] * torch.rand(n_guesses, 2) + thxy_min[None, :]
-        thxys = minimize_levmarq(
-            thxy_0s,
+        thetaxy_0s = fov[None, :] * torch.rand(n_guesses, 2) + thetaxy_min[None, :]
+        thetaxys = minimize_levmarq(
+            thetaxy_0s,
             bxy.repeat(n_guesses, 1),
             get_beta_hat,
-            lam=lam,
+            lam=LM_damping,
             max_iters=max_iters_guesses,
         )
         # If the batch contains one point that optimizes poorly, the whole batch
         # can fail. If that happens, rerun with new guesses until it doesn't.
-        if (thxys != thxy_0s).any():
+        if (thetaxys != thetaxy_0s).any():
             break
 
     # Pare down to number of images
-    thxys = get_cluster_means(thxys, n_images)
+    thetaxys = get_cluster_means(thetaxys, n_images)
 
     # Run final optimization
     return minimize_levmarq(
-        thxys, bxy.repeat(n_images, 1), get_beta_hat, lam=lam, max_iters=max_iters_final
+        thetaxys,
+        bxy.repeat(n_images, 1),
+        get_beta_hat,
+        lam=LM_damping,
+        max_iters=max_iters_final,
     )
```

## Comparing `caustic/lenses/kappa_grid.py` & `caustic/lenses/pixelated_convergence.py`

 * *Files 19% similar despite different names*

```diff
@@ -6,116 +6,116 @@
 from scipy.fft import next_fast_len
 from torch import Tensor
 
 from ..cosmology import Cosmology
 from ..utils import get_meshgrid, interp2d, safe_divide, safe_log
 from .base import ThinLens
 
-__all__ = ("KappaGrid",)
+__all__ = ("PixelatedConvergence",)
 
-class KappaGrid(ThinLens):
+class PixelatedConvergence(ThinLens):
     def __init__(
         self,
         name: str,
         fov: float,
         n_pix: int,
         cosmology: Cosmology,
         z_l: Optional[Tensor] = None,
-        thx0: Optional[Tensor] = torch.tensor(0.0),
-        thy0: Optional[Tensor] = torch.tensor(0.0),
-        kappa_map: Optional[Tensor] = None,
-        kappa_map_shape: Optional[tuple[int, ...]] = None,
-        mode: str = "fft",
+        x0: Optional[Tensor] = torch.tensor(0.0),
+        y0: Optional[Tensor] = torch.tensor(0.0),
+        convergence_map: Optional[Tensor] = None,
+        convergence_map_shape: Optional[tuple[int, ...]] = None,
+        convolution_mode: str = "fft",
         use_next_fast_len: bool = True,
     ):
         """Strong lensing with user provided kappa map
 
-        KappaGrid is a class for strong gravitational lensing with a
+        PixelatedConvergence is a class for strong gravitational lensing with a
         user-provided kappa map. It inherits from the ThinLens class.
         This class enables the computation of deflection angles and
         lensing potential by applying the user-provided kappa map to a
         grid using either Fast Fourier Transform (FFT) or a 2D
         convolution.
 
         Attributes:
-            name (str): The name of the KappaGrid object.
+            name (str): The name of the PixelatedConvergence object.
             fov (float): The field of view in arcseconds.
             n_pix (int): The number of pixels on each side of the grid.
             cosmology (Cosmology): An instance of the cosmological parameters.
             z_l (Optional[Tensor]): The redshift of the lens.
-            thx0 (Optional[Tensor]): The x-coordinate of the center of the grid.
-            thy0 (Optional[Tensor]): The y-coordinate of the center of the grid.
-            kappa_map (Optional[Tensor]): A 2D tensor representing the kappa map.
-            kappa_map_shape (Optional[tuple[int, ...]]): The shape of the kappa map.
-            mode (str, optional): The convolution mode for calculating deflection angles and lensing potential.
+            x0 (Optional[Tensor]): The x-coordinate of the center of the grid.
+            y0 (Optional[Tensor]): The y-coordinate of the center of the grid.
+            convergence_map (Optional[Tensor]): A 2D tensor representing the convergence map.
+            convergence_map_shape (Optional[tuple[int, ...]]): The shape of the convergence map.
+            convolution_mode (str, optional): The convolution mode for calculating deflection angles and lensing potential.
                 It can be either "fft" (Fast Fourier Transform) or "conv2d" (2D convolution). Default is "fft".
             use_next_fast_len (bool, optional): If True, adds additional padding to speed up the FFT by calling
                 `scipy.fft.next_fast_len`. The speed boost can be substantial when `n_pix` is a multiple of a
                 small prime number. Default is True.
 
         """
         
         super().__init__(name, cosmology, z_l)
 
-        if kappa_map is not None and kappa_map.ndim != 2:
+        if convergence_map is not None and convergence_map.ndim != 2:
             raise ValueError(
-                f"kappa_map must be 2D (received {kappa_map.ndim}D tensor)"
+                f"convergence_map must be 2D (received {convergence_map.ndim}D tensor)"
             )
-        elif kappa_map_shape is not None and len(kappa_map_shape) != 2:
+        elif convergence_map_shape is not None and len(convergence_map_shape) != 2:
             raise ValueError(
-                f"kappa_map_shape must be 2D (received {len(kappa_map_shape)}D)"
+                f"convergence_map_shape must be 2D (received {len(convergence_map_shape)}D)"
             )
 
-        self.add_param("thx0", thx0)
-        self.add_param("thy0", thy0)
-        self.add_param("kappa_map", kappa_map, kappa_map_shape)
+        self.add_param("x0", x0)
+        self.add_param("y0", y0)
+        self.add_param("convergence_map", convergence_map, convergence_map_shape)
 
         self.n_pix = n_pix
         self.fov = fov
         self.res = fov / n_pix
         self.use_next_fast_len = use_next_fast_len
 
         # Construct kernels
         x_mg, y_mg = get_meshgrid(self.res, 2 * self.n_pix, 2 * self.n_pix)
         # Shift to center kernels within pixel at index n_pix
         x_mg = x_mg - self.res / 2
         y_mg = y_mg - self.res / 2
         d2 = x_mg**2 + y_mg**2
-        self.Psi_kernel = safe_log(d2.sqrt())
+        self.potential_kernel = safe_log(d2.sqrt())
         self.ax_kernel = safe_divide(x_mg, d2)
         self.ay_kernel = safe_divide(y_mg, d2)
         # Set centers of kernels to zero
-        self.Psi_kernel[..., self.n_pix, self.n_pix] = 0
+        self.potential_kernel[..., self.n_pix, self.n_pix] = 0
         self.ax_kernel[..., self.n_pix, self.n_pix] = 0
         self.ay_kernel[..., self.n_pix, self.n_pix] = 0
 
-        self.Psi_kernel_tilde = None
+        self.potential_kernel_tilde = None
         self.ax_kernel_tilde = None
         self.ay_kernel_tilde = None
         self._s = None
 
         # Triggers creation of FFTs of kernels
-        self.mode = mode
+        self.convolution_mode = convolution_mode
 
     def to(
         self, device: Optional[torch.device] = None, dtype: Optional[torch.dtype] = None
     ):
         """
-        Move the KappaGrid object and all its tensors to the specified device and dtype.
+        Move the ConvergenceGrid object and all its tensors to the specified device and dtype.
 
         Args:
             device (Optional[torch.device]): The target device to move the tensors to.
             dtype (Optional[torch.dtype]): The target data type to cast the tensors to.
         """        
         super().to(device, dtype)
-        self.Psi_kernel = self.Psi_kernel.to(device=device, dtype=dtype)
+        self.potential_kernel = self.potential_kernel.to(device=device, dtype=dtype)
         self.ax_kernel = self.ax_kernel.to(device=device, dtype=dtype)
         self.ay_kernel = self.ay_kernel.to(device=device, dtype=dtype)
-        if self.Psi_kernel_tilde is not None:
-            self.Psi_kernel_tilde = self.Psi_kernel_tilde.to(device=device)
+        if self.potential_kernel_tilde is not None:
+            self.potential_kernel_tilde = self.potential_kernel_tilde.to(device=device)
         if self.ax_kernel_tilde is not None:
             self.ax_kernel_tilde = self.ax_kernel_tilde.to(device=device)
         if self.ay_kernel_tilde is not None:
             self.ay_kernel_tilde = self.ay_kernel_tilde.to(device=device)
 
     def _fft2_padded(self, x: Tensor) -> Tensor:
         """
@@ -154,192 +154,195 @@
 
         Returns:
             Tensor: The input tensor without padding.
         """
         return x[..., 1:, 1:]
 
     @property
-    def mode(self):
+    def convolution_mode(self):
         """
-        Get the convolution mode of the KappaGrid object.
+        Get the convolution mode of the ConvergenceGrid object.
 
         Returns:
             str: The convolution mode, either "fft" or "conv2d".
         """
-        return self._mode
+        return self._convolution_mode
 
-    @mode.setter
-    def mode(self, mode: str):
+    @convolution_mode.setter
+    def convolution_mode(self, convolution_mode: str):
         """
-        Set the convolution mode of the KappaGrid object.
+        Set the convolution mode of the ConvergenceGrid object.
 
         Args:
             mode (str): The convolution mode to be set, either "fft" or "conv2d".
         """
-        if mode == "fft":
+        if convolution_mode == "fft":
             # Create FFTs of kernels
-            self.Psi_kernel_tilde = self._fft2_padded(self.Psi_kernel)
+            self.potential_kernel_tilde = self._fft2_padded(self.potential_kernel)
             self.ax_kernel_tilde = self._fft2_padded(self.ax_kernel)
             self.ay_kernel_tilde = self._fft2_padded(self.ay_kernel)
-        elif mode == "conv2d":
+        elif convolution_mode == "conv2d":
             # Drop FFTs of kernels
-            self.Psi_kernel_tilde = None
+            self.potential_kernel_tilde = None
             self.ax_kernel_tilde = None
             self.ay_kernel_tilde = None
         else:
-            raise ValueError("invalid convolution mode")
+            raise ValueError("invalid convolution convolution_mode")
 
-        self._mode = mode
+        self._convolution_mode = convolution_mode
 
-    def alpha(
-        self, thx: Tensor, thy: Tensor, z_s: Tensor, x: Optional[dict[str, Any]] = None
+    def reduced_deflection_angle(
+        self, x: Tensor, y: Tensor, z_s: Tensor, params: Optional["Packed"] = None
     ) -> tuple[Tensor, Tensor]:
         """
-        Compute the deflection angles at the specified positions using the given kappa map.
+        Compute the deflection angles at the specified positions using the given convergence map.
 
         Args:
-            thx (Tensor): The x-coordinates of the positions to compute the deflection angles for.
-            thy (Tensor): The y-coordinates of the positions to compute the deflection angles for.
+            x (Tensor): The x-coordinates of the positions to compute the deflection angles for.
+            y (Tensor): The y-coordinates of the positions to compute the deflection angles for.
             z_s (Tensor): The source redshift.
-            x (Optional[dict[str, Any]]): A dictionary containing additional parameters.
+            params (Packed, optional): A dictionary containing additional parameters.
 
         Returns:
             tuple[Tensor, Tensor]: The x and y components of the deflection angles at the specified positions.
         """
-        z_l, thx0, thy0, kappa_map = self.unpack(x)
+        z_l, x0, y0, convergence_map = self.unpack(params)
 
-        if self.mode == "fft":
-            alpha_x_map, alpha_y_map = self._alpha_fft(kappa_map)
+        if self.convolution_mode == "fft":
+            deflection_angle_x_map, deflection_angle_y_map = self._deflection_angle_fft(convergence_map)
         else:
-            alpha_x_map, alpha_y_map = self._alpha_conv2d(kappa_map)
+            deflection_angle_x_map, deflection_angle_y_map = self._deflection_angle_conv2d(convergence_map)
 
         # Scale is distance from center of image to center of pixel on the edge
         scale = self.fov / 2
-        alpha_x = interp2d(
-            alpha_x_map, (thx - thx0).view(-1) / scale, (thy - thy0).view(-1) / scale
-        ).reshape(thx.shape)
-        alpha_y = interp2d(
-            alpha_y_map, (thx - thx0).view(-1) / scale, (thy - thy0).view(-1) / scale
-        ).reshape(thx.shape)
-        return alpha_x, alpha_y
+        deflection_angle_x = interp2d(
+            deflection_angle_x_map, (x - x0).view(-1) / scale, (y - y0).view(-1) / scale
+        ).reshape(x.shape)
+        deflection_angle_y = interp2d(
+            deflection_angle_y_map, (x - x0).view(-1) / scale, (y - y0).view(-1) / scale
+        ).reshape(x.shape)
+        return deflection_angle_x, deflection_angle_y
 
-    def _alpha_fft(self, kappa_map: Tensor) -> tuple[Tensor, Tensor]:
+    def _deflection_angle_fft(self, convergence_map: Tensor) -> tuple[Tensor, Tensor]:
         """
         Compute the deflection angles using the Fast Fourier Transform (FFT) method.
 
         Args:
-            kappa_map (Tensor): The 2D tensor representing the kappa map.
+            convergence_map (Tensor): The 2D tensor representing the convergence map.
 
         Returns:
             tuple[Tensor, Tensor]: The x and y components of the deflection angles.
         """
-        kappa_tilde = self._fft2_padded(kappa_map)
-        alpha_x = torch.fft.irfft2(kappa_tilde * self.ax_kernel_tilde, self._s) * (
+        convergence_tilde = self._fft2_padded(convergence_map)
+        deflection_angle_x = torch.fft.irfft2(convergence_tilde * self.ax_kernel_tilde, self._s) * (
             self.res**2 / pi
         )
-        alpha_y = torch.fft.irfft2(kappa_tilde * self.ay_kernel_tilde, self._s) * (
+        deflection_angle_y = torch.fft.irfft2(convergence_tilde * self.ay_kernel_tilde, self._s) * (
             self.res**2 / pi
         )
-        return self._unpad_fft(alpha_x), self._unpad_fft(alpha_y)
+        return self._unpad_fft(deflection_angle_x), self._unpad_fft(deflection_angle_y)
 
-    def _alpha_conv2d(self, kappa_map: Tensor) -> tuple[Tensor, Tensor]:
+    def _deflection_angle_conv2d(self, convergence_map: Tensor) -> tuple[Tensor, Tensor]:
         """
         Compute the deflection angles using the 2D convolution method.
 
         Args:
-            kappa_map (Tensor): The 2D tensor representing the kappa map.
+            convergence_map (Tensor): The 2D tensor representing the convergence map.
 
         Returns:
             tuple[Tensor, Tensor]: The x and y components of the deflection angles.
         """
-        # Use kappa_map as kernel since the kernel is twice as large. Flip since
+        # Use convergence_map as kernel since the kernel is twice as large. Flip since
         # we actually want the cross-correlation.
-        kappa_map_flipped = kappa_map.flip((-1, -2))[None, None]
-        alpha_x = F.conv2d(self.ax_kernel[None, None], kappa_map_flipped)[0, 0] * (
+        convergence_map_flipped = convergence_map.flip((-1, -2))[None, None]
+        deflection_angle_x = F.conv2d(self.ax_kernel[None, None], convergence_map_flipped)[0, 0] * (
             self.res**2 / pi
         )
-        alpha_y = F.conv2d(self.ay_kernel[None, None], kappa_map_flipped)[0, 0] * (
+        deflection_angle_y = F.conv2d(self.ay_kernel[None, None], convergence_map_flipped)[0, 0] * (
             self.res**2 / pi
         )
-        return self._unpad_conv2d(alpha_x), self._unpad_conv2d(alpha_y)
+        return self._unpad_conv2d(deflection_angle_x), self._unpad_conv2d(deflection_angle_y)
 
-    def Psi(
-        self, thx: Tensor, thy: Tensor, z_s: Tensor, x: Optional[dict[str, Any]] = None
+    def potential(
+        self, x: Tensor, y: Tensor, z_s: Tensor, params: Optional["Packed"] = None
     ) -> Tensor:
         """
-        Compute the lensing potential at the specified positions using the given kappa map.
+        Compute the lensing potential at the specified positions using the given convergence map.
 
         Args:
-        thx (Tensor): The x-coordinates of the positions to compute the lensing potential for.
-        thy (Tensor): The y-coordinates of the positions to compute the lensing potential for.
+        x (Tensor): The x-coordinates of the positions to compute the lensing potential for.
+        y (Tensor): The y-coordinates of the positions to compute the lensing potential for.
         z_s (Tensor): The source redshift.
-        x (Optional[dict[str, Any]]): A dictionary containing additional parameters.
+        params (Packed, optional): A dictionary containing additional parameters.
 
         Returns:
             Tensor: The lensing potential at the specified positions.
         """
-        z_l, thx0, thy0, kappa_map = self.unpack(x)
+        z_l, x0, y0, convergence_map = self.unpack(params)
 
-        if self.mode == "fft":
-            Psi_map = self._Psi_fft(kappa_map)
+        if self.convolution_mode == "fft":
+            potential_map = self._potential_fft(convergence_map)
         else:
-            Psi_map = self._Psi_conv2d(kappa_map)
+            potential_map = self._potential_conv2d(convergence_map)
 
         # Scale is distance from center of image to center of pixel on the edge
         scale = self.fov / 2
         return interp2d(
-            Psi_map, (thx - thx0).view(-1) / scale, (thy - thy0).view(-1) / scale
-        ).reshape(thx.shape)
+            potential_map, (x - x0).view(-1) / scale, (y - y0).view(-1) / scale
+        ).reshape(x.shape)
 
-    def _Psi_fft(self, kappa_map: Tensor) -> Tensor:
+    def _potential_fft(self, convergence_map: Tensor) -> Tensor:
         """
         Compute the lensing potential using the Fast Fourier Transform (FFT) method.
     
         Args:
-            kappa_map (Tensor): The 2D tensor representing the kappa map.
+            convergence_map (Tensor): The 2D tensor representing the convergence map.
     
         Returns:
             Tensor: The lensing potential.
         """
-        kappa_tilde = self._fft2_padded(kappa_map)
-        Psi = torch.fft.irfft2(kappa_tilde * self.Psi_kernel_tilde, self._s) * (
+        convergence_tilde = self._fft2_padded(convergence_map)
+        potential = torch.fft.irfft2(convergence_tilde * self.potential_kernel_tilde, self._s) * (
             self.res**2 / pi
         )
-        return self._unpad_fft(Psi)
+        return self._unpad_fft(potential)
 
-    def _Psi_conv2d(self, kappa_map: Tensor) -> Tensor:
+    def _potential_conv2d(self, convergence_map: Tensor) -> Tensor:
         """
         Compute the lensing potential using the 2D convolution method.
     
         Args:
-            kappa_map (Tensor): The 2D tensor representing the kappa map.
+            convergence_map (Tensor): The 2D tensor representing the convergence map.
     
         Returns:
             Tensor: The lensing potential.
         """
-        # Use kappa_map as kernel since the kernel is twice as large. Flip since
+        # Use convergence_map as kernel since the kernel is twice as large. Flip since
         # we actually want the cross-correlation.
-        kappa_map_flipped = kappa_map.flip((-1, -2))[None, None]
-        Psi = F.conv2d(self.Psi_kernel[None, None], kappa_map_flipped)[0, 0] * (
+        convergence_map_flipped = convergence_map.flip((-1, -2))[None, None]
+        potential = F.conv2d(self.potential_kernel[None, None], convergence_map_flipped)[0, 0] * (
             self.res**2 / pi
         )
-        return self._unpad_conv2d(Psi)
+        return self._unpad_conv2d(potential)
 
-    def kappa(
-        self, thx: Tensor, thy: Tensor, z_s: Tensor, x: Optional[dict[str, Any]] = None
+    def convergence(
+        self, x: Tensor, y: Tensor, z_s: Tensor, params: Optional["Packed"] = None
     ) -> Tensor:
         """
-        Compute the convergence (kappa) at the specified positions. This method is not implemented.
+        Compute the convergence at the specified positions. This method is not implemented.
     
         Args:
-            thx (Tensor): The x-coordinates of the positions to compute the convergence for.
-            thy (Tensor): The y-coordinates of the positions to compute the convergence for.
+            x (Tensor): The x-coordinates of the positions to compute the convergence for.
+            y (Tensor): The y-coordinates of the positions to compute the convergence for.
             z_s (Tensor): The source redshift.
-            x (Optional[dict[str, Any]]): A dictionary containing additional parameters.
+            params (Packed, optional): A dictionary containing additional parameters.
     
         Returns:
             Tensor: The convergence at the specified positions.
     
         Raises:
             NotImplementedError: This method is not implemented.
         """
-        raise NotImplementedError()
+        x0, y0, convergence_map, pixelscale = self.unpack(params)
+        return interp2d(
+            convergence_map, (x - x0).view(-1) / pixelscale, (y - y0).view(-1) / pixelscale
+        ).reshape(x.shape)
```

## Comparing `caustic-0.3.0.dist-info/LICENSE` & `caustic-0.4.0.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `caustic-0.3.0.dist-info/METADATA` & `caustic-0.4.0.dist-info/METADATA`

 * *Files 4% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: caustic
-Version: 0.3.0
+Version: 0.4.0
 Summary: The lensing pipeline of the future.
 Author-email: Connor Stone <connorstone628@gmail.com>, Adam Coogan <dr.adam.coogan@gmail.com>
 License: MIT License
         
         Copyright (c) [2023] [caustic authors]
         
         Permission is hereby granted, free of charge, to any person obtaining a copy
```

## Comparing `caustic-0.3.0.dist-info/RECORD` & `caustic-0.4.0.dist-info/RECORD`

 * *Files 25% similar despite different names*

```diff
@@ -1,36 +1,36 @@
-caustic/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-caustic/constants.py,sha256=Ru4bn3Ah-eZxQh5j1bJIlbNR6ht7q4CIMLApbuPnR6w,496
-caustic/cosmology.py,sha256=M8wkgI25zcRbW47d1v1H1XVHXqPiQhDIuldJkhhzeF4,8554
-caustic/fwd_raytrace.py,sha256=TmuwCN6Ljs6DbGCpITAhGKrFkFrBwN9U1RZIen-cD1w,3536
-caustic/packed.py,sha256=QPV2B2-Ll70ko6hOtsskK3EJf_RLC3aAdKGIr2KmAfY,154
-caustic/parameter.py,sha256=GR2Cpf7YkfccUXIayLm5dUJbSH-8Eed0NnmkzRZRr3o,3392
-caustic/parametrized.py,sha256=dVJB0b6CjvV5opmRyzf5gZwBLRxgN6hoSn_18J41DEU,21182
-caustic/simulator.py,sha256=rz6BGGoKnjQcpjNLpc5OhJ2wwngm0ovj3uzcS5kkElc,631
-caustic/utils.py,sha256=5bA_T0FQCv4wPU2UbLM6ioSrj75PjCT7D55pCxIrcxM,11755
+caustic/__init__.py,sha256=f6pMQ_pIAcFJqyZT34HK4vLZKYFBDQRfMjXRhsFTH0c,246
+caustic/constants.py,sha256=DDuzUgDSeOGtqhEuhkmJIYmV4FkmqZfVm_AzvjDSIYc,598
+caustic/cosmology.py,sha256=Fpz3ud1mmeu01luVg9voPjMxrc2ooZ7fOePtWtJBdPE,8952
+caustic/forward_raytrace.py,sha256=K5_WUaFyfWtLgL1AgDXotxFjrsOVPBHJdNQYDnagwkc,3685
+caustic/packed.py,sha256=hSgey6KbDgfNOoxVY4pFBtp4kt_2w48nBm5wUz52nuY,155
+caustic/parameter.py,sha256=w2_ewXOPk803BwFDnRY3IYzvHBoUVnl1BiEDrhvW_-U,3380
+caustic/parametrized.py,sha256=dR55WIy3pxS5tEHv6n0UmeEzNuP2MiYY4zb5utbagWc,21171
+caustic/simulator.py,sha256=g5mnw3KOgaYsioS7gs6_gaZqVTnRRLCm9sScz5P2Ilw,619
+caustic/utils.py,sha256=yjd97KbZPsYWsPyRHbb50WWVgdl8kwUc0FfoBarK4tg,11725
 caustic/data/__init__.py,sha256=RPbwqLtzDvhoxLIgofTDfwNJ6qxdqObF2wgqiF86dfs,80
 caustic/data/hdf5dataset.py,sha256=yf_qEhaAE_fQTgZXhV5JfPILXrvizjH_NlVzW-GVRtM,1563
 caustic/data/illustris_kappa.py,sha256=OTBtyWAbBID9qkgtaymvpNHSAGh0KeMDiPMXcdP8C5Y,683
 caustic/data/probes.py,sha256=DyOKkkBZ34gcrIG7exm2Cu-HpjsrZv5bczQQas4xiRA,675
-caustic/lenses/__init__.py,sha256=OUKg2WqPZdDf0F4xfsOxm3jtNktmXRfHXZ6gu4GyRU8,248
-caustic/lenses/base.py,sha256=65SJUuFaW6-LhWiG_Wi_spTBqeZB35s4-ZdykkF3ZXI,13591
-caustic/lenses/epl.py,sha256=8rd-vaQwKBAoLtXCneEKMXqqIORzEYu3gZZeU-Ndlaw,7271
-caustic/lenses/external_shear.py,sha256=j8EWqq3AYsrwwoPpFrZuJ2cZsSwakBNStJmdJ3Uq1FU,3634
-caustic/lenses/kappa_grid.py,sha256=ul_X22CvoSVopS2GaeYB870XLIbxJoXZ8HHjdHc5jWY,13160
-caustic/lenses/multiplane.py,sha256=8K_goiuEUz2MDWq1O_GR3fGYu9ySkS3J2Fo4ee_D9GE,5613
-caustic/lenses/nfw.py,sha256=N5pstXFAH5hxqM4Ry3LKrz6BXzJqfjz5MZLGof2Xo8o,10688
-caustic/lenses/point.py,sha256=CqWYHIkrKigeTzNOWI5Bb40aRu2Er5IYURfpyF1kiyU,4008
-caustic/lenses/pseudo_jaffe.py,sha256=M3zL5kt-qgwX-HQB-p6RWzuBGgK0aG5zfI5vxcFHMyA,7035
-caustic/lenses/sie.py,sha256=egvEX_cFHPLQbIs17rOJviQb0eP3lctcMlr8XVL2wCo,4395
-caustic/lenses/singleplane.py,sha256=G_JCgyoR13oDjwivOmXQgk3u7Qz-QI-v_QFwuRt5Hs8,3209
-caustic/lenses/sis.py,sha256=kXVnU9tDL0OdE9MkwONEV3CknwXSIUlsezkpugDINL0,3489
-caustic/lenses/utils.py,sha256=d74rdlHW22Tm_uChHI_oH2AJNJOMb6nZaoDpNw0rglM,2674
+caustic/lenses/__init__.py,sha256=S5Y9lAan0vdfiuVpcElcYt8EasaGB8erMCBsTeruT5M,259
+caustic/lenses/base.py,sha256=ekhX5EhfFy1aMCq91ErON2qtKRyx1LtSQECNWBNTqZ0,16265
+caustic/lenses/epl.py,sha256=qS1PNZGLNYUsREjmyXhWe9tQCy_YWHgqbVZQDZ2tWjY,7239
+caustic/lenses/external_shear.py,sha256=xGAZJjW9QsV8ixZVb7mVlG78py1K1sVO7vd7-FafkH8,3617
+caustic/lenses/multiplane.py,sha256=fw9NzCVtBDC8_9p3T7Y--Owgv3zIkjmN9mB7ifTiU3c,5481
+caustic/lenses/nfw.py,sha256=-Jm1ztAPMTrm9wMCCaxJ2v3TBOMbE-B0lZannvi75N0,10539
+caustic/lenses/pixelated_convergence.py,sha256=7HTwsqujtiR9syTesNMdawz3XPdFmIvHIGf75NjFIiw,14235
+caustic/lenses/point.py,sha256=e177dOqLilgWCk4PDuW-Snnx6bGNE9CMX9lmB1e-QZc,3951
+caustic/lenses/pseudo_jaffe.py,sha256=uyBGoErBqG2YYcWInEn0Yk0RpYxEs_73EzJRuNS8kRA,7521
+caustic/lenses/sie.py,sha256=5ca2oB8xAS3ZbHSFmi4LOcbakTkehBeXkMW6YlbsqFI,4488
+caustic/lenses/singleplane.py,sha256=8tP0hX4Rc3Jl3UpWhJnUKL4ba4rhsFWI6CZ_r9di0tI,3365
+caustic/lenses/sis.py,sha256=Bs91Y3xx5jhGYP9uZzApp-i4DKQgqbBMWyb25TU-2cU,3434
+caustic/lenses/utils.py,sha256=-AT-NexgGsmGRcsmElpPmtxd0xkFgELCd70G-bvPf78,2458
 caustic/sources/__init__.py,sha256=_CK3BYNbk-S3yKBGmcbPeKpCe4QHlh6iEwT9UCJuWbU,89
-caustic/sources/base.py,sha256=vYTPLSaU2ZCQUY-UcBv3Evlh_ZXubdPzPU3qwtZ1OFI,2006
-caustic/sources/pixelated.py,sha256=uSIHoq-HFkTxbsIn0PNYJEy3O8t8WTFXoavuvfTCwCs,3162
+caustic/sources/base.py,sha256=mHJRfsDS1M0WJLThDCJaZJpT77rW3VqgFLgqDKyEDXI,2000
+caustic/sources/pixelated.py,sha256=PzITfYJI2HefvLPbbiFWDlY6SVsMysV8eOEww9ny40A,3253
 caustic/sources/probes.py,sha256=aNUclNlFTsdGxdwu_dclpRza7scQBHN4AX5hP67oXtc,792
-caustic/sources/sersic.py,sha256=OPn6zWcdQ8_nmQ87I3XxiU9jJOxrDKcQoFHD1aobcZA,4948
-caustic-0.3.0.dist-info/LICENSE,sha256=cllh7ggKgLVBj8dXi9pC1mZkHLZlf3xxeLCSJoJIctg,1076
-caustic-0.3.0.dist-info/METADATA,sha256=Vr-CThtQN3EQZlTtgxZ5IA3lgf42Cpyx98AmeIWKp8M,3393
-caustic-0.3.0.dist-info/WHEEL,sha256=pkctZYzUS4AYVn6dJ-7367OJZivF2e8RA9b_ZBjif18,92
-caustic-0.3.0.dist-info/top_level.txt,sha256=LQoSbW8clrogX400rPniIRZwXwEUKH2gPpPFEhl7ATs,8
-caustic-0.3.0.dist-info/RECORD,,
+caustic/sources/sersic.py,sha256=7UK8HJrhmVz9L1HV033rLYvh4Gk6SE2xnkZhBzcuug4,4876
+caustic-0.4.0.dist-info/LICENSE,sha256=cllh7ggKgLVBj8dXi9pC1mZkHLZlf3xxeLCSJoJIctg,1076
+caustic-0.4.0.dist-info/METADATA,sha256=A5L0MtEx8D4ER-E8nGh6aCW-J-tiGIu_DaiiHBLhpq0,3393
+caustic-0.4.0.dist-info/WHEEL,sha256=a-zpFRIJzOq5QfuhBzbhiA1eHTzNCJn8OdRvhdNX0Rk,110
+caustic-0.4.0.dist-info/top_level.txt,sha256=LQoSbW8clrogX400rPniIRZwXwEUKH2gPpPFEhl7ATs,8
+caustic-0.4.0.dist-info/RECORD,,
```

