# Comparing `tmp/pdfCropMargins-1.2.0-py2.py3-none-any.whl.zip` & `tmp/pdfCropMargins-2.0.0-py2.py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,26 +1,27 @@
-Zip file size: 1839751 bytes, number of entries: 24
--rw-rw-r--  2.0 unx      215 b- defN 23-May-31 00:03 pdfCropMargins/__init__.py
+Zip file size: 1839346 bytes, number of entries: 25
+-rw-rw-r--  2.0 unx      215 b- defN 23-Jun-09 02:47 pdfCropMargins/__init__.py
 -rw-rw-r--  2.0 unx      197 b- defN 22-Dec-07 15:25 pdfCropMargins/__main__.py
--rw-rw-r--  2.0 unx    13904 b- defN 23-May-31 00:03 pdfCropMargins/calculate_bounding_boxes.py
+-rw-rw-r--  2.0 unx    14131 b- defN 23-Jun-09 02:45 pdfCropMargins/calculate_bounding_boxes.py
 -rw-rw-r--  2.0 unx      181 b- defN 22-Dec-07 15:25 pdfCropMargins/directory_locator.py
--rw-rw-r--  2.0 unx    31258 b- defN 23-May-31 00:03 pdfCropMargins/external_program_calls.py
+-rw-rw-r--  2.0 unx    31257 b- defN 23-Jun-09 02:45 pdfCropMargins/external_program_calls.py
 -rw-rw-r--  2.0 unx     8673 b- defN 23-Mar-12 21:58 pdfCropMargins/get_window_sizing_info.py
--rw-rw-r--  2.0 unx    58643 b- defN 23-Mar-12 22:46 pdfCropMargins/gui.py
--rw-rw-r--  2.0 unx    79226 b- defN 23-May-31 00:03 pdfCropMargins/main_pdfCropMargins.py
--rw-rw-r--  2.0 unx    49723 b- defN 23-May-31 00:03 pdfCropMargins/manpage_data.py
+-rw-rw-r--  2.0 unx    58742 b- defN 23-Jun-09 02:45 pdfCropMargins/gui.py
+-rw-rw-r--  2.0 unx    69332 b- defN 23-Jun-09 17:56 pdfCropMargins/main_pdfCropMargins.py
+-rw-rw-r--  2.0 unx    48446 b- defN 23-Jun-09 17:16 pdfCropMargins/manpage_data.py
 -rw-rw-r--  2.0 unx     8262 b- defN 22-Dec-31 02:09 pdfCropMargins/pdfCropMargins.py
 -rw-rw-r--  2.0 unx     8924 b- defN 22-Dec-07 15:25 pdfCropMargins/prettified_argparse.py
--rw-rw-r--  2.0 unx    12497 b- defN 23-May-31 00:03 pdfCropMargins/pymupdf_routines.py
+-rw-rw-r--  2.0 unx    20044 b- defN 23-Jun-09 02:45 pdfCropMargins/pymupdf_routines.py
+-rw-rw-r--  2.0 unx     3669 b- defN 23-Jun-03 03:46 pdfCropMargins/tmp_test_metadata_setting.py
 -rw-rw-r--  2.0 unx        0 b- defN 17-Mar-05 00:20 pdfCropMargins/pdftoppm_windows_local/__init__.py
 -rw-rw-r--  2.0 unx        0 b- defN 19-Aug-19 00:10 pdfCropMargins/pdftoppm_windows_local/xpdf_tools_win_4_01_01/__init__.py
 -rw-rw-r--  2.0 unx        0 b- defN 19-Aug-19 00:32 pdfCropMargins/pdftoppm_windows_local/xpdf_tools_win_4_01_01/bin32/__init__.py
 -rwxr-xr--  2.0 unx  1690624 b- defN 19-Aug-19 00:06 pdfCropMargins/pdftoppm_windows_local/xpdf_tools_win_4_01_01/bin32/pdftoppm.exe
 -rw-rw-r--  2.0 unx        0 b- defN 19-Aug-19 00:32 pdfCropMargins/pdftoppm_windows_local/xpdf_tools_win_4_01_01/bin64/__init__.py
 -rwxr-xr--  2.0 unx  2090496 b- defN 19-Aug-19 00:06 pdfCropMargins/pdftoppm_windows_local/xpdf_tools_win_4_01_01/bin64/pdftoppm.exe
--rw-rw-r--  2.0 unx    35546 b- defN 23-May-31 00:07 pdfCropMargins-1.2.0.dist-info/LICENSE
--rw-rw-r--  2.0 unx    61810 b- defN 23-May-31 00:07 pdfCropMargins-1.2.0.dist-info/METADATA
--rw-rw-r--  2.0 unx      110 b- defN 23-May-31 00:07 pdfCropMargins-1.2.0.dist-info/WHEEL
--rw-rw-r--  2.0 unx      125 b- defN 23-May-31 00:07 pdfCropMargins-1.2.0.dist-info/entry_points.txt
--rw-rw-r--  2.0 unx       15 b- defN 23-May-31 00:07 pdfCropMargins-1.2.0.dist-info/top_level.txt
-?rw-rw-r--  2.0 unx     2385 b- defN 23-May-31 00:07 pdfCropMargins-1.2.0.dist-info/RECORD
-24 files, 4152814 bytes uncompressed, 1835753 bytes compressed:  55.8%
+-rw-rw-r--  2.0 unx    35546 b- defN 23-Jun-09 17:58 pdfCropMargins-2.0.0.dist-info/LICENSE
+-rw-rw-r--  2.0 unx    59105 b- defN 23-Jun-09 17:58 pdfCropMargins-2.0.0.dist-info/METADATA
+-rw-rw-r--  2.0 unx      110 b- defN 23-Jun-09 17:58 pdfCropMargins-2.0.0.dist-info/WHEEL
+-rw-rw-r--  2.0 unx      125 b- defN 23-Jun-09 17:58 pdfCropMargins-2.0.0.dist-info/entry_points.txt
+-rw-rw-r--  2.0 unx       15 b- defN 23-Jun-09 17:58 pdfCropMargins-2.0.0.dist-info/top_level.txt
+?rw-rw-r--  2.0 unx     2485 b- defN 23-Jun-09 17:58 pdfCropMargins-2.0.0.dist-info/RECORD
+25 files, 4150579 bytes uncompressed, 1835186 bytes compressed:  55.8%
```

## zipnote {}

```diff
@@ -30,14 +30,17 @@
 
 Filename: pdfCropMargins/prettified_argparse.py
 Comment: 
 
 Filename: pdfCropMargins/pymupdf_routines.py
 Comment: 
 
+Filename: pdfCropMargins/tmp_test_metadata_setting.py
+Comment: 
+
 Filename: pdfCropMargins/pdftoppm_windows_local/__init__.py
 Comment: 
 
 Filename: pdfCropMargins/pdftoppm_windows_local/xpdf_tools_win_4_01_01/__init__.py
 Comment: 
 
 Filename: pdfCropMargins/pdftoppm_windows_local/xpdf_tools_win_4_01_01/bin32/__init__.py
@@ -48,26 +51,26 @@
 
 Filename: pdfCropMargins/pdftoppm_windows_local/xpdf_tools_win_4_01_01/bin64/__init__.py
 Comment: 
 
 Filename: pdfCropMargins/pdftoppm_windows_local/xpdf_tools_win_4_01_01/bin64/pdftoppm.exe
 Comment: 
 
-Filename: pdfCropMargins-1.2.0.dist-info/LICENSE
+Filename: pdfCropMargins-2.0.0.dist-info/LICENSE
 Comment: 
 
-Filename: pdfCropMargins-1.2.0.dist-info/METADATA
+Filename: pdfCropMargins-2.0.0.dist-info/METADATA
 Comment: 
 
-Filename: pdfCropMargins-1.2.0.dist-info/WHEEL
+Filename: pdfCropMargins-2.0.0.dist-info/WHEEL
 Comment: 
 
-Filename: pdfCropMargins-1.2.0.dist-info/entry_points.txt
+Filename: pdfCropMargins-2.0.0.dist-info/entry_points.txt
 Comment: 
 
-Filename: pdfCropMargins-1.2.0.dist-info/top_level.txt
+Filename: pdfCropMargins-2.0.0.dist-info/top_level.txt
 Comment: 
 
-Filename: pdfCropMargins-1.2.0.dist-info/RECORD
+Filename: pdfCropMargins-2.0.0.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## pdfCropMargins/__init__.py

```diff
@@ -1,9 +1,9 @@
 """
 pdfCropMargins
 """
 
-__version__ = "1.2.0" # major version, minor version, patch (see PEP440)
+__version__ = "2.0.0" # major version, minor version, patch (see PEP440)
 
 # The only function designed to be called from a user's Python code.
 from pdfCropMargins.pdfCropMargins import crop
```

## pdfCropMargins/calculate_bounding_boxes.py

```diff
@@ -27,14 +27,15 @@
 
 """
 
 import sys
 import os
 import glob
 import time
+import io
 from . import external_program_calls as ex
 from . import pymupdf_routines
 
 #
 # Image-processing imports.
 #
 
@@ -65,27 +66,25 @@
 
 args = None # Command-line arguments; set in get_bounding_box_list.
 
 #
 # The main functions of the module.
 #
 
-def get_bounding_box_list(input_doc_fname, input_doc, full_page_box_list,
-                          set_of_page_nums_to_crop, argparse_args, chosen_PdfWriter):
+def get_bounding_box_list(input_doc_fname, input_doc_mupdf_wrapper, full_page_box_list,
+                          set_of_page_nums_to_crop, argparse_args):
     """Calculate a bounding box for each page in the document.  The
     `input_doc_fname` argument is the filename of the document's original PDF
-    file, `input_doc` is the `PdfReader` for the document.  The argument
-    `full_page_box_list` is a list of the full-page-size boxes (which is used
-    to correct for any nonzero origins in the PDF coordinates).  The
-    `set_of_page_nums_to_crop` argument is the set of page numbers to crop; it
-    is passed so that unnecessary calculations can be skipped.  The
+    file, `input_doc_mupdf_wrapper` is a class wrapping the PyMuPDF document.
+    The argument `full_page_box_list` is a list of the full-page-size boxes
+    (which is used to correct for any nonzero origins in the PDF coordinates).
+    The `set_of_page_nums_to_crop` argument is the set of page numbers to crop;
+    it is passed so that unnecessary calculations can be skipped.  The
     `argparse_args` argument should be passed the args parsed from the command
-    line by argparse.  The `chosen_PdfWriter` is the PdfWriter class
-    from whichever pyPdf package was chosen by the main program.  The function
-    returns the list of bounding boxes."""
+    line by argparse.  The function returns the list of bounding boxes."""
     global args
     args = argparse_args # Make args available to all funs in module, as a global.
 
     if args.calcbb == "gb":
         if args.verbose:
             print("\nUsing Ghostscript to calculate the bounding boxes.")
         bbox_list = ex.get_bounding_box_list_ghostscript(input_doc_fname,
@@ -94,15 +93,16 @@
         if not has_pillow:
             print("\nError in pdfCropMargins: No version of the Python 'pillow'"
                   "\npackage was found.  Either install that Python package or use"
                   "\nGhostscript directly ('--calcbb gb' or '--gsBbox') if you"
                   "\nhave Ghostscript installed.", file=sys.stderr)
             ex.cleanup_and_exit(1)
 
-        bbox_list = get_bounding_box_list_render_image(input_doc_fname, input_doc)
+        bbox_list = get_bounding_box_list_render_image(input_doc_fname,
+                                                       input_doc_mupdf_wrapper)
 
     # Now we need to use the full page boxes to translate for non-zero origin.
     bbox_list = correct_bounding_box_list_for_nonzero_origin(bbox_list, full_page_box_list)
 
     return bbox_list
 
 def correct_bounding_box_list_for_nonzero_origin(bbox_list, full_box_list):
@@ -117,28 +117,32 @@
     for bbox, full_box in zip(bbox_list, full_box_list):
         left_x = full_box[0]
         lower_y = full_box[1]
         corrected_box_list.append([bbox[0]+left_x, bbox[1]+lower_y,
                                  bbox[2]+left_x, bbox[3]+lower_y])
     return corrected_box_list
 
-def get_bounding_box_list_render_image(pdf_file_name, input_doc):
+def get_bounding_box_list_render_image(pdf_file_name, input_doc_mupdf_wrapper):
     """Calculate the bounding box list by directly rendering each page of the PDF as
-    an image file.  The MediaBox and CropBox values in `input_doc` should have
-    already been set to the chosen page size before the rendering."""
+    an image file.  The MediaBox and CropBox values in `input_doc_mupdf_wrapper`
+    media boxex should have already been set to the chosen page size before the rendering."""
     if args.calcbb == "m":
         program_to_use = "mupdf"
     elif args.calcbb == "p":
         program_to_use = "pdftoppm"
     elif args.calcbb == "gr":
         program_to_use = "Ghostscript"
     else:
         raise ValueError("Attempting render pages when no rendering method was specified"
                 "\nPassed 'calcbb' argument of '{}'.".format(args.calcbb))
 
+    #
+    # Render all the pages to images.
+    #
+
     if args.verbose:
         print("\nRendering the PDF to images using the " + program_to_use + " program,"
               "\nthis may take a while...")
 
     # Threshold value set in range 0-255, where 0 is black, with 191 default.
     threshold = args.threshold[0]
     dark_background_light_foreground = False
@@ -163,26 +167,29 @@
     if args.verbose:
         print("\nAnalyzing the page images with Pillow to find bounding boxes,"
               "\nusing the threshold " + str(args.threshold[0]) + "."
               "  Finding the bounding box for page:\n")
 
     bounding_box_list = []
 
+    #
+    # Loop over each page and calculate the bounding box for the rendered image.
+    #
+
     for page_num, tmp_image_file_name in enumerate(outfiles):
-        curr_page = input_doc.pages[page_num]
+        curr_page = input_doc_mupdf_wrapper.document[page_num]
 
         # Open the image in Pillow.  Retry a few times on fail in case race conditions.
         if program_to_use == "mupdf":
-            import io
             image = image_list[page_num]
             # Opening directly in Pillow: https://github.com/pymupdf/PyMuPDF/issues/322
             pil_im = Image.open(io.BytesIO(image))
 
         else:
-            max_num_tries = 3
+            max_num_tr:ies = 3
             time_between_tries = 1
             curr_num_tries = 0
             while True:
                 try:
                     # PIL for some reason fails in Python 3.4 if you open the image
                     # from a file you opened yourself.  Works in Python 2 and earlier
                     # Python 3.  So original code is commented out, and path passed.
@@ -221,15 +228,16 @@
         else:
             pil_im = pil_im.point(lambda p: 255 if p >= threshold else 0) # create positive image
 
         if args.showImages:
             pil_im.show() # usually for debugging or param-setting
 
         # Calculate the bounding box of the negative image, and append to list.
-        bounding_box = calculate_bounding_box_from_image(pil_im, curr_page)
+        bounding_box = calculate_bounding_box_from_image(pil_im,
+                                 pymupdf_routines.get_box(curr_page, "mediabox"))
         bounding_box_list.append(bounding_box)
 
         # Clean up the image files after they are no longer needed.
         # tmpImageFile.close() # see above comment
         if tmp_image_file_name:
             os.remove(tmp_image_file_name)
 
@@ -277,15 +285,15 @@
     document_pages = pymupdf_routines.MuPdfDocument(args)
     num_pages = document_pages.open_document(pdf_file_name)
 
     # Note that the images here are PPM bytes objects.
     page_images = [document_pages.get_page_ppm_for_crop(i) for i in range(num_pages)]
     return page_images
 
-def calculate_bounding_box_from_image(im, curr_page):
+def calculate_bounding_box_from_image(im, curr_page_mediabox):
     """This function uses a Pillow routine to get the bounding box, in bp, of
     the rendered image."""
     x_max, y_max = im.size
     bounding_box = im.getbbox() # Note this uses ltrb convention.
     if not bounding_box:
         #print("\nWarning: could not calculate a bounding box for this page."
         #      "\nAn empty page is assumed.", file=sys.stderr)
@@ -293,21 +301,21 @@
 
     bounding_box = list(bounding_box) # Make temporarily mutable.
 
     # Compensate for reversal of the image y convention versus PDF.
     bounding_box[1] = y_max - bounding_box[1]
     bounding_box[3] = y_max - bounding_box[3]
 
-    full_page_box = curr_page.mediabox # Should have been set already to chosen box.
+    full_page_box = curr_page_mediabox # Should have been set already to chosen box.
 
     # Convert pixel units to PDF's bp units.
-    convert_x = float(full_page_box.right
-                    - full_page_box.left) / x_max
-    convert_y = float(full_page_box.top
-                    - full_page_box.bottom) / y_max
+    convert_x = float(full_page_box.x1
+                    - full_page_box.x0) / x_max
+    convert_y = float(full_page_box.y1
+                    - full_page_box.y0) / y_max
 
     # Get final box; note conversion to lower-left point, upper-right point format.
     final_box = [bounding_box[0] * convert_x,
                  bounding_box[3] * convert_y,
                  bounding_box[2] * convert_x,
                  bounding_box[1] * convert_y]
```

## pdfCropMargins/external_program_calls.py

```diff
@@ -189,15 +189,14 @@
         dir_name = program_temp_directory
     tmp_output_file = tempfile.NamedTemporaryFile(delete=True,
                      prefix=temp_file_prefix, suffix=extension, dir=dir_name, mode="wb")
     tmp_output_filename = tmp_output_file.name
     tmp_output_file.close() # This deletes the file, too, but it is empty in this case.
     return tmp_output_filename
 
-
 # The global directory that all temporary files are written to.  Other modules
 # all use the definition from this module.  This makes it easy to clean up all
 # the possibly large files, even on KeyboardInterrupt, by just deleting this
 # directory.
 program_temp_directory = None # Set by `create_temporary_directory`.
 
 # Set up an environment variable so Ghostscript will use program_temp_directory
```

## pdfCropMargins/gui.py

```diff
@@ -418,14 +418,15 @@
 
     update_funs.append(update_absoluteOffset_values)
 
     ##
     ## Code for uniformOrderStat options.
     ##
 
+    uniformOrderStat_spinner_values = tuple(range(0, num_pages))
     if args.uniformOrderStat:
         args_dict["uniformOrderStat"] = args.uniformOrderStat
     else:
         args_dict["uniformOrderStat"] = [0]
 
     if args.uniformOrderStat4:
         args_dict["uniformOrderStat4"] = args.uniformOrderStat4
@@ -438,22 +439,22 @@
     else:
         args_dict["uniformOrderStat4"] = [0] * 4
 
     dummy_spacing_spinner = sg.Text("", size=(7,1), pad=(0,0))
 
     text_uniformOrderStat = sg.Text("uniformOrderStat",
                       tooltip=get_help_text_string_for_tooltip(cmd_parser, "uniformOrderStat"))
-    input_text_uniformOrderStat = sg.Spin(values=spinner_values,
+    input_text_uniformOrderStat = sg.Spin(values=uniformOrderStat_spinner_values,
                                  initial_value=args_dict["uniformOrderStat"][0], pad=(0,0),
                                  size=(5, 1), enable_events=True, key="uniformOrderStat")
 
     # Code for uniformOrderStat4.
     text_uniformOrderStat4 = sg.Text("uniformOrderStat4",
                       tooltip=get_help_text_string_for_tooltip(cmd_parser, "uniformOrderStat4"))
-    input_text_uniformOrderStat4 = [sg.Spin(values=spinner_values,
+    input_text_uniformOrderStat4 = [sg.Spin(values=uniformOrderStat_spinner_values,
                                     initial_value=args_dict["uniformOrderStat4"][i], size=(5, 1),
                                     enable_events=True, key=f"uniformOrderStat4_{i}", pad=(1,0))
                                     for i in [0,1,2,3]]
 
     def update_uniformOrderStat_values(values_dict):
         """Update both the uniformOrderStat value and the uniformOrderStat4 values."""
         update_paired_1_and_4_values(input_text_uniformOrderStat,
```

## pdfCropMargins/main_pdfCropMargins.py

```diff
@@ -1,11 +1,11 @@
 """
 
 This script is not the starting/entry point script.  If installed with pip you
-can just run `pdf-crop-margins` to run the program.  When pip is not used the
+can just run `pdfcropmargins` to run the program.  When pip is not used the
 starting point for the pdfCropMargins program is to import function `main` from
 the `pdfCropMargins.py` script and run it.  The source directory has a
 `__main__.py` file which does this automatically when Python is invoked on the
 directory.  There is also standalone script in the `bin` directory which is the
 preferred way to run the program when it is not installed via pip.
 
 =====================================================================
@@ -26,31 +26,62 @@
 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
 Source code site: https://github.com/abarker/pdfCropMargins
 
 """
 
+# Might want an option to delete the XML save data.
+
+# TODO GUI options not error-checked/repaired on arg reprocessing, uniformOrderStat
+# Separate out the parts of `process_command_line_arguments` that can be re-run from
+# the top of `process_pdf_file` each time it is called.  Also allows implementing
+# the `--stringRestored` option, which is commented out in manpage file.
+
+# TODO: Maybe use _restored and restored_ prefix and suffix for restore ops???
+# Need a new option --stringRestored.
+
+# TODO: Maybe add option to see the MuPdf warnings, use
+# fitz.TOOLS.mupdf_warnings() first to empty warnings and then to get warnings,
+# see https://github.com/pymupdf/PyMuPDF/discussions/1501
+
 # TODO: Make --evenodd option equalize the pages after separately calculating
 # the crops, just do the max over them.
 
+# TODO: Deleting metadata on restore doesn't seem to remove key like docs say.
+#       So restored document still registers as already cropped.
+#       See the `check_and_set_crop_metadata` function.
+#       https://pymupdf.readthedocs.io/en/latest/recipes-low-level-interfaces.html#how-to-extend-pdf-metadata
+
 # Some general notes, useful for reading the code.
 #
-# Margins are conveniently described as left, bottom, right, and top, but boxes
-# in PDF files are usually defined by the lower-left point's x and y values
-# followed by the upper-right point's x and y values.  This is equivalent
-# information (since x and y is implicit in the margin names) but the viewpoint
-# is slightly different.  The origin is at the lower left.
+# Margins are described as left, bottom, right, and top (lbrt). Boxes
+# in pypdf2 and PDF are defined by the lower-left point's x and y values
+# followed by the upper-right point's x and y values, which is equivalent
+# information (since x and y are implicit in the margin names).
+# The origin is at the lower left. The pymupdf program uses the top left
+# as origin, which results in ltrb ordering:
+#
+# From: https://github.com/pymupdf/PyMuPDF/issues/317
+#    (Py-)MuPDF always uses a page's top-left point as the origin (0,0) of its
+#    coordinate system - for whatever reason, prresumably because it does not
+#    only deal with PDF, but also other document types.  PDF uses a page's
+#    bottom-left point as (0,0).
 #
-# This program (like the Ghostscript program) uses the PDF ordering convention
-# (lbrt) for listing margins and defining boxes.  Note that Pillow uses some
-# different conventions.  The origin in PDFs is the lower left going up but the
-# origin in Pillow images is the upper left going down.  Also, the bounding box
-# routine of Pillow returns ltrb instead of lbrt.  Keep in mind that the program
-# needs to make these conversions when rendering explicitly to images.
+# This program (like the Ghostscript program and pypdf2) uses the PDF ordering
+# convention (lbrt) for listing margins and defining boxes.  Note that Pillow
+# uses some different conventions.  The origin in PDFs is the lower left going
+# up but the origin in Pillow images is the upper left going down.  So the
+# bounding box routine of Pillow returns ltrb instead of lbrt.  Keep in mind
+# that the program needs to make these conversions when rendering explicitly to
+# images.
+#
+# This program uses pymupdf, but uses the PDF and pypdf2 convention (mainly
+# because it originally used pypdf2).  All values are converted by a wrapper
+# around the pymupdf routines, which are in the module pymupdf_routines.
 
 import sys
 import os
 import shutil
 import time
 from decimal import Decimal
 from warnings import warn
@@ -59,48 +90,30 @@
     import readline # Makes prompts go to stdout rather than stderr.
 except ImportError: # Not available on Windows.
     pass
 
 from . import __version__ # Get the version number from the __init__.py file.
 from .manpage_data import cmd_parser, DEFAULT_THRESHOLD_VALUE
 from .prettified_argparse import parse_command_line_arguments
-from .pymupdf_routines import has_mupdf
+from .pymupdf_routines import (has_mupdf, MuPdfDocument, get_box, set_box, Rect,
+        intersect_pdf_boxes, fitz)
 
 from . import external_program_calls as ex
 project_src_directory = ex.project_src_directory
 
-try:
-    from PyPDF2 import PdfWriter, PdfReader
-    from PyPDF2.generic import (NameObject, create_string_object, RectangleObject,
-                                FloatObject, IndirectObject)
-except ImportError:
-    print("\nError in pdfCropMargins: No system PyPDF2 Python package"
-          "\nwas found.  Reinstall pdfCropMargins via pip or install that"
-          "\ndependency ('pip install pypdf2').\n", file=sys.stderr)
-    ex.cleanup_and_exit(1)
-
-try:
-    from PyPDF2.errors import PdfReadError, ParseError, PyPdfError # Versions >= 2.0.
-except ImportError:
-    try:
-        from PyPDF2.utils import PdfReadError, ParseError, PyPdfError # Versions < 2.0.
-    except ImportError:
-        print("\nError in pdfCropMargins: The PdfReadError exception could not"
-              "\nbe found.  Try updating pdfCropMargins and/or PyPDF2 via pip.",
-              file=sys.stderr)
-        ex.cleanup_and_exit(1)
-
 from .calculate_bounding_boxes import get_bounding_box_list
 
 ##
 ## Some data used by the program.
 ##
 
 # The string which is appended to Producer metadata in cropped PDFs.
-PRODUCER_MODIFIER = " (Cropped by pdfCropMargins.)"
+PRODUCER_MODIFIER = " (Cropped by pdfCropMargins.)" # String for older versions.
+PRODUCER_MODIFIER_2 = " (Cropped by pdfCropMargins>=2.0.)" # Added to Producer metadata.
+RESTORE_METADATA_KEY = "pdfCropMarginsRestoreData" # Key for XML dict restore data.
 
 # Limit precision to some reasonable amount to prevent problems in some PDF viewers.
 DECIMAL_PRECISION_FOR_MARGIN_POINT_VALUES = 8
 
 args = None # Global set during cmd-line processing (since almost all funs use it).
 
 ##
@@ -196,134 +209,133 @@
     if float_ratio == 0 or float_ratio == float("inf"):
         print("\nError in pdfCropMargins: Bad format in argument to "
               " setPageRatios.\nZero or infinite aspect ratios are not allowed.",
               file=sys.stderr)
         raise ValueError
     return float_ratio
 
-def intersect_boxes(box1, box2):
-    """Takes two pyPdf boxes (such as page.mediabox) and returns the pyPdf
-    box which is their intersection."""
-    if not box1 and not box2: return None
-    if not box1: return box2
-    if not box2: return box1
-    intersect = RectangleObject([0, 0, 0, 0]) # Note [llx,lly,urx,ury] == [l,b,r,t]
-    intersect.upper_right = (min(box1.upper_right[0], box2.upper_right[0]),
-                            min(box1.upper_right[1], box2.upper_right[1]))
-    intersect.lower_left = (max(box1.lower_left[0], box2.lower_left[0]),
-                           max(box1.lower_left[1], box2.lower_left[1]))
-    return intersect
-
 def mod_box_for_rotation(box, angle, undo=False):
     """The user sees left, bottom, right, and top margins on a page, but inside
     the PDF and in pyPdf the page may be rotated (such as in landscape mode).
     In the case of 90 degree clockwise rotation the left really modifies the
     top, the top really modifies right, and so forth.  In order for the options
     like '--percentRetain4' and '--absoluteOffset4' to work as expected the
     values need to be shifted to match any "hidden" rotations on any page.
     The `box` argument is a 4-tuple of left, bottom, right, top values."""
-
     def rotate_ninety_degrees_clockwise(box, n):
         """The `n` here is the number of 90deg rotations to do."""
-        if n == 0: return box
+        if n == 0:
+            return box
         box = rotate_ninety_degrees_clockwise(box, n-1)
         return [box[1], box[2], box[3], box[0]]
 
     # These are for clockwise, swap do and undo to reverse.
     do_map = {0: 0, 90: 1, 180: 2, 270: 3} # Map angle to num of 90deg rotations.
     undo_map = {0: 0, 90: 3, 180: 2, 270: 1}
 
     if not undo:
         return rotate_ninety_degrees_clockwise(box, do_map[angle])
     else:
         return rotate_ninety_degrees_clockwise(box, undo_map[angle])
 
-def get_full_page_box_assigning_media_and_crop(page, skip_pre_crop=False):
+def get_full_page_box_assigning_media_and_crop(page):
     """This returns whatever PDF box was selected (by the user option
     '--fullPageBox') to represent the full page size.  All cropping is done
     relative to this box.  The default selection option is the MediaBox
     intersected with the CropBox so multiple crops work as expected.
 
     The argument page should be a pyPdf page object.
 
     This function also sets the MediaBox and CropBox of the page to the
     full-page size and saves the old values in the same page namespace, so it
     should only be called once for each page.  It returns a `RectangleObject`
     box."""
-    # Note skip_pre_crop option isn't used, may or may not be useful.
 
     # Find the page rotation angle (degrees).
     # Note rotation is clockwise, and four values are allowed: 0 90 180 270
-    try:
-        rotation = page["/Rotate"].get_object() # this works, needs try
-        #rotation = page.get("/Rotate", 0) # from the PyPDF2 source, default 0
-    except KeyError:
-        rotation = 0
-    while rotation >= 360: rotation -= 360
-    while rotation < 0: rotation += 360
+    rotation = page.rotation
+    while rotation >= 360:
+        rotation -= 360
+    while rotation < 0:
+        rotation += 360
 
     # Save the rotation value in the page's namespace so we can restore it later.
     page.rotationAngle = rotation
 
-    # Un-rotate the page, leaving it with an rotation of 0.
-    page.rotate(-rotation)
+    # Un-rotate the page, to a rotation of 0.
+    page.set_rotation(0)
 
     # Save copies of some values in the page's namespace, to possibly restore later.
-    page.original_media_box = page.mediabox
-    page.original_crop_box = page.cropbox
+    page.original_media_box = get_box(page, "mediabox")
+    page.original_crop_box = get_box(page, "cropbox")
+
+    box_string = ["m", "c"]
 
     first_loop = True
     for box_string in args.fullPageBox:
-        if box_string == "m": f_box = page.mediabox
-        if box_string == "c": f_box = page.cropbox
-        if box_string == "t": f_box = page.trimbox
-        if box_string == "a": f_box = page.artbox
-        if box_string == "b": f_box = page.bleedbox
+        if box_string == "m":
+            f_box = get_box(page, "mediabox")
+        if box_string == "c":
+            f_box = get_box(page, "cropbox")
+        if box_string == "t":
+            f_box = get_box(page, "trimbox")
+        if box_string == "a":
+            f_box = get_box(page, "artbox")
+        if box_string == "b":
+            f_box = get_box(page, "bleedbox")
 
         # Take intersection over all chosen boxes.
         if first_loop:
             full_box = f_box
         else:
-            full_box = intersect_boxes(full_box, f_box)
+            full_box = intersect_pdf_boxes(full_box, f_box, page)
 
         first_loop = False
 
-    if not skip_pre_crop:
-        # Do any absolute pre-cropping specified for the page (after modifying any
-        # absolutePreCrop4 arguments to take into account rotations to the page).
-        precrop_box = mod_box_for_rotation(args.absolutePreCrop4, rotation)
-        full_box = RectangleObject([float(full_box.lower_left[0]) + precrop_box[0],
-                                    float(full_box.lower_left[1]) + precrop_box[1],
-                                    float(full_box.upper_right[0]) - precrop_box[2],
-                                    float(full_box.upper_right[1]) - precrop_box[3]])
-
-    page.mediabox = full_box
-    page.cropbox = full_box
+    return rotation, full_box, page
 
+def apply_precrop(rotation, full_box, page):
+    """Apply the precrop to the document's box settings."""
+    # Do any absolute pre-cropping specified for the page (after modifying any
+    # absolutePreCrop4 arguments to take into account rotations to the page).
+    precrop_box = mod_box_for_rotation(args.absolutePreCrop4, rotation)
+
+    full_box = [float(full_box[0]) + precrop_box[0],
+                float(full_box[1]) + precrop_box[1],
+                float(full_box[2]) - precrop_box[2],
+                float(full_box[3]) - precrop_box[3],
+                ]
+
+    # Note that MediaBox is set FIRST, since PyMuPDF will reset all other boxes
+    # when it is set.
+    set_box(page, "mediabox", full_box)
+    set_box(page, "cropbox", full_box)
     return full_box
 
-def get_full_page_box_list_assigning_media_and_crop(input_doc, quiet=False,
-                                                    skip_pre_crop=False):
-    """Get a list of all the full-page box values for each page.  The argument
-    input_doc should be a `PdfReader` object.  The boxes on the list are in the
-    simple 4-float list format used by this program, not `RectangleObject` format."""
+def get_full_page_box_list_assigning_media_and_crop(input_doc_mupdf_wrapper, quiet=False):
+    """Get a list of all the full-page box values for each page.  The boxes on
+    the list are in the simple 4-float list format used by this program, not
+    `RectangleObject` format."""
 
     full_page_box_list = []
     rotation_list = []
 
     if args.verbose and not quiet:
         print(f"\nOriginal full page sizes (rounded to "
               f"{DECIMAL_PRECISION_FOR_MARGIN_POINT_VALUES} digits) in PDF format (lbrt):")
 
-    for page_num in range(len(input_doc.pages)):
+    for page_num in range(input_doc_mupdf_wrapper.num_pages):
 
         # Get the current page and find the full-page box.
-        curr_page = input_doc.pages[page_num]
-        full_page_box = get_full_page_box_assigning_media_and_crop(curr_page,
-                                                                   skip_pre_crop)
+        curr_page = input_doc_mupdf_wrapper.page_list[page_num]
+        rotation, full_box, page = get_full_page_box_assigning_media_and_crop(curr_page)
+
+        # Do any absolute pre-cropping specified for the page (after modifying any
+        # absolutePreCrop4 arguments to take into account rotations to the page).
+        full_page_box = apply_precrop(rotation, full_box, page)
 
         if args.verbose and not quiet:
             # want to display page num numbering from 1, so add one
             rounded_box_string = ", ".join([str(round(f,
                         DECIMAL_PRECISION_FOR_MARGIN_POINT_VALUES)) for f in full_page_box])
             print(f"\t{str(page_num+1)}   rot = "
                   f"{curr_page.rotationAngle}  \t [{rounded_box_string}]")
@@ -632,294 +644,211 @@
                 top_weight /= total_tb_weight
                 ratio_set_crop_list.append((left, bottom - difference * bottom_weight,
                                            right, top + difference * top_weight))
         final_crop_list = ratio_set_crop_list
 
     return final_crop_list, delta_page_nums
 
-def check_producer_modifier(metadata_info):
-    """Check Producer metadata attribute to see if this program cropped document before.
-    Returns the new producer modifier string to add to the producer metadata along with
-    a boolean `already_cropped_by_this_program`."""
-    producer_mod = PRODUCER_MODIFIER # String added to the producer metadata, marks when cropped.
+def check_and_set_crop_metadata(document_wrapper_class, metadata_info):
+    """First check the producer metadata attribute to see if this program was
+    cropped document before.  Returns the variable
+    `already_cropped_by_this_program` which is either `False` or has the value
+    string `"<2.0"` or `">=2.0".
+
+    The "Producer" metadata then has a string appended (if not already there)
+    to indicate that this program modified the file."""
+    def has_xml_restore_data():
+        """This function is a workaround because setting the XML metadata key
+        to "null" doesn't seem to delete the key itself like the docs say.  Need
+        to look at the value to determine if there is data there to determine
+        `already_cropped_by_this_program` since value is set null on restore."""
+        # TODO: Should be able to just check key with `doc_wrap.has_xml_metadata_key`
+        # but doesn't work.
+        data_value, has_xml_metadata, has_key = document_wrapper_class.get_xml_metadata_value(
+                                                                         RESTORE_METADATA_KEY)
+        if has_key:
+            return data_value[0] == "["
+        return False
+
     if metadata_info:
-        old_producer_string = metadata_info.producer
+        old_producer_string = metadata_info["producer"]
     else:
         return PRODUCER_MODIFIER, False # Can't read metadata, but maybe can set it.
-    if old_producer_string and old_producer_string.endswith(producer_mod):
-        producer_mod = "" # No need to pile up suffixes each time on Producer.
+
+    if has_xml_restore_data(): # See note in function.
+        if args.verbose:
+            print("\nThe document was already cropped at least once by pdfCropMargins>=2.0.")
+        already_cropped_by_this_program = ">=2.0"
+
+    elif old_producer_string and old_producer_string.endswith(PRODUCER_MODIFIER):
         if args.verbose:
-            print("\nThe document was already cropped at least once by pdfCropMargins.")
-        already_cropped_by_this_program = True
+            print("\nThe document was already cropped at least once by pdfCropMargins<2.0.")
+        already_cropped_by_this_program = "<2.0"
+        # Update the Producer suffix to the the new PRODUCER_MODIFIER_2.
+        new_producer_string = old_producer_string.replace(PRODUCER_MODIFIER, PRODUCER_MODIFIER_2)
+        metadata_info["producer"] = new_producer_string
+
     else:
         if args.verbose:
             print("\nThe document was not previously cropped by pdfCropMargins.")
+        metadata_info["producer"] = metadata_info["producer"] + PRODUCER_MODIFIER_2
         already_cropped_by_this_program = False
-    return producer_mod, already_cropped_by_this_program
-
-def set_cropped_metadata(input_doc, output_doc, metadata_info, producer_mod):
-    """Set the metadata for the output document.  Mostly just copied over, but
-    "Producer" has a string appended to indicate that this program modified the
-    file.  That allows for the undo operation to make sure that this
-    program cropped the file in the first place."""
 
-    # Setting metadata with pyPdf requires low-level pyPdf operations, see
-    # http://stackoverflow.com/questions/2574676/change-metadata-of-pdf-file-with-pypdf
-    #
-    # TODO: Later versions support metadata directly:
-    #    https://pypdf2.readthedocs.io/en/latest/user/metadata.html
-    if not metadata_info:
-        # In case it's null, just set values to empty strings.  This class just holds
-        # data temporary in the same format; this is not sent into PyPDF2.
-        class MetadataInfo:
-            author = ""
-            creator = ""
-            producer = ""
-            subject = ""
-            title = ""
-        metadata_info = MetadataInfo()
-
-    output_info_dict = output_doc._info.get_object()
-
-    # Note that all None metadata attributes are currently set to the empty string
-    # when passing along the metadata information.
-    def st(item):
-        if item is None: return ""
-        else: return item
-
-    output_info_dict.update({
-          NameObject("/Author"): create_string_object(st(metadata_info.author)),
-          NameObject("/Creator"): create_string_object(st(metadata_info.creator)),
-          NameObject("/Producer"): create_string_object(st(metadata_info.producer)
-                                                                 + producer_mod),
-          NameObject("/Subject"): create_string_object(st(metadata_info.subject)),
-          NameObject("/Title"): create_string_object(st(metadata_info.title))
-          })
-
-def apply_crop_list(crop_list, input_doc, page_nums_to_crop,
-                                          already_cropped_by_this_program):
-    """Apply the crop list to the pages of the input `PdfReader` object."""
-    if args.restore and not already_cropped_by_this_program:
-        print("\nWarning from pdfCropMargins: The Producer string indicates that"
-              "\neither this document was not previously cropped by pdfCropMargins"
-              "\nor else it was modified by another program after that.  Ignoring the"
-              "\nrestore operation.", file=sys.stderr)
-        return
+    document_wrapper_class.set_standard_metadata(metadata_info)
+    return already_cropped_by_this_program
 
-    if args.verbose:
-        if args.restore:
-            print("\nRestoring the document to margins saved for each page in the ArtBox.")
-        else:
-            print("\nNew full page sizes after cropping, in PDF format (lbrt):")
+def serialize_boxlist(boxlist):
+    """Return the string for the list of boxes."""
+    return str([list(b) for b in boxlist])
+
+def deserialize_boxlist(boxlist_string):
+    """Return the string for the list of boxes."""
+    if boxlist_string[0] != "[" or boxlist_string[-1] != "]":
+        return None
+    boxlist_string = boxlist_string[2:-2]
+    split_list = boxlist_string.split("], [")
+    deserialized_boxlist = []
+    for box in split_list:
+        values = box.split(",")
+        try:
+            deserialized_boxlist.append([float(v) for v in values])
+        except ValueError:
+            return None
+    return deserialized_boxlist
 
+def save_old_boxes_for_restore(input_doc_mupdf_wrapper, original_mediabox_list,
+                               original_cropbox_list, original_artbox_list,
+                               already_cropped_by_this_program):
+    """Save the intersection of the cropbox and the mediabox."""
+    if already_cropped_by_this_program == "<2.0":
+        old_boxes_to_save_list = original_artbox_list
+    else:
+        old_boxes_to_save_list = [] # Save list of old boxes to possibly save for later restore.
+        for page_num in range(input_doc_mupdf_wrapper.document.page_count):
+            curr_page = input_doc_mupdf_wrapper.page_list[page_num]
+
+            # Do the save for later restore if that option is chosen and Producer is not set.
+            box = intersect_pdf_boxes(original_mediabox_list[page_num],
+                                      original_cropbox_list[page_num], curr_page)
+            old_boxes_to_save_list.append(box)
+
+    serialized_saved_boxes_list = serialize_boxlist(old_boxes_to_save_list)
+    input_doc_mupdf_wrapper.set_xml_metadata_item(RESTORE_METADATA_KEY,
+                                                        serialized_saved_boxes_list)
+
+def apply_crop_list(crop_list, input_doc_mupdf_wrapper, page_nums_to_crop,
+                    already_cropped_by_this_program):
+    """Apply the crop list to the pages of the input document."""
     if args.writeCropDataToFile:
         args.writeCropDataToFile = ex.get_expanded_path(args.writeCropDataToFile)
         f = open(args.writeCropDataToFile, "w")
+    else:
+        f = None
 
-    # Copy over each page, after modifying the appropriate PDF boxes.
-    for page_num in range(len(input_doc.pages)):
+    if args.verbose:
+        print("\nNew full page sizes after cropping, in PDF format (lbrt):")
 
-        curr_page = input_doc.pages[page_num]
+    # Set the appropriate PDF boxes on each page.
+    for page_num in range(input_doc_mupdf_wrapper.document.page_count):
+        curr_page = input_doc_mupdf_wrapper.page_list[page_num]
 
         # Restore any rotation which was originally on the page.
-        curr_page.rotate(curr_page.rotationAngle)
+        curr_page.set_rotation(curr_page.rotationAngle)
 
-        # Only do the restore from ArtBox if '--restore' option was selected.
-        if args.restore:
-            if not curr_page.artbox:
-                print("\nWarning from pdfCropMargins: Attempting to restore pages from"
-                      "\nthe ArtBox in each page, but page", page_num, "has no readable"
-                      "\nArtBox.  Leaving that page unchanged.", file=sys.stderr)
-                continue
-            curr_page.mediabox = curr_page.artbox
-            curr_page.cropbox = curr_page.artbox
-            continue
-
-        # Do the save to ArtBox if that option is chosen and Producer is set.
-        if not args.noundosave and not already_cropped_by_this_program:
-            curr_page.artbox = intersect_boxes(curr_page.original_media_box,
-                                               curr_page.original_crop_box)
-
-        # Reset the CropBox and MediaBox to their saved original values
-        # (they were saved by `get_full_page_box_assigning_media_and_crop`
-        # in the `curr_page` object's namespace).
-        curr_page.mediabox = curr_page.original_media_box
-        curr_page.cropbox = curr_page.original_crop_box
+        # Reset the CropBox and MediaBox to their saved original values (they
+        # were saved by `get_full_page_box_assigning_media_and_crop` in the
+        # `curr_page` object's namespace).  Restore the MediaBox and CropBox to
+        # the saved values.  Note that MediaBox is set FIRST, since PyMuPDF
+        # will reset all other boxes when it is set.
+        set_box(curr_page, "mediabox", curr_page.original_media_box)
+        set_box(curr_page, "cropbox", curr_page.original_crop_box)
 
         # Copy the original page without further mods if it wasn't in the range
         # selected for cropping.
         if page_num not in page_nums_to_crop:
             continue
 
-        # Convert the computed "box to crop to" into a `RectangleObject` (for pyPdf).
-        rounded_values = [round(Decimal(f), DECIMAL_PRECISION_FOR_MARGIN_POINT_VALUES)
-                          for f in crop_list[page_num]] # RectangleObject converts to Decimal.
-        new_cropped_box = RectangleObject(rounded_values)
+        rounded_values = [round(f, DECIMAL_PRECISION_FOR_MARGIN_POINT_VALUES)
+                                for f in crop_list[page_num]]
+        new_cropped_box = rounded_values
 
         if args.verbose:
             print("\t"+str(page_num+1)+"\t", list(new_cropped_box)) # page numbering from 1
         if args.writeCropDataToFile:
             print("\t"+str(page_num+1)+"\t", list(new_cropped_box), file=f)
 
         if not args.boxesToSet:
             args.boxesToSet = ["m", "c"]
 
         # Now set any boxes which were selected to be set via the '--boxesToSet' option.
         if "m" in args.boxesToSet:
-            curr_page.mediabox = new_cropped_box
+            # Note the MediaBox is always set FIRST, since it resets the other boxes.
+            set_box(curr_page, "mediabox", new_cropped_box)
         if "c" in args.boxesToSet:
-            curr_page.cropbox = new_cropped_box
+            set_box(curr_page, "cropbox", new_cropped_box)
         if "t" in args.boxesToSet:
-            curr_page.trimbox = new_cropped_box
+            set_box(curr_page, "trimbox", new_cropped_box)
         if "a" in args.boxesToSet:
-            curr_page.artbox = new_cropped_box
+            set_box(curr_page, "artbox", new_cropped_box)
         if "b" in args.boxesToSet:
-            curr_page.bleedbox = new_cropped_box
+            set_box(curr_page, "bleedbox", new_cropped_box)
 
     if args.writeCropDataToFile:
         f.close()
         ex.cleanup_and_exit(0)
 
-def setup_output_document(input_doc, tmp_input_doc, metadata_info, producer_mod,
-                                                    copy_document_catalog=True):
-    """Create the output `PdfWriter` objects and copy over the relevant info.
-    Returns the writer objects `output_doc`, `tmp_output_doc`, and the boolean
-    `already_cropped_by_this_program`.  This function also sets the metadata for
-    the cropped output file."""
-    # NOTE: Inserting pages from a PdfReader into multiple PdfWriters
-    # seems to cause problems (writer can hang on write), so only one is used.
-    # This is why the tmp_input_doc file was created earlier, to get copies of
-    # the page objects which are independent of those in input_doc.  An ugly
-    # hack for a nasty bug to track down.
-    #
-    # Possible thing to try, copying pages:
-    #    https://stackoverflow.com/questions/52315259
+def apply_restore_operation(already_cropped_by_this_program, input_doc_mupdf_wrapper,
+                            original_artbox_list):
+    """Restore the saved page boxes to the document."""
+    if args.writeCropDataToFile:
+        args.writeCropDataToFile = ex.get_expanded_path(args.writeCropDataToFile)
+        f = open(args.writeCropDataToFile, "w")
+    else:
+        f = None
 
-    # NOTE: You can get the `_root_object` attribute (dict for the document
-    # catalog) from the output document after calling `cloneReaderDocumentRoot`
-    # or else you can just directly get it from the `input_doc.trailer dict`, as
-    # below (which is from the code for `cloneReaderDocumentRoot`), but you
-    # CANNOT set the full `_root_object` to be the `_root_object` attribute for
-    # the actual output_doc or else only blank pages show up in acroread (whether
-    # or not there is any attempt to explicitly copy the pages over).  The same
-    # is true for using `cloneDocumentFromReader` (which just calls
-    # `cloneReaderDocumentRoot` followed by `appendPagesFromReader`).  At least
-    # the '/Pages' key and value in `_root_object` cause problems, so they are
-    # skipped in the partial copy.  Probably a bug in PyPDF2.  See the original
-    # code for the routines on the github pages below.
-    #
-    # https://github.com/mstamy2/PyPDF2/blob/master/PyPDF2/pdf.py
-    # https://github.com/mstamy2/PyPDF2/blob/master/PyPDF2/generic.py
-    #
-    # Files still can change zoom mode on clicking outline links, but that is
-    # an Adobe implementation problem, and happens even in the uncropped files:
-    #    https://superuser.com/questions/278302/
-
-    output_doc = PdfWriter()
-
-    def root_objects_not_indirect(input_doc, root_object):
-        """This can expand some of the `IndirectObject` objects in a root object to
-        see the actual values.  Currently only used for debugging.  May mess up the
-        input doc and require a temporary one."""
-        if isinstance(root_object, dict):
-            return {root_objects_not_indirect(input_doc, key):
-                    root_objects_not_indirect(input_doc, value) for
-                                                  key, value in root_object.items()}
-        elif isinstance(root_object, list):
-            return [root_objects_not_indirect(input_doc, item) for item in root_object]
-        elif isinstance(root_object, IndirectObject):
-            return input_doc.get_object(root_object)
-        else:
-            return root_object
+    if already_cropped_by_this_program == ">=2.0":
+        saved_boxes, has_xml_metadata, xml_metadata_has_key = (
+                input_doc_mupdf_wrapper.get_xml_metadata_value(RESTORE_METADATA_KEY))
+        saved_boxes_list = deserialize_boxlist(saved_boxes)
+        if not saved_boxes_list:
+            print("\nError in pdfCropMargins: Could not deserialize the data saved for the"
+                    "\nrestore operation.  Deleting the key and the data.", file=sys.stderr)
+            input_doc_mupdf_wrapper.delete_xml_metadata_item(RESTORE_METADATA_KEY)
+
+    elif already_cropped_by_this_program == "<2.0":
+        saved_boxes_list = original_artbox_list
+
+    if not saved_boxes_list or len(saved_boxes_list) != input_doc_mupdf_wrapper.num_pages:
+        print("\nError in pdfCropMargins: The number of pages in the saved restore"
+              "\ndata is not the same as the number of pages in the document.  The"
+              "\nrestore operation will be ignored.", file=sys.stderr)
+        return
 
-    if args.docCatBlacklist or args.docCatWhitelist:
-        warn("\nThe blacklist and whitelist options for the document catalog are deprecated"
-                " and will be removed in version 3.0.", DeprecationWarning, 2)
-
-    doc_cat_whitelist = args.docCatWhitelist.split()
-    if "ALL" in doc_cat_whitelist:
-        doc_cat_whitelist = ["ALL"]
-
-    doc_cat_blacklist = args.docCatBlacklist.split()
-    if "ALL" in doc_cat_blacklist:
-        doc_cat_blacklist = ["ALL"]
-
-    # Partially copy over the document catalog data from input_doc to output_doc.
-    if not copy_document_catalog or (
-            not doc_cat_whitelist and doc_cat_blacklist == ["ALL"]):
-        # Check this first, to completely skip the possibly problematic code getting
-        # document catalog items when possible.  Does not print a skipped list, though.
-        if args.verbose:
-            print("\nNot copying any document catalog items to the cropped document.")
-    else:
-        # TODO: Try using the clone_reader_document_root function instead.
-        # https://pypdf2.readthedocs.io/en/latest/modules/PdfWriter.html#PyPDF2.PdfWriter.clone_reader_document_root
-        try:
-            root_object = input_doc.trailer["/Root"]
+    for page_num in range(input_doc_mupdf_wrapper.document.page_count):
+        curr_page = input_doc_mupdf_wrapper.page_list[page_num]
 
-            copied_items = []
-            skipped_items = []
-            for key, value in root_object.items():
-                # Some possible keys can be:
-                #
-                # /Type -- required, must have value /Catalog
-                # /Pages -- required, indirect ref to page tree; skip, will change
-                # /PageMode -- set to /UseNone, /UseOutlines, /UseThumbs, /Fullscreen,
-                #              /UseOC, or /UseAttachments, with /UseNone default.
-                # /OpenAction -- action to take when document is opened, like zooming
-                # /PageLayout -- set to /SinglePage, /OneColumn, /TwoColumnLeft,
-                #                /TwoColumnRight, /TwoPageLeft, /TwoPageRight
-                # /Names -- a name dictionary to avoid having to use object numbers
-                # /Outlines -- indirect ref to document outline, i.e., bookmarks
-                # /Dests -- a dict of destinations in the PDF
-                # /ViewerPreferences -- a viewer preferences dict
-                # /MetaData -- XMP metadata, as opposed to other metadata
-                # /PageLabels -- alternate numbering for pages, only affect PDF viewers
-                if key == "/Pages":
-                    skipped_items.append(key)
-                    continue
-                if doc_cat_whitelist != ["ALL"] and key not in doc_cat_whitelist:
-                    if doc_cat_blacklist == ["ALL"] or key in doc_cat_blacklist:
-                        skipped_items.append(key)
-                        continue
-                copied_items.append(key)
-                output_doc._root_object[NameObject(key)] = value
+        # Restore any rotation which was originally on the page.
+        curr_page.set_rotation(curr_page.rotationAngle)
 
-            if args.verbose:
-                print("\nCopied these items from the document catalog:\n   ", end="")
-                print(*copied_items)
-                print("Skipped copy of these items from the document catalog:\n   ", end="")
-                print(*skipped_items)
-
-        except (KeyboardInterrupt, EOFError):
-            raise
-        except: # Just catch any errors here; don't know which might be raised.
-            # On exception just warn and get a new PdfWriter object, to be safe.
-            print("\nWarning: The document catalog data could not be copied to the"
-                  "\nnew, cropped document.  Try fixing the PDF document using"
-                  "\n'--gsFix' if you have Ghostscript installed.", file=sys.stderr)
-            output_doc = PdfWriter()
-
-    #output_doc.appendPagesFromReader(input_doc) # Works, but wait and test more.
-    for page in [input_doc.pages[i] for i in range(len(input_doc.pages))]:
-        output_doc.add_page(page)
-
-    tmp_output_doc = PdfWriter()
-    #tmp_output_doc.appendPagesFromReader(tmp_input_doc)  # Works, but test more.
-    for page in [tmp_input_doc.pages[i] for i in range(len(tmp_input_doc.pages))]:
-        tmp_output_doc.add_page(page)
+        # Restore the MediaBox and CropBox to the saved values.  Note that
+        # MediaBox is set FIRST, since PyMuPDF will reset all other boxes
+        # when it is set.
+        set_box(curr_page, "mediabox", saved_boxes_list[page_num])
+        set_box(curr_page, "cropbox", saved_boxes_list[page_num])
+        if args.writeCropDataToFile:
+            print("\t"+str(page_num+1)+"\t", saved_boxes_list[page_num], file=f)
 
-    ##
-    ## Copy the metadata from input_doc to output_doc, modifying the Producer string
-    ## if this program didn't already set it.  Get bool for whether this program
-    ## cropped the document already.
-    ##
+    # The saved restore data is no longer needed.
+    if args.verbose:
+        print("\nDeleting the saved restore metadata since it is no longer needed.")
+    input_doc_mupdf_wrapper.delete_xml_metadata_item(RESTORE_METADATA_KEY)
 
-    set_cropped_metadata(input_doc, output_doc, metadata_info, producer_mod)
-    return output_doc, tmp_output_doc
+    if args.writeCropDataToFile:
+        f.close()
+        ex.cleanup_and_exit(0)
 
 ##############################################################################
 #
 # Functions implementing the major operations.
 #
 ##############################################################################
 
@@ -930,17 +859,18 @@
     args = parsed_args
 
     if args.prevCropped:
         args.gui = False # Ignore the GUI when --prevCropped option is selected.
         args.verbose = False # Wants to eval the text in Bash script.
 
     if args.verbose:
-        print("\nProcessing the PDF with pdfCropMargins (version", __version__+")...")
+        print(f"\nProcessing the PDF with pdfCropMargins (version {__version__})...")
         print("Python version:", ex.python_version)
         print("System type:", ex.system_os)
+        print(fitz.__doc__) # Print out PyMuPDF version info.
 
     if len(args.pdf_input_doc) > 1:
         print("\nError in pdfCropMargins: Only one input PDF document is allowed."
               "\nFound more than one on the command line:", file=sys.stderr)
         for f in args.pdf_input_doc:
             print("   ", f, file=sys.stderr)
         print(file=sys.stderr)
@@ -1014,14 +944,17 @@
 
     if args.absoluteOffset and not args.absoluteOffset4:
         args.absoluteOffset4 = args.absoluteOffset * 4 # expand to 4 offsets
     if args.verbose:
         print("\nThe absolute offsets to be applied to each margin, in units of bp,"
               " are:\n   ", args.absoluteOffset4)
 
+    # TODO: Note that these verbose messages are NOT printed when the GUI is used, since
+    # the processing only calls process_pdf_file.  Similarly, range checks and repairs
+    # for uniformOrderStat are not processed when entered directly into the GUI.
     if args.uniformOrderStat and not args.uniformOrderStat4:
         args.uniformOrderStat4 = args.uniformOrderStat * 4 # expand to 4 offsets
     if args.verbose:
         print("\nThe uniform order statistics to apply to each margin, in units of bp,"
               " are:\n   ", args.uniformOrderStat4)
 
     #
@@ -1154,125 +1087,53 @@
             print("\nAttempting to fix the PDF input file before reading it...")
         fixed_input_doc_pathname = ex.fix_pdf_with_ghostscript_to_tmp_file(input_doc_path)
     else:
         fixed_input_doc_pathname = input_doc_path
 
     return input_doc_path, fixed_input_doc_pathname, output_doc_path
 
-def open_file_in_pdfreader(fixed_input_doc_pathname):
-    """Open the file in a `PdfFileReader` object and return readers for the input
-    document, and the temp input document (bug workaround) as well as metadata
-    information, an open file object for the fixed input document, and the number
-    of pages in the document.  The open file object will need to be closed."""
-    ##
-    ## Open the input document in a PdfReader object.  Due to an apparent bug
-    ## in pyPdf we open two PdfReader objects for the file.  The time required
-    ## should still be small relative to finding the bounding boxes of pages.  The bug
-    ## is that writing a PdfWriter tends to hang on certain files if 1) pages from
-    ## the same PdfReader are shared between two PdfWriter objects, or 2)
-    ## the PdfWriter is written, the pages are modified, and there is an attempt
-    ## to write the same PdfWriter to a different file.
-    ##
-
-    # Open the input file object.
-    try:
-        fixed_input_doc_file_object = open(fixed_input_doc_pathname, "rb")
-    except OSError:
-        print("Error in pdfCropMargins: Could not open output document with "
-              "filename '{}'".format(fixed_input_doc_pathname))
-        ex.cleanup_and_exit(1)
-
-    try:
-        strict_mode = False
-        input_doc = PdfReader(fixed_input_doc_file_object, strict=strict_mode)
-        tmp_input_doc = PdfReader(fixed_input_doc_file_object, strict=strict_mode)
-    except (KeyboardInterrupt, EOFError):
-        raise
-    except Exception as e: # PyPDF2 can raise various, catch the rest here.
-        print("\nError in pdfCropMargins: The PyPDF2 module failed in an"
-              "\nattempt to read this input file:\n   {}\n"
-              "\nIs the file a PDF file?  If so then it may be corrupted."
-              "\nIf you have Ghostscript installed you can attempt to fix"
-              "\nthe document by using the pdfCropMargins option '--gsFix'"
-              "\n(assuming you are not using that option already).  That option"
-              "\ncan also convert some PostScript files to a readable format."
-              "\n\nThe error message was:\n   {}".format(fixed_input_doc_pathname, e),
-              file=sys.stderr)
-        ex.cleanup_and_exit(1)
-
-    ##
-    ## See if the document needs to be decrypted.
-    ##
-
-    if args.password:
-        try:
-            input_doc.decrypt(args.password)
-            tmp_input_doc.decrypt(args.password)
-        except KeyError:
-            print("\nDecrypting with the password from the '--password' option"
-                  "\nfailed.", file=sys.stderr)
-            ex.cleanup_and_exit(1)
-    else: # Try decrypting with an empty password.
-        try:
-            input_doc.decrypt("")
-            tmp_input_doc.decrypt("")
-        except (KeyError, PdfReadError):
-            pass # Document apparently wasn't encrypted with an empty password.
-
-    ##
-    ## Print out some data and metadata in verbose mode.
-    ##
-
-    try: # Note this is after decryption.
-        input_doc_num_pages = len(input_doc.pages) # Can raise PdfReadError.
-    except PdfReadError as e:
-        print("\nError in pdfCropMargins: The PyPDF2 module failed with a"
-              "\nPdfReadError in an attempt get the number of pages in input file:\n   {}\n"
-              "\nIs the file a PDF file?  If so then it may be corrupted."
-              "\nIf you have Ghostscript installed you can attempt to fix"
-              "\nthe document by using the pdfCropMargins option '--gsFix'"
-              "\n(assuming you are not using that option already).  That option"
-              "\ncan also convert some PostScript files to a readable format."
-              "\n\nThe error message was:\n   {}".format(fixed_input_doc_pathname, e),
-              file=sys.stderr)
-        ex.cleanup_and_exit(1)
+def open_file_in_pymupdf(fixed_input_doc_pathname):
+    """Open the file in a `MuPdfDocument`."""
+    input_doc_mupdf_wrapper = MuPdfDocument(args)
+    input_doc_num_pages = input_doc_mupdf_wrapper.open_document(fixed_input_doc_pathname)
 
     if args.verbose:
         print(f"\nThe input document has {input_doc_num_pages} pages.")
+        if input_doc_mupdf_wrapper.document.is_repaired:
+            print("\nThe document was repaired by PyMuPDF on being read.")
+        else:
+            print("\nThe document was not repaired by PyMuPDF on being read.")
 
-    try: # This is needed because the call sometimes just raises an error.
-        metadata_info = input_doc.metadata
-    except (PdfReadError, ParseError):
-        print("\nWarning: Document metadata could not be read.", file=sys.stderr)
-        metadata_info = None
+    # Note this is only the standard metadata, not any additional metadata like
+    # any restore metadata.
+    metadata_info = input_doc_mupdf_wrapper.get_standard_metadata()
 
     if args.verbose and not metadata_info:
         print("\nNo readable metadata in the document.")
     elif args.verbose:
         try:
             print("\nThe document's metadata, if set:\n")
             print("   The Author attribute set in the input document is:\n      %s"
-                  % (metadata_info.author))
+                  % (metadata_info["author"]))
             print("   The Creator attribute set in the input document is:\n      %s"
-                  % (metadata_info.creator))
+                  % (metadata_info["creator"]))
             print("   The Producer attribute set in the input document is:\n      %s"
-                  % (metadata_info.producer))
+                  % (metadata_info["producer"]))
             print("   The Subject attribute set in the input document is:\n      %s"
-                  % (metadata_info.subject))
+                  % (metadata_info["subject"]))
             print("   The Title attribute set in the input document is:\n      %s"
-                  % (metadata_info.title))
-        # Some metadata cannot be decoded or encoded, at least on Windows.  Could
-        # print from a function instead to write all the lines which can be written.
-        except (UnicodeDecodeError, UnicodeEncodeError):
+                  % (metadata_info["title"]))
+        except (KeyError, UnicodeDecodeError, UnicodeEncodeError):
             print("\nWarning: Could not write all the document's metadata to the screen."
-                  "\nGot a UnicodeEncodeError or a UnicodeDecodeError.", file=sys.stderr)
-    return input_doc, tmp_input_doc, metadata_info, fixed_input_doc_file_object, input_doc_num_pages
+                  "\nGot a KeyError or a UnicodeEncodeError.", file=sys.stderr)
+
+    return input_doc_mupdf_wrapper, metadata_info, input_doc_num_pages
 
 def get_set_of_page_numbers_to_crop(input_doc_num_pages):
-    """Compute the set containing the pyPdf page number of all the pages
+    """Compute the set containing the page number of all the pages
     which the user has selected for cropping from the command line."""
     all_page_nums = set(range(0, input_doc_num_pages))
     if args.pages:
         try:
             page_nums_to_crop = parse_page_range_specifiers(args.pages, all_page_nums)
         except ValueError:
             print(
@@ -1293,83 +1154,51 @@
                 print("\n   ", end="")
             print("%5d" % (p_num_list[i]+1), " ", end="")
         print()
     elif args.verbose:
         print("\nAll the pages of the document will be cropped.")
     return page_nums_to_crop
 
-def write_pdf_file(output_doc_pathname, output_doc, tmp_output_doc, input_doc, tmp_input_doc,
-                   metadata_info, producer_mod):
-    """Write out the pdf file from `output_doc` to the file at `output_doc_filename`."""
-    if args.verbose:
-        print("\nWriting the cropped PDF file.")
-
-    try:
-        output_doc_stream = open(output_doc_pathname, "wb")
-    except OSError:
-        print("Error in pdfCropMargins: Could not open output document with "
-              "filename '{}'".format(output_doc_pathname))
-        ex.cleanup_and_exit(1)
-
-    try:
-        output_doc.write(output_doc_stream)
-    except (KeyboardInterrupt, EOFError):
-        raise
-    except PyPdfError: # PyPDF2 can raise various exceptions.
-        try:
-            # We know the write succeeded on tmp_output_doc or we wouldn't be here.
-            # Malformed document catalog info can cause write failures, so get
-            # a new output_doc without that data and try the write again.
-            print("\nWrite failure, trying one more time...", file=sys.stderr)
-            output_doc_stream.close()
-            output_doc_stream = open(output_doc_pathname, "wb")
-            output_doc, tmp_output_doc, setup_output_document(
-                    input_doc, tmp_input_doc, metadata_info, producer_mod,
-                    copy_document_catalog=False)
-            output_doc.write(output_doc_stream)
-            print("\nWarning: Document catalog data caused a write failure.  A retry"
-                  "\nwithout that data succeeded.  No document catalog information was"
-                  "\ncopied to the cropped output file.  Try fixing the PDF file.  If"
-                  "\nyou have ghostscript installed, run pdfCropMargins with the '--gsFix'"
-                  "\noption.  You can also try blacklisting some of the document catalog"
-                  "\nitems using the '--dcb' option.", file=sys.stderr)
-        except (KeyboardInterrupt, EOFError):
-            raise
-        except: # Give up... PyPDF2 can raise many errors for many reasons.
-            print("\nError in pdfCropMargins: The pyPdf program failed in trying to"
-                  "\nwrite out a PDF file of the document.  The document may be"
-                  "\ncorrupted.  If you have Ghostscript, try using the '--gsFix'"
-                  "\noption (assuming you are not already using it).", file=sys.stderr)
-            ex.cleanup_and_exit(1)
-
-    output_doc_stream.close()
-
 def process_pdf_file(input_doc_pathname, fixed_input_doc_pathname, output_doc_pathname,
                      bounding_box_list=None):
     """This function does the real work.  It is called by `main()` in
     `pdfCropMargins.py`, which just handles catching exceptions and cleaning
-    up.  It returns the name of the modified file that was written to disk.
-
-    If a bounding box list is passed in then the calculation is skipped and
-    that list is used.
+    up.
 
-    Returns the bounding box list."""
-
-    # Open the input file object.
-    (input_doc,
-     tmp_input_doc, # Bug workaround, see the function for comment.
-     metadata_info,
-     fixed_input_doc_file_object, # Note this file object is opened and needs to be closed.
-     input_doc_num_pages) = open_file_in_pdfreader(fixed_input_doc_pathname)
-
-    producer_mod, already_cropped_by_this_program = check_producer_modifier(
-                                                              metadata_info)
+    If a bounding box list is passed in then the bounding box calculation is
+    skipped and that list is used instead (for cases with the GUI when the
+    boxes do not change but the cropping does).
+
+    Returns the bounding box list and data about the minimum cropping deltas
+    for each margins."""
+
+    input_doc_mupdf_wrapper, metadata_info, input_doc_num_pages = open_file_in_pymupdf(
+                                                                   fixed_input_doc_pathname)
+
+    # Get any necessary page boxes BEFORE the MediaBox is set.  The pyMuPDF
+    # program will reset the other boxes when setting the MediaBox if they're
+    # not fully contained.  For the ArtBox this is for backward compatibility
+    # with the earlier PyPDF restore option.
+    original_mediabox_list = input_doc_mupdf_wrapper.get_box_list("mediabox")
+    original_cropbox_list = input_doc_mupdf_wrapper.get_box_list("cropbox")
+    original_artbox_list = input_doc_mupdf_wrapper.get_box_list("artbox")
+    #original_trimbox_list = input_doc_mupdf_wrapper.get_box_list("trimbox")
+    #original_bleedbox_list = input_doc_mupdf_wrapper.get_box_list("bleedbox")
+
+    already_cropped_by_this_program = check_and_set_crop_metadata(input_doc_mupdf_wrapper,
+                                                                  metadata_info)
+
+    if not args.noundosave:
+        if already_cropped_by_this_program == "<2.0" or not already_cropped_by_this_program:
+            save_old_boxes_for_restore(input_doc_mupdf_wrapper, original_mediabox_list,
+                                       original_cropbox_list, original_artbox_list,
+                                       already_cropped_by_this_program)
 
     if args.prevCropped:
-        fixed_input_doc_file_object.close()
+        input_doc_mupdf_wrapper.close_document()
         if already_cropped_by_this_program:
             #print("code 0")
             exit_code = 0
         else:
             #print("code 1")
             exit_code = 1
         ex.cleanup_and_exit(exit_code)
@@ -1378,118 +1207,110 @@
     #if args.exitPrevCropped and already_cropped_by_this_program:
     #    fixed_input_doc_file_object.close()
     #    if args.verbose:
     #        print("The file was previously cropped by pdfCropMargins, exiting.")
     #    ex.cleanup_and_exit(0)
 
     ##
-    ## Now compute the set containing the pyPdf page number of all the pages
+    ## Now compute the set containing the page number of all the pages
     ## which the user has selected for cropping from the command line.  Most
-    ## calculations are still carried-out for all the pages in the document.
+    ## calculations are still carried out for all the pages in the document.
     ## (There are a few optimizations for expensive operations like finding
     ## bounding boxes; the rest is negligible).  This keeps the correspondence
     ## between page numbers and the positions of boxes in the box lists.  The
     ## function `apply_crop_list` then just ignores the cropping information
     ## for any pages which were not selected.
     ##
 
     page_nums_to_crop = get_set_of_page_numbers_to_crop(input_doc_num_pages)
 
     ##
     ## Get a list with the full-page boxes for each page: (left,bottom,right,top)
     ## This function also sets the MediaBox and CropBox of the pages to the
     ## chosen full-page size as a side-effect, saving the old boxes.  Any absolute
-    ## pre-crop is also applied here.
+    ## pre-crop is also applied here (so it is rendered that way for the later
+    ## bounding-box-finding operation).
     ##
 
     full_page_box_list, rotation_list = get_full_page_box_list_assigning_media_and_crop(
-                                                          input_doc, skip_pre_crop=False)
-    # The below return values aren't used, but the function is called to replicate
-    # its side-effects on `tmp_input_doc`.
-    tmp_full_page_box_list, tmp_rotation_list = get_full_page_box_list_assigning_media_and_crop(
-                                            tmp_input_doc, quiet=True, skip_pre_crop=False)
-
-    ##
-    ## Define a `PdfWriter` object and copy `input_doc` info over to it.
-    ##
-
-    output_doc, tmp_output_doc = setup_output_document(input_doc, tmp_input_doc,
-                                                       metadata_info, producer_mod)
+                                              input_doc_mupdf_wrapper)
 
     ##
     ## Write out the PDF document again, with the CropBox and MediaBox reset.
-    ## This temp version is ONLY used for calculating the bounding boxes of
-    ## pages.  Note we are writing from `tmp_output_doc` (due to an apparent bug
-    ## discussed above).  After this `tmp_input_doc` and `tmp_output_doc` are no
-    ## longer needed.
+    ## This temp document version is ONLY used for calculating the bounding boxes of
+    ## pages.
     ##
 
-    if not bounding_box_list and not args.restore:
-        doc_with_crop_and_media_boxes_name = ex.get_temporary_filename(".pdf")
-        with open(doc_with_crop_and_media_boxes_name, "wb"
-                                          ) as doc_with_crop_and_media_boxes_object:
+    if not args.restore:
+        if not bounding_box_list:
+            doc_with_crop_and_media_boxes_name = ex.get_temporary_filename(".pdf")
             if args.verbose:
-                print("\nWriting out the PDF with the CropBox and MediaBox redefined.")
-
-            try:
-                tmp_output_doc.write(doc_with_crop_and_media_boxes_object)
-            except (KeyboardInterrupt, EOFError):
-                raise
-            except PyPdfError: # PyPDF2 can raise various exceptions.
-                print("\nError in pdfCropMargins: The pyPdf program failed in trying to"
-                      "\nwrite out a PDF file of the document.  The document may be"
-                      "\ncorrupted.  If you have Ghostscript, try using the '--gsFix'"
-                      "\noption (assuming you are not already using it).", file=sys.stderr)
-                ex.cleanup_and_exit(1)
+                # TODO Consider writing this to a memory file rather than to disk.
+                print("\nWriting out the PDF with the CropBox and MediaBox redefined"
+                        "\n(so pre-crops are included in the bounding box calculations).")
+            input_doc_mupdf_wrapper.save_document(doc_with_crop_and_media_boxes_name)
 
     ##
     ## Calculate the `bounding_box_list` containing tight page bounds for each page.
     ##
 
-    if not bounding_box_list and not args.restore:
-        bounding_box_list = get_bounding_box_list(doc_with_crop_and_media_boxes_name,
-                input_doc, full_page_box_list, page_nums_to_crop, args, PdfWriter)
-        if args.verbose:
-            print("\nThe bounding boxes are:")
-            for pNum, b in enumerate(bounding_box_list):
-                print("\t", pNum+1, "\t", b)
-        os.remove(doc_with_crop_and_media_boxes_name) # No longer needed.
+    if not args.restore:
+        if not bounding_box_list:
+            bounding_box_list = get_bounding_box_list(doc_with_crop_and_media_boxes_name,
+                    input_doc_mupdf_wrapper, full_page_box_list, page_nums_to_crop, args)
+            if args.verbose:
+                print("\nThe bounding boxes are:")
+                for pNum, b in enumerate(bounding_box_list):
+                    print("\t", pNum+1, "\t", b)
+            os.remove(doc_with_crop_and_media_boxes_name) # No longer needed.
 
-    elif args.verbose and not args.restore:
-        print("\nUsing the bounding box list passed in instead of calculating it.")
+        elif args.verbose:
+            print("\nUsing the bounding box list passed in instead of calculating it.")
 
     ##
-    ## Calculate the `crop_list` based on the fullpage boxes and the bounding boxes.
+    ## Calculate the `crop_list` based on the fullpage boxes and the bounding boxes,
+    ## after the precrop has been applied.
     ##
 
     if not args.restore:
         crop_list, delta_page_nums = calculate_crop_list(full_page_box_list, bounding_box_list,
                                         rotation_list, page_nums_to_crop)
     else:
         crop_list = None # Restore, not needed in this case.
         delta_page_nums = ("N/A","N/A","N/A","N/A")
 
     ##
-    ## Apply the calculated crops to the pages of the PdfReader input_doc.
-    ## These pages are copied to the PdfWriter output_doc.
+    ## Apply the calculated crops to the pages (after restoring the original mediabox
+    ## and cropbox).
     ##
 
-    apply_crop_list(crop_list, input_doc, page_nums_to_crop,
-                                          already_cropped_by_this_program)
+    if args.restore:
+        if args.verbose:
+            print("\nRestoring the document to margins saved for each page.")
+
+        if not already_cropped_by_this_program:
+            print("\nWarning from pdfCropMargins: The Producer string and metadata indicate"
+                  "\nthat either this document was not previously cropped by pdfCropMargins"
+                  "\nor else it was modified by another program after that and cannot"
+                  "\nbe restored.  Ignoring the restore operation.", file=sys.stderr)
+        else:
+            apply_restore_operation(already_cropped_by_this_program,
+                                    input_doc_mupdf_wrapper, original_artbox_list)
+
+    else:
+        apply_crop_list(crop_list, input_doc_mupdf_wrapper, page_nums_to_crop,
+                        already_cropped_by_this_program)
 
     ##
     ## Write the final PDF out to a file.
     ##
 
-    write_pdf_file(output_doc_pathname, output_doc, tmp_output_doc, input_doc, tmp_input_doc,
-                                                               metadata_info, producer_mod)
+    input_doc_mupdf_wrapper.save_document(output_doc_pathname)
+    input_doc_mupdf_wrapper.close_document()
 
-    # We're finished with this open file; close it and let temp dir removal delete it.
-    # Note that the PdfReader object has opened it, so be careful where it is closed.
-    fixed_input_doc_file_object.close()
     return bounding_box_list, delta_page_nums
 
 def handle_options_on_cropped_file(input_doc_pathname, output_doc_pathname):
     """Handle the options which apply after the file is written such as previewing
     and renaming."""
 
     def do_preview(output_doc_pathname):
```

## pdfCropMargins/manpage_data.py

```diff
@@ -90,25 +90,21 @@
    in the PDF file (and are interpreted by programs like Acrobat Reader).
    Both the CropBox and the MediaBox are set to the newly-computed cropped
    size.  After this the view of the document in most programs will be the new,
    cropped view.
 
    In order to reduce the number of copies of a document which must be saved, a
    basic '--restore' option is provided.  When cropping a file not produced by
-   the pdfCropMargins program the default is to save the intersection of the
-   MediaBox and any existing CropBox in the ArtBox.  This saves the "usual"
+   the pdfCropMargins program the default is to save the intersections of the
+   MediaBox and any existing CropBox for each page as XML metadata.  This saves the "usual"
    view of the original document in programs like Acrobat Reader.  Subsequent
    crops of a file produced by pdfCropMargins do not by default alter the
-   ArtBox.  The restore option simply copies the saved values back to the
-   MarginBox and CropBox.  Note that this assumes the ArtBox is unused (it is
-   rarely used, and this feature can be turned off with the -A option).  So,
-   for example, you can make annotations to a file with cropped margins and
-   still produce a version with the annotations which viewers display as the
-   original margins.  Programs which change the "Producer" string in the PDF
-   may interfere with this feature.
+   saved data.  The restore option simply copies the saved values back to the
+   MediaBox and CropBox.  (Old versions of the program saved to the ArtBox;
+   if these are cropped again the data is migrated to XML metadata.)
 
    Below are several examples using more of the command-line options, each
    applied to an input file called doc.pdf.  The output filename is unspecified
    in most of these examples, so the program will automatically generate the
    filename (or an output filename can always be explicitly provided with '-o'):
 ^^f
 
@@ -257,15 +253,14 @@
         prog="pdf-crop-margins")
 else:
     cmd_parser = argparse.ArgumentParser(
         formatter_class=formatter_class,
         description=description, epilog=epilog,
         prog="pdf-crop-margins")
 
-
 cmd_parser.add_argument("pdf_input_doc", nargs="+", metavar="PDF_FILE", help="""
 
    The pathname of the PDF file to crop.  Use quotes around any file or
    directory name which contains a space.  If no filename is given for the
    cropped PDF output file via the '-o' flag then a default output filename
    will be generated.  By default it is the same as the source filename except
    that the suffix ".pdf" is replaced by "_cropped.pdf", overwriting by default
@@ -500,25 +495,23 @@
    document are ignored.  Note that restore information is always saved for all
    the pages (in the ArtBox) unless '--noundosave' is selected.^^n""")
 
 cmd_parser.add_argument("-c", "--calcbb", choices=["d", "m", "p", "gr", "gb", "o"],
                        metavar="[d|m|p|gr|gb|o]", default="d", help="""
 
    Choose the method to calculate bounding boxes (or to render the PDF pages in
-   order to calculate the boxes).  The default option 'd' will choose the MuPDF
-   rendering option if the PyMuPDF dependency is installed, otherwise it will
-   use pdftoppm rendering or Ghostscript rendering, in that order, if the
-   external programs can be located.  The options to force a particular method
-   are MuPDF ('m'), pdftoppm ('p'), or Ghostscript ('gr') for rendering, or
-   direct Ghostscript bounding-box calculation ('gb').  For pdftoppm or
-   Ghostscript options the corresponding program must be installed and
-   locatable (see the path-setting options below if the default locator fails).
-   Only the explicit rendering methods will work for scanned pages (see
-   '--gsBbox').  Choosing 'o' reverts to the old default behavior of first
-   looking for pdftoppm and then looking for Ghostscript for rendering.^^n""")
+   order to calculate the boxes).  The default option 'd' will currently choose
+   the MuPDF rendering option.  The options to force a particular method are
+   MuPDF ('m'), pdftoppm ('p'), or Ghostscript ('gr') for rendering, or direct
+   Ghostscript bounding-box calculation ('gb').  For pdftoppm or Ghostscript
+   options the corresponding program must be installed and locatable (see the
+   path-setting options below if the default locator fails).  Only the explicit
+   rendering methods will work for scanned pages (see '--gsBbox').  Choosing
+   'o' reverts to the old default behavior of first looking for pdftoppm and
+   then looking for Ghostscript for rendering.^^n""")
 
 cmd_parser.add_argument("-gs", "--gsBbox", action="store_true", help="""
 
    This option is maintained for backward compatibility; using '-c gb' is now
    preferred.  Use Ghostscript to directly find the bounding boxes for the
    pages, with no explict rendering of the pages.  (The default is to
    explicitly render the PDF pages to image files and calculate bounding boxes
@@ -591,28 +584,30 @@
    string should be used with the option.  To also place the window at (0,0)
    the string would be "1024x728+0+0".  See also the '--guiFontSize' option
    which can be used to decrease the overall size of the GUI window.^^n""")
 
 cmd_parser.add_argument("-gf", "--guiFontSize", default=None, metavar="INT", help="""
 
    Choose the GUI font size.  Making this smaller than the default of 11 can
-   also make the GUI smaller if it does not fit on a smaller monitor.
-   +0+0".^^n""")
+   also make the GUI smaller if it does not fit on a smaller monitor.^^n""")
 
 cmd_parser.add_argument("-b", "--boxesToSet", choices=["m", "c", "t", "a", "b"],
                         metavar="[m|c|t|a|b]", action="append", default=[], help="""
 
    By default the pdfCropMargins program sets both the MediaBox and the CropBox
    for each page of the cropped PDF document to the new, cropped page size.
    This default setting is usually sufficient, but this option can be used to
    select different PDF boxes to set.  The option takes one argument, which is
    the first letter (lowercase) of a type of box.  The choices are MediaBox
    (m), CropBox (c), TrimBox (t), ArtBox (a), and BleedBox (b).  This option
    overrides the default and can be repeated multiple times to set several box
-   types.^^n""")
+   types.  Note that the program now uses PyMuPDF to set the boxes, and it
+   will refuse to set any non-MediaBox boxes unless they are fully contained
+   in the MediaBox.  In that case a warning will be issued and the box will
+   not be set.^^n""")
 
 cmd_parser.add_argument("-f", "--fullPageBox", choices=["m", "c", "t", "a", "b"],
                         metavar="[m|c|t|a|b]", action="append", default=[], help="""
 
    By default the program first (before any cropping is calculated) sets the
    MediaBox and CropBox of each page in (a copy of) the document to the
    intersection of its previous MediaBox and CropBox.   This ensures that the
@@ -628,40 +623,34 @@
    rendering when finding bounding boxes.  The default with '-gs' is the
    CropBox.^^n""")
 
 cmd_parser.add_argument("-r", "--restore", action="store_true", help="""
 
    This is a simple undo operation which essentially undoes all the crops ever
    made by pdfCropMargins and returns to the original margins (provided no
-   other program modified the Producer metadata or ArtBoxes).  By default,
-   whenever this program crops a file for the first time it saves the MediaBox
-   intersected with the CropBox as the new ArtBox (since the ArtBox is rarely
-   used).  The Producer metadata is checked to see if this was the first time.
-   If so, the ArtBox for each page is simply copied to the MediaBox and the
-   CropBox for the page.  This restores the earlier view of the document, such
-   as in Acrobat Reader (but does not completely restore the previous condition
-   in cases where the MediaBox and CropBox differed or the ArtBox had a
-   previous value).  Any options such as '-u', '-p', and '-a' which do not make
-   sense in a restore operation are ignored.  Note that as far as default
-   filenames the operation is treated as just another crop operation (the
-   default-generated output filename still has a "_cropped.pdf" suffix).  The
-   '--modifyOriginal' option (or its query variant) can be used with this
-   option.  Saving in the ArtBoxes can be disabled by using the '--noundosave'
-   option.^^n""")
+   other program modified the saved XML data for the pdfCropMargins key).  By
+   default, whenever this program crops a file for the first time it saves the
+   MediaBox intersected with the CropBox for each page as XML metadata.  The
+   XML metadata is is checked to see if there is any existing restore data.  If
+   so, the saved metadata for each page is simply copied to the MediaBox and
+   the CropBox for the page.  This restores the earlier view of the document,
+   such as in Acrobat Reader (but does not completely restore the previous
+   condition in cases where the MediaBox and CropBox differed).  Any options
+   such as '-u', '-p', and '-a' which do not make sense in a restore operation
+   are ignored.  Note that as far as default filenames the operation is treated
+   as just another crop operation (the default-generated output filename still
+   has a "_cropped.pdf" suffix).  The '--modifyOriginal' option (or its query
+   variant) can be used with this option.  Saving restore data as XML metadata
+   can be disabled by using the '--noundosave' option.^^n""")
 
-# Maybe later: an option to choose which box to save to, or none, rather
-# than just turn off ArtBox.
 cmd_parser.add_argument("-A", "--noundosave", action="store_true", help="""
 
-   Do not save any restore data in the ArtBox.  This option will need to be
-   selected if the document actually uses the ArtBox for anything important
-   (which is rare).  Note that the '--restore' operation will not work
-   correctly for the cropped document if this option is included in the
-   cropping command.  (The program does not currently check for this when doing
-   a restore.)^^n""")
+   Do not save any restore data as XML metadata.  Note that the '--restore'
+   operation will not work correctly for the cropped document later if this
+   option is included in the cropping command.^^n""")
 
 cmd_parser.add_argument("-gsf", "--gsFix", action="store_true", help="""
 
    Attempt to repair the input PDF file with Ghostscript before it is read-in.
    This requires that Ghostscript be available.  (See the general description
    text above for the actual command that is run.)  This can also be used to
    automatically convert some PostScript files (.ps) to PDF for cropping.  The
@@ -765,14 +754,34 @@
 cmd_parser.add_argument("-ss", "--stringSeparator", default="_", metavar="STR",
                         help="""
 
    This option can be used to set the separator string which will be used when
    appending or prepending string values to automatically generate filenames.
    The default value is "_".^^n""")
 
+# TODO: These options would be easy to add, except that they currently wouldn't
+# work with the GUI since they are done at file open time.  Need to separate
+# out the processing that can be redone each time for `process_pdf_file`.  Also
+# good for `uniformOrderStat` arg checking.
+#
+#cmd_parser.add_argument("-sr", "--stringRestored", default="restored",
+#                        metavar="STR", help="""
+#
+#   This option can be used to set the string which will be appended (or
+#   prepended) to the document filename when automatically generating the output
+#   filename for a restored document.  The default value is "restored".^^n""")
+#
+#cmd_parser.add_argument("-sr", "--stringUnrestored", default="unrestored",
+#                        metavar="STR", help="""
+#
+#   This option can be used to set the string which will be appended (or
+#   prepended) to the document filename when automatically generating the output
+#   filename for the original, cropped file.  The default value is
+#   "restored".^^n""")
+
 cmd_parser.add_argument("-pw", "--password", metavar="PASSWD", help="""
 
    Specify a password to be used to decrypt an encrypted PDF file.  Note that
    decrypting with an empty password is always tried, so this option is only
    needed for non-empty passwords.  The resulting cropped file will not be
    encrypted, so use caution if important data is involved.^^n""")
 
@@ -834,60 +843,31 @@
    This option weights any whitespace added by the '--setPageRatios' argument.
    It takes four weight arguments, one per margin.  The four floating point
    arguments should be the left, bottom, right, and top weights, respectively.
    The weights determine what proportion of the total height(width) increase
    necessary to achieve the target page ratio is added to the corresponding
    margin.  All weights must be greater than zero.^^n""")
 
-cmd_parser.add_argument("-dcb", "--docCatBlacklist", default="",
-                        metavar="STR", help="""
-
-   Data associated with the full document, such as outlines, bookmarks, and
-   modes, is saved in the document catalog of the PDF file.  By default it is
-   all copied over to the cropped document if possible (with some exceptions,
-   e.g., "/Pages" will be modified by cropping).  If this is not wanted, or if
-   it causes problems for a document, this option specifies a blacklist of
-   document catalog items that will never be copied.  The arguments should be
-   passed as a single, quoted, whitespace-separated string, for example
-   "/Outlines /PageMode /OpenAction".  The special value "ALL" blacklists
-   everything.  An empty string blacklists nothing, and is the default.  As an
-   example, it can be useful to blacklist "/OpenAction" if on opening the PDF
-   it does something like zooming which is not desired.  Blacklisting
-   `/PageMode` can also be useful to, for example, not open the outline by
-   default.  Running in verbose mode '-v' will show which document catalog
-   items are and are not being copied for a document.^^n""")
-
-cmd_parser.add_argument("-dcw", "--docCatWhitelist", default="",
-                        metavar="STR", help="""
-
-   See the '--docCatBlacklist' option.  This is just a whitelist that
-   essentially works the same way.  The whitelist takes precedence over the
-   blacklist.  It specifies a list of items which will always be copied over
-   even if they are in the blacklist.  Useful combined with setting the
-   blacklist to "ALL" if you only want one or two of the items.  The default
-   value is the empty string, which whitelists nothing and so only the
-   blacklist is used.  Setting to "ALL" guarantees that everything possible is
-   copied over.^^n""")
-
 cmd_parser.add_argument("-i", "--showImages", action="store_true", help="""
 
    When explicitly rendering PDF files to image files, display the inverse
    image files that are used to find the bounding boxes.  Useful for debugging
    and for choosing some of the other parameters (such as the threshold).  This
    option requires a default external viewer program selected by the Pillow
    image manipulation package (xv on Unix, and usually Paint on Windows).^^n""")
 
 cmd_parser.add_argument("-pdl", "--pdftoppmLocal", action="store_true", help="""
 
-   Use a locally-packaged pdftoppm executable rather than the system version.
-   This option is only available on Windows machines; it is ignored otherwise.
-   By default the first pdftoppm executable found in the directories in the
-   PATH environment variable is used.  On Windows the program will revert to
-   this option if PDF image-rendering is required, PyMuPDF is not installed,
-   and no system pdftoppm or Ghostscript executable can be found.^^n""")
+   This option is deprecated.  Use a locally-packaged pdftoppm executable
+   rather than the system version.  This option is only available on Windows
+   machines; it is ignored otherwise.  By default the first pdftoppm executable
+   found in the directories in the PATH environment variable is used.  On
+   Windows the program will revert to this option if PDF image-rendering is
+   required, PyMuPDF is not installed, and no system pdftoppm or Ghostscript
+   executable can be found.^^n""")
 
 cmd_parser.add_argument("-gsp", "--ghostscriptPath", type=str, metavar="PATH",
                         default="", help="""
 
    Pass in a pathname to the ghostscript executable that the program should
    use.  No globbing is done.  Useful when the program is in a nonstandard
    location.^^n""")
```

## pdfCropMargins/pymupdf_routines.py

```diff
@@ -1,16 +1,27 @@
 """
 
-Code that calls pyMuPDF.
+This module contains a wrapper class, `MuPdfDocument`, which provides
+a wrapper for the PyMuPDF library functions.  The program was originally
+written to use the PyPDF library.  Those libraries use some different
+conventions, such as the origin of coordinates and shifting of box
+values other than the MediaBox.  The wrapper converts between the
+formats to return the PyPDF format that the main code expects.
+
+Note that the PyMuPDF program resets all the other boxes when the
+`set_mediabox` method is called.  All other boxes must be fully contained
+within the mediabox for consistency:
+    https://pymupdf.readthedocs.io/en/latest/page.html#Page.set_mediabox
+
+See the `get_box` and `set_box` function comments for other PyMuPDF behavior
+that needs to be taken into account (all but mediabox are translated to start
+at zero, for example).
 
 =========================================================================
 
-Some of this code is heavily modified from the GPL example/demo code found here:
-https://github.com/PySimpleGUI/PySimpleGUI/blob/master/DemoPrograms/Demo_PDF_Viewer.py
-
 Copyright (C) 2020 Allen Barker (Allen.L.Barker@gmail.com)
 Source code site: https://github.com/abarker/pdfCropMargins
 
 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.
@@ -19,238 +30,407 @@
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 
 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
+Some of this code is heavily modified from the GPL example/demo code found here:
+https://github.com/PySimpleGUI/PySimpleGUI/blob/master/DemoPrograms/Demo_PDF_Viewer.py
+
 """
 
 import sys
 import warnings
+import copy
 from . import external_program_calls as ex
 
 has_mupdf = True
 
 try: # Extra dependencies for the GUI version.  Make sure they are installed.
     with warnings.catch_warnings():
         #warnings.filterwarnings("ignore",category=DeprecationWarning)
         import fitz
-    if not [int(i) for i in fitz.VersionBind.split(".")] >= [1, 16, 17]:
+        from fitz import Rect
+        import os
+        import tempfile # Maybe later write to the regular tmp dir...
+    # Need at least 1.19.4 for setting MediaBox resetting all other boxes behavior.
+    # Version 1.19.6 is the last one supporting Python 3.6.
+    if not [int(i) for i in fitz.VersionBind.split(".")] >= [1, 19, 4]:
         has_mupdf = False
         MuPdfDocument = None
 
 except ImportError:
     has_mupdf = False
     MuPdfDocument = None
 
-if has_mupdf:
+#
+# Utility functions.
+#
+
+def intersect_pdf_boxes(box1, box2, page):
+    """Return the intersection of PDF-style boxes by converting to
+    pymupdf `Rect`, using its intersection function, and then
+    converting back."""
+    # TODO: page argument no longer required, here or in "conversion" routines, maybe remove.
+    box1_pymupdf = convert_box_pdf_to_pymupdf(box1, page)
+    box2_pymupdf = convert_box_pdf_to_pymupdf(box2, page)
+    intersection = box1_pymupdf.intersect(box2_pymupdf)
+    return convert_box_pymupdf_to_pdf(intersection, page)
+
+def convert_box_pymupdf_to_pdf(box_pymupdf, page):
+    """Convert a box from PyMuPDF format to PDF format."""
+    # Note these funs were not needed; this still makes a copy and might be needed later.
+    # This issue with raw PDF values didn't matter: https://github.com/pymupdf/PyMuPDF/issues/317
+    return fitz.Rect(box_pymupdf)
+
+def convert_box_pdf_to_pymupdf(box_pdf, page):
+    """Convert a box from PDF format to PyMuPDF format."""
+    # Note these funs were not needed; this still makes a copy and might be needed later.
+    # This issue with raw PDF values didn't matter: https://github.com/pymupdf/PyMuPDF/issues/317
+    return fitz.Rect(box_pdf)
+
+def get_box(page, boxstring):
+    """Return the box for the specified box string, converted to PyPDF2/PDF coordinates which
+    assume that bottom-left is the origin. (Pymupdf uses the top-left as the origin).
+    It also shifts all but the mediabox to have zero be the reference for the top y value
+    (shifting it by the value of the mediabox top y value)."""
+    if boxstring != "mediabox":
+        mediabox = page.mediabox
+    box = getattr(page, boxstring)
+    converted_box = convert_box_pymupdf_to_pdf(box, page)
+
+    # Need to shift for pymupdf zeroing out the top y coordinate of all
+    # but the mediabox. See the glossary:
+    # https://pymupdf.readthedocs.io/en/latest/glossary.html#MediaBox
+    if boxstring != "mediabox":
+        converted_box[1] += mediabox[1]
+        converted_box[3] += mediabox[1]
+
+    return converted_box
+
+def set_box(page, boxstring, box):
+    """Set the box for the specified box string, converted to PyPDF2 coordinates which
+    assume that bottom-left is the origin.  (PyMuPDF uses the top-left as the origin.
+    See `get_box`."""
+    if boxstring != "mediabox":
+        mediabox = page.mediabox
+    set_box_method = getattr(page, "set_" + boxstring)
+    converted_box = convert_box_pdf_to_pymupdf(box, page)
+
+    # Need to shift for pymupdf zeroing out the top y coordinate of all
+    # but the mediabox. See the glossary:
+    # https://pymupdf.readthedocs.io/en/latest/glossary.html#MediaBox
+    if boxstring != "mediabox":
+        converted_box[1] -= mediabox[1]
+        converted_box[3] -= mediabox[1]
+
+    try:
+        set_box_method(converted_box)
+    except ValueError:
+        print(f"\nWarning in pdfCropMargins: The {boxstring} could not be written"
+              f" to the page,\nprobably a conflict with the mediabox.",
+              file=sys.stdout)
+
+#
+# The main class.
+#
+
+class MuPdfDocument:
+    """Holds `pyMuPDF` document and PyMuPDF pages of the document for the GUI
+    to display.  Has methods to get rendered images.  Note that the page numbering
+    convention is from zero."""
+
+    def __init__(self, args):
+        """Initialize an empty object.  The `args` parameter should be passed a
+        parsed command-line argument object from argparse with the user-selected
+        command-line options."""
+        self.args = args
+        self.clear_cache()
+        self.document = None
+
+    def clear_cache(self):
+        """Clear the cache of rendered document pages."""
+        self.num_pages = 0
+        self.page_display_list_cache = []
+        self.page_crop_display_list_cache = []
+
+    def open_document(self, doc_fname):
+        """Open the document with fitz (PyMuPDF) and return the number of pages."""
+        # TODO: How to open a file and repair it:
+        # https://pymupdf.readthedocs.io/en/latest/recipes-general.html#how-to-dynamically-clean-up-corrupt-pdfs
+        try:
+            self.document = fitz.open(doc_fname)
+        except RuntimeError:
+            print("\nError in pdfCropMargins: The PyMuPDF program could not read"
+                  " the document\n   '{}'\nin order to display it in the GUI.   If you"
+                  " have Ghostscript installed\nconsider running pdfCropMargins with the"
+                  " '--gsFix' option to attempt to repair it."
+                  .format(doc_fname), file=sys.stderr)
+            ex.cleanup_and_exit(1)
+
+        # Decrypt if necessary.
+        if self.document.is_encrypted:
+            if self.args.password:
+                # Return code is positive for success, negative for failure. If positive,
+                #   bit 0 set = no password required
+                #   bit 1 set = user password authenticated
+                #   bit 2 set = owner password authenticated
+                authenticate_code = self.document.authenticate(self.args.password)
+                if self.document.is_encrypted:
+                    print("\nError in pdfCropMargins: The document was not correctly "
+                          "decrypted by PyMuPDF using the password passed in.",
+                          file=sys.stderr)
+                    ex.cleanup_and_exit(1)
+            else: # Try an empty password.
+                authenticate_code = self.document.authenticate("")
+                if self.document.is_encrypted:
+                    print("\nError in pdfCropMargins: The document is encrypted "
+                          "and the empty password does not work.  Try passing in a "
+                          "password with the '--password' option.",
+                          file=sys.stderr)
+                    ex.cleanup_and_exit(1)
+
+        # The pages are all kept on a list here to retain their attributes, which are lost
+        # when the page.load_page method is called again in pymupdf.
+        self.page_list = [page for page in self.document]
+        self.num_pages = len(self.document)
+
+        self.page_display_list_cache = [None] * self.num_pages
+        self.page_crop_display_list_cache = [None] * self.num_pages
+        return self.num_pages
+
+    def get_page_sizes(self):
+        """Return a list of the page sizes."""
+        size_list = []
+        for page in self.document:
+            size_list.append((page.rect.width, page.rect.height))
+        return size_list
+
+    def page_count(self):
+        """Return the number of pages."""
+        return self.document.page_count
+
+    def get_max_and_min_page_sizes(self):
+        """Return tuples (max_wid, max_ht) and (min_wid, min_ht)."""
+        page_sizes = self.get_page_sizes()
+        max_page_sizes = (max(p[0] for p in page_sizes), max(p[1] for p in page_sizes))
+        min_page_sizes = (min(p[0] for p in page_sizes), min(p[1] for p in page_sizes))
+        return max_page_sizes, min_page_sizes
+
+    def get_max_and_min_aspect_ratios(self):
+        """Return the maximum and minimum aspect ratios over all the pages."""
+        page_sizes = self.get_page_sizes()
+        max_ratio = max(p[0]/p[1] for p in page_sizes)
+        min_ratio = min(p[0]/p[1] for p in page_sizes)
+        return max_ratio, min_ratio
+
+    def get_max_width_and_height(self):
+        """Return the maximum width and height (in points) of PDF pages in the
+        document."""
+        max_wid = -1
+        max_ht = -1
+        for page in self.document:
+            if page.rect.width > max_wid:
+                max_wid = page.rect.width
+            if page.rect.height > max_ht:
+                max_ht = page.rect.height
+        return max_wid, max_ht
+
+    def get_box_list(self, boxstring):
+        """Get a list of all the boxes of the type `boxstring`, e.g. `"artbox"`
+        or `"mediabox"`."""
+        boxlist = []
+        for page in self.document:
+            boxlist.append(get_box(page, boxstring))
+        return boxlist
+
+    def save_document(self, file_path):
+        """Save a document, possibly repairing/cleaning it."""
+        # See here:
+        #    https://pymupdf.readthedocs.io/en/latest/document.html#Document.save
+        self.document.save(file_path)
+
+    def close_document(self):
+        """Close the document and clear its pages."""
+        self.page_list = []
+        self.document.close()
+        self.clear_cache()
+
+    def get_page_ppm_for_crop(self, page_num, cache=False):
+        """Return an unscaled and unclipped `.ppm` file suitable for cropping the page.
+        Not indended for displaying in the GUI."""
+        # NOTE: The calculated bounding boxes are already saved in GUI, so
+        # there is no need to cache these.  After crops the PDF is written
+        # out and re-read, which would clear the cache, anyway.
+
+        # NOTE: The default DPI with the identity matrix is 72 DPI.
+        # Ghostscript default is 72 DPI and pdftoppm is 150 DPI (the
+        # current pdfCropMargins default).
+        # https://github.com/pymupdf/PyMuPDF/issues/181
+
+        # Use grayscale for lower memory requirement; good enough for cropping.
+        # See: https://pymupdf.readthedocs.io/en/latest/colorspace.html#colorspace
+        colorspace = fitz.csGRAY # or fitz.csRGB, or see above.
+
+        if cache:
+            page_crop_display_list = self.page_crop_display_list_cache[page_num]
+            if not page_crop_display_list:  # Create if not yet there.
+                self.page_crop_display_list_cache[page_num] = self.document[
+                                                              page_num].get_displaylist()
+                page_crop_display_list = self.page_crop_display_list_cache[page_num]
+        else:
+            page_crop_display_list = self.document[page_num].get_displaylist()
 
-    class MuPdfDocument:
-        """Holds `pyMuPDF` document and PyMuPDF pages of the document for the GUI
-        to display.  Has methods to get rendered images.  Note that the page numbering
-        convention is from zero."""
-        def __init__(self, args):
-            """Initialize an empty object.  The `args` parameter should be passed a
-            parsed command-line argument object from argparse with the user-selected
-            command-line options."""
-            self.args = args
-            self.clear_cache()
-
-        def clear_cache(self):
-            """Clear the cache of rendered document pages."""
-            self.num_pages = 0
-            self.page_display_list_cache = []
-            self.page_crop_display_list_cache = []
-
-        def open_document(self, doc_fname):
-            """Open the document with fitz (PyMuPDF) and return the number of pages."""
-            # TODO: How to open a file and repair it:
-            # https://pymupdf.readthedocs.io/en/latest/recipes-general.html#how-to-dynamically-clean-up-corrupt-pdfs
-            try:
-                self.document = fitz.open(doc_fname)
-            except RuntimeError:
-                print("\nError in pdfCropMargins: The PyMuPDF program could not read"
-                      " the document\n   '{}'\nin order to display it in the GUI.   If you"
-                      " have Ghostscript installed\nconsider running pdfCropMargins with the"
-                      " '--gsFix' option to attempt to repair it."
-                      .format(doc_fname), file=sys.stderr)
-                ex.cleanup_and_exit(1)
-
-            # Decrypt if necessary.
-            if self.document.is_encrypted:
-                if self.args.password:
-                    # Return code is positive for success, negative for failure. If positive,
-                    #   bit 0 set = no password required
-                    #   bit 1 set = user password authenticated
-                    #   bit 2 set = owner password authenticated
-                    authenticate_code = self.document.authenticate(self.args.password)
-                    if self.document.is_encrypted:
-                        print("\nError in pdfCropMargins: The document was not correctly "
-                              "decrypted by PyMuPDF using the password passed in.",
-                              file=sys.stderr)
-                        ex.cleanup_and_exit(1)
-                else: # Try an empty password.
-                    authenticate_code = self.document.authenticate("")
-                    if self.document.is_encrypted:
-                        print("\nError in pdfCropMargins: The document is encrypted "
-                              "and the empty password does not work.  Try passing in a "
-                              "password with the '--password' option.",
-                              file=sys.stderr)
-                        ex.cleanup_and_exit(1)
-
-            self.num_pages = len(self.document)
-            self.page_display_list_cache = [None] * self.num_pages
-            self.page_crop_display_list_cache = [None] * self.num_pages
-            return self.num_pages
-
-        def get_page_sizes(self):
-            """Return a list of the page sizes."""
-            size_list = []
-            for page in self.document:
-                size_list.append((page.rect.width, page.rect.height))
-            return size_list
-
-        def get_max_and_min_page_sizes(self):
-            """Return tuples (max_wid, max_ht) and (min_wid, min_ht)."""
-            page_sizes = self.get_page_sizes()
-            max_page_sizes = (max(p[0] for p in page_sizes), max(p[1] for p in page_sizes))
-            min_page_sizes = (min(p[0] for p in page_sizes), min(p[1] for p in page_sizes))
-            return max_page_sizes, min_page_sizes
-
-        def get_max_and_min_aspect_ratios(self):
-            """Return the maximum and minimum aspect ratios over all the pages."""
-            page_sizes = self.get_page_sizes()
-            max_ratio = max(p[0]/p[1] for p in page_sizes)
-            min_ratio = min(p[0]/p[1] for p in page_sizes)
-            return max_ratio, min_ratio
-
-        def get_max_width_and_height(self):
-            """Return the maximum width and height (in points) of PDF pages in the
-            document."""
-            max_wid = -1
-            max_ht = -1
-            for page in self.document:
-                if page.rect.width > max_wid:
-                    max_wid = page.rect.width
-                if page.rect.height > max_ht:
-                    max_ht = page.rect.height
-            return max_wid, max_ht
-
-        def save_document(self):
-            """Save a document, possibly repairing/cleaning it."""
-            # See here:
-            #    https://pymupdf.readthedocs.io/en/latest/document.html#Document.save
-            raise NotImplementedError
-
-        def close_document(self):
-            """Close the document and clear its pages."""
-            self.document.close()
-            self.clear_cache()
-
-        def return_pypdf_pdfreader(self):
-            """Return a PyPDF `PdfReader` class instance for the current document."""
-            # TODO, just write out (maybe to memory) and open one on it...
-
-        def get_page_ppm_for_crop(self, page_num, cache=False):
-            """Return an unscaled and unclipped `.ppm` file suitable for cropping the page.
-            Not indended for displaying in the GUI."""
-            # NOTE: The calculated bounding boxes are already saved in GUI, so
-            # there is no need to cache these.  After crops the PDF is written
-            # out and re-read, which would clear the cache, anyway.
-
-            # NOTE: The default DPI with the identity matrix is 72 DPI.
-            # Ghostscript default is 72 DPI and pdftoppm is 150 DPI (the
-            # current pdfCropMargins default).
-            # https://github.com/pymupdf/PyMuPDF/issues/181
-
-            # Use grayscale for lower memory requirement; good enough for cropping.
-            # See: https://pymupdf.readthedocs.io/en/latest/colorspace.html#colorspace
-            colorspace = fitz.csGRAY # or fitz.csRGB, or see above.
+        # https://github.com/pymupdf/PyMuPDF/issues/322 # Also info on opening in Pillow.
+        # TODO: Above page also lists a faster way than getting ppm first.
 
-            if cache:
-                page_crop_display_list = self.page_crop_display_list_cache[page_num]
-                if not page_crop_display_list:  # Create if not yet there.
-                    self.page_crop_display_list_cache[page_num] = self.document[
-                                                                  page_num].get_displaylist()
-                    page_crop_display_list = self.page_crop_display_list_cache[page_num]
-            else:
-                page_crop_display_list = self.document[page_num].get_displaylist()
-
-            # https://github.com/pymupdf/PyMuPDF/issues/322 # Also info on opening in Pillow.
-            # TODO: Above page also lists a faster way than getting ppm first.
-
-            # Pillow Image: https://pillow.readthedocs.io/en/stable/reference/Image.html
-            # Pillow modes: https://pillow.readthedocs.io/en/stable/handbook/concepts.html#concept-modes
-            # PyMuPDF Pixmap: https://pymupdf.readthedocs.io/en/latest/pixmap.html#Pixmap.__init__
-            # PyMuPDF get_pixmap: https://pymupdf.readthedocs.io/en/latest/page.html#Page.getPixmap
-
-            mat_0 = fitz.Matrix(1, 1)
-            # New in PyMuPDF version 1.16.0, annots kwarg for whether to ignore them.
-            pixmap = page_crop_display_list.get_pixmap(matrix=fitz.Identity,
-                                                      colorspace=colorspace,
-                                                      clip=None, alpha=False)
-            if self.args:
-                # TODO: Is this working right?  Here, you change matrix in get_pixmap:
-                # https://stackoverflow.com/questions/63821179/extract-images-from-pdf-in-high-resolution-with-python
-                # Is setting actually changing the matrix?
-                resolution = self.args.resX, self.args.resY
-            pixmap.set_dpi(*resolution)
-
-            # Maybe pgm below??
-            image_ppm = pixmap.tobytes("ppm")  # Make PPM image from pixmap for tkinter.
-            return image_ppm
-
-        def get_display_page(self, page_num, max_image_size, zoom=False,
-                             reset_cached=False):
-            """Return a `tkinter.PhotoImage` or a PNG image for a document page
-            number.  The `page_num` argument is a 0-based page number.  The
-            `zoom` argument is the top-left of old clip rect, and one of -1, 0,
-            +1 for dim. x or y to indicate the arrow key pressed.  The
-            `max_image_size` argument is the (width, height) of available image
-            area."""
-            if not reset_cached:
-                page_display_list = self.page_display_list_cache[page_num]
-            else:
-                page_display_list = None
-
-            if not page_display_list:  # Create if not yet there.
-                self.page_display_list_cache[page_num] = self.document[page_num].get_displaylist()
-                page_display_list = self.page_display_list_cache[page_num]
-
-            page_rect = page_display_list.rect  # The page rectangle.
-            clip = page_rect
-
-            # Make sure that all the images across the document will fit the screen.
-            max_wid, max_ht = self.get_max_width_and_height()
-
-            nozoom_scale = min(max_image_size[0]/max_wid,
-                               max_image_size[1]/max_ht)
-            nozoom_mat = fitz.Matrix(nozoom_scale, nozoom_scale)
-
-            if zoom:
-                width2 = page_rect.width / 2
-                height2 = page_rect.height / 2
-
-                clip = page_rect * 0.5     # Clip rect size is a quarter page.
-                top_left = zoom[0]
-                top_left.x += zoom[1] * (width2 / 2)     # adjust top-left ...
-                top_left.x = max(0, top_left.x)          # according to ...
-                top_left.x = min(width2, top_left.x)     # arrow key ...
-                top_left.y += zoom[2] * (height2 / 2)    # provided, but ...
-                top_left.y = max(0, top_left.y)          # stay within ...
-                top_left.y = min(height2, top_left.y)    # the page rect
-                clip = fitz.Rect(top_left, top_left.x + width2, top_left.y + height2)
-
-                # Clip rect is ready, now fill it.
-                zoom_mat = nozoom_mat * fitz.Matrix(2, 2)  # The zoom matrix.
-                pixmap = page_display_list.get_pixmap(alpha=False, matrix=zoom_mat, clip=clip)
-
-            else:  # Show the total page.
-                pixmap = page_display_list.get_pixmap(matrix=nozoom_mat, alpha=False)
-
-            #image_png = pixmap.tobytes()  # get the PNG image
-            image_height, image_width = pixmap.height, pixmap.width
-            image_ppm = pixmap.tobytes("png")  # Make PPM image from pixmap for tkinter.
-            image_tl = clip.tl # Clip position (top left).
-            return image_ppm, image_tl, image_height, image_width
+        # Pillow Image: https://pillow.readthedocs.io/en/stable/reference/Image.html
+        # Pillow modes: https://pillow.readthedocs.io/en/stable/handbook/concepts.html#concept-modes
+        # PyMuPDF Pixmap: https://pymupdf.readthedocs.io/en/latest/pixmap.html#Pixmap.__init__
+        # PyMuPDF get_pixmap: https://pymupdf.readthedocs.io/en/latest/page.html#Page.getPixmap
+
+        mat_0 = fitz.Matrix(1, 1)
+        # New in PyMuPDF version 1.16.0, annots kwarg for whether to ignore them.
+        pixmap = page_crop_display_list.get_pixmap(matrix=fitz.Identity,
+                                                  colorspace=colorspace,
+                                                  clip=None, alpha=False)
+        if self.args:
+            # TODO: Is this working right?  Here, you change matrix in get_pixmap:
+            # https://stackoverflow.com/questions/63821179/extract-images-from-pdf-in-high-resolution-with-python
+            # Is setting actually changing the matrix?
+            resolution = self.args.resX, self.args.resY
+        pixmap.set_dpi(*resolution)
+
+        # Maybe pgm below??
+        image_ppm = pixmap.tobytes("ppm")  # Make PPM image from pixmap for tkinter.
+        return image_ppm
+
+    def get_display_page(self, page_num, max_image_size, zoom=False,
+                         reset_cached=False):
+        """Return a `tkinter.PhotoImage` or a PNG image for a document page
+        number.  The `page_num` argument is a 0-based page number.  The
+        `zoom` argument is the top-left of old clip rect, and one of -1, 0,
+        +1 for dim. x or y to indicate the arrow key pressed.  The
+        `max_image_size` argument is the (width, height) of available image
+        area."""
+        if not reset_cached:
+            page_display_list = self.page_display_list_cache[page_num]
+        else:
+            page_display_list = None
+
+        if not page_display_list:  # Create if not yet there.
+            self.page_display_list_cache[page_num] = self.document[page_num].get_displaylist()
+            page_display_list = self.page_display_list_cache[page_num]
+
+        page_rect = page_display_list.rect  # The page rectangle.
+        clip = page_rect
+
+        # Make sure that all the images across the document will fit the screen.
+        max_wid, max_ht = self.get_max_width_and_height()
+
+        nozoom_scale = min(max_image_size[0]/max_wid,
+                           max_image_size[1]/max_ht)
+        nozoom_mat = fitz.Matrix(nozoom_scale, nozoom_scale)
+
+        if zoom:
+            width2 = page_rect.width / 2
+            height2 = page_rect.height / 2
+
+            clip = page_rect * 0.5     # Clip rect size is a quarter page.
+            top_left = zoom[0]
+            top_left.x += zoom[1] * (width2 / 2)     # adjust top-left ...
+            top_left.x = max(0, top_left.x)          # according to ...
+            top_left.x = min(width2, top_left.x)     # arrow key ...
+            top_left.y += zoom[2] * (height2 / 2)    # provided, but ...
+            top_left.y = max(0, top_left.y)          # stay within ...
+            top_left.y = min(height2, top_left.y)    # the page rect
+            clip = fitz.Rect(top_left, top_left.x + width2, top_left.y + height2)
+
+            # Clip rect is ready, now fill it.
+            zoom_mat = nozoom_mat * fitz.Matrix(2, 2)  # The zoom matrix.
+            pixmap = page_display_list.get_pixmap(alpha=False, matrix=zoom_mat, clip=clip)
+
+        else:  # Show the total page.
+            pixmap = page_display_list.get_pixmap(matrix=nozoom_mat, alpha=False)
+
+        #image_png = pixmap.tobytes()  # get the PNG image
+        image_height, image_width = pixmap.height, pixmap.width
+        image_ppm = pixmap.tobytes("png")  # Make PPM image from pixmap for tkinter.
+        image_tl = clip.tl # Clip position (top left).
+        return image_ppm, image_tl, image_height, image_width
+
+    def get_standard_metadata(self):
+        """Return the standard metadata from the document."""
+        metadata_info = self.document.metadata
+        return metadata_info
+
+    def set_standard_metadata(self, metadata_dict):
+        """Set the standard metadata dict for the document."""
+        self.document.set_metadata(metadata_dict)
+
+    def has_xml_metadata_key(self, key):
+        """Return a boolean indicating if the XML metadata dict has the key `key`."""
+        data_type, value = self.document.xref_get_key(-1, "Info")  # /Info key in the trailer
+        if data_type != "xref":
+            return None # No metadata at all.
+        else:
+            xref = int(value.replace("0 R", ""))  # Extract the metadata xref.
+            if key in self.document.xref_get_keys(xref):
+                return True
+            return False
+
+    def get_xml_metadata(self):
+        """Return a copy of the XML metadata dict with all the items, not just the
+        standard ones."""
+        # https://pymupdf.readthedocs.io/en/latest/recipes-low-level-interfaces.html#how-to-extend-pdf-metadata
+        metadata = {}  # Make a local metadata dict.
+
+        data_type, value = self.document.xref_get_key(-1, "Info")  # /Info key in the trailer
+        if data_type != "xref":
+            has_xml_metadata = False # No metadata at all.
+        else:
+            has_xml_metadata = True
+            xref = int(value.replace("0 R", ""))  # Extract the metadata xref.
+            for key in self.document.xref_get_keys(xref):
+                metadata[key] = self.document.xref_get_key(xref, key)[1]
+
+        return has_xml_metadata, metadata
+
+    def get_xml_metadata_value(self, key):
+        """Return the XML metadata with the given key, if available.  Returns `None`
+        if there is no metadata or if the key is not present in the dict.  Also
+        returns booleans `has_xml_metadata` and `has_key` so failures can be
+        diagnosed."""
+        # https://pymupdf.readthedocs.io/en/latest/recipes-low-level-interfaces.html#how-to-extend-pdf-metadata
+        data_value = None
+        has_key = False
+        has_xml_metadata, metadata = self.get_xml_metadata()
+
+        if not has_xml_metadata:
+            return data_value, has_xml_metadata, has_key # No metadata at all.
+
+        if key in metadata:
+            has_key = True
+            data_value = metadata[key]
+        return data_value, has_xml_metadata, has_key
+
+    def set_xml_metadata_item(self, key, data_string):
+        """Set XML metadata with the arbitrary string `data_string` as the data.  Any
+        key can be used also, provided it is compliant with PDF specs.  To delete data
+        for a key set the key to have the string "null" as its data value."""
+        # https://pymupdf.readthedocs.io/en/latest/recipes-low-level-interfaces.html#how-to-extend-pdf-metadata
+        data_type, value = self.document.xref_get_key(-1, "Info")  # /Info key in the trailer
+        if data_type != "xref":
+            raise ValueError("PDF has no metadata, cannot set XML metadata.")
+
+        xref = int(value.replace("0 R", ""))  # Extract the metadata xref.
+        pdf_data_string = fitz.get_pdf_str(data_string) # Convert the string format.
+
+        self.document.xref_set_key(xref, key, pdf_data_string) # Add the data info.
+
+    def delete_xml_metadata_item(self, key):
+        """Delete the key `key` and the data associated with it."""
+        # TODO: This doesn't seem to delete the key like the docs say, only the metadata.
+        # https://pymupdf.readthedocs.io/en/latest/recipes-low-level-interfaces.html#how-to-extend-pdf-metadata
+        self.set_xml_metadata_item(key, "null")
```

## Comparing `pdfCropMargins-1.2.0.dist-info/LICENSE` & `pdfCropMargins-2.0.0.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `pdfCropMargins-1.2.0.dist-info/METADATA` & `pdfCropMargins-2.0.0.dist-info/METADATA`

 * *Files 4% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: pdfCropMargins
-Version: 1.2.0
+Version: 2.0.0
 Summary: A command-line program to crop the margins of PDF files, with many options.
 Home-page: https://github.com/abarker/pdfCropMargins
 Author: Allen Barker
 Author-email: Allen.L.Barker@gmail.com
 License: GPL
 Keywords: pdf,crop,margins,resize
 Platform: UNKNOWN
@@ -21,15 +21,14 @@
 Classifier: Programming Language :: Python :: 3.9
 Classifier: Programming Language :: Python :: 3.10
 Classifier: Programming Language :: Python :: Implementation :: CPython
 Classifier: Programming Language :: Python :: Implementation :: PyPy
 Classifier: Topic :: Utilities
 Requires-Dist: wheel
 Requires-Dist: pillow (>=9.3.0)
-Requires-Dist: PyPDF2 (<3.0.0,>=2.11.0)
 Requires-Dist: PySimpleGUI (>=4.19.0.6)
 Requires-Dist: PyMuPDF (>=1.19.6)
 
 ==============
 pdfCropMargins
 ==============
 
@@ -43,15 +42,14 @@
 ========
 
 - Automatically detects the margins and can crop a given percentage of them.
 - Can crop all the pages to the same size to give a uniform appearance (such as
   in two-up).
 - Works on Linux, Windows, Cygwin, and OS X/Darwin.
 - Has an optional graphical user interface (GUI) for interactive cropping.
-- A version of pdftoppm for Windows is included.
 - Renders and analyzes page images to find the bounding boxes, which allows it
   to deal with noisy scanned PDFs.
 - A rudimentary 'undo' capability is implemented by default. 
 - Can crop pages uniformly based on the nth smallest crop values, which helps
   with noisy images or documents where a few pages have unwanted markings in
   their margins.
 - Can automatically run a document previewer on the output file.
@@ -75,81 +73,79 @@
 What's New
 ==========
 
 See the `CHANGELOG
 <https://github.com/abarker/pdfCropMargins/blob/master/CHANGELOG.rst>`_ for
 recent changes and new features.
 
-**New in recent versions (Mar 2023):**
+**PdfCropMargins 2.0.0 is now out (June 2023).**
 
-* The minimimum Python version is now Python 3.7 due to several dependencies
-  requiring it.
+* The program now uses PyMuPDF for all internal PDF processing instead of
+  PyPDF.  The PyPDF dependency has been removed, and PyMuPDF is a required
+  depencency.
+
+* PyMuPDF always tries to repair documents on reading them, which should reduce
+  some problems with corrupted documents.
+
+**BREAKING CHANGES**:
+
+* The PyMuPDF program is much stricter about setting page boxes than PyPDF, in
+  order to avoid inconsistent situations.  Setting the MediaBox automatically
+  resets all the other boxes (CropBox, etc.) to their defaults.  The MediaBox
+  is always set first.  By default crops still set the MediaBox and CropBox,
+  but the other boxes will be reset.
+
+* All the other boxes must be completely contained in the MediaBox to be set.
+  If not (when using the ``--boxesToSet`` option) a warning will be issued and
+  the action will be ignored.
+
+* The ArtBox can no longer be used to save restore information.  The restore
+  information is instead saved in the XML metadata.  Documents that were
+  cropped by earlier versions will automatically have their ArtBox data
+  transferred to XML restore metadata unless the ``--noundosave`` option is
+  used.
 
-* You can now use either ``pdf-crop-margins`` or ``pdfcropmargins`` to launch the
-  program from the command line.
-
-* The GUI layout has been updated for more intuitive use of the options that take
-  four values, for the left, bottom, right, and top margins.
-
-* The GUI now displays the smallest delta values on each crop
-  as buttons that take you to the page.  This is useful for fine-tuning crops
-  to not chop off useful information.
-
-* There is now a new ``--cropSafe`` (``-cs``) option which ensures that crops
-  do not exceed the bounding box size when enabled.  The ``--cropSafeMin4``
-  (``-csm4``) option, if set, allows a user-specified extra amount of safe
-  margin beyond the bounding box.
-
-* The new options ``--keepHorizCenter`` (``-khz``) and ``--keepVertCenter``
-  (``-kvc``) have been added.  They force equal cropping on the left and right
-  or top and bottom pages, respectively.  The minimum of the delta values is
-  used on each page.
-
-* Added an option ``--prevCropped`` (``-pc``) which just tests whether or not
-  the document was previously cropped with pdfCropMargins.  This is meant for
-  scripting use.
-
-* The PDF preview in the GUI now resizes properly when the window is reconfigured.
-  The new ``--guiFontSize`` argument can be used to size the font.
+* The options ``--docCatBlacklist`` and ``--docCatWhitelist`` have been removed
+  since PyMuPDF automatically retains the full document catalog.
 
 Installing 
 ==========
 
 The easiest way to install the pdfCropMargins program is by using pip.
 
-The basic features work out of the box with the GUI install, but the default
-install and some of the options require either the external program
-pdftoppm or Ghostscript.  For information on installing those programs on Linux
-and Windows, see: `Installing pdftoppm and/or Ghostscript
+The basic features work out of the box, some of the options require either the
+external program pdftoppm or Ghostscript.  For information on installing those
+programs on Linux and Windows, see: `Installing pdftoppm and/or Ghostscript
 <https://github.com/abarker/pdfCropMargins/tree/master/doc/installing_pdftoppm_and_ghostscript.rst>`_
 .
 
 Linux/Ubuntu
 ------------
 
 If you are installing via pip with the ``--user`` option be sure
 ``$HOME/.local/bin`` is in your system ``PATH``.  (To install system-wide
-without ``--user`` the ``pip3`` command below would also need to be run with
+without ``--user`` the ``pip3`` command below would need to be run with
 ``sudo``.)
 
 .. code-block:: sh
 
-   sudo apt install python3-pip ghostscript poppler-utils python3-setuptools python3-tk
+   sudo apt install python3-pip python3-setuptools python3-tk
+   sudo apt install ghostscript poppler-utils # Optional for pdftoppm and Ghostscript.
    pip3 install pdfCropMargins --user --upgrade
 
 **Troubleshooting:** If you have problems with the install of PyMuPDF, the
 first thing to try is to upgrade your version of the pip program and then
 retry:
 
 .. code-block:: sh
 
    pip3 install pip --upgrade --user
 
 If you still get an error "Failed building wheel for pymupdf" with the GUI
-install you can try forcing a binary install of pyMuPDF:
+install you can try forcing a binary install of PyMuPDF:
 
 .. code-block:: sh
 
    pip3 install pdfCropMargins --user --upgrade --only-binary pymupdf
 
 Windows
 -------
@@ -157,24 +153,24 @@
 The install command is:
 
 .. code-block:: sh
 
    pip install pdfCropMargins --upgrade
 
 The ``pip`` program should be automatically installed along with Python.  If
-you cannot find the pip executable you can usually run pip like this:
+you cannot find the pip executable you can usually run it like this:
 
 .. code-block:: sh
 
    python -m pip <arguments-to-pip>
 
 Note that on some Windows installs the executable for Python is ``py`` rather
 than ``python``.
 
-In order for the command ``pdf-crop-margins`` to work from the command line the
+In order for the command ``pdfcropmargins`` to work from the command line the
 Python ``bin`` directory must be on the Windows ``Path``.  The system-wide
 Python ``bin`` directory should already be on the path if you checked the box
 to modify ``Path`` when you installed Python; otherwise it should be added.
 (Note that if you install with the ``--user`` option to pip then you need to be
 sure that the *local* Python ``bin`` directory is in the Windows ``Path``.)
 
 Running
@@ -183,34 +179,34 @@
 The program can be run 1) from the command line, 2) from the command line with
 a GUI, 3) from a Python program, or 3) from the source repo.
 
 Running from the command line
 -----------------------------
 
 After installation via pip the program can be run with either the command
-``pdf-crop-margins`` or the command ``pdfcropmargins``.  For example:
+``pdfcropmargins`` or the command ``pdf-crop-margins``.  For example:
 
 .. code-block:: sh
 
-   pdf-crop-margins -v -s -u your-file.pdf
+   pdfcropmargins -v -s -u your-file.pdf
 
 That command prints verbose output, forces all pages to be the same size
 (``-s``) and then crops each page by the same amount (``-u``) for a uniform
 appearance, retaining the default of 10% of the margins.  To run the
 same command with the GUI for fine-tuning, use:
 
 .. code-block:: sh
 
-   pdf-crop-margins -v -s -u -gui your-file.pdf
+   pdfcropmargins -v -s -u -gui your-file.pdf
 
 For help and to see the many command-line options that are available, run:
 
 .. code-block:: sh
 
-   pdf-crop-margins -h | more
+   pdfcropmargins -h | more
 
 The full output of that command is also listed below, at the bottom of this
 page.  On Windows you may need to explicitly put the Python distribution's
 ``Scripts`` directory into your environment ``PATH`` in order to avoid having
 to use the full pathname.
 
 Running with the GUI
@@ -243,21 +239,32 @@
    crop(["-p", "0", "-gui", "paper2.pdf"])
 
 Any necessary exception handling should be performed by the calling code.  The
 code may call ``sys.exit``, so checking for ``SystemExit`` or ``BaseException`` may
 be required.
 
 The ``crop`` function always returns four values, some of which may be set to
-``None``: the output file path, the exit code, the text written to standard
-input, and the text written to standard output.  If the keyword argument
-``string_io`` is set true then standard output and standard error streams are
-temporarily redirected to capture any output text as strings, which are
-returned as the final two arguments.  Otherwise those values are set to
-``None``.  The keyword argument ``quiet`` implies the ``string_io`` argument,
-but does not echo anything to the terminal while the ``crop`` function runs.
+``None``:
+
+* the output file path,
+
+* the exit code,
+
+* the text written to standard input,
+
+* the text written to standard output.
+
+If the keyword argument ``string_io`` is set true (the default is false) then
+standard output and standard error streams are temporarily redirected to
+capture any output text as strings, which are returned as the final two
+arguments.  Otherwise those values are set to ``None``.  The keyword argument
+``quiet`` implies the ``string_io`` argument, but does not echo anything to the
+terminal while the ``crop`` function runs.
+
+An example usage:
 
 .. code-block:: python
 
    output_doc_pathname, exit_code, stdout_str, stderr_str = crop(
                             ["-p4", "0", "10", "0", "10", "paper2.pdf"],
                             string_io=True, quiet=False)
 
@@ -265,18 +272,17 @@
 ------------------------------------
 
 The pdfCropMargins program can be run directly from the source code directory
 tree, provided the dependencies are installed.  Just clone the repo and run the
 program ``pdfCropMargins.py`` located in the ``bin`` directory.
 
 To pip install the program and its dependencies from the cloned repo rather
-than from PyPI just go to the root of the source directory and run ``pip
-install .`` for the GUI version or ``pip install .`` for the non-GUI
-version.  (As usual, for code development use the ``-e`` option to make the
-code editable.)
+than from PyPI just go to the root of the source directory and run ``pip install .``
+(As usual, for code development use the ``-e`` option to make the code
+editable.)
 
 Getting good crops
 ------------------
 
 * To diagnose unexpected crops, look at the pages with the smallest delta values,
   as indicated in the verbose (``-v``) output or at the bottom of the GUI.
   This tells you the page with the smallest crop amount for a margin.
@@ -309,17 +315,16 @@
                            [-u] [-m INT] [-m4 INT INT INT INT] [-mp INT] [-s]
                            [-ms INT] [-e] [-g PAGESTR] [-c [d|m|p|gr|gb|o]] [-gs]
                            [-gsr] [-t BYTEVAL] [-nb INT] [-ns INT] [-x DPI]
                            [-y DPI] [-sr STR] [-gf INT] [-b [m|c|t|a|b]]
                            [-f [m|c|t|a|b]] [-r] [-A] [-gsf] [-nc] [-pv PROG]
                            [-mo] [-q] [-nco] [-pf] [-sc STR] [-su STR] [-ss STR]
                            [-pw PASSWD] [-pc] [-khc] [-kvc] [-spr FLOAT:FLOAT]
-                           [-prw FLOAT FLOAT FLOAT FLOAT] [-dcb STR] [-dcw STR]
-                           [-i] [-pdl] [-gsp PATH] [-ppp PATH] [--version]
-                           [-wcdf FILEPATH]
+                           [-prw FLOAT FLOAT FLOAT FLOAT] [-i] [-pdl] [-gsp PATH]
+                           [-ppp PATH] [--version] [-wcdf FILEPATH]
                            PDF_FILE [PDF_FILE ...]
 
    Description:
 
         A command-line application to crop the margins of PDF files. Cropping
         the margins can make it easier to read the pages of a PDF document --
         whether the document is printed or displayed on a screen -- because the
@@ -346,25 +351,21 @@
         Reader). Both the CropBox and the MediaBox are set to the newly-
         computed cropped size. After this the view of the document in most
         programs will be the new, cropped view.
 
         In order to reduce the number of copies of a document which must be
         saved, a basic '--restore' option is provided. When cropping a file not
         produced by the pdfCropMargins program the default is to save the
-        intersection of the MediaBox and any existing CropBox in the ArtBox.
-        This saves the "usual" view of the original document in programs like
-        Acrobat Reader. Subsequent crops of a file produced by pdfCropMargins
-        do not by default alter the ArtBox. The restore option simply copies
-        the saved values back to the MarginBox and CropBox. Note that this
-        assumes the ArtBox is unused (it is rarely used, and this feature can
-        be turned off with the -A option). So, for example, you can make
-        annotations to a file with cropped margins and still produce a version
-        with the annotations which viewers display as the original margins.
-        Programs which change the "Producer" string in the PDF may interfere
-        with this feature.
+        intersections of the MediaBox and any existing CropBox for each page as
+        XML metadata. This saves the "usual" view of the original document in
+        programs like Acrobat Reader. Subsequent crops of a file produced by
+        pdfCropMargins do not by default alter the saved data. The restore
+        option simply copies the saved values back to the MediaBox and CropBox.
+        (Old versions of the program saved to the ArtBox; if these are cropped
+        again the data is migrated to XML metadata.)
 
         Below are several examples using more of the command-line options, each
         applied to an input file called doc.pdf. The output filename is
         unspecified in most of these examples, so the program will
         automatically generate the filename (or an output filename can always
         be explicitly provided with '-o'):
 
@@ -725,27 +726,24 @@
                   are ignored, and pages falling outside the document are
                   ignored. Note that restore information is always saved for all
                   the pages (in the ArtBox) unless '--noundosave' is selected.
 
      -c [d|m|p|gr|gb|o], --calcbb [d|m|p|gr|gb|o]
                   Choose the method to calculate bounding boxes (or to render the
                   PDF pages in order to calculate the boxes). The default option
-                  'd' will choose the MuPDF rendering option if the PyMuPDF
-                  dependency is installed, otherwise it will use pdftoppm
-                  rendering or Ghostscript rendering, in that order, if the
-                  external programs can be located. The options to force a
-                  particular method are MuPDF ('m'), pdftoppm ('p'), or
-                  Ghostscript ('gr') for rendering, or direct Ghostscript
-                  bounding-box calculation ('gb'). For pdftoppm or Ghostscript
-                  options the corresponding program must be installed and
-                  locatable (see the path-setting options below if the default
-                  locator fails). Only the explicit rendering methods will work
-                  for scanned pages (see '--gsBbox'). Choosing 'o' reverts to the
-                  old default behavior of first looking for pdftoppm and then
-                  looking for Ghostscript for rendering.
+                  'd' will currently choose the MuPDF rendering option. The
+                  options to force a particular method are MuPDF ('m'), pdftoppm
+                  ('p'), or Ghostscript ('gr') for rendering, or direct
+                  Ghostscript bounding-box calculation ('gb'). For pdftoppm or
+                  Ghostscript options the corresponding program must be installed
+                  and locatable (see the path-setting options below if the
+                  default locator fails). Only the explicit rendering methods
+                  will work for scanned pages (see '--gsBbox'). Choosing 'o'
+                  reverts to the old default behavior of first looking for
+                  pdftoppm and then looking for Ghostscript for rendering.
 
      -gs, --gsBbox
                   This option is maintained for backward compatibility; using '-c
                   gb' is now preferred. Use Ghostscript to directly find the
                   bounding boxes for the pages, with no explict rendering of the
                   pages. (The default is to explicitly render the PDF pages to
                   image files and calculate bounding boxes from the images.) This
@@ -814,26 +812,30 @@
                   would be "1024x728+0+0". See also the '--guiFontSize' option
                   which can be used to decrease the overall size of the GUI
                   window.
 
      -gf INT, --guiFontSize INT
                   Choose the GUI font size. Making this smaller than the default
                   of 11 can also make the GUI smaller if it does not fit on a
-                  smaller monitor. +0+0".
+                  smaller monitor.
 
      -b [m|c|t|a|b], --boxesToSet [m|c|t|a|b]
                   By default the pdfCropMargins program sets both the MediaBox
                   and the CropBox for each page of the cropped PDF document to
                   the new, cropped page size. This default setting is usually
                   sufficient, but this option can be used to select different PDF
                   boxes to set. The option takes one argument, which is the first
                   letter (lowercase) of a type of box. The choices are MediaBox
                   (m), CropBox (c), TrimBox (t), ArtBox (a), and BleedBox (b).
                   This option overrides the default and can be repeated multiple
-                  times to set several box types.
+                  times to set several box types. Note that the program now uses
+                  PyMuPDF to set the boxes, and it will refuse to set any non-
+                  MediaBox boxes unless they are fully contained in the MediaBox.
+                  In that case a warning will be issued and the box will not be
+                  set.
 
      -f [m|c|t|a|b], --fullPageBox [m|c|t|a|b]
                   By default the program first (before any cropping is
                   calculated) sets the MediaBox and CropBox of each page in (a
                   copy of) the document to the intersection of its previous
                   MediaBox and CropBox. This ensures that the cropping is
                   relative to the usual document-view in programs like Acrobat
@@ -849,63 +851,59 @@
                   option since Ghostscript does its own internal rendering when
                   finding bounding boxes. The default with '-gs' is the
                   CropBox.
 
      -r, --restore
                   This is a simple undo operation which essentially undoes all
                   the crops ever made by pdfCropMargins and returns to the
-                  original margins (provided no other program modified the
-                  Producer metadata or ArtBoxes). By default, whenever this
+                  original margins (provided no other program modified the saved
+                  XML data for the pdfCropMargins key). By default, whenever this
                   program crops a file for the first time it saves the MediaBox
-                  intersected with the CropBox as the new ArtBox (since the
-                  ArtBox is rarely used). The Producer metadata is checked to see
-                  if this was the first time. If so, the ArtBox for each page is
-                  simply copied to the MediaBox and the CropBox for the page.
-                  This restores the earlier view of the document, such as in
-                  Acrobat Reader (but does not completely restore the previous
-                  condition in cases where the MediaBox and CropBox differed or
-                  the ArtBox had a previous value). Any options such as '-u',
-                  '-p', and '-a' which do not make sense in a restore operation
-                  are ignored. Note that as far as default filenames the
-                  operation is treated as just another crop operation (the
-                  default-generated output filename still has a "_cropped.pdf"
-                  suffix). The '--modifyOriginal' option (or its query variant)
-                  can be used with this option. Saving in the ArtBoxes can be
-                  disabled by using the '--noundosave' option.
+                  intersected with the CropBox for each page as XML metadata. The
+                  XML metadata is is checked to see if there is any existing
+                  restore data. If so, the saved metadata for each page is simply
+                  copied to the MediaBox and the CropBox for the page. This
+                  restores the earlier view of the document, such as in Acrobat
+                  Reader (but does not completely restore the previous condition
+                  in cases where the MediaBox and CropBox differed). Any options
+                  such as '-u', '-p', and '-a' which do not make sense in a
+                  restore operation are ignored. Note that as far as default
+                  filenames the operation is treated as just another crop
+                  operation (the default-generated output filename still has a
+                  "_cropped.pdf" suffix). The '--modifyOriginal' option (or its
+                  query variant) can be used with this option. Saving restore
+                  data as XML metadata can be disabled by using the '--
+                  noundosave' option.
 
      -A, --noundosave
-                  Do not save any restore data in the ArtBox. This option will
-                  need to be selected if the document actually uses the ArtBox
-                  for anything important (which is rare). Note that the '--
+                  Do not save any restore data as XML metadata. Note that the '--
                   restore' operation will not work correctly for the cropped
-                  document if this option is included in the cropping command.
-                  (The program does not currently check for this when doing a
-                  restore.)
+                  document later if this option is included in the cropping
+                  command.
 
      -gsf, --gsFix
                   Attempt to repair the input PDF file with Ghostscript before it
-                  is read-in with PyPdf. This requires that Ghostscript be
-                  available. (See the general description text above for the
-                  actual command that is run.) This can also be used to
-                  automatically convert some PostScript files (.ps) to PDF for
-                  cropping. The repaired PDF is written to a temporary file; the
-                  original PDF file is not modified. The original filename is
-                  treated as usual as far as automatic name-generation, the '--
-                  modify-original' option, and so forth. This option is often
-                  helpful if the program hangs or raises an error due to a
-                  corrupted PDF file. Note that when re-cropping a file already
-                  cropped by pdfCropMargins this option is probably not
-                  necessary, and if it is used in a re-crop (at least with
-                  current versions of Ghostscript) it will reset the Producer
-                  metadata which the pdfCropMargins program uses to tell if the
-                  file was already cropped by the program (so the '--restore'
-                  option will not work in combination with this option). This
-                  option is not recommended as something to use by default unless
-                  you encounter many corrupted PDF files and do not need to
-                  restore back to the original margins.
+                  is read-in. This requires that Ghostscript be available. (See
+                  the general description text above for the actual command that
+                  is run.) This can also be used to automatically convert some
+                  PostScript files (.ps) to PDF for cropping. The repaired PDF is
+                  written to a temporary file; the original PDF file is not
+                  modified. The original filename is treated as usual as far as
+                  automatic name-generation, the '--modify-original' option, and
+                  so forth. This option is often helpful if the program hangs or
+                  raises an error due to a corrupted PDF file. Note that when re-
+                  cropping a file already cropped by pdfCropMargins this option
+                  is probably not necessary, and if it is used in a re-crop (at
+                  least with current versions of Ghostscript) it will reset the
+                  Producer metadata which the pdfCropMargins program uses to tell
+                  if the file was already cropped by the program (so the '--
+                  restore' option will not work in combination with this option).
+                  This option is not recommended as something to use by default
+                  unless you encounter many corrupted PDF files and do not need
+                  to restore back to the original margins.
 
      -nc, --noclobber
                   Never overwrite an existing file with the cropped output
                   file.
 
      -pv PROG, --preview PROG
                   Run a PDF viewer on the cropped PDF output. The viewer process
@@ -1038,62 +1036,32 @@
                   setPageRatios' argument. It takes four weight arguments, one
                   per margin. The four floating point arguments should be the
                   left, bottom, right, and top weights, respectively. The weights
                   determine what proportion of the total height(width) increase
                   necessary to achieve the target page ratio is added to the
                   corresponding margin. All weights must be greater than zero.
 
-     -dcb STR, --docCatBlacklist STR
-                  Data associated with the full document, such as outlines,
-                  bookmarks, and modes, is saved in the document catalog of the
-                  PDF file. By default it is all copied over to the cropped
-                  document if possible (with some exceptions, e.g., "/Pages" will
-                  be modified by cropping). If this is not wanted, or if it
-                  causes problems for a document, this option specifies a
-                  blacklist of document catalog items that will never be copied.
-                  The arguments should be passed as a single, quoted, whitespace-
-                  separated string, for example "/Outlines /PageMode
-                  /OpenAction". The special value "ALL" blacklists everything. An
-                  empty string blacklists nothing, and is the default. As an
-                  example, it can be useful to blacklist "/OpenAction" if on
-                  opening the PDF it does something like zooming which is not
-                  desired. Blacklisting `/PageMode` can also be useful to, for
-                  example, not open the outline by default. Running in verbose
-                  mode '-v' will show which document catalog items are and are
-                  not being copied for a document.
-
-     -dcw STR, --docCatWhitelist STR
-                  See the '--docCatBlacklist' option. This is just a whitelist
-                  that essentially works the same way. The whitelist takes
-                  precedence over the blacklist. It specifies a list of items
-                  which will always be copied over even if they are in the
-                  blacklist. Useful combined with setting the blacklist to "ALL"
-                  if you only want one or two of the items. The default value is
-                  the empty string, which whitelists nothing and so only the
-                  blacklist is used. Setting to "ALL" guarantees that everything
-                  possible is copied over.
-
      -i, --showImages
                   When explicitly rendering PDF files to image files, display the
                   inverse image files that are used to find the bounding boxes.
                   Useful for debugging and for choosing some of the other
                   parameters (such as the threshold). This option requires a
                   default external viewer program selected by the Pillow image
                   manipulation package (xv on Unix, and usually Paint on
                   Windows).
 
      -pdl, --pdftoppmLocal
-                  Use a locally-packaged pdftoppm executable rather than the
-                  system version. This option is only available on Windows
-                  machines; it is ignored otherwise. By default the first
-                  pdftoppm executable found in the directories in the PATH
-                  environment variable is used. On Windows the program will
-                  revert to this option if PDF image-rendering is required,
-                  PyMuPDF is not installed, and no system pdftoppm or Ghostscript
-                  executable can be found.
+                  This option is deprecated. Use a locally-packaged pdftoppm
+                  executable rather than the system version. This option is only
+                  available on Windows machines; it is ignored otherwise. By
+                  default the first pdftoppm executable found in the directories
+                  in the PATH environment variable is used. On Windows the
+                  program will revert to this option if PDF image-rendering is
+                  required, PyMuPDF is not installed, and no system pdftoppm or
+                  Ghostscript executable can be found.
 
      -gsp PATH, --ghostscriptPath PATH
                   Pass in a pathname to the ghostscript executable that the
                   program should use. No globbing is done. Useful when the
                   program is in a nonstandard location.
 
      -ppp PATH, --pdftoppmPath PATH
@@ -1110,7 +1078,8 @@
                   automated testing and debugging.
 
 
    The pdfCropMargins program is Copyright (c) 2014 by Allen Barker.
    Released under the GNU GPL license, version 3 or later.
 
 
+
```

## Comparing `pdfCropMargins-1.2.0.dist-info/RECORD` & `pdfCropMargins-2.0.0.dist-info/RECORD`

 * *Files 24% similar despite different names*

```diff
@@ -1,24 +1,25 @@
-pdfCropMargins/__init__.py,sha256=BW9vP0Pd3fZYCzbLWjOP1Lw1xaA6jiyTU9xtCGOBR_Q,215
+pdfCropMargins/__init__.py,sha256=p2DW5DAzgagaIs2T7vbvqwB4zVJFBC7yOnB3GF9guTI,215
 pdfCropMargins/__main__.py,sha256=eqembSzHFaMzW0tHq9tLGzlVhpaTnGd7WEDBYFw-ynk,197
-pdfCropMargins/calculate_bounding_boxes.py,sha256=y0J7TVEAJIRSeKNTOrGy4P30uiRLpuUp7LKhIrLq7Z8,13904
+pdfCropMargins/calculate_bounding_boxes.py,sha256=n_PY4xzJgc-8ZaH1O1ida2W1L6heH32BbzLKHVCEeLE,14131
 pdfCropMargins/directory_locator.py,sha256=L3vgSdGVtBDJf8RVAVX0WxcDhqR8j5O3uv37X96lxmg,181
-pdfCropMargins/external_program_calls.py,sha256=7TtLspyfW-KxaLNLiyuh_9dtEPmZTfxg8wX8iDhAj2s,31258
+pdfCropMargins/external_program_calls.py,sha256=VHOMgmL3HggHOic9WuRqJjTxNP5ZCxNFIgaIQWsL1G8,31257
 pdfCropMargins/get_window_sizing_info.py,sha256=mYsxadWzL5x0CaAzVaaOD79b7rJcAfxQ6HlDz6FsU0k,8673
-pdfCropMargins/gui.py,sha256=KG8iWXzG1qCjiQlBGfU2jEPyW9O6b5CY3Sk6OP_xT0M,58643
-pdfCropMargins/main_pdfCropMargins.py,sha256=W-0ov7aHjWG4tx2bHoaq2qBW2ihGlHyUCSjFhtEi0WA,79226
-pdfCropMargins/manpage_data.py,sha256=ReTR_Y3ENmBx25ReXape03SRaSb41PPlVz1x5psGhOI,49723
+pdfCropMargins/gui.py,sha256=URE0X7HI-Jm_DRpZdDleVSkDunUAVbptTKStWATTlJY,58742
+pdfCropMargins/main_pdfCropMargins.py,sha256=oXBg0LZ04YnmZiW7tsAVB-jz1jg4xf3w_yzBneK0xY0,69332
+pdfCropMargins/manpage_data.py,sha256=aXyEqAs9--kSxlQb5acDBWLB3dXwotCCOTXW5Gz-H8s,48446
 pdfCropMargins/pdfCropMargins.py,sha256=4kCvbjNMl8xcXy62jb-GrvWaMJ31wJd9ZncVddr8yjs,8262
 pdfCropMargins/prettified_argparse.py,sha256=OxtStEDN8UdU7OkSBeGxudJ_McwYArYmupVqiAfXK74,8924
-pdfCropMargins/pymupdf_routines.py,sha256=hOgU8Euip1YT2nryfUTmo6nKS4CHpwd6Ln7QjYzOW2M,12497
+pdfCropMargins/pymupdf_routines.py,sha256=-VZHW7yUtyYrYrNJnjQMJ_SzIXstkC0bmONywlrSmfo,20044
+pdfCropMargins/tmp_test_metadata_setting.py,sha256=RLc-98lX0XYBHvBY5N_1z69s_75FK8dXU0AR6ly9ADU,3669
 pdfCropMargins/pdftoppm_windows_local/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 pdfCropMargins/pdftoppm_windows_local/xpdf_tools_win_4_01_01/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 pdfCropMargins/pdftoppm_windows_local/xpdf_tools_win_4_01_01/bin32/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 pdfCropMargins/pdftoppm_windows_local/xpdf_tools_win_4_01_01/bin32/pdftoppm.exe,sha256=paogYneEsikm1y6Q8wRcYxAGYwbZYMi5v0KctOSsQwI,1690624
 pdfCropMargins/pdftoppm_windows_local/xpdf_tools_win_4_01_01/bin64/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 pdfCropMargins/pdftoppm_windows_local/xpdf_tools_win_4_01_01/bin64/pdftoppm.exe,sha256=SIlcH87t54NMT_9s8RWV4x4CCMnlKLURNsKVVUbzI7Y,2090496
-pdfCropMargins-1.2.0.dist-info/LICENSE,sha256=Je6hz-X3DSxDtjXaCDoczW7YB4RuX2zpU0PPiD410us,35546
-pdfCropMargins-1.2.0.dist-info/METADATA,sha256=RBZEokvqFtcltfNoVICSnSBv88vlXImTzuNNsAzm9rE,61810
-pdfCropMargins-1.2.0.dist-info/WHEEL,sha256=Z-nyYpwrcSqxfdux5Mbn_DQ525iP7J2DG3JgGvOYyTQ,110
-pdfCropMargins-1.2.0.dist-info/entry_points.txt,sha256=BAuD78hKbj7Par2JQxg5x_1KRI_Op3LXjRZMKR-bkOY,125
-pdfCropMargins-1.2.0.dist-info/top_level.txt,sha256=8xlp0kBdEXsm3mBVRnpsjvl5VIxXhjw8xKOq3q2iFjI,15
-pdfCropMargins-1.2.0.dist-info/RECORD,,
+pdfCropMargins-2.0.0.dist-info/LICENSE,sha256=Je6hz-X3DSxDtjXaCDoczW7YB4RuX2zpU0PPiD410us,35546
+pdfCropMargins-2.0.0.dist-info/METADATA,sha256=gOfqI-sJ6u8EKxjmNYLW7o7XQr6E8Z1S3A8g7VWlj8U,59105
+pdfCropMargins-2.0.0.dist-info/WHEEL,sha256=Z-nyYpwrcSqxfdux5Mbn_DQ525iP7J2DG3JgGvOYyTQ,110
+pdfCropMargins-2.0.0.dist-info/entry_points.txt,sha256=BAuD78hKbj7Par2JQxg5x_1KRI_Op3LXjRZMKR-bkOY,125
+pdfCropMargins-2.0.0.dist-info/top_level.txt,sha256=8xlp0kBdEXsm3mBVRnpsjvl5VIxXhjw8xKOq3q2iFjI,15
+pdfCropMargins-2.0.0.dist-info/RECORD,,
```

